<html><head><title>[design] 8 Classifying semi-Latin squares</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP007.htm">Previous</a>] [<a href ="CHAP009.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>8 Classifying semi-Latin squares</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP008.htm#SECT001">Semi-Latin squares and SOMAs</a>
<li> <A HREF="CHAP008.htm#SECT002">The function SemiLatinSquareDuals</a>
</ol><p>
<p>
This chapter describes the function <code>SemiLatinSquareDuals</code> which can
classify semi-Latin squares with certain given properties, and return
a list of their duals as block designs.
<p>
<p>
<h2><a name="SECT001">8.1 Semi-Latin squares and SOMAs</a></h2>
<p><p>
Let <i>n</i> and <i>k</i> be positive integers. An (<i>n</i>&times;<i>n</i>)/<i>k</i> <strong>semi-Latin
square</strong>
<a name = "I0"></a>

is an <i>n</i> by <i>n</i> array <i>A</i>, whose
entries are <i>k</i>-subsets of a <i>kn</i>-set <i>X</i> (the <strong>symbol-set</strong>), such that
each element of <i>X</i> occurs exactly once in each row and exactly once in
each column of <i>A</i>. (Thus an (<i>n</i>&times;<i>n</i>)/1 semi-Latin square is the same
thing as a Latin square of order <i>n</i>.) For extensive useful information on
semi-Latin squares, see <a href="http://www.maths.qmul.ac.uk/~rab/sls.html">http://www.maths.qmul.ac.uk/~rab/sls.html</a>.
<p>
A SOMA(<i>k</i>,<i>n</i>)
<a name = "I1"></a>

is an (<i>n</i>&times;<i>n</i>)/<i>k</i> semi-Latin square <i>A</i>,
with <i>n</i> &#8805; 2, in which no 2-subset of the symbol-set is contained in
more than one entry of <i>A</i>.  For extensive useful information on SOMAs,
see <a href="http://www.maths.qmul.ac.uk/~lsoicher/soma/">http://www.maths.qmul.ac.uk/~lsoicher/soma/</a>.
<p>
Let <i>A</i> and <i>B</i> be (<i>n</i>&times;<i>n</i>)/<i>k</i> semi-Latin squares.  We say that
<i>B</i> is <strong>(weakly) isomorphic</strong> to <i>A</i> if <i>B</i> can be obtained from <i>A</i>
by applying one or more of: a row permutation; a column permutation;
transposing; renaming the symbols. If transposing is not allowed then we
get the concept of strong isomorphism. More formally, <i>B</i> is <strong>strongly
isomorphic</strong> to <i>A</i> if <i>B</i> can be obtained from <i>A</i> by applying one or
more of: a row permutation; a column permutation; renaming the symbols.
<p>
Let <i>A</i> be an (<i>n</i>&times;<i>n</i>)/<i>k</i>  semi-Latin square.  Then the dual of <i>A</i>
can be represented as a binary block design as follows. The point-set of
<i>D</i> is taken to be the Cartesian square of {1,&#8230;,<i>n</i>}, with [<i>x</i>,<i>y</i>]
representing the [<i>x</i>,<i>y</i>]-entry of <i>A</i>. The blocks of <i>D</i> are in one-to-one
correspondance with the symbols of <i>A</i>, with the <i>i</i>-th block of <i>D</i>
consisting of the ordered pairs [<i>x</i>,<i>y</i>] such that the <i>i</i>-th symbol of
<i>A</i> is contained in the [<i>x</i>,<i>y</i>]-entry of <i>A</i>. Given <i>D</i>, the semi-Latin
square <i>A</i> can be recovered, up to the naming of its symbols.
<p>
<p>
<h2><a name="SECT002">8.2 The function SemiLatinSquareDuals</a></h2>
<p><p>
<a name = "SSEC002.1"></a>
<li><code>SemiLatinSquareDuals( </code><var>n</var><code>, </code><var>k</var><code> )</code>
<li><code>SemiLatinSquareDuals( </code><var>n</var><code>, </code><var>k</var><code>, </code><var>maxmult</var><code> )</code>
<li><code>SemiLatinSquareDuals( </code><var>n</var><code>, </code><var>k</var><code>, </code><var>maxmult</var><code>, </code><var>blockintsizes</var><code> )</code>
<li><code>SemiLatinSquareDuals( </code><var>n</var><code>, </code><var>k</var><code>, </code><var>maxmult</var><code>, </code><var>blockintsizes</var><code>, </code><var>isolevel</var><code> )</code>
<p>
Let <var>n</var> and <var>k</var> be positive integers. Then this function (which makes
heavy use of the function <code>BlockDesigns</code>) returns a list <var>DL</var> of block
designs which are the duals of the (<i>n</i> &times;<i>n</i> )/<i>k</i>  semi-Latin
squares whose properties are specified by the given parameters, described
below. In practice, depending on the specified properties, this function
can be useful for <var>n</var> up to about 6 or 7.
<p>
The parameter <var>maxmult</var>, if given, must be a positive integer or
the string <code>"default"</code>. If it is a positive integer, then <var>maxmult</var>
specifies an upper bound on the multiplicity of each block in each
semi-Latin square dual in <var>DL</var>. The default value for <var>maxmult</var> (if
omitted or if given as <code>"default"</code>) is <var>k</var>, which poses no constraint
on the block multiplicities.
<p>
The parameter <var>blockintsizes</var>, if given, must be a set of non-negative
integers or the string <code>"default"</code>.  If it is given as a set, then
<var>blockintsizes</var> specifies, for each semi-Latin square dual in <var>DL</var>,
the set of possible sizes for the intersection of a block <i>B</i> with a
different block (but possibly a repeat of <i>B</i>).  The default value for
<var>blockintsizes</var> (if omitted or if given as <code>"default"</code>) is <code>[0..</code><var>n</var><code>]</code>,
which poses no constraint on the block intersection sizes. Note that
block intersection sizes in the dual of a semi-Latin square correspond
to concurrencies of points in the semi-Latin square itself. Also note
that if <i>n</i>  &#8805; 2 and <var>blockintsizes</var> is specified to be <code>[0,1]</code> then
the (<i>n</i>&times;<i>n</i>)/<i>k</i> semi-Latin squares being considered are SOMA(<i>k</i>,<i>n</i>)s.
<p>
The parameter <var>isolevel</var>, if given, must be 0, 1, 2, 3, 4 or the string
<code>"default"</code> (the default value is 2).  The value 0 specifies that <var>DL</var>
will contain at most one (semi-Latin square dual given as a) block design,
and will contain one such block design if and only if a semi-Latin square
with the required properties exists. The value&nbsp;1 specifies that <var>DL</var>
will contain a list of duals representing all weak isomorphism classes
of semi-Latin squares with the required properties (possibly with some
classes represented more than once) and the value 2 specifies that <var>DL</var>
will contain precisely one dual semi-Latin square representative for
each weak isomorphism class of semi-Latin squares with the required
properties. The values 3 and 4 for <var>isolevel</var> play the roles of 1 and 2,
respectively, but with weak isomorphism replaced by strong isomorphism.
Thus, <i>isolevel</i> =3 specifies that <var>DL</var> will contain a list of duals
representing all strong isomorphism classes of semi-Latin squares with
the required properties (possibly with some classes represented more than
once) and <i>isolevel</i> =4 specifies that <var>DL</var> will contain precisely one
dual semi-Latin square representative for each strong isomorphism class
of semi-Latin squares with the required properties.
<p>
For example, we determine the numbers of weak and strong isomorphism
classes of (4&times;4)/<i>k</i> semi-Latin squares for <i>k</i>=1,&#8230;,6. (These
numbers disagree with P.&nbsp;E.&nbsp;Chigbu's classification for the cases <i>k</i>=3,4
<a href="biblio.htm#BaCh"><cite>BaCh</cite></a>.)
<p>
<pre>
gap&gt; List([1..6],k-&gt;Length(SemiLatinSquareDuals(4,k))); # weak
[ 2, 10, 40, 164, 621, 2298 ]
gap&gt; List([1..6],k-&gt;Length(SemiLatinSquareDuals(4,k,"default","default",4))); # strong
[ 2, 11, 46, 201, 829, 3343 ]
</pre>
<p>
Next, we determine one SOMA(3,6). 
<p>
<pre>
gap&gt; SemiLatinSquareDuals(6,3,"default",[0,1],0);
[ rec( isBlockDesign := true, v := 36, 
      blocks := [ [ 1, 8, 15, 22, 29, 36 ], [ 1, 9, 16, 23, 30, 32 ], 
          [ 1, 12, 14, 21, 28, 35 ], [ 2, 9, 17, 24, 25, 34 ], 
          [ 2, 11, 18, 22, 27, 31 ], [ 2, 12, 16, 19, 29, 33 ], 
          [ 3, 10, 14, 24, 29, 31 ], [ 3, 11, 16, 20, 25, 36 ], 
          [ 3, 12, 13, 23, 26, 34 ], [ 4, 7, 14, 23, 27, 36 ], 
          [ 4, 8, 17, 21, 30, 31 ], [ 4, 9, 18, 19, 26, 35 ], 
          [ 5, 7, 15, 20, 30, 34 ], [ 5, 8, 13, 24, 28, 33 ], 
          [ 5, 10, 18, 21, 25, 32 ], [ 6, 7, 17, 22, 26, 33 ], 
          [ 6, 10, 13, 20, 27, 35 ], [ 6, 11, 15, 19, 28, 32 ] ], 
      tSubsetStructure := rec( t := 1, lambdas := [ 3 ] ), isBinary := true, 
      isSimple := true, blockSizes := [ 6 ], blockNumbers := [ 18 ], r := 3, 
      autSubgroup := &lt;permutation group of size 72 with 3 generators&gt;, 
      pointNames := [ [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], 
          [ 1, 6 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ], [ 2, 4 ], [ 2, 5 ], 
          [ 2, 6 ], [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 3, 4 ], [ 3, 5 ], 
          [ 3, 6 ], [ 4, 1 ], [ 4, 2 ], [ 4, 3 ], [ 4, 4 ], [ 4, 5 ], 
          [ 4, 6 ], [ 5, 1 ], [ 5, 2 ], [ 5, 3 ], [ 5, 4 ], [ 5, 5 ], 
          [ 5, 6 ], [ 6, 1 ], [ 6, 2 ], [ 6, 3 ], [ 6, 4 ], [ 6, 5 ], 
          [ 6, 6 ] ] ) ]
</pre>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP007.htm">Previous</a>] [<a href ="CHAP009.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>design manual<br>March 2019
</address></body></html>