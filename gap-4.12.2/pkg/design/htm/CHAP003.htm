<html><head><title>[design] 3 Constructing block designs</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP002.htm">Previous</a>] [<a href ="CHAP004.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>3 Constructing block designs</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP003.htm#SECT001">Functions to construct block designs</a>
</ol><p>
<p>
<p>
<h2><a name="SECT001">3.1 Functions to construct block designs</a></h2>
<p><p>
<a name = "SSEC001.1"></a>
<li><code>BlockDesign( </code><var>v</var><code>, </code><var>B</var><code> )</code>
<li><code>BlockDesign( </code><var>v</var><code>, </code><var>B</var><code>, </code><var>G</var><code> )</code>
<p>
Let <var>v</var> be a positive integer and <var>B</var> a non-empty list of non-empty
sorted lists of elements of {1,&#8230;,<i>v</i> }.
<p>
The first version of this function returns the block design with point-set
{1,&#8230;,<i>v</i> } and block multiset <var>C</var>, where <var>C</var> is <code>SortedList(</code><var>B</var><code>)</code>.
<p>
For the second version of this function, we require <var>G</var> to be a group
of permutations of {1,&#8230;,<i>v</i> }, and the function returns the
block design with point-set {1,&#8230;,<i>v</i> } and block multiset <var>C</var>,
where <var>C</var> is the sorted list of the concatenation of the <var>G</var>-orbits of
the elements of <var>B</var>.
<p>
<pre>
gap&gt; BlockDesign( 2, [[1,2],[1],[1,2]] );
rec( isBlockDesign := true, v := 2, blocks := [ [ 1 ], [ 1, 2 ], [ 1, 2 ] ] )
gap&gt; D:=BlockDesign(7, [[1,2,4]], Group((1,2,3,4,5,6,7)));
rec( isBlockDesign := true, v := 7, 
  blocks := [ [ 1, 2, 4 ], [ 1, 3, 7 ], [ 1, 5, 6 ], [ 2, 3, 5 ], 
      [ 2, 6, 7 ], [ 3, 4, 6 ], [ 4, 5, 7 ] ], 
  autSubgroup := Group([ (1,2,3,4,5,6,7) ]) )
gap&gt; AllTDesignLambdas(D);
[ 7, 3, 1 ]
</pre>
<p>
<a name = "SSEC001.2"></a>
<li><code>AGPointFlatBlockDesign( </code><var>n</var><code>, </code><var>q</var><code>, </code><var>d</var><code> )</code>
<p>
Let <var>n</var> be positive integer, <var>q</var> a prime-power, and <var>d</var> a non-negative
integer less than or equal to <var>n</var>. Then this function returns the block
design whose points are the points of the affine space <i>AG</i>(<i>n</i> ,<i>q</i> ),
and whose blocks are the <i>d</i> -flats of <i>AG</i>(<i>n</i> ,<i>q</i> ), considering a
<i>d</i> -flat as a set of points.
<p>
Note that the <strong>affine space</strong> <i>AG</i>(<i>n</i> ,<i>q</i> ) consists of all the cosets of
all the subspaces of the vector space <i>V</i>(<i>n</i> ,<i>q</i> ), with the <strong>points</strong>
being the cosets of the 0-dimensional subspace and the <strong><i>d</i> -flats</strong>
being the cosets of the <i>d</i> -dimensional subspaces. As is usual, we
identify the points with the vectors in <i>V</i>(<i>n</i> ,<i>q</i> ), and these vectors
are given as the point-names.
<p>
<pre>
gap&gt; D:=AGPointFlatBlockDesign(2,4,1);
rec( isBlockDesign := true, v := 16, 
  blocks := [ [ 1, 2, 3, 4 ], [ 1, 5, 9, 13 ], [ 1, 6, 11, 16 ], 
      [ 1, 7, 12, 14 ], [ 1, 8, 10, 15 ], [ 2, 5, 12, 15 ], [ 2, 6, 10, 14 ], 
      [ 2, 7, 9, 16 ], [ 2, 8, 11, 13 ], [ 3, 5, 10, 16 ], [ 3, 6, 12, 13 ], 
      [ 3, 7, 11, 15 ], [ 3, 8, 9, 14 ], [ 4, 5, 11, 14 ], [ 4, 6, 9, 15 ], 
      [ 4, 7, 10, 13 ], [ 4, 8, 12, 16 ], [ 5, 6, 7, 8 ], [ 9, 10, 11, 12 ], 
      [ 13, 14, 15, 16 ] ], 
  autSubgroup := Group([ (5,9,13)(6,10,14)(7,11,15)(8,12,16), 
      (2,5,6)(3,9,11)(4,13,16)(7,14,12)(8,10,15), 
      (1,5)(2,6)(3,7)(4,8)(9,13)(10,14)(11,15)(12,16), 
      (3,4)(7,8)(9,13)(10,14)(11,16)(12,15) ]), 
  pointNames := [ [ 0*Z(2), 0*Z(2) ], [ 0*Z(2), Z(2)^0 ], [ 0*Z(2), Z(2^2) ], 
      [ 0*Z(2), Z(2^2)^2 ], [ Z(2)^0, 0*Z(2) ], [ Z(2)^0, Z(2)^0 ], 
      [ Z(2)^0, Z(2^2) ], [ Z(2)^0, Z(2^2)^2 ], [ Z(2^2), 0*Z(2) ], 
      [ Z(2^2), Z(2)^0 ], [ Z(2^2), Z(2^2) ], [ Z(2^2), Z(2^2)^2 ], 
      [ Z(2^2)^2, 0*Z(2) ], [ Z(2^2)^2, Z(2)^0 ], [ Z(2^2)^2, Z(2^2) ], 
      [ Z(2^2)^2, Z(2^2)^2 ] ] )
gap&gt; AllTDesignLambdas(D);
[ 20, 5, 1 ]
</pre>
<p>
<a name = "SSEC001.3"></a>
<li><code>PGPointFlatBlockDesign( </code><var>n</var><code>, </code><var>q</var><code>, </code><var>d</var><code> )</code>
<p>
Let <var>n</var> be a non-negative integer, <var>q</var> a prime-power, and <var>d</var> a
non-negative integer less than or equal to <var>n</var>. Then this function
returns the block design whose points are the (projective) points of
the projective space <i>PG</i>(<i>n</i> ,<i>q</i> ), and whose blocks are the <i>d</i> -flats
of <i>PG</i>(<i>n</i> ,<i>q</i> ), considering a <i>d</i> -flat as a set of projective points.
<p>
Note that the <strong>projective space</strong> <i>PG</i>(<i>n</i> ,<i>q</i> ) consists of all the
subspaces of the vector space <i>V</i>(<i>n</i> +1,<i>q</i> ), with the <strong>projective
points</strong> being the 1-dimensional subspaces and the <strong><i>d</i> -flats</strong> being
the (<i>d</i> +1)-dimensional subspaces.
<p>
<pre>
gap&gt; D:=PGPointFlatBlockDesign(3,2,1);
rec( isBlockDesign := true, v := 15, 
  blocks := [ [ 1, 2, 3 ], [ 1, 4, 5 ], [ 1, 6, 7 ], [ 1, 8, 9 ], 
      [ 1, 10, 11 ], [ 1, 12, 13 ], [ 1, 14, 15 ], [ 2, 4, 6 ], [ 2, 5, 7 ], 
      [ 2, 8, 10 ], [ 2, 9, 11 ], [ 2, 12, 14 ], [ 2, 13, 15 ], [ 3, 4, 7 ], 
      [ 3, 5, 6 ], [ 3, 8, 11 ], [ 3, 9, 10 ], [ 3, 12, 15 ], [ 3, 13, 14 ], 
      [ 4, 8, 12 ], [ 4, 9, 13 ], [ 4, 10, 14 ], [ 4, 11, 15 ], [ 5, 8, 13 ], 
      [ 5, 9, 12 ], [ 5, 10, 15 ], [ 5, 11, 14 ], [ 6, 8, 14 ], [ 6, 9, 15 ], 
      [ 6, 10, 12 ], [ 6, 11, 13 ], [ 7, 8, 15 ], [ 7, 9, 14 ], 
      [ 7, 10, 13 ], [ 7, 11, 12 ] ], 
  autSubgroup := Group([ (8,12)(9,13)(10,14)(11,15), 
      (1,2,4,8)(3,6,12,9)(5,10)(7,14,13,11) ]), 
  pointNames := [ &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt; ] )
gap&gt; AllTDesignLambdas(D);
[ 35, 7, 1 ]
</pre>
<p>
<a name = "SSEC001.4"></a>
<li><code>WittDesign( </code><var>n</var><code> )</code>
<p>
Suppose <i>n</i>  &#8712; {9,10,11,12,21,22,23,24}. 
<p>
If <i>n</i> =24 then this function returns the <strong>large Witt design</strong> <i>W</i><sub>24</sub>,
the unique (up to isomorphism) 5-(24,8,1) design. If <i>n</i> =24&#8722;<i>i</i>, where
<i>i</i>  &#8712; {1,2,3}, then the <i>i</i>-fold point-derived design of <i>W</i><sub>24</sub>
is returned; this is the unique (up to isomorphism) (5&#8722;<i>i</i>)-(24&#8722;<i>i</i>,8&#8722;<i>i</i>,1)
design.
<p>
If <i>n</i> =12 then this function returns the <strong>small Witt design</strong> <i>W</i><sub>12</sub>,
the unique (up to isomorphism) 5-(12,6,1) design. If <i>n</i> =12&#8722;<i>i</i>, where
<i>i</i>  &#8712; {1,2,3}, then the <i>i</i>-fold point-derived design of <i>W</i><sub>12</sub>
is returned; this is the unique (up to isomorphism) (5&#8722;<i>i</i>)-(12&#8722;<i>i</i>,6&#8722;<i>i</i>,1)
design.
<p>
<pre>
gap&gt; W24:=WittDesign(24);;
gap&gt; AllTDesignLambdas(W24);
[ 759, 253, 77, 21, 5, 1 ]
gap&gt; DisplayCompositionSeries(AutomorphismGroup(W24));
G (3 gens, size 244823040)
 | M(24)
1 (0 gens, size 1)
gap&gt; W10:=WittDesign(10);;
gap&gt; AllTDesignLambdas(W10);
[ 30, 12, 4, 1 ]
gap&gt; DisplayCompositionSeries(AutomorphismGroup(W10));
G (4 gens, size 1440)
 | Z(2)
S (4 gens, size 720)
 | Z(2)
S (3 gens, size 360)
 | A(6) ~ A(1,9) = L(2,9) ~ B(1,9) = O(3,9) ~ C(1,9) = S(2,9) ~ 2A(1,9) = U(2,\
9)
1 (0 gens, size 1)
</pre>
<p>
<a name = "SSEC001.5"></a>
<li><code>DualBlockDesign( </code><var>D</var><code> )</code>
<p>
Suppose <var>D</var> is a block design for which every point lies on at least
one block.  Then this function returns the dual of <var>D</var>, the block design
in which the roles of points and blocks are interchanged, but incidence
(including repeated incidence) stays the same.  Note that, since the
list of blocks of a block design is always sorted, the block list of
the dual of the dual of <var>D</var> may not be equal to the block list of <var>D</var>.
<p>
<pre>
gap&gt; D:=BlockDesign(4,[[1,3],[2,3,4],[3,4]]);;
gap&gt; dualD:=DualBlockDesign(D);
rec( isBlockDesign := true, v := 3, 
  blocks := [ [ 1 ], [ 1, 2, 3 ], [ 2 ], [ 2, 3 ] ], 
  pointNames := [ [ 1, 3 ], [ 2, 3, 4 ], [ 3, 4 ] ] )
gap&gt; DualBlockDesign(dualD).blocks;           
[ [ 1, 2 ], [ 2, 3, 4 ], [ 2, 4 ] ]
</pre>
<p>
<a name = "SSEC001.6"></a>
<li><code>ComplementBlocksBlockDesign( </code><var>D</var><code> )</code>
<p>
Suppose <var>D</var> is a binary incomplete-block design.
Then this function returns the block design on the same
point-set as <var>D</var>, whose blocks are the complements of
those of <var>D</var> (complemented with respect to the point-set).
<p>
<pre>
gap&gt; D:=PGPointFlatBlockDesign(2,2,1);
rec( isBlockDesign := true, v := 7, 
  pointNames := [ &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt; ], 
  blocks := [ [ 1, 2, 3 ], [ 1, 4, 5 ], [ 1, 6, 7 ], [ 2, 4, 6 ], 
      [ 2, 5, 7 ], [ 3, 4, 7 ], [ 3, 5, 6 ] ] )
gap&gt; AllTDesignLambdas(D);
[ 7, 3, 1 ]
gap&gt; C:=ComplementBlocksBlockDesign(D);
rec( isBlockDesign := true, v := 7, 
  blocks := [ [ 1, 2, 4, 7 ], [ 1, 2, 5, 6 ], [ 1, 3, 4, 6 ], [ 1, 3, 5, 7 ], 
      [ 2, 3, 4, 5 ], [ 2, 3, 6, 7 ], [ 4, 5, 6, 7 ] ], 
  pointNames := [ &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt;, 
      &lt;vector space of dimension 1 over GF(2)&gt; ] )
gap&gt; AllTDesignLambdas(C);
[ 7, 4, 2 ]
</pre>
<p>
<a name = "SSEC001.7"></a>
<li><code>DeletedPointsBlockDesign( </code><var>D</var><code>, </code><var>Y</var><code> )</code>
<p>
Suppose <var>D</var> is a block design and <var>Y</var> is a proper subset of the point-set
of <var>D</var>.
<p>
Then this function returns the block design <i>DP</i> obtained from <var>D</var> by
deleting the points in <var>Y</var> from the point-set, and from each block.
It is an error if the resulting design contains an empty block.
The points of <i>DP</i> are relabelled 1,2,&#183;.&#183;, preserving the order of
the corresponding points of <var>D</var>; the point-names of <i>DP</i> (listed in
<code><i>DP</i>.pointNames</code>) are those of these corresponding points of <var>D</var>.
<p>
<pre>
gap&gt; D:=BlockDesigns(rec(v:=11,blockSizes:=[5],
&gt;       tSubsetStructure:=rec(t:=2,lambdas:=[2])))[1];
rec( isBlockDesign := true, v := 11, 
  blocks := [ [ 1, 2, 3, 4, 5 ], [ 1, 2, 9, 10, 11 ], [ 1, 3, 6, 7, 9 ], 
      [ 1, 4, 7, 8, 10 ], [ 1, 5, 6, 8, 11 ], [ 2, 3, 6, 8, 10 ], 
      [ 2, 4, 6, 7, 11 ], [ 2, 5, 7, 8, 9 ], [ 3, 4, 8, 9, 11 ], 
      [ 3, 5, 7, 10, 11 ], [ 4, 5, 6, 9, 10 ] ], 
  tSubsetStructure := rec( t := 2, lambdas := [ 2 ] ), isBinary := true, 
  isSimple := true, blockSizes := [ 5 ], blockNumbers := [ 11 ], r := 5, 
  autGroup := Group([ (2,4)(3,5)(7,11)(8,9), (1,3)(2,5)(7,9)(10,11), 
      (1,5,3)(6,11,7)(8,10,9), (1,10,5,2,11,3)(4,9,7)(6,8) ]) )
gap&gt; AllTDesignLambdas(D);      
[ 11, 5, 2 ]
gap&gt; DP:=DeletedPointsBlockDesign(D,[5,8]);
rec( isBlockDesign := true, v := 9, 
  blocks := [ [ 1, 2, 3, 4 ], [ 1, 2, 7, 8, 9 ], [ 1, 3, 5, 6, 7 ], 
      [ 1, 4, 6, 8 ], [ 1, 5, 9 ], [ 2, 3, 5, 8 ], [ 2, 4, 5, 6, 9 ], 
      [ 2, 6, 7 ], [ 3, 4, 7, 9 ], [ 3, 6, 8, 9 ], [ 4, 5, 7, 8 ] ], 
  pointNames := [ 1, 2, 3, 4, 6, 7, 9, 10, 11 ] )
gap&gt; PairwiseBalancedLambda(DP);
2
</pre>
<p>
<a name = "SSEC001.8"></a>
<li><code>DeletedBlocksBlockDesign( </code><var>D</var><code>, </code><var>Y</var><code>)</code>
<p>
Suppose <var>D</var> is a block design, and <var>Y</var> is a proper sublist of the 
block-list of <var>D</var> (<var>Y</var> need not be sorted).
<p>
Then this function returns the block design obtained from <var>D</var> by deleting
the blocks in <var>Y</var> (counting repeats) from the block-list of <var>D</var>.
<p>
<pre>
gap&gt; D:=BlockDesign(7,[[1,2,4],[1,2,4]],Group((1,2,3,4,5,6,7)));
rec( isBlockDesign := true, v := 7, 
  blocks := [ [ 1, 2, 4 ], [ 1, 2, 4 ], [ 1, 3, 7 ], [ 1, 3, 7 ], 
      [ 1, 5, 6 ], [ 1, 5, 6 ], [ 2, 3, 5 ], [ 2, 3, 5 ], [ 2, 6, 7 ], 
      [ 2, 6, 7 ], [ 3, 4, 6 ], [ 3, 4, 6 ], [ 4, 5, 7 ], [ 4, 5, 7 ] ], 
  autSubgroup := Group([ (1,2,3,4,5,6,7) ]) )
gap&gt; DeletedBlocksBlockDesign(D,[[2,3,5],[2,3,5],[4,5,7]]);
rec( isBlockDesign := true, v := 7, 
  blocks := [ [ 1, 2, 4 ], [ 1, 2, 4 ], [ 1, 3, 7 ], [ 1, 3, 7 ], 
      [ 1, 5, 6 ], [ 1, 5, 6 ], [ 2, 6, 7 ], [ 2, 6, 7 ], [ 3, 4, 6 ], 
      [ 3, 4, 6 ], [ 4, 5, 7 ] ] )
</pre>
<p>
<a name = "SSEC001.9"></a>
<li><code>AddedPointBlockDesign( </code><var>D</var><code>, </code><var>Y</var><code> )</code>
<li><code>AddedPointBlockDesign( </code><var>D</var><code>, </code><var>Y</var><code>, </code><var>pointname</var><code> )</code>
<p>
Suppose <var>D</var> is a block design, and <var>Y</var> is a sublist of the block-list
of <var>D</var> (<var>Y</var> need not be sorted).
<p>
Then this function returns the block design obtained from <var>D</var> by adding
the new point <code></code><var>D</var><code>.v+1</code> to the point-set, and adding this new point
(once) to each block of <var>Y</var> (where repeats count).
<p>
The optional parameter <var>pointname</var> specifies a point-name for the
new point.
<p>
<pre>
gap&gt; D:=BlockDesign(7,[[1,2,4],[1,2,4]],Group((1,2,3,4,5,6,7)));
rec( isBlockDesign := true, v := 7, 
  blocks := [ [ 1, 2, 4 ], [ 1, 2, 4 ], [ 1, 3, 7 ], [ 1, 3, 7 ], 
      [ 1, 5, 6 ], [ 1, 5, 6 ], [ 2, 3, 5 ], [ 2, 3, 5 ], [ 2, 6, 7 ], 
      [ 2, 6, 7 ], [ 3, 4, 6 ], [ 3, 4, 6 ], [ 4, 5, 7 ], [ 4, 5, 7 ] ], 
  autSubgroup := Group([ (1,2,3,4,5,6,7) ]) )
gap&gt; AddedPointBlockDesign(D,[[2,3,5],[2,3,5],[4,5,7]],"infinity");
rec( isBlockDesign := true, v := 8, 
  blocks := [ [ 1, 2, 4 ], [ 1, 2, 4 ], [ 1, 3, 7 ], [ 1, 3, 7 ], 
      [ 1, 5, 6 ], [ 1, 5, 6 ], [ 2, 3, 5, 8 ], [ 2, 3, 5, 8 ], [ 2, 6, 7 ], 
      [ 2, 6, 7 ], [ 3, 4, 6 ], [ 3, 4, 6 ], [ 4, 5, 7 ], [ 4, 5, 7, 8 ] ], 
  pointNames := [ 1, 2, 3, 4, 5, 6, 7, "infinity" ] )
</pre>
<p>
<a name = "SSEC001.10"></a>
<li><code>AddedBlocksBlockDesign( </code><var>D</var><code>, </code><var>Y</var><code> )</code>
<p>
Suppose <var>Y</var> is a list of multisets of points of the block design <var>D</var>.
Then this function returns a new block design, whose point-set is that
of <var>D</var>, and whose block list is that of <var>D</var> with the elements of <var>Y</var>
(including repeats) added.
<p>
<pre>
gap&gt; D:=BlockDesign(7,[[1,2,4]],Group((1,2,3,4,5,6,7)));           
rec( isBlockDesign := true, v := 7, 
  blocks := [ [ 1, 2, 4 ], [ 1, 3, 7 ], [ 1, 5, 6 ], [ 2, 3, 5 ], 
      [ 2, 6, 7 ], [ 3, 4, 6 ], [ 4, 5, 7 ] ], 
  autSubgroup := Group([ (1,2,3,4,5,6,7) ]) )
gap&gt; AddedBlocksBlockDesign(D,D.blocks);
rec( isBlockDesign := true, v := 7, 
  blocks := [ [ 1, 2, 4 ], [ 1, 2, 4 ], [ 1, 3, 7 ], [ 1, 3, 7 ], 
      [ 1, 5, 6 ], [ 1, 5, 6 ], [ 2, 3, 5 ], [ 2, 3, 5 ], [ 2, 6, 7 ], 
      [ 2, 6, 7 ], [ 3, 4, 6 ], [ 3, 4, 6 ], [ 4, 5, 7 ], [ 4, 5, 7 ] ] )
</pre>
<p>
<a name = "SSEC001.11"></a>
<li><code>DerivedBlockDesign( </code><var>D</var><code>, </code><var>x</var><code> )</code>
<p>
Suppose <var>D</var> is a block design, and <var>x</var> is a point or block of <var>D</var>.
Then this function returns the <strong>derived design</strong>
<a name = "I0"></a>

<i>DD</i> of <var>D</var>, with respect to <var>x</var>.
<p>
If <var>x</var> is a point then <i>DD</i> is the block design whose blocks are those
of <var>D</var> containing <var>x</var>, but with <var>x</var> deleted from these blocks, and the
points of <i>DD</i> are those which occur in some block of <i>DD</i>.
<p>
If <var>x</var> is a block, then the points of <i>DD</i> are the points in <var>x</var>, and
the blocks of <i>DD</i> are the blocks of <var>D</var> other than <var>x</var> containing at
least one point of <var>x</var>, but with all points not in <var>x</var> deleted from
these blocks.  Note that any repeat of <var>x</var>, but not <var>x</var> itself, is a
block of <i>DD</i>.
<p>
It is an error if the resulting block design <i>DD</i> has no blocks or an
empty block.
<p>
The points of <i>DD</i> are relabelled 1,2,&#183;.&#183;, preserving the order of
the corresponding points of <var>D</var>; the point-names of <i>DD</i> (listed in
<code><i>DD</i>.pointNames</code>) are those of these corresponding points of <var>D</var>.
<p>
<pre>
gap&gt; D:=BlockDesigns(rec(v:=11,blockSizes:=[5],
&gt;       tSubsetStructure:=rec(t:=2,lambdas:=[2])))[1];
rec( isBlockDesign := true, v := 11, 
  blocks := [ [ 1, 2, 3, 4, 5 ], [ 1, 2, 9, 10, 11 ], [ 1, 3, 6, 7, 9 ], 
      [ 1, 4, 7, 8, 10 ], [ 1, 5, 6, 8, 11 ], [ 2, 3, 6, 8, 10 ], 
      [ 2, 4, 6, 7, 11 ], [ 2, 5, 7, 8, 9 ], [ 3, 4, 8, 9, 11 ], 
      [ 3, 5, 7, 10, 11 ], [ 4, 5, 6, 9, 10 ] ], 
  tSubsetStructure := rec( t := 2, lambdas := [ 2 ] ), isBinary := true, 
  isSimple := true, blockSizes := [ 5 ], blockNumbers := [ 11 ], r := 5, 
  autGroup := Group([ (2,4)(3,5)(7,11)(8,9), (1,3)(2,5)(7,9)(10,11), 
      (1,5,3)(6,11,7)(8,10,9), (1,10,5,2,11,3)(4,9,7)(6,8) ]) )
gap&gt; AllTDesignLambdas(D);      
[ 11, 5, 2 ]
gap&gt; DD:=DerivedBlockDesign(D,6);
rec( isBlockDesign := true, v := 10, 
  blocks := [ [ 1, 3, 6, 8 ], [ 1, 5, 7, 10 ], [ 2, 3, 7, 9 ], 
      [ 2, 4, 6, 10 ], [ 4, 5, 8, 9 ] ], 
  pointNames := [ 1, 2, 3, 4, 5, 7, 8, 9, 10, 11 ] )
gap&gt; AllTDesignLambdas(DD);
[ 5, 2 ]
gap&gt; DD:=DerivedBlockDesign(D,D.blocks[6]);
rec( isBlockDesign := true, v := 5, 
  blocks := [ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 2, 3 ], [ 2, 4 ], 
      [ 2, 5 ], [ 3, 4 ], [ 3, 5 ], [ 4, 5 ] ], 
  pointNames := [ 2, 3, 6, 8, 10 ] )
gap&gt; AllTDesignLambdas(DD);
[ 10, 4, 1 ]
</pre>
<p>
<a name = "SSEC001.12"></a>
<li><code>ResidualBlockDesign( </code><var>D</var><code>, </code><var>x</var><code> )</code>
<p>
Suppose <var>D</var> is a block design, and <var>x</var> is a point or block of <var>D</var>.
Then this function returns the <strong>residual design</strong>
<a name = "I1"></a>

<i>RD</i> of <var>D</var>, with respect to <var>x</var>.
<p>
If <var>x</var> is a point then <i>RD</i> is the block design whose blocks are those
of <var>D</var> not containing <var>x</var>, and the points of <i>RD</i> are those which occur
in some block of <i>RD</i>.
<p>
If <var>x</var> is a block, then the points of <i>RD</i> are those of <var>D</var> not in
<var>x</var>, and the blocks of <i>RD</i> are the blocks of <var>D</var> (including repeats)
containing at least one point not in <var>x</var>, but with all points in <var>x</var>
deleted from these blocks.
<p>
It is an error if the resulting block design <i>RD</i> has no blocks.
<p>
The points of <i>RD</i> are relabelled 1,2,&#183;.&#183;, preserving the order of
the corresponding points of <var>D</var>; the point-names of <i>RD</i> (listed in
<code><i>RD</i>.pointNames</code>) are those of these corresponding points of <var>D</var>.
<p>
<pre>
gap&gt; D:=BlockDesigns(rec(v:=11,blockSizes:=[5],
&gt;       tSubsetStructure:=rec(t:=2,lambdas:=[2])))[1];
rec( isBlockDesign := true, v := 11, 
  blocks := [ [ 1, 2, 3, 4, 5 ], [ 1, 2, 9, 10, 11 ], [ 1, 3, 6, 7, 9 ], 
      [ 1, 4, 7, 8, 10 ], [ 1, 5, 6, 8, 11 ], [ 2, 3, 6, 8, 10 ], 
      [ 2, 4, 6, 7, 11 ], [ 2, 5, 7, 8, 9 ], [ 3, 4, 8, 9, 11 ], 
      [ 3, 5, 7, 10, 11 ], [ 4, 5, 6, 9, 10 ] ], 
  tSubsetStructure := rec( t := 2, lambdas := [ 2 ] ), isBinary := true, 
  isSimple := true, blockSizes := [ 5 ], blockNumbers := [ 11 ], r := 5, 
  autGroup := Group([ (2,4)(3,5)(7,11)(8,9), (1,3)(2,5)(7,9)(10,11), 
      (1,5,3)(6,11,7)(8,10,9), (1,10,5,2,11,3)(4,9,7)(6,8) ]) )
gap&gt; AllTDesignLambdas(D);      
[ 11, 5, 2 ]
gap&gt; RD:=ResidualBlockDesign(D,6);
rec( isBlockDesign := true, v := 10, 
  blocks := [ [ 1, 2, 3, 4, 5 ], [ 1, 2, 8, 9, 10 ], [ 1, 4, 6, 7, 9 ], 
      [ 2, 5, 6, 7, 8 ], [ 3, 4, 7, 8, 10 ], [ 3, 5, 6, 9, 10 ] ], 
  pointNames := [ 1, 2, 3, 4, 5, 7, 8, 9, 10, 11 ] )
gap&gt; AllTDesignLambdas(RD);
[ 6, 3 ]
gap&gt; RD:=ResidualBlockDesign(D,D.blocks[6]);
rec( isBlockDesign := true, v := 6, 
  blocks := [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 6 ], [ 1, 4, 5 ], 
      [ 1, 5, 6 ], [ 2, 3, 5 ], [ 2, 4, 6 ], [ 2, 5, 6 ], [ 3, 4, 5 ], 
      [ 3, 4, 6 ] ], pointNames := [ 1, 4, 5, 7, 9, 11 ] )
gap&gt; AllTDesignLambdas(RD);
[ 10, 5, 2 ]
</pre>
<p>
<a name = "SSEC001.13"></a>
<li><code>TDesignFromTBD( </code><var>D</var><code>, </code><var>t</var><code>, </code><var>k</var><code> )</code>
<p>
For <i>t</i> a non-negative integer, <i>K</i> a set of positive integers, and
<i>v</i>,&#955; positive integers with <i>t</i> &#8804; <i>v</i>, a <i>t</i>-<strong>wise balanced design</strong>,
or a <i>t</i>-(<i>v</i>,<i>K</i>,&#955;) <strong>design</strong>, is a binary block design with exactly
<i>v</i> points, such that each block has size in <i>K</i> and each <i>t</i>-subset of
the points is contained in exactly &#955; blocks.
<p>
Now let <var>t</var> and <var>k</var> be positive integers, <var>D</var> be a <var>t</var>-(<i>v</i>,<i>K</i>,&#955;)
design (for some set <i>K</i>), and <i>t</i>  &#8804; <i>k</i>  &#8804; <i>k</i><sub>1</sub>, where exactly <i>s</i>
distinct block-sizes <i>k</i><sub>1</sub> &lt;  &#8230; &lt;  <i>k</i><sub><i>s</i></sub> occur in <var>D</var>. Then this
function returns the <var>t</var>-design <i>D</i><sup>*</sup>=<i>D</i><sup>*</sup>(<i>t</i>,<i>k</i>) described and studied
in <a href="biblio.htm#McSo"><cite>McSo</cite></a>.
<p>
The point set of <i>D</i><sup>*</sup> is that of <var>D</var>, and the block multiset of <i>D</i><sup>*</sup>
consists of, for each <i>i</i>=1,&#8230;,<i>s</i> and each block <i>B</i> of <var>D</var> of size
<i>k</i><sub><i>i</i></sub> (including repeats), exactly <br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"><i>n</i>/</td><td align="left" class="cl">&#x239B;<br />&#x239D;</td><td nowrap="nowrap" align="center"><i>k</i><sub><i>i</i></sub>&#8722;<i>t</i><br /><i>k</i>&#8722;<i>t</i><br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;</td><td nowrap="nowrap" align="center"></td></tr></table></td></tr></table> copies of
every <i>k</i>-subset of <i>B</i>, where <br clear="all" /><table border="0" width="100%"><tr><td><table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center"><i>n</i>:=\lcm(</td><td align="left" class="cl">&#x239B;<br />&#x239D;</td><td nowrap="nowrap" align="center"><i>k</i><sub><i>i</i></sub>&#8722;<i>t</i><br /><i>k</i>&#8722;<i>t</i><br /></td><td align="left" class="cl">&#x239E;<br />&#x23A0;</td><td nowrap="nowrap" align="center">:1 &#8804; <i>i</i> &#8804; <i>s</i>)</td></tr></table></td></tr></table>.
<p>
It is shown in <a href="biblio.htm#McSo"><cite>McSo</cite></a> that <i>D</i><sup>*</sup> is a <i>t</i>-(<i>v</i>,<i>k</i>,<i>n</i>&#955;) design,
that \Aut(<i>D</i>) &#8838; \Aut(<i>D</i><sup>*</sup>), and that if &#955; = 1 and <i>t</i> &lt; <i>k</i>,
then \Aut(<i>D</i>)=\Aut(<i>D</i><sup>*</sup>).
<p>
<pre>
gap&gt; D:=BlockDesigns(rec(v:=10, blockSizes:=[3,4],       
&gt;          tSubsetStructure:=rec(t:=2,lambdas:=[1])))[1];
rec( isBlockDesign := true, v := 10, 
  blocks := [ [ 1, 2, 3, 4 ], [ 1, 5, 6, 7 ], [ 1, 8, 9, 10 ], [ 2, 5, 10 ], 
      [ 2, 6, 8 ], [ 2, 7, 9 ], [ 3, 5, 9 ], [ 3, 6, 10 ], [ 3, 7, 8 ], 
      [ 4, 5, 8 ], [ 4, 6, 9 ], [ 4, 7, 10 ] ], 
  tSubsetStructure := rec( t := 2, lambdas := [ 1 ] ), isBinary := true, 
  isSimple := true, blockSizes := [ 3, 4 ], blockNumbers := [ 9, 3 ], 
  autGroup := Group([ (5,6,7)(8,9,10), (2,3)(5,7)(8,10), 
      (2,3,4)(5,7,6)(8,9,10), (2,3,4)(5,9,6,8,7,10), (2,6,9,3,7,10)(4,5,8) ]) 
 )
gap&gt; PairwiseBalancedLambda(D);                          
1
gap&gt; Dstar:=TDesignFromTBD(D,2,3);   
rec( isBlockDesign := true, v := 10, 
  blocks := [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ], [ 1, 5, 6 ], 
      [ 1, 5, 7 ], [ 1, 6, 7 ], [ 1, 8, 9 ], [ 1, 8, 10 ], [ 1, 9, 10 ], 
      [ 2, 3, 4 ], [ 2, 5, 10 ], [ 2, 5, 10 ], [ 2, 6, 8 ], [ 2, 6, 8 ], 
      [ 2, 7, 9 ], [ 2, 7, 9 ], [ 3, 5, 9 ], [ 3, 5, 9 ], [ 3, 6, 10 ], 
      [ 3, 6, 10 ], [ 3, 7, 8 ], [ 3, 7, 8 ], [ 4, 5, 8 ], [ 4, 5, 8 ], 
      [ 4, 6, 9 ], [ 4, 6, 9 ], [ 4, 7, 10 ], [ 4, 7, 10 ], [ 5, 6, 7 ], 
      [ 8, 9, 10 ] ], 
  autGroup := Group([ (5,6,7)(8,9,10), (2,3)(5,7)(8,10), (2,3,4)(5,7,6)(8,9,
        10), (2,3,4)(5,9,6,8,7,10), (2,6,9,3,7,10)(4,5,8) ]) )
gap&gt; AllTDesignLambdas(Dstar);
[ 30, 9, 2 ]
</pre>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP002.htm">Previous</a>] [<a href ="CHAP004.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>design manual<br>March 2019
</address></body></html>