<html><head><title>[design] 4 Determining basic properties of block designs</title></head>
<body text="#000000" bgcolor="#ffffff">
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP003.htm">Previous</a>] [<a href ="CHAP005.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<h1>4 Determining basic properties of block designs</h1><p>
<P>
<H3>Sections</H3>
<oL>
<li> <A HREF="CHAP004.htm#SECT001">The functions for basic properties</a>
</ol><p>
<p>
<p>
<h2><a name="SECT001">4.1 The functions for basic properties</a></h2>
<p><p>
<a name = "SSEC001.1"></a>
<li><code>IsBlockDesign( </code><var>obj</var><code> )</code>
<p>
This boolean function  returns <code>true</code> if and only if <var>obj</var>, which can be
an object of arbitrary type, is a block design.
<p>
<pre>
gap&gt; IsBlockDesign(5);
false
gap&gt; IsBlockDesign( BlockDesign(2,[[1],[1,2],[1,2]]) );
true
</pre>
<p>
<a name = "SSEC001.2"></a>
<li><code>IsBinaryBlockDesign( </code><var>D</var><code> )</code>
<p>
This boolean function  returns <code>true</code> if and only if the block design
<var>D</var> is <strong>binary</strong>, that is, if no block of <var>D</var> has a repeated element.
<p>
<pre>
gap&gt; IsBinaryBlockDesign( BlockDesign(2,[[1],[1,2],[1,2]]) );
true
gap&gt; IsBinaryBlockDesign( BlockDesign(2,[[1],[1,2],[1,2,2]]) );
false
</pre>
<p>
<a name = "SSEC001.3"></a>
<li><code>IsSimpleBlockDesign( </code><var>D</var><code> )</code>
<p>
This boolean function  returns <code>true</code> if and only if the block design
<var>D</var> is <strong>simple</strong>, that is, if no block of <var>D</var> is repeated.
<p>
<pre>
gap&gt; IsSimpleBlockDesign( BlockDesign(2,[[1],[1,2],[1,2]]) );  
false
gap&gt; IsSimpleBlockDesign( BlockDesign(2,[[1],[1,2],[1,2,2]]) );
true
</pre>
<p>
<a name = "SSEC001.4"></a>
<li><code>IsConnectedBlockDesign( </code><var>D</var><code> )</code>
<p>
This boolean function  returns <code>true</code> if and only if the block design
<var>D</var> is <strong>connected</strong>, that is, if its incidence graph is a connected
graph.
<p>
<pre>
gap&gt; IsConnectedBlockDesign( BlockDesign(2,[[1],[2]]) ); 
false
gap&gt; IsConnectedBlockDesign( BlockDesign(2,[[1,2]]) );  
true
</pre>
<p>
<a name = "SSEC001.5"></a>
<li><code>BlockDesignPoints( </code><var>D</var><code> )</code>
<p>
This function returns the set of points of the block design <var>D</var>, that is
<code>[1..</code><var>D</var><code>.v]</code>. The returned result is immutable.
<p>
<pre>
gap&gt; D:=BlockDesign(3,[[1,2],[1,3],[2,3],[2,3]]);
rec( isBlockDesign := true, v := 3, 
  blocks := [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 2, 3 ] ] )
gap&gt; BlockDesignPoints(D);                       
[ 1 .. 3 ]
</pre>
<p>
<a name = "SSEC001.6"></a>
<li><code>NrBlockDesignPoints( </code><var>D</var><code> )</code>
<p>
This function returns the number of points of the block design <var>D</var>.
<p>
<pre>
gap&gt; D:=BlockDesign(3,[[1,2],[1,3],[2,3],[2,3]]);
rec( isBlockDesign := true, v := 3, 
  blocks := [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 2, 3 ] ] )
gap&gt; NrBlockDesignPoints(D);                     
3
</pre>
<p>
<a name = "SSEC001.7"></a>
<li><code>BlockDesignBlocks( </code><var>D</var><code> )</code>
<p>
This function returns the (sorted) list of blocks of the block design <var>D</var>.
The returned result is immutable.
<p>
<pre>
gap&gt; D:=BlockDesign(3,[[1,2],[1,3],[2,3],[2,3]]);
rec( isBlockDesign := true, v := 3, 
  blocks := [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 2, 3 ] ] )
gap&gt; BlockDesignBlocks(D);                       
[ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 2, 3 ] ]
</pre>
<p>
<a name = "SSEC001.8"></a>
<li><code>NrBlockDesignBlocks( </code><var>D</var><code> )</code>
<p>
This function returns the number of blocks of the block design <var>D</var>.
<p>
<pre>
gap&gt; D:=BlockDesign(3,[[1,2],[1,3],[2,3],[2,3]]);
rec( isBlockDesign := true, v := 3, 
  blocks := [ [ 1, 2 ], [ 1, 3 ], [ 2, 3 ], [ 2, 3 ] ] )
gap&gt; NrBlockDesignBlocks(D);                     
4
</pre>
<p>
<a name = "SSEC001.9"></a>
<li><code>BlockSizes( </code><var>D</var><code> )</code>
<p>
This function returns the set of sizes (actually list-lengths) of the 
blocks of the block design <var>D</var>.
<p>
<pre>
gap&gt; BlockSizes( BlockDesign(3,[[1],[1,2,2],[1,2,3],[2],[3]]) );  
[ 1, 3 ]
</pre>
<p>
<a name = "SSEC001.10"></a>
<li><code>BlockNumbers( </code><var>D</var><code> )</code>
<p>
Let <var>D</var> be a block design. Then this function returns a list of
the same length as <code>BlockSizes(</code><var>D</var><code>)</code>, such that the <i>i</i>-th element 
of this returned list is the number of blocks of <var>D</var> of size
<code>BlockSizes(</code><var>D</var><code>)[<i>i</i>]</code>.
<p>
<pre>
gap&gt; D:=BlockDesign(3,[[1],[1,2,2],[1,2,3],[2],[3]]); 
rec( isBlockDesign := true, v := 3, 
  blocks := [ [ 1 ], [ 1, 2, 2 ], [ 1, 2, 3 ], [ 2 ], [ 3 ] ] )
gap&gt; BlockSizes(D);
[ 1, 3 ]
gap&gt; BlockNumbers(D);
[ 3, 2 ]
</pre>
<p>
<a name = "SSEC001.11"></a>
<li><code>ReplicationNumber( </code><var>D</var><code> )</code>
<p>
If the block design <var>D</var> is equireplicate, then this function returns
its replication number; otherwise <code>fail</code> is returned.
<p>
A block design <i>D</i> is <strong>equireplicate</strong> with <strong>replication number</strong> <i>r</i> if,
for every point <i>x</i> of <i>D</i>, <i>r</i> is equal to the sum over the blocks of
the multiplicity of <i>x</i> in a block. For a binary block design this is
the same as saying that each point <i>x</i> is contained in exactly <i>r</i> blocks.
<p>
<pre>
gap&gt; ReplicationNumber(BlockDesign(4,[[1],[1,2],[2,3,3],[4,4]]));
2
gap&gt; ReplicationNumber(BlockDesign(4,[[1],[1,2],[2,3],[4,4]]));  
fail
</pre>
<p>
<a name = "SSEC001.12"></a>
<li><code>PairwiseBalancedLambda( </code><var>D</var><code> )</code>
<p>
A binary block design <i>D</i> is <strong>pairwise balanced</strong> if <i>D</i> has at least two
points and every pair of distinct points is contained in exactly &#955;
blocks, for some positive constant &#955;.
<p>
Given a binary block design <var>D</var>, this function returns <code>fail</code> if <var>D</var> is
not pairwise balanced, and otherwise the positive constant &#955; such
that every pair of distinct points of <var>D</var> is in exactly &#955; blocks.
<p>
<pre>
gap&gt; D:=BlockDesigns(rec(v:=10, blockSizes:=[3,4],       
&gt;          tSubsetStructure:=rec(t:=2,lambdas:=[1])))[1];
rec( isBlockDesign := true, v := 10, 
  blocks := [ [ 1, 2, 3, 4 ], [ 1, 5, 6, 7 ], [ 1, 8, 9, 10 ], [ 2, 5, 10 ], 
      [ 2, 6, 8 ], [ 2, 7, 9 ], [ 3, 5, 9 ], [ 3, 6, 10 ], [ 3, 7, 8 ], 
      [ 4, 5, 8 ], [ 4, 6, 9 ], [ 4, 7, 10 ] ], 
  tSubsetStructure := rec( t := 2, lambdas := [ 1 ] ), isBinary := true, 
  isSimple := true, blockSizes := [ 3, 4 ], blockNumbers := [ 9, 3 ], 
  autGroup := Group([ (5,6,7)(8,9,10), (2,3)(5,7)(8,10), 
      (2,3,4)(5,7,6)(8,9,10), (2,3,4)(5,9,6,8,7,10), (2,6,9,3,7,10)(4,5,8) ]) 
 )
gap&gt; PairwiseBalancedLambda(D);                          
1
</pre>
<p>
<a name = "SSEC001.13"></a>
<li><code>TSubsetLambdasVector( </code><var>D</var><code>, </code><var>t</var><code> )</code>
<p>
Let <var>D</var> be a block design, <var>t</var> a non-negative integer, and 
<code><i>v</i>=</code><var>D</var><code>.v</code>. Then this function returns an integer vector <i>L</i> 
whose positions correspond to the <var>t</var>-subsets of {1,&#8230;,<i>v</i>}.
The <i>i</i>-th element of <i>L</i> is the sum over all blocks <i>B</i> of <var>D</var> 
of the number of times the <i>i</i>-th <var>t</var>-subset (in lexicographic order) 
is contained in <i>B</i>. (For example, if <i>t</i>=2 and <i>B</i>=[1,1,2,3,3,4], then
<i>B</i> contains [1,2] twice, [1,3] four times, [1,4] twice,
[2,3] twice, [2,4] once, and [3,4] twice.) In particular, 
if <var>D</var> is binary then <i>L</i>[<i>i</i>] is simply the number of blocks of <var>D</var> 
containing the <i>i</i>-th <var>t</var>-subset (in lexicographic order).
<p>
<pre>
gap&gt; D:=BlockDesign(3,[[1],[1,2,2],[1,2,3],[2],[3]]);;
gap&gt; TSubsetLambdasVector(D,0);
[ 5 ]
gap&gt; TSubsetLambdasVector(D,1);
[ 3, 4, 2 ]
gap&gt; TSubsetLambdasVector(D,2);
[ 3, 1, 1 ]
gap&gt; TSubsetLambdasVector(D,3);
[ 1 ]
</pre>
<p>
<a name = "SSEC001.14"></a>
<li><code>AllTDesignLambdas( </code><var>D</var><code> )</code>
<p>
If the block design <var>D</var> is not a <i>t</i>-design for some <i>t</i> &#8805; 0 then this
function returns an empty list. Otherwise <var>D</var> is a binary block design
with constant block size <i>k</i>, say, and this function returns a list
<i>L</i> of length <i>T</i>+1, where <i>T</i> is the maximum <i>t</i> &#8804; <i>k</i> such that <var>D</var>
is a <i>t</i>-design, and, for <i>i</i>=1,&#8230;,<i>T</i>+1, <i>L</i>[<i>i</i>] is equal to the
(constant) number of blocks of <var>D</var> containing an (<i>i</i>&#8722;1)-subset of
the point-set of <var>D</var>. The returned result is immutable.
<p>
<pre>
gap&gt; AllTDesignLambdas(PGPointFlatBlockDesign(3,2,1));                  
[ 35, 7, 1 ]
</pre>
<p>
<a name = "SSEC001.15"></a>
<li><code>AffineResolvableMu( </code><var>D</var><code> )</code>
<p>
A block design is <strong>affine resolvable</strong> if the design is resolvable 
and any two blocks not in the same parallel class of a resolution 
meet in a constant number &#956; of points. 
<p>
If the block design <var>D</var> is affine resolvable, then this function
returns its value of &#956;; otherwise <code>fail</code> is returned.
<p>
The value 0 is returned if, and only if, <var>D</var> consists of a single
parallel class.
<p>
<pre>
gap&gt; P:=PGPointFlatBlockDesign(2,3,1);; # projective plane of order 3 
gap&gt; AffineResolvableMu(P);
fail
gap&gt; A:=ResidualBlockDesign(P,P.blocks[1]);; # affine plane of order 3
gap&gt; AffineResolvableMu(A);                                           
1
</pre>
<p>
[<a href = "chapters.htm">Up</a>] [<a href ="CHAP003.htm">Previous</a>] [<a href ="CHAP005.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
<P>
<address>design manual<br>March 2019
</address></body></html>