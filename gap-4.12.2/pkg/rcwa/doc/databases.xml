<!-- #################################################################### -->
<!-- ##                                                                ## -->
<!-- ##  databases.xml         RCWA documentation         Stefan Kohl  ## -->
<!-- ##                                                                ## -->
<!-- #################################################################### -->

<Chapter Label="ch:Databases">
<Heading>
  Databases of Residue-Class-Wise Affine Groups and -Mappings
</Heading>

The &RCWA; package contains a number of databases of rcwa groups and rcwa
mappings. They can be loaded into a &GAP; session by the functions described
in this chapter.

<!-- #################################################################### -->

<Section Label="sec:Examples">
<Heading>The collection of examples</Heading>

<ManSection>
  <Func Name="LoadRCWAExamples" Arg = ""/>
  <Returns>
    the name of the variable to which the record containing the
    collection of examples of rcwa groups and -mappings loaded from the file
    <F>pkg/rcwa/examples/examples.g</F> got bound.
  </Returns>
  <Description>
    The components of the examples record are records which contain the
    individual groups and mappings.
    A detailed description of some of the examples can be found in
    Chapter&nbsp;<Ref Label="ch:Examples"/>.
<Example>
<![CDATA[
gap> LoadRCWAExamples();
"RCWAExamples"                                
gap> Set(RecNames(RCWAExamples));
[ "AbelianGroupOverPolynomialRing", "Basics", "CT3Z", "CTPZ", 
  "CheckingForSolvability", "ClassSwitches", 
  "ClassTranspositionProducts", "ClassTranspositionsAsCommutators", 
  "CollatzFactorizationOld", "CollatzMapping", "CollatzlikePerms", 
  "CoprimeMultDiv", "F2_PSL2Z", "Farkas", "FiniteQuotients", 
  "FiniteVsDenseCycles", "GF2xFiniteCycles", "GrigorchukQuotients", 
  "Hexagon", "HicksMullenYucasZavislak", "HigmanThompson", 
  "LongCyclesOfPrimeLength", "MatthewsLeigh", 
  "MaybeInfinitelyPresentedGroup", "ModuliOfPowers", 
  "OddNumberOfGens_FiniteOrder", "Semilocals", 
  "SlowlyContractingMappings", "Syl3_S9", "SymmetrizingCollatzTree", 
  "TameGroupByCommsOfWildPerms", "Venturini", "ZxZ" ]
gap> AssignGlobals(RCWAExamples.CollatzMapping);
The following global variables have been assigned:
[ "T", "T5", "T5m", "T5p", "Tm", "Tp" ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:DatabasesOfRcwaGroups">
<Heading>Databases of rcwa groups</Heading>

<ManSection>
  <Func Name="LoadDatabaseOfGroupsGeneratedBy3ClassTranspositions"
        Arg = "" Label = "small database"/>
  <Returns>
    the name of the variable to which the record containing the
    database of all groups generated by 3 class transpositions which
    interchange residue classes with moduli <M>\leq 6</M> got bound.
  </Returns>
  <Description>
    The database record has at least the following components (the index
    <C>i</C> is always an integer in the range <C>[1..52394]</C>, and the
    term <Q>indices</Q> always refers to list indices in that range):
    <List>

      <Mark><C>cts</C></Mark>
      <Item>
        The list of all 69 class transpositions which interchange residue
        classes with moduli <M>\leq 6</M>.
      </Item>

      <Mark><C>grps</C></Mark>
      <Item>
        The list of the 52394 groups -- 21948 finite and 30446 infinite ones.
      </Item>

      <Mark><C>sizes</C></Mark>
      <Item>
        The list of group orders --
        it is <C>Size(grps[i]) = sizes[i]</C>.
      </Item>

      <Mark><C>mods</C></Mark>
      <Item>
        The list of moduli of the groups --
        it is <C>Mod(grps[i]) = mods[i]</C>.
      </Item>

      <Mark><C>equalityclasses</C></Mark>
      <Item>
        A list of lists of indices <C>i</C> of groups which are known
        to be equal, i.e. if <C>i</C> and <C>j</C> lie in the same list,
        then <C>grps[i] = grps[j]</C>.
      </Item>

      <Mark><C>samegroups</C></Mark>
      <Item>
        A list of lists, where <C>samegroups[i]</C> is a list of indices
        of groups which are known to be equal to <C>grps[i]</C>.
      </Item>

      <Mark><C>conjugacyclasses</C></Mark>
      <Item>
        A list of lists of indices of groups which are known to be conjugate
        in RCWA(&ZZ;).
      </Item>

      <Mark><C>subgroups</C></Mark>
      <Item>
        A list of lists, where <C>subgroups[i]</C> is a list of indices
        of groups which are known to be proper subgroups of <C>grps[i]</C>.
      </Item>

      <Mark><C>supergroups</C></Mark>
      <Item>
        A list of lists, where <C>supergroups[i]</C> is a list of indices
        of groups which are known to be proper supergroups of <C>grps[i]</C>.
      </Item>

      <Mark><C>chains</C></Mark>
      <Item>
        A list of lists, where each list contains the indices of the groups
        in a descending chain of subgroups.
      </Item>

      <Mark><C>respectedpartitions</C></Mark>
      <Item>
        The list of shortest respected partitions.
        If <C>grps[i]</C> is finite, then <C>respectedpartitions[i]</C>
        is a list of pairs (residue, modulus) for the residue classes
        in the shortest respected partition <C>grps[i]</C>. If <C>grps[i]</C>
        is infinite, then <C>respectedpartitions[i] = fail</C>.
      </Item>

      <Mark><C>partitionlengths</C></Mark>
      <Item>
        The list of lengths of shortest respected partitions.
        If the group <C>grps[i]</C> is finite, then <C>partitionlengths[i]</C>
        is the length of the shortest respected partition of <C>grps[i]</C>.
        If <C>grps[i]</C> is infinite, then <C>partitionlengths[i] = 0</C>.
      </Item>

      <Mark><C>degrees</C></Mark>
      <Item>
        The list of permutation degrees, i.e. numbers of moved points,
        in the action of the finite groups on their shortest respected
        partitions. If there is no respected partition, i.e. if
        <C>grps[i]</C> is infinite, then <C>degrees[i] = 0</C>.
      </Item>

      <Mark><C>orbitlengths</C></Mark>
      <Item>
        The list of lists of orbit lengths in the action of the finite groups
        on their shortest respected partitions.
        If <C>grps[i]</C> is infinite, then <C>orbitlengths[i] = fail</C>.
      </Item>

      <Mark><C>permgroupgens</C></Mark>
      <Item>
        The list of lists of generators of the isomorphic permutation groups
        induced by the finite groups on their shortest respected partitions.
        If <C>grps[i]</C> is infinite, then <C>permgroupgens[i] = fail</C>.
      </Item>

      <Mark><C>stabilize_digitsum_base2_mod2</C></Mark>
      <Item>
         The list of indices of groups which stabilize the digit sum
         in base 2 modulo&nbsp;2.
      </Item>
      <Mark><C>stabilize_digitsum_base2_mod3</C></Mark>
      <Item>
         The list of indices of groups which stabilize the digit sum
         in base 2 modulo&nbsp;3.
      </Item>

      <Mark><C>stabilize_digitsum_base3_mod2</C></Mark>
      <Item>
         The list of indices of groups which stabilize the digit sum
         in base 3 modulo&nbsp;2.
      </Item>

      <Mark><C>freeproductcandidates</C></Mark>
      <Item>
         A list of indices of groups which may be isomorphic to the free
         product of 3 copies of the cyclic group of order&nbsp;2.
      </Item>

      <Mark><C>freeproductlikes</C></Mark>
      <Item>
         A list of indices of groups which are not isomorphic to the free
         product of 3 copies of the cyclic group of order&nbsp;2, but
         where the shortest relation indicating this is relatively long.
      </Item>

      <Mark><C>abc_torsion</C></Mark>
      <Item>
         A list of pairs (index, order of product of generators) for all
         infinite groups for which the product of the generators has
         finite order.
      </Item>

      <Mark><C>cyclist</C></Mark>
      <Item>
         A list described in the comments in
         <F>rcwa/data/3ctsgroups6/spheresizecycles.g</F>.
      </Item>

      <Mark><C>finiteorbits</C></Mark>
      <Item>
         A record described in the comments in
         <F>rcwa/data/3ctsgroups6/finite-orbits.g</F>.
      </Item>

      <Mark><C>intransitivemodulo</C></Mark>
      <Item>
        For every modulus <C>m</C> from 1 to 60, <C>intransitivemodulo[m]</C>
        is the list of indices of groups none of whose orbits on &ZZ;
        has nontrivial intersection with all residue classes
        modulo&nbsp;<C>m</C>.
      </Item>

      <Mark><C>trsstatus</C></Mark>
      <Item>
        A list of strings which describe what is known about whether the
        groups <C>grps[i]</C> act transitively on the nonnegative integers
        in their support, or how the computation has failed.
      </Item>

      <Mark><C>orbitgrowthtype</C></Mark>
      <Item>
        A list of integers and lists of integers which encode what has been
        observed heuristically on the growth of the orbits of the groups
        <C>grps[i]</C> on&nbsp;&ZZ;.
      </Item>

    </List>
    Note that the database contains an entry for every unordered
    3-tuple of distinct class transpositions in <C>cts</C>, which means
    that it contains multiple copies of equal groups -- cf. the components
    <C>equalityclasses</C> and <C>samegroups</C> described above. <P/>

    To mention an example, the group <C>grps[44132]</C> might be called
    the <Q>Collatz group</Q> -- its action on the set of positive integers
    which are not multiples of 6 is transitive if and only if the Collatz
    conjecture holds.
<Example>
<![CDATA[
gap> LoadDatabaseOfGroupsGeneratedBy3ClassTranspositions();
"3CTsGroups6"
gap> AssignGlobals(3CTsGroups6); # for convenience
The following global variables have been assigned:
[ "3CTsGroupsWithGivenOrbit", "Id3CTsGroup", 
  "ProbablyFixesDigitSumsModulo", "ProbablyStabilizesDigitSumsModulo", 
  "TriangleTypes", "abc_torsion", "chains", "conjugacyclasses", "cts", 
  "cyclist", "degrees", "epifromfpgroupto_ct23z", 
  "epifromfpgrouptocollatzgroup_c", "epifromfpgrouptocollatzgroup_t", 
  "equalityclasses", "finiteorbits", "freeproductcandidates", 
  "freeproductlikes", "groups", "grps", "intransitivemodulo", 
  "minwordlengthcoprimemultdiv", "minwordlengthnonbalanced", "mods", 
  "orbitgrowthtype", "orbitlengths", "partitionlengths", "permgroupgens",
  "redundant_generator", "refinementseqlngs", "respectedpartitions", 
  "samegroups", "shortresidueclassorbitlengths", "sizes", "sizespos", 
  "sizesset", "spheresizebound_12", "spheresizebound_24", 
  "spheresizebound_4", "spheresizebound_6", 
  "stabilize_digitsum_base2_mod2", "stabilize_digitsum_base2_mod3", 
  "stabilize_digitsum_base3_mod2", "subgroups", "supergroups", 
  "trsstatus", "trsstatuspos", "trsstatusset" ]
gap> grps[44132]; # the "3n+1 group"
<(2(3),4(6)),(1(3),2(6)),(1(2),4(6))>
gap> trsstatus[44132]; # deciding this would solve the 3n+1 problem
"exceeded memory bound"
gap> Length(Set(sizes));
1066
gap> Maximum(Filtered(sizes,IsInt)); # order of largest finite group stored
7165033589793852697531456980706732548435609645091822296777976465116824959\
2135499174617837911754921014138184155204934961004073853323458315539461543\
4480515260818409913846161473536000000000000000000000000000000000000000000\
000000
gap> PrintFactorsInt(last);                                    
2^200*3^103*5^48*7^28*11^16*13^13*17^8*19^6*23^6*29
gap> Positions(sizes,last);                               
[ 33814, 36548 ]
gap> grps{last};
[ <(1(5),4(5)),(0(3),1(6)),(3(4),0(6))>, 
  <(0(5),3(5)),(2(3),4(6)),(0(4),5(6))> ]
gap> samegroups[1];    
[ 1, 2, 68 ]
gap> grps[1] = grps[68];
true
gap> Maximum(mods);
77760
gap> Positions(mods,last);
[ 26311, 26313, 26452, 26453, 26455, 26456, 26457, 26459, 26461, 26462, 
  27781, 27784, 27785, 27786, 27788, 27789, 27790, 27791, 27829, 27832, 
  30523, 30524, 30525, 30526, 30529, 30530, 30532, 30534, 32924, 32927, 
  32931, 32933 ]
gap> Set(sizes{last});     
[ 45509262704640000 ]
gap> Collected(mods);
[ [ 0, 30446 ], [ 3, 1 ], [ 4, 37 ], [ 5, 120 ], [ 6, 1450 ], [ 8, 18 ], 
  [ 10, 45 ], [ 12, 3143 ], [ 15, 165 ], [ 18, 484 ], [ 20, 528 ], 
  [ 24, 1339 ], [ 30, 2751 ], [ 36, 2064 ], [ 40, 26 ], [ 48, 515 ], 
  [ 60, 2322 ], [ 72, 2054 ], [ 80, 44 ], [ 90, 108 ], [ 96, 108 ], 
  [ 108, 114 ], [ 120, 782 ], [ 144, 310 ], [ 160, 26 ], [ 180, 206 ], 
  [ 192, 6 ], [ 216, 72 ], [ 240, 304 ], [ 270, 228 ], [ 288, 14 ], 
  [ 360, 84 ], [ 432, 36 ], [ 480, 218 ], [ 540, 18 ], [ 720, 120 ], 
  [ 810, 112 ], [ 864, 8 ], [ 960, 94 ], [ 1080, 488 ], [ 1620, 44 ], 
  [ 1920, 38 ], [ 2160, 506 ], [ 3240, 34 ], [ 3840, 12 ], 
  [ 4320, 218 ], [ 4860, 16 ], [ 6480, 282 ], [ 7680, 10 ], 
  [ 8640, 16 ], [ 12960, 120 ], [ 14580, 2 ], [ 25920, 34 ], 
  [ 30720, 2 ], [ 38880, 12 ], [ 51840, 8 ], [ 77760, 32 ] ]
gap> Collected(trsstatus);
[ [ "> 1 orbit (mod m)", 593 ], 
  [ "Mod(U DecreasingOn) exceeded <maxmod>", 23 ], 
  [ "U DecreasingOn stable and exceeded memory bound", 11 ], 
  [ "U DecreasingOn stable for <maxeq> steps", 5753 ], 
  [ "exceeded memory bound", 497 ], [ "finite", 21948 ], 
  [ "intransitive, but finitely many orbits", 8 ], 
  [ "seemingly only finite orbits (long)", 1227 ], 
  [ "seemingly only finite orbits (medium)", 2501 ], 
  [ "seemingly only finite orbits (short)", 4816 ], 
  [ "seemingly only finite orbits (very long)", 230 ], 
  [ "seemingly only finite orbits (very long, very unclear)", 76 ], 
  [ "seemingly only finite orbits (very short)", 208 ], 
  [ "there are infinite orbits which have exponential sphere size growth"
        , 2934 ], 
  [ "there are infinite orbits which have linear sphere size growth", 
      10881 ],
  [ "there are infinite orbits which have unclear sphere size growth", 
      86 ], [ "transitive", 562 ], 
  [ "transitive up to one finite orbit", 40 ] ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Func Name="LoadDatabaseOfGroupsGeneratedBy3ClassTranspositions"
        Arg = "max_m" Label = "both databases"/>
  <Returns>
    the name of the variable to which the record containing the
    database of all groups generated by 3 class transpositions which
    interchange residue classes with moduli less than or equal to
    <A>max_m</A> got bound, where <A>max_m</A> is either 6 or&nbsp;9.
  </Returns>
  <Description>
    If <A>max_m</A> is 6, this is equivalent to the call of the function
    without argument described above. If <A>max_m</A> is 9, the function
    returns a record with at least the following components
    (in the sequel, the indices <C>i > j > k</C> are always integers in
    the range <C>[1..264]</C>):
    <List>

      <Mark><C>cts</C></Mark>
      <Item>
        The list of all 264 class transpositions which interchange residue
        classes with moduli <M>\leq 9</M>.
      </Item>

      <Mark><C>mods</C></Mark>
      <Item>
        The list of moduli of the groups, i.e.
        <C>Mod(Group(cts{[i,j,k]})) = mods[i][j][k]</C>.
      </Item>

      <Mark><C>partlengths</C></Mark>
      <Item>
        The list of lengths of shortest respected partitions of the groups
        in the database, i.e.
        <C>Length(RespectedPartition(Group(cts{[i,j,k]})))</C> <C>=</C>
        <C>partlengths[i][j][k]</C>.
      </Item>

      <Mark><C>sizes</C></Mark>
      <Item>
        The list of orders of the groups, i.e.
        <C>Size(Group(cts{[i,j,k]}))</C> <C>=</C> <C>sizes[i][j][k]</C>.
      </Item>

      <Mark><C>All3CTs9Indices</C></Mark>
      <Item>
        A selector function which takes as argument a function <A>func</A>
        of three arguments <A>i</A>, <A>j</A> and <A>k</A>. It returns a
        list of all triples of indices <C>[<A>i</A>,<A>j</A>,<A>k</A>]</C>
        where <M>264 \geq i > j > k \geq 1</M> for which <A>func</A>
        returns <C>true</C>.
      </Item>

      <Mark><C>All3CTs9Groups</C></Mark>
      <Item>
        A selector function which takes as argument a function <A>func</A>
        of three arguments <A>i</A>, <A>j</A> and <A>k</A>. It returns a
        list of all groups <C>Group(cts{[<A>i</A>,<A>j</A>,<A>k</A>]})</C>
        from the database for which
        <C><A>func</A>(<A>i</A>,<A>j</A>,<A>k</A>)</C> returns <C>true</C>.
      </Item>

    </List>
<Example>
<![CDATA[
gap> LoadDatabaseOfGroupsGeneratedBy3ClassTranspositions(9);
"3CTsGroups9"
gap> AssignGlobals(3CTsGroups9);
The following global variables have been assigned:
[ "All3CTs9Groups", "All3CTs9Indices", "cts", "mods", "partlengths", 
  "sizes" ]
gap> PrintFactorsInt(Maximum(Filtered(Flat(sizes),n->n<>infinity)));
2^1283*3^673*5^305*7^193*11^98*13^84*17^50*19^41*23^25*29^13*31^4
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Func Name="LoadDatabaseOfGroupsGeneratedBy4ClassTranspositions"
        Arg = ""/>
  <Returns>
    the name of the variable to which the record containing the
    database of all groups generated by 4 class transpositions which
    interchange residue classes with moduli <M>\leq 6</M> for which
    all subgroups generated by 3 out of the 4 generators are finite
    got bound.
  </Returns>
  <Description>
    The record has at least the following components (the index <C>i</C>
    is always an integer in the range <C>[1..140947]</C>, and the term
    <Q>indices</Q> always refers to list indices in that range):
    <List>

      <Mark><C>cts</C></Mark>
      <Item>
        The list of all 69 class transpositions which interchange residue
        classes with moduli <M>\leq 6</M>.
      </Item>

      <Mark><C>grps4_3finite</C></Mark>
      <Item>
        The list of all 140947 groups in the database.
      </Item>

      <Mark><C>grps4_3finitepos</C></Mark>
      <Item>
        The list obtained from <C>grps4_3finite</C> by replacing every group
        by the list of positions of its generators in the list <C>cts</C>.
      </Item>

      <Mark><C>sizes4</C></Mark>
      <Item>
        The list of group orders --
        it is <C>Size(grps4_3finite[i]) = sizes4[i]</C>.
      </Item>

      <Mark><C>mods4</C></Mark>
      <Item>
        The list of moduli of the groups --
        it is <C>Mod(grps4_3finite[i]) = mods4[i]</C>.
      </Item>

      <Mark><C>conjugacyclasses4cts</C></Mark>
      <Item>
        A list of lists of indices of groups which are known to be conjugate
        in RCWA(&ZZ;).
      </Item>

      <Mark><C>grps4_3finite_reps</C></Mark>
      <Item>
        Tentative conjugacy class representatives from the list
        <C>grps4_3finite</C> -- <E>tentative</E> in the sense that likely
        some of the groups in the list are still conjugate.
      </Item>

    </List>
    Note that the database contains an entry for every suitable unordered
    4-tuple of distinct class transpositions in <C>cts</C>, which means
    that it contains multiple copies of equal groups. 
<Example>
<![CDATA[
gap> LoadDatabaseOfGroupsGeneratedBy4ClassTranspositions(); 
"4CTsGroups6"
gap> AssignGlobals(4CTsGroups6);
The following global variables have been assigned:
[ "conjugacyclasses4cts", "cts", "grps4_3finite", "grps4_3finite_reps", 
  "grps4_3finitepos", "mods4", "sizes4", "sizes4pos", "sizes4set" ]
gap> Length(grps4_3finite);
140947
gap> Length(sizes4);
140947
gap> Size(grps4_3finite[1]);
518400
gap> sizes4[1];
518400
gap> Maximum(Filtered(sizes4,IsInt));
<integer 420...000 (3852 digits)>
gap> Modulus(grps4_3finite[1]);
12
gap> mods4[1];
12
gap> Length(Set(sizes4));
7339
gap> Length(Set(mods4));
91
gap> conjugacyclasses4cts{[1..4]};
[ [ 1, 23, 563, 867 ], [ 2, 859 ], [ 3, 622 ], [ 4, 16, 868, 873 ] ]
gap> grps4_3finite[1] = grps4_3finite[23];
true
gap> grps4_3finite[4] = grps4_3finite[16];
false
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

<Section Label="sec:DatabasesOfRcwaMappings">
<Heading>Databases of rcwa mappings</Heading>

<ManSection>
  <Func Name="LoadDatabaseOfProductsOf2ClassTranspositions"
        Arg = ""/>
  <Returns>
    the name of the variable to which the record containing
    the database of products of 2 class transpositions got bound.
  </Returns>
  <Description>
    There are 69 class transpositions which interchange residue
    classes with moduli <M>\leq 6</M>, thus there is a total of
    <M>(69 \cdot 68)/2 = 2346</M> unordered pairs of distinct
    such class transpositions. Looking at intersection-
    and subset relations between the 4 involved residue classes,
    we can distinguish 17 different <Q>intersection types</Q>
    (or 18, together with the trivial case of equal class transpositions).
    The intersection type does not fully determine the cycle
    structure of the product. -- In total, we can distinguish
    88 different cycle types of products of 2 class transpositions
    which interchange residue classes with moduli <M>\leq 6</M>. <P/>

    The components of the database record are a list <C>CTPairs</C> 
    of all 2346 pairs of distinct class transpositions which interchange
    residue classes with moduli <M>\leq 6</M>, functions
    <C>CTPairsIntersectionTypes</C>, <C>CTPairIntersectionType</C> and
    <C>CTPairProductType</C>, as well as data lists <C>OrdersMatrix</C>,
    <C>CTPairsProductClassification</C>, <C>CTPairsProductType</C>,
    <C>CTProds12</C> and <C>CTProds32</C>.
    -- For the description of these components, see the file
    <F>pkg/rcwa/data/ctproducts/ctprodclass.g</F>.
<Example>
<![CDATA[
gap> LoadDatabaseOfProductsOf2ClassTranspositions();
"CTProducts"
gap> Set(RecNames(CTProducts));
[ "CTPairIntersectionType", "CTPairProductType", "CTPairs", 
  "CTPairsIntersectionTypes", "CTPairsProductClassification", 
  "CTPairsProductType", "CTProds12", "CTProds32", "OrdersMatrix" ]
gap> Length(CTProducts.CTPairs);
2346
gap> Collected(List(CTProducts.CTPairsProductType,l->l[2])); # order stats
[ [ 2, 165 ], [ 3, 255 ], [ 4, 173 ], [ 6, 693 ], [ 10, 2 ], 
  [ 12, 345 ], [ 15, 4 ], [ 20, 10 ], [ 30, 120 ], [ 60, 44 ], 
  [ infinity, 535 ] ]
]]>
</Example>
  </Description>
</ManSection>

<ManSection>
  <Func Name="LoadDatabaseOfNonbalancedProductsOfClassTranspositions"
        Arg = ""/>
  <Returns>
    the name of the variable to which the record containing the database
    of non-balanced products of class transpositions got bound.
  </Returns>
  <Description>
    This database contains a list of the 24 pairs of class
    transpositions which interchange residue classes with moduli
    <M>\leq 6</M> and whose product is not balanced, as well as a list
    of all 36 essentially distinct triples of such class transpositions
    whose product has coprime multiplier and divisor.
<Example>
<![CDATA[
gap> LoadDatabaseOfNonbalancedProductsOfClassTranspositions();
"CTProductsNB"
gap> Set(RecNames(CTProductsNB));
[ "PairsOfCTsWhoseProductIsNotBalanced", 
  "TriplesOfCTsWhoseProductHasCoprimeMultiplierAndDivisor" ]
gap> CTProductsNB.PairsOfCTsWhoseProductIsNotBalanced;
[ [ ( 1(2), 2(4) ), ( 2(4), 3(6) ) ], [ ( 1(2), 2(4) ), ( 2(4), 5(6) ) ], 
  [ ( 1(2), 2(4) ), ( 2(4), 1(6) ) ], [ ( 1(2), 0(4) ), ( 0(4), 1(6) ) ], 
  [ ( 1(2), 0(4) ), ( 0(4), 3(6) ) ], [ ( 1(2), 0(4) ), ( 0(4), 5(6) ) ], 
  [ ( 0(2), 1(4) ), ( 1(4), 2(6) ) ], [ ( 0(2), 1(4) ), ( 1(4), 4(6) ) ], 
  [ ( 0(2), 1(4) ), ( 1(4), 0(6) ) ], [ ( 0(2), 3(4) ), ( 3(4), 4(6) ) ], 
  [ ( 0(2), 3(4) ), ( 3(4), 2(6) ) ], [ ( 0(2), 3(4) ), ( 3(4), 0(6) ) ], 
  [ ( 1(2), 2(6) ), ( 3(4), 2(6) ) ], [ ( 1(2), 2(6) ), ( 1(4), 2(6) ) ], 
  [ ( 1(2), 4(6) ), ( 3(4), 4(6) ) ], [ ( 1(2), 4(6) ), ( 1(4), 4(6) ) ], 
  [ ( 1(2), 0(6) ), ( 1(4), 0(6) ) ], [ ( 1(2), 0(6) ), ( 3(4), 0(6) ) ], 
  [ ( 0(2), 1(6) ), ( 2(4), 1(6) ) ], [ ( 0(2), 1(6) ), ( 0(4), 1(6) ) ], 
  [ ( 0(2), 3(6) ), ( 2(4), 3(6) ) ], [ ( 0(2), 3(6) ), ( 0(4), 3(6) ) ], 
  [ ( 0(2), 5(6) ), ( 2(4), 5(6) ) ], [ ( 0(2), 5(6) ), ( 0(4), 5(6) ) ] 
 ]
]]>
</Example>
  </Description>
</ManSection>

</Section>

<!-- #################################################################### -->

</Chapter>

<!-- #################################################################### -->
