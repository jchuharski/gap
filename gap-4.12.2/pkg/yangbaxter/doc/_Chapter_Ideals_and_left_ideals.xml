<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Ideals_and_left_ideals">
<Heading>Ideals and left ideals</Heading>

 In this section we describe several functions related 
 to ideals and left ideals of skew braces. References: 
 <Cite Key="MR3647970"/> and <Cite Key="MR3763907"/>.
<Section Label="Chapter_Ideals_and_left_ideals_Section_Left_ideals">
<Heading>Left ideals</Heading>

 An left ideal <Math>I</Math> of a skew brace <Math>A</Math> is a subgroup <Math>I</Math> of
 the additive group of <Math>A</Math> such that <Math>\lambda_a(I)\subseteq I</Math> for all <Math>a\in A</Math>.
<ManSection>
  <Attr Arg="obj" Name="LeftIdeals" Label="for IsSkewbrace"/>
 <Returns>a list with the left ideals of the skew brace <A>obj</A>
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="StrongLeftIdeals" Label="for IsSkewbrace"/>
 <Returns>a list with the left ideals of the skew brace <A>obj</A> that are normal in the additive group of <Math>A</Math>
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="obj" Name="IsLeftIdeal" Label="for IsSkewbrace, IsCollection"/>
 <Returns><A>true</A> if the subset is a left ideal of <A>obj</A>
</Returns>
 <Description>
<Example><![CDATA[
gap> br := SmallBrace(8,4);
<brace of size 8>
gap> leftideals := LeftIdeals(br);
[ <brace of size 1>, <brace of size 2>, <brace of size 4>, <brace of size 8> ]
gap> List(leftideals, x->IsLeftIdeal(br, x));
[ true, true, true, true ]
gap> List(leftideals, IdBrace);
[ [ 1, 1 ], [ 2, 1 ], [ 4, 1 ], [ 8, 4 ] ]
]]></Example>


 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Ideals_and_left_ideals_Section_Ideals">
<Heading>Ideals</Heading>

 An ideal <Math>I</Math> of a skew brace <Math>A</Math> is a normal subgroup <Math>I</Math> of
 the additive group of <Math>A</Math> such that <Math>\lambda_a(I)\subseteq I</Math> and <Math>a\circ I=I\circ a</Math> for all <Math>a\in A</Math>.
<ManSection>
  <Oper Arg="obj,subset" Name="IsIdeal" Label="for IsSkewbrace, IsCollection"/>
 <Returns><A>true</A> if the <A>subset</A> is a left ideal of <A>obj</A>
</Returns>
 <Description>
<Example><![CDATA[
gap> br := SmallBrace(8,4);
<brace of size 8>
gap> leftideals := LeftIdeals(br);
[ <brace of size 1>, <brace of size 2>, <brace of size 4>, <brace of size 8> ]
gap> List(leftideals, x->IsLeftIdeal(br, x));
[ true, true, true, true ]
gap> List(leftideals, IdBrace);
[ [ 1, 1 ], [ 2, 1 ], [ 4, 1 ], [ 8, 4 ] ]
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="Ideals" Label="for IsSkewbrace"/>
 <Returns>a list with the ideals of the skew brace <A>obj</A>
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<P/>
<ManSection>
  <Oper Arg="arg1,arg2" Name="AsIdeal" Label="for IsSkewbrace, IsCollection"/>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="obj,subset" Name="IdealGeneratedBy" Label="for IsSkewbrace, IsCollection"/>
 <Returns>the ideal of <A>obj</A> generated by the given <A>subset</A>
</Returns>
 <Description>
 The ideal of a skew brace <Math>A</Math> generated by a subset <Math>X</Math> is the intersection
 of all the ideals of <Math>A</Math> containing <Math>X</Math>.
<Example><![CDATA[
gap> br := SmallSkewbrace(6,6);;
gap> AsList(br);
[ <()>, <(1,2,3)(4,5,6)>, <(1,3,2)(4,6,5)>, <(1,4)(2,5)(3,6)>, 
  <(1,5,3,4,2,6)>, <(1,6,2,4,3,5)> ]
gap> IdealGeneratedBy(br, [last[2]]);
<brace of size 3>
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Oper Arg="ideal1,ideal2" Name="IntersectionOfTwoIdeals" Label="for IsSkewbrace and IsIdealInParent, IsSkewbrace and IsIdealInParent"/>
 <Returns>the intersection of <A>ideal1</A> and <A>ideal2</A>
</Returns>
 <Description>
<Example><![CDATA[
gap> br := SmallSkewbrace(6,6);;
gap> Ideals(br);;
gap> IntersectionOfTwoIdeals(last[2],last[3]);
<brace of size 1>
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Oper Arg="ideal1,ideal2" Name="SumOfTwoIdeals" Label="for IsSkewbrace and IsIdealInParent, IsSkewbrace and IsIdealInParent"/>
 <Returns>the sum of <A>ideal1</A> and <A>ideal2</A>
</Returns>
 <Description>
<Example><![CDATA[
gap> br := SmallSkewbrace(6,6);;
gap> Ideals(br);;
gap> SumOfTwoIdeals(last[2],last[3]);
<brace of size 6>
]]></Example>


 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Ideals_and_left_ideals_Section_Sequences_left_ideals">
<Heading>Sequences (left) ideals</Heading>

<ManSection>
  <Attr Arg="obj" Name="LeftSeries" Label="for IsSkewbrace"/>
 <Returns>the left ideals of the left series of <A>obj</A>
</Returns>
 <Description>
 The left series of a skew brace <Math>A</Math> is defined recursively as 
 <Math>A^1=A</Math> and <Math>A^{n+1}=A*A^n</Math> for <Math>n\geq1</Math>, where <Math>a*b=\lambda_a(b)-b</Math>. Each
 <Math>A^n</Math> is a left ideal.
<Example><![CDATA[
gap> br := SmallSkewbrace(8,20);
<skew brace of size 8>
gap> LeftSeries(br);
[ <skew brace of size 8>, <brace of size 2>, <brace of size 1> ]
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="RightSeries" Label="for IsSkewbrace"/>
 <Returns>the ideals of the right series of <A>obj</A>
</Returns>
 <Description>
 The right series of a skew brace 0<Math>A</Math> is defined recursively as 
 <Math>A^{(1)}=A</Math> and <Math>A^{(n+1)}=A*A^{(n)}</Math> for <Math>n\geq1</Math>, where <Math>a*b=\lambda_a(b)-b</Math>
<Example><![CDATA[
gap> br := SmallSkewbrace(8,20);
<skew brace of size 8>
gap> RightSeries(br);
[ <skew brace of size 8>, <brace of size 2>, <brace of size 1> ]
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Prop Arg="obj" Name="IsLeftNilpotent" Label="for IsSkewbrace"/>
 <Returns><A>true</A> if the skew brace <A>obj</A> is left nilpotent.
</Returns>
 <Description>
 A skew brace <Math>A</Math> is said to be left nilpotent
 if there exists <Math>n\geq1</Math> such that <Math>A^n=0</Math>.
<Example><![CDATA[
gap> IsLeftNilpotent(SmallBrace(8,18));
true
gap> IsLeftNilpotent(SmallBrace(12,2));
false
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Prop Arg="obj" Name="IsSimpleSkewbrace" Label="for IsSkewbrace"/>
 <Returns><A>true</A> if the skew brace <A>obj</A> is simple.
</Returns>
 <Description>
 A skew brace <Math>A</Math> is said to be simple if <Math>\{0\}</Math> and <Math>A</Math> are its only ideals.
<Example><![CDATA[
gap> IsSimple(SmallSkewbrace(12,22));
true
gap> IsSimple(SmallSkewbrace(12,21));
false
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Prop Arg="obj" Name="IsRightNilpotent" Label="for IsSkewbrace"/>
 <Returns><A>true</A> if the skew brace <A>obj</A> is right nilpotent.
</Returns>
 <Description>
 A skew brace <Math>A</Math> is said to be right nilpotent
 if there exists <Math>n\geq1</Math> such that <Math>A^{(n)}=0</Math>.
<Example><![CDATA[
gap> IsRightNilpotent(SmallBrace(8,18));
false
gap> IsRightNilpotent(SmallBrace(12,2));
true
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="LeftNilpotentIdeals" Label="for IsSkewbrace"/>
 <Returns>the list of right or left nilpotent ideals of <A>obj</A>
</Returns>
 <Description>
 An ideal <Math>I</Math> of a skew brace <Math>A</Math> is said to be left if
 it is left nilpotent as a skew brace.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="RightNilpotentIdeals" Label="for IsSkewbrace"/>
 <Returns>the list of right or left nilpotent ideals of <A>obj</A>
</Returns>
 <Description>
 An ideal <Math>I</Math> of a skew brace <Math>A</Math> is said to be right nilpotent if
 An ideal <Math>I</Math> of a skew brace <Math>A</Math> is said to be left if
 it is right nilpotent as a skew brace.
<Example><![CDATA[
gap> br := SmallBrace(8,18);;
gap> IsLeftNilpotent(br);
true
gap> IsRightNilpotent(br);
false
gap> Length(LeftNilpotentIdeals(br));
3
gap> Length(RightNilpotentIdeals(br));
2
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Oper Arg="obj,bound" Name="SmoktunowiczSeries" Label="for IsSkewbrace, IsInt"/>
 <Returns>a list of <A>bound</A> left ideals of the Smoktunowicz's series of <A>obj</A>
</Returns>
 <Description>
 The Smoktunowicz's series of a skew brace <Math>A</Math> is defined recursively as 
 <Math>A^{[1]}=A</Math> and 
 <Math>A^{[n+1]}</Math> is the additive subgroup of <Math>A</Math> generated by <Math>A^{[i]}*A^{[n+1-i]}</Math> for <Math>1\leq i+j\leq n+1</Math>, 
 where <Math>a*b=\lambda_a(b)-b</Math>. 
<Example><![CDATA[
gap> br := SmallBrace(16,145);;
gap> SmoktunowiczSeries(br,4);
[ <brace of size 16>, <brace of size 8>, <brace of size 4>, <brace of size 2>,
  <brace of size 2> ]
gap> SmoktunowiczSeries(br,5);
[ <brace of size 16>, <brace of size 8>, <brace of size 4>, <brace of size 2>,
  <brace of size 2>, <brace of size 1> ]
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="Socle" Label="for IsSkewbrace"/>
 <Returns>the socle of <A>obj</A>
</Returns>
 <Description>
 The socle of a skew brace <Math>A</Math> is the ideal <Math>\ker\lambda\cap Z(A,+)</Math>. 
<Example><![CDATA[
gap> Socle(SmallSkewbrace(6,2));
<brace of size 1>
gap> Socle(SmallBrace(8,20));
<brace of size 8>
gap> Socle(SmallBrace(8,2));
<brace of size 4>
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="Annihilator" Label="for IsSkewbrace"/>
 <Returns>the annihilator of <A>obj</A>
</Returns>
 <Description>
 The socle of a skew brace <Math>A</Math> is the ideal <Math>\ker\lambda\cap Z(A,+)\cap Z(A,\circ)</Math>. 
<Example><![CDATA[
gap> Annihilator(SmallSkewbrace(8,12));
<brace of size 2>
gap> Annihilator(SmallSkewbrace(4,2));
<brace of size 2>
gap> Annihilator(SmallSkewbrace(8,14));
<brace of size 4>
]]></Example>


 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Ideals_and_left_ideals_Section_Mutipermutation_skew_braces">
<Heading>Mutipermutation skew braces</Heading>

<ManSection>
  <Oper Arg="obj" Name="SocleSeries" Label="for IsSkewbrace"/>
 <Returns>the socle series of <A>obj</A>
</Returns>
 <Description>
 The socle series of a skew brace <Math>A</Math> is defined recursively as 
 <Math>A_1=A</Math> and <Math>A_{n+1}=A_n/\mathrm{Soc}(A_n)</Math>, see <Cite Key="MR3763907"/>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="MultipermutationLevel" Label="for IsSkewbrace"/>
 <Returns>the multipermutation level of the skew brace <A>obj</A>
</Returns>
 <Description>
 The multipermutation level of a skew brace <Math>A</Math> is defined as the smallest
 positive integer <Math>n</Math> such that the <Math>n</Math>-th term 
 <Math>A_n</Math> of the socle series has only one element, see 
 Definition 5.17 of <Cite Key="MR3763907"/>.
<Example><![CDATA[
gap> br := SmallBrace(8,20);;
gap> SocleSeries(br);
[ <brace of size 8>, <brace of size 1> ]
gap> MultipermutationLevel(br);
2
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Prop Arg="obj" Name="IsMultipermutation" Label="for IsSkewbrace"/>
 <Returns><A>true</A> if the skew brace <A>obj</A> has finite multipermutation  level and <A>false</A> otherwise
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="Fix" Label="for IsSkewbrace"/>
 <Returns>the left ideal <Math>\{x\in A:\lambda_a(x)=x\;\forall a\in A\}</Math>  of the skew brace <Math>A</Math>. 
</Returns>
 <Description>
<Example><![CDATA[
gap> br := SmallSkewbrace(6,1);;
gap> IsTrivialSkewbrace(br);
true
gap> Fix(br);
[ <()>, <(1,2,3)(4,5,6)>, <(1,3,2)(4,6,5)>, <(1,4)(2,6)(3,5)>,
  <(1,5)(2,4)(3,6)>, <(1,6)(2,5)(3,4)> ]
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="KernelOfLambda" Label="for IsSkewbrace"/>
 <Returns>the kernel of the map <Math>\lambda</Math> as a subset of elements of the skew brace <A>obj</A>.
</Returns>
 <Description>
<Example><![CDATA[
gap> br := SmallBrace(6,1);;
gap> KernelOfLambda(br);
[ <()>, <(1,2,3)(4,5,6)>, <(1,3,2)(4,6,5)> ]
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Oper Arg="obj,ideal" Name="Quotient" Label="for IsSkewbrace, IsSkewbrace"/>
 <Returns>the quotient <A>obj</A> by <A>ideal</A>
</Returns>
 <Description>
<Example><![CDATA[
gap> br := SmallBrace(8,10);;
gap> ideals := Ideals(br);;
gap> Quotient(br, ideals[3]);
<brace of size 4>
gap> br/ideals[3];
<brace of size 4>
]]></Example>


 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Ideals_and_left_ideals_Section_Prime_and_semiprime_ideals">
<Heading>Prime and semiprime ideals</Heading>

<ManSection>
  <Prop Arg="obj" Name="IsPrimeBrace" Label="for IsSkewbrace"/>
 <Returns><A>true</A> if the skew brace <A>obj</A> is prime
</Returns>
 <Description>
 A skew brace <Math>A</Math> is said to be prime if for all non-zero ideals <Math>I</Math> and <Math>J</Math> one has
 <Math>I*J\ne 0</Math> 
<Example><![CDATA[
gap> IsPrimeBrace(SmallBrace(24,12));
false
gap> IsPrimeBrace(SmallBrace(24,94));
true
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Prop Arg="obj" Name="IsPrimeIdeal" Label="for IsSkewbrace and IsIdealInParent"/>
 <Returns><A>true</A> if the ideal <A>obj</A> is prime
</Returns>
 <Description>
 An ideal <Math>I</Math> of a skew brace <Math>A</Math> is said to be prime if <Math>A/I</Math> is a prime skew brace.
<Example><![CDATA[
gap> br := SmallBrace(24,94);
<brace of size 24>
gap> IsPrimeBrace(br);
true
gap> Ideals(br);;
gap> IsPrimeIdeal(last[2]);
true
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="PrimeIdeals" Label="for IsSkewbrace"/>
 <Returns>the list of prime ideals of the skew brace <A>obj</A>
</Returns>
 <Description>
<Example><![CDATA[
gap> Length(PrimeIdeals(SmallBrace(24,94)));
2
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="IsSemiprime" Label="for IsSkewbrace"/>
 <Returns><A>true</A> if the skew brace <A>obj</A> is semiprime
</Returns>
 <Description>
 An ideal <Math>I</Math> of a skew brace <Math>A</Math> is said to be semiprime if <Math>A/I</Math> is a semiprime skew brace.
<Example><![CDATA[
gap> br := DirectProductSkewbraces(SmallSkewbrace(12,22),SmallSkewbrace(12,22));;
gap> IsSemiprime(br);
true
]]></Example>


 </Description>
</ManSection>


<P/>
<ManSection>
  <Attr Arg="obj" Name="IsSemiprimeIdeal" Label="for IsSkewbrace and IsIdealInParent"/>
 <Returns><A>true</A> if the ideal <A>obj</A> is semiprime
</Returns>
 <Description>
<Example><![CDATA[
gap> SemiprimeIdeals(SmallSkewbrace(12,24));
[ <skew brace of size 12> ]
gap> IsSemiprimeIdeal(last[1]);
true
]]></Example>


 </Description>
</ManSection>


<P/>
<ManSection>
  <Attr Arg="obj" Name="SemiprimeIdeals" Label="for IsSkewbrace"/>
 <Returns>the list of semiprime ideals of the skew brace <A>obj</A>
</Returns>
 <Description>
<Example><![CDATA[
gap> SemiprimeIdeals(SmallSkewbrace(12,24));
[ <skew brace of size 12> ]
gap> Length(SemiprimeIdeals(SmallSkewbrace(12,22)));
2
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="BaerRadical" Label="for IsSkewbrace"/>
 <Returns>the Baer radical of the skew brace <A>obj</A>
</Returns>
 <Description>
<Example><![CDATA[
gap> br := SmallSkewbrace(6,2);;
gap> BaerRadical(br);
<skew brace of size 6>
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Prop Arg="obj" Name="IsBaer" Label="for IsSkewbrace"/>
 <Returns><A>true</A> if the skew brace <A>obj</A> is ia Baer radical skew brace.
</Returns>
 <Description>
 A skew brace <Math>A</Math> is said to be Baer radical if <Math>A=B(A)</Math>, where
 <Math>B(A)</Math> is the Baer radical of <Math>A</Math> (i.e., the intersection of all prime ideals of <Math>A</Math>).
<Example><![CDATA[
gap> br := SmallSkewbrace(6,2);;
gap> IsBaer(br);
true
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="WedderburnRadical" Label="for IsSkewbrace"/>
 <Returns>the Wedderburn radical of the skew brace <A>obj</A>
</Returns>
 <Description>
The Wedderburn radical of a skew brace is the intersection of all its prime ideals
<Example><![CDATA[
gap> br := SmallSkewbrace(6,2);;
gap> WedderburnRadical(br);
<brace of size 3>
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="SolvableSeries" Label="for IsSkewbrace"/>
 <Returns>a list with the solvable series of the skew brace <A>obj</A>
</Returns>
 <Description>
 The solvable series of a skew brace <Math>A</Math> is defined recursively as 
 <Math>A_{1}=A</Math> and <Math>A_{n+1}=A_{n}*A_{n}</Math> for <Math>n\geq1</Math>, where <Math>a*b=\lambda_a(b)-b</Math>
<Example><![CDATA[
gap> br := SmallSkewbrace(8,20);;
gap> IsSolvable(br);
true
gap> SolvableSeries(br);
[ <skew brace of size 8>, <brace of size 2>, <brace of size 1> ]
gap> br := SmallSkewbrace(12,23);;
gap> IsSolvable(br);
false
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Prop Arg="obj,ideal" Name="IsMinimalIdeal" Label="for IsSkewbrace and IsIdealInParent"/>
 <Returns><A>true</A> if <A>ideal</A> is a minimal ideal of <A>obj</A>  An ideal <Math>I</Math> of <Math>A</Math> is said to be <Emph>minimal</Emph> if does not
  contain any other ideal of <Math>A</Math>. 
  To check if an ideal <Math>I</Math> of <Math>A</Math> is minimal, one computes the ideals
  of <Math>I</Math> and keep only those that are simple as a skew brace.
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="obj" Name="MinimalIdeals" Label="for IsSkewbrace"/>
 <Returns>a list of minimal ideals of the skew brace <A>obj</A>
</Returns>
 <Description>
<P/>
 </Description>
</ManSection>


</Section>


</Chapter>

