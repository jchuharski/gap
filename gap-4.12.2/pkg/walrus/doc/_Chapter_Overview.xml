<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Overview">
<Heading>Overview</Heading>

<P/>
<Section Label="Chapter_Overview_Section_Examples">
<Heading>Examples</Heading>

<ManSection>
  <Func Arg="p,q,r" Name="TriangleGroup" />
 <Returns>a pregroup presentation
</Returns>
 <Description>
 Returns a pregroup presentation for the <M>(<A>p</A>,<A>q</A>,<A>r</A>)</M>-triangle group,
 the pregroup is the pregroup of the free product of a cyclic group of order <A>p</A> generated
 by <M>x</M> and a cyclic group of order <A>q</A> generated by <M>y</M> together with the relation
 <M>(xy)^r</M>.
<Example><![CDATA[
gap> T := TriangleGroup(2,3,7);
<pregroup presentation with 3 generators and 1 relators>
gap> Pregroup(T);
<pregroup with 4 elements in table rep>
gap> Relators(T);
[ <pregroup relator ([ "2", "3" ])^7> ]
gap> T := TriangleGroup(17,22,100);
<pregroup presentation with 37 generators and 1 relators>
gap> Pregroup(T);
<pregroup with 38 elements in table rep>
gap> Relators(T);
[ <pregroup relator ([ "2", "18" ])^100> ]
gap> IsHyperbolic(T, 1/6);
true
]]></Example>


 </Description>
</ManSection>


<ManSection Label="AutoDoc_generated_group1">
  <Func Arg="m,n" Name="TriangleCommutatorQuotient" />
  <Func Arg="arg" Name="TriSH" />
 <Returns>a pregroup presentation
</Returns>
 <Description>
 Returns a pregroup presentation of the quotient of the <M>(2,3,<A>m</A>)</M>-triangle group
 by the normal subgroup generated by <M>n</M>th power of the commutator of
 <M>x</M> and <M>y</M>.
 The name <Ref Func="TriSH" /> is a synonym for <Ref Func="TriangleCommutatorQuotient" /> provided
 for backwards compatibility and might be removed in the future.
<P/>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="p,q,r,len" Name="RandomTriangleQuotient" />
 <Returns>a pregroup presentation
</Returns>
 <Description>
 Returns the quotient of the <M>(<A>p</A>,<A>q</A>,<A>r</A>)</M>-triangle group
 by a random relator of length <A>len</A>.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="" Name="JackButtonGroup" />
 <Returns>a pregroup presentation
</Returns>
 <Description>
 The Jack-Button group, as suggested to me by Alan Logan. It is known 
 to be hyperbolic, but the tester fails for it. The pregroup is the pregroup
 of the free group of rank 3 with generators <M>a</M>,<M>b</M>, and <M>t</M>
 and two
 relators <M>t^{-1}atb^{-1}a^{-1}</M> and <M>t^{-1}ata^{-1}b^{-1}</M>.
<Example><![CDATA[
gap> J := JackButtonGroup();
<pregroup presentation with 6 generators and 2 relators>
gap> Pregroup(J);
<pregroup of free group of rank 3>
gap> Relators(J);
[ <pregroup relator TatBA>, <pregroup relator TatAB> ]
]]></Example>


 </Description>
</ManSection>


<ManSection>
  <Func Arg="pg, nrel, lrel" Name="RandomPregroupPresentation" />
 <Returns>a pregroup presentation
</Returns>
 <Description>
 Returns a pregroup presentation over the given pregroup <A>pg</A> with
 <A>nrel</A> randomly chosen relators of length <A>lrel</A>.
 </Description>
</ManSection>


<ManSection>
  <Func Arg="pg, len" Name="RandomPregroupWord" />
 <Returns>a list of integers
</Returns>
 <Description>
 A random list of pregroup element numbers of the pregroup <A>pregroup</A> of
 length <A>len</A>. When interpreted as a pregroup word this is cyclically
 reduced.
 </Description>
</ManSection>


</Section>


<P/>
 This package provides the operations <C>IsHyperbolic</C>, ways of testing a
 finitely presented group for hyperbolicity in the sense of Gromov.
 <P/>
<P/>
 The algorithm is based on ideas by Richard Parker, and the theory is described
 in the paper "Polynomial time proofs that groups are hyperbolic".
<P/>
<Section Label="Chapter_Overview_Section_Testing_Hyperbolicity">
<Heading>Testing Hyperbolicity</Heading>

<P/>
 The main function of this package is the so-called RSym-tester. Given a
 (pregroup) presentation of a group, this function will try to prove whether
 the group defined by the presentation is hyperbolic, and will give an answer
 in polynomial time.
 Since hyperbolicity is undecidable, the answer can be positive, negative, or
 inconclusive.
<P/>
 As a simple example consider the following. Triangle groups are known to be
 hyperbolic when the sum <M>\frac{1}{p} + \frac{1}{q} + \frac{1}{r}</M> is less
 than <M>1</M>. The parameter for <Ref Func="IsHyperbolic" Label="for IsPregroupPresentation"/>
 gives the algorithm a hint how hard it should try.
<Example><![CDATA[
gap> triangle := TriangleGroup(2,3,7);
<pregroup presentation with 3 generators and 1 relators>
gap> IsHyperbolic(triangle, 1/6);
true
gap> triangle := TriangleGroup(3,3,3);
<pregroup presentation with 3 generators and 1 relators>
gap> IsHyperbolic(triangle, 1/6);
[ fail, [ [ 1, 0, 0, 0 ], [ 2, 1, 1, 1/36 ], [ 1, 2, 2, 1/18 ],
         [ 2, 3, 3, 1/12 ], [ 1, 4, 4, 1/9 ], [ 2, 5, 5, 5/36 ],
         [ 1, 6, 6, 1/6 ] ], [ 2, 5, 5, 5/36 ] ]
]]></Example>


<P/>
 One can also create pregroup presentations by giving a pregroup
 and relators, that is, words over the pregroup.
<Example><![CDATA[
gap> G1 := CyclicGroup(3);;
gap> pg := PregroupOfFreeProduct(G1,G1);
<pregroup with 5 elements in table rep>
gap> rel := [2,5,3,4,3,4,3,4,3,5,2,4,3,5,2,4,3,5,3,4,2,4,3,5];
[ 2, 5, 3, 4, 3, 4, 3, 4, 3, 5, 2, 4, 3, 5, 2, 4, 3, 5, 3, 4, 2, 4, 3, 5 ]
gap> pgp := NewPregroupPresentation(pg,[pg_word(pg,rel)]);
<pregroup presentation with 4 generators and 1 relators>
gap> res := RSymTest(pgp, 0);;
gap> res[1];
fail
]]></Example>


<P/>
</Section>


<Section Label="Chapter_Overview_Section_The_MAGMA-compatible_interface">
<Heading>The MAGMA-compatible interface</Heading>

<P/>
 An implementation of the hyperbolicity testing algorithm and word-problem
 solver exist in MAGMA as well. For ease of comparison between the results
 these two systems give, &walrus; contains an interface that aims to be
 compatible with MAGMA's. Please refer to MAGMA's documentation for further
 details.
<P/>
<Example><![CDATA[
gap> F := FreeGroup("x", "y");;
gap> AssignGeneratorVariables(F);;
gap> rred := [ y^3 ];;
gap> rgreen := [ x^4, (x*y)^4 ];;
gap> IsHyperbolic(F, rred, rgreen, 1/10);
[ fail, [ [ 1, 0, 0, 0 ], [ 2, 1, 1, 13/120 ], [ 1, 2, 2, 13/60 ],
          [ 2, 3, 3, 13/40 ], [ 1, 4, 4, 13/30 ] ], [ 2, 3, 3, 13/40 ] ]
]]></Example>


</Section>


</Chapter>

