<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Monoidal_Categories">
<Heading>Monoidal Categories</Heading>

<P/>
<Section Label="Chapter_Monoidal_Categories_Section_Monoidal_Categories">
<Heading>Monoidal Categories</Heading>

<P/>
A <Math>6</Math>-tuple <Math>( \mathbf{C}, \otimes, 1, \alpha, \lambda, \rho )</Math>
 consisting of
<List>
<Item>
a category <Math>\mathbf{C}</Math>,
</Item>
<Item>
a functor <Math>\otimes: \mathbf{C} \times \mathbf{C} \rightarrow \mathbf{C}</Math> compatible with the congruence of morphisms,
</Item>
<Item>
an object <Math>1 \in \mathbf{C}</Math>,
</Item>
<Item>
a natural isomorphism <Math>\alpha_{a,b,c}: a \otimes (b \otimes c) \cong (a \otimes b) \otimes c</Math>,
</Item>
<Item>
a natural isomorphism <Math>\lambda_{a}: 1 \otimes a \cong a</Math>,
</Item>
<Item>
a natural isomorphism <Math>\rho_{a}: a \otimes 1 \cong a</Math>,
</Item>
</List>
is called a <Emph>monoidal category</Emph>, if
<List>
<Item>
for all objects <Math>a,b,c,d</Math>, the pentagon identity holds:
</Item>
</List>
 <Math>(\alpha_{a,b,c} \otimes \mathrm{id}_d) \circ \alpha_{a,b \otimes c, d} \circ ( \mathrm{id}_a \otimes \alpha_{b,c,d} ) \sim \alpha_{a \otimes b, c, d} \circ \alpha_{a,b,c \otimes d}</Math>,
<List>
<Item>
for all objects <Math>a,c</Math>, the triangle identity holds:
</Item>
</List>
 <Math>( \rho_a \otimes \mathrm{id}_c ) \circ \alpha_{a,1,c} \sim \mathrm{id}_a \otimes \lambda_c</Math>.
<P/>
The corresponding GAP property is given by
<C>IsMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="alpha, beta" Name="TensorProductOnMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes b, a' \otimes b')</Math>
</Returns>
 <Description>
 The arguments are two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>.
 The output is the tensor product <Math>\alpha \otimes \beta</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, alpha, beta, r" Name="TensorProductOnMorphismsWithGivenTensorProducts" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes b, a' \otimes b')</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = a \otimes b</Math>,
 two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>,
 and an object <Math>r = a' \otimes b'</Math>.
 The output is the tensor product <Math>\alpha \otimes \beta</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, c" Name="AssociatorRightToLeft" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a \otimes (b \otimes c), (a \otimes b) \otimes c )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the associator <Math>\alpha_{a,(b,c)}: a \otimes (b \otimes c) \rightarrow (a \otimes b) \otimes c</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, a, b, c, r" Name="AssociatorRightToLeftWithGivenTensorProducts" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a \otimes (b \otimes c), (a \otimes b) \otimes c )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a \otimes (b \otimes c)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = (a \otimes b) \otimes c</Math>.
 The output is the associator <Math>\alpha_{a,(b,c)}: a \otimes (b \otimes c) \rightarrow (a \otimes b) \otimes c</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, c" Name="AssociatorLeftToRight" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (a \otimes b) \otimes c \rightarrow a \otimes (b \otimes c) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the associator <Math>\alpha_{(a,b),c}: (a \otimes b) \otimes c \rightarrow a \otimes (b \otimes c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, a, b, c, r" Name="AssociatorLeftToRightWithGivenTensorProducts" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (a \otimes b) \otimes c \rightarrow a \otimes (b \otimes c) )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = (a \otimes b) \otimes c</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = a \otimes (b \otimes c)</Math>.
 The output is the associator <Math>\alpha_{(a,b),c}: (a \otimes b) \otimes c \rightarrow a \otimes (b \otimes c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="LeftUnitor" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1 \otimes a, a)</Math>
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the left unitor <Math>\lambda_a: 1 \otimes a \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, s" Name="LeftUnitorWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1 \otimes a, a)</Math>
</Returns>
 <Description>
 The arguments are an object <Math>a</Math> and an object <Math>s = 1 \otimes a</Math>.
 The output is the left unitor <Math>\lambda_a: 1 \otimes a \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="LeftUnitorInverse" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, 1 \otimes a)</Math>
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the inverse of the left unitor <Math>\lambda_a^{-1}: a \rightarrow 1 \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, r" Name="LeftUnitorInverseWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, 1 \otimes a)</Math>
</Returns>
 <Description>
 The argument is an object <Math>a</Math> and an object <Math>r = 1 \otimes a</Math>.
 The output is the inverse of the left unitor <Math>\lambda_a^{-1}: a \rightarrow 1 \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="RightUnitor" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes 1, a)</Math>
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the right unitor <Math>\rho_a: a \otimes 1 \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, s" Name="RightUnitorWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes 1, a)</Math>
</Returns>
 <Description>
 The arguments are an object <Math>a</Math> and an object <Math>s = a \otimes 1</Math>.
 The output is the right unitor <Math>\rho_a: a \otimes 1 \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="RightUnitorInverse" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, a \otimes 1)</Math>
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the inverse of the right unitor <Math>\rho_a^{-1}: a \rightarrow a \otimes 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, r" Name="RightUnitorInverseWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, a \otimes 1)</Math>
</Returns>
 <Description>
 The arguments are an object <Math>a</Math> and an object <Math>r = a \otimes 1</Math>.
 The output is the inverse of the right unitor <Math>\rho_a^{-1}: a \rightarrow a \otimes 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="TensorProductOnObjects" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The arguments are two objects <Math>a, b</Math>.
 The output is the tensor product <Math>a \otimes b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorProductOnObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math> 
 to the category for the basic operation <C>TensorProductOnObjects</C>.
 <Math>F: (a,b) \mapsto a \otimes b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="C" Name="TensorUnit" Label="for IsCapCategory"/>
 <Returns>an object
</Returns>
 <Description>
 The argument is a category <Math>\mathbf{C}</Math>.
 The output is the tensor unit <Math>1</Math> of <Math>\mathbf{C}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorUnit" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math> 
 to the category for the basic operation <C>TensorUnit</C>.
 <Math>F: ( ) \mapsto 1</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Additive_Monoidal_Categories">
<Heading>Additive Monoidal Categories</Heading>

<P/>
<ManSection>
  <Oper Arg="a, L" Name="LeftDistributivityExpanding" Label="for IsCapCategoryObject, IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a \otimes (b_1 \oplus \dots \oplus b_n), (a \otimes b_1) \oplus \dots \oplus (a \otimes b_n) )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>a</Math>
 and a list of objects <Math>L = (b_1, \dots, b_n)</Math>.
 The output is the left distributivity morphism
 <Math>a \otimes (b_1 \oplus \dots \oplus b_n) \rightarrow (a \otimes b_1) \oplus \dots \oplus (a \otimes b_n)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, a, L, r" Name="LeftDistributivityExpandingWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = a \otimes (b_1 \oplus \dots \oplus b_n)</Math>,
 an object <Math>a</Math>,
 a list of objects <Math>L = (b_1, \dots, b_n)</Math>,
 and an object <Math>r = (a \otimes b_1) \oplus \dots \oplus (a \otimes b_n)</Math>.
 The output is the left distributivity morphism
 <Math>s \rightarrow r</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, L" Name="LeftDistributivityFactoring" Label="for IsCapCategoryObject, IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (a \otimes b_1) \oplus \dots \oplus (a \otimes b_n), a \otimes (b_1 \oplus \dots \oplus b_n) )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>a</Math>
 and a list of objects <Math>L = (b_1, \dots, b_n)</Math>.
 The output is the left distributivity morphism
 <Math>(a \otimes b_1) \oplus \dots \oplus (a \otimes b_n) \rightarrow a \otimes (b_1 \oplus \dots \oplus b_n)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, a, L, r" Name="LeftDistributivityFactoringWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = (a \otimes b_1) \oplus \dots \oplus (a \otimes b_n)</Math>,
 an object <Math>a</Math>,
 a list of objects <Math>L = (b_1, \dots, b_n)</Math>,
 and an object <Math>r = a \otimes (b_1 \oplus \dots \oplus b_n)</Math>.
 The output is the left distributivity morphism
 <Math>s \rightarrow r</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="L, a" Name="RightDistributivityExpanding" Label="for IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (b_1 \oplus \dots \oplus b_n) \otimes a, (b_1 \otimes a) \oplus \dots \oplus (b_n \otimes a) )</Math>
</Returns>
 <Description>
 The arguments are a list of objects <Math>L = (b_1, \dots, b_n)</Math>
 and an object <Math>a</Math>.
 The output is the right distributivity morphism
 <Math>(b_1 \oplus \dots \oplus b_n) \otimes a \rightarrow (b_1 \otimes a) \oplus \dots \oplus (b_n \otimes a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, L, a, r" Name="RightDistributivityExpandingWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = (b_1 \oplus \dots \oplus b_n) \otimes a</Math>,
 a list of objects <Math>L = (b_1, \dots, b_n)</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = (b_1 \otimes a) \oplus \dots \oplus (b_n \otimes a)</Math>.
 The output is the right distributivity morphism
 <Math>s \rightarrow r</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="L, a" Name="RightDistributivityFactoring" Label="for IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (b_1 \otimes a) \oplus \dots \oplus (b_n \otimes a), (b_1 \oplus \dots \oplus b_n) \otimes a)</Math>
</Returns>
 <Description>
 The arguments are a list of objects <Math>L = (b_1, \dots, b_n)</Math>
 and an object <Math>a</Math>.
 The output is the right distributivity morphism
 <Math>(b_1 \otimes a) \oplus \dots \oplus (b_n \otimes a) \rightarrow (b_1 \oplus \dots \oplus b_n) \otimes a </Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, L, a, r" Name="RightDistributivityFactoringWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( s, r )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = (b_1 \otimes a) \oplus \dots \oplus (b_n \otimes a)</Math>,
 a list of objects <Math>L = (b_1, \dots, b_n)</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = (b_1 \oplus \dots \oplus b_n) \otimes a</Math>.
 The output is the right distributivity morphism
 <Math>s \rightarrow r</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Braided_Monoidal_Categories">
<Heading>Braided Monoidal Categories</Heading>

<P/>
A monoidal category <Math>\mathbf{C}</Math> equipped with a natural isomorphism
<Math>B_{a,b}: a \otimes b \cong b \otimes a</Math>
is called a <Emph>braided monoidal category</Emph>
if
<List>
<Item>
<Math>\lambda_a \circ B_{a,1} \sim \rho_a</Math>,
</Item>
<Item>
<Math>(B_{c,a} \otimes \mathrm{id}_b) \circ \alpha_{c,a,b} \circ B_{a \otimes b,c} \sim \alpha_{a,c,b} \circ ( \mathrm{id}_a \otimes B_{b,c}) \circ \alpha^{-1}_{a,b,c}</Math>,
</Item>
<Item>
<Math>( \mathrm{id}_b \otimes B_{c,a} ) \circ \alpha^{-1}_{b,c,a} \circ B_{a,b \otimes c} \sim \alpha^{-1}_{b,a,c} \circ (B_{a,b} \otimes \mathrm{id}_c) \circ \alpha_{a,b,c}</Math>.
</Item>
</List>
<P/>
The corresponding GAP property is given by
<C>IsBraidedMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="a,b" Name="Braiding" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a \otimes b, b \otimes a )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the braiding <Math> B_{a,b}: a \otimes b \rightarrow b \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="BraidingWithGivenTensorProducts" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a \otimes b, b \otimes a )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a \otimes b</Math>, 
 two objects <Math>a,b</Math>,
 and an object <Math>r = b \otimes a</Math>.
 The output is the braiding <Math> B_{a,b}: a \otimes b \rightarrow b \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="BraidingInverse" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b \otimes a, a \otimes b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the inverse braiding <Math> B_{a,b}^{-1}: b \otimes a \rightarrow a \otimes b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="BraidingInverseWithGivenTensorProducts" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b \otimes a, a \otimes b )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = b \otimes a</Math>, 
 two objects <Math>a,b</Math>,
 and an object <Math>r = a \otimes b</Math>.
 The output is the inverse braiding <Math> B_{a,b}^{-1}: b \otimes a \rightarrow a \otimes b</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Symmetric_Monoidal_Categories">
<Heading>Symmetric Monoidal Categories</Heading>

<P/>
A braided monoidal category <Math>\mathbf{C}</Math> is called <Emph>symmetric monoidal category</Emph>
if <Math>B_{a,b}^{-1} \sim B_{b,a}</Math>.
The corresponding GAP property is given by
<C>IsSymmetricMonoidalCategory</C>.
<P/>
</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Closed_Monoidal_Categories">
<Heading>Closed Monoidal Categories</Heading>

<P/>
A monoidal category <Math>\mathbf{C}</Math>
which has for each functor <Math>- \otimes b: \mathbf{C} \rightarrow \mathbf{C}</Math>
a right adjoint (denoted by <Math>\mathrm{\underline{Hom}}(b,-)</Math>)
is called a <Emph>closed monoidal category</Emph>.
<P/>
If no operations involving duals are installed manually, the dual objects will be derived as <Math>a^\vee \coloneqq \mathrm{\underline{Hom}}(a,1)</Math>.
<P/>
The corresponding GAP property is called
<C>IsClosedMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="a, b" Name="InternalHomOnObjects" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the internal hom object <Math>\mathrm{\underline{Hom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="InternalHomOnMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a',b), \mathrm{\underline{Hom}}(a,b') )</Math>
</Returns>
 <Description>
 The arguments are two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>.
 The output is the internal hom morphism
 <Math>\mathrm{\underline{Hom}}(\alpha,\beta): \mathrm{\underline{Hom}}(a',b) \rightarrow \mathrm{\underline{Hom}}(a,b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, alpha, beta, r" Name="InternalHomOnMorphismsWithGivenInternalHoms" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a',b), \mathrm{\underline{Hom}}(a,b') )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = \mathrm{\underline{Hom}}(a',b)</Math>,
 two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}}(a,b')</Math>.
 The output is the internal hom morphism
 <Math>\mathrm{\underline{Hom}}(\alpha,\beta): \mathrm{\underline{Hom}}(a',b) \rightarrow \mathrm{\underline{Hom}}(a,b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="EvaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,b) \otimes a, b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a, b</Math>.
 The output is the evaluation morphism <Math>\mathrm{ev}_{a,b}: \mathrm{\underline{Hom}}(a,b) \otimes a \rightarrow b</Math>, i.e.,
 the counit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, s" Name="EvaluationMorphismWithGivenSource" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,b) \otimes a, b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>s = \mathrm{\underline{Hom}}(a,b) \otimes a</Math>.
 The output is the evaluation morphism <Math>\mathrm{ev}_{a,b}: \mathrm{\underline{Hom}}(a,b) \otimes a \rightarrow b</Math>, i.e.,
 the counit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="CoevaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, \mathrm{\underline{Hom}}(b, a \otimes b) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the coevaluation morphism <Math>\mathrm{coev}_{a,b}: a \rightarrow \mathrm{\underline{Hom}}(b, a \otimes b)</Math>, i.e.,
 the unit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, r" Name="CoevaluationMorphismWithGivenRange" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, \mathrm{\underline{Hom}}(b, a \otimes b) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>r = \mathrm{\underline{Hom}}(b, a \otimes b)</Math>.
 The output is the coevaluation morphism <Math>\mathrm{coev}_{a,b}: a \rightarrow \mathrm{\underline{Hom}}(b, a \otimes b)</Math>, i.e.,
 the unit of the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, f" Name="TensorProductToInternalHomAdjunctionMap" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, \mathrm{\underline{Hom}}(b,c) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and a morphism <Math>f: a \otimes b \rightarrow c</Math>.
 The output is a morphism <Math>g: a \rightarrow \mathrm{\underline{Hom}}(b,c)</Math>
 corresponding to <Math>f</Math> under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, f, i" Name="TensorProductToInternalHomAdjunctionMapWithGivenInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, \mathrm{\underline{Hom}}(b,c) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>, a morphism <Math>f: a \otimes b \rightarrow c</Math> and an object <Math>i = \mathrm{\underline{Hom}}(b,c)</Math>.
 The output is a morphism <Math>g: a \rightarrow \mathrm{\underline{Hom}}(b,c)</Math>
 corresponding to <Math>f</Math> under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, c, g" Name="InternalHomToTensorProductAdjunctionMap" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes b, c)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>b,c</Math> and a morphism <Math>g: a \rightarrow \mathrm{\underline{Hom}}(b,c)</Math>.
 The output is a morphism <Math>f: a \otimes b \rightarrow c</Math> corresponding to <Math>g</Math> under the
 tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="b, c, g, t" Name="InternalHomToTensorProductAdjunctionMapWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes b, c)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>b,c</Math>, a morphism <Math>g: a \rightarrow \mathrm{\underline{Hom}}(b,c)</Math> and an object <Math>t = a \otimes b</Math>.
 The output is a morphism <Math>f: a \otimes b \rightarrow c</Math> corresponding to <Math>g</Math> under the
 tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,c" Name="MonoidalPreComposeMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,b) \otimes \mathrm{\underline{Hom}}(b,c), \mathrm{\underline{Hom}}(a,c) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the precomposition morphism
 <Math>\mathrm{MonoidalPreComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{Hom}}(a,b) \otimes \mathrm{\underline{Hom}}(b,c) \rightarrow \mathrm{\underline{Hom}}(a,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,c,r" Name="MonoidalPreComposeMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,b) \otimes \mathrm{\underline{Hom}}(b,c), \mathrm{\underline{Hom}}(a,c) )</Math>.
</Returns>
 <Description>
 The arguments are
 an object <Math>s = \mathrm{\underline{Hom}}(a,b) \otimes \mathrm{\underline{Hom}}(b,c)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}}(a,c)</Math>.
 The output is the precomposition morphism
 <Math>\mathrm{MonoidalPreComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{Hom}}(a,b) \otimes \mathrm{\underline{Hom}}(b,c) \rightarrow \mathrm{\underline{Hom}}(a,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,c" Name="MonoidalPostComposeMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(b,c) \otimes \mathrm{\underline{Hom}}(a,b), \mathrm{\underline{Hom}}(a,c) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the postcomposition morphism
 <Math>\mathrm{MonoidalPostComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{Hom}}(b,c) \otimes \mathrm{\underline{Hom}}(a,b) \rightarrow \mathrm{\underline{Hom}}(a,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,c,r" Name="MonoidalPostComposeMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(b,c) \otimes \mathrm{\underline{Hom}}(a,b), \mathrm{\underline{Hom}}(a,c) )</Math>.
</Returns>
 <Description>
 The arguments are
 an object <Math>s = \mathrm{\underline{Hom}}(b,c) \otimes \mathrm{\underline{Hom}}(a,b)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}}(a,c)</Math>.
 The output is the postcomposition morphism
 <Math>\mathrm{MonoidalPostComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{Hom}}(b,c) \otimes \mathrm{\underline{Hom}}(a,b) \rightarrow \mathrm{\underline{Hom}}(a,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="DualOnObjects" Label="for IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is its dual object <Math>a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="DualOnMorphisms" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b^{\vee}, a^{\vee} )</Math>.
</Returns>
 <Description>
 The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
 The output is its dual morphism <Math>\alpha^{\vee}: b^{\vee} \rightarrow a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,alpha,r" Name="DualOnMorphismsWithGivenDuals" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b^{\vee}, a^{\vee} )</Math>.
</Returns>
 <Description>
 The argument is an object <Math>s = b^{\vee}</Math>,
 a morphism <Math>\alpha: a \rightarrow b</Math>,
 and an object <Math>r = a^{\vee}</Math>.
 The output is the dual morphism <Math>\alpha^{\vee}: b^{\vee} \rightarrow a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="EvaluationForDual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes a, 1 )</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the evaluation morphism <Math>\mathrm{ev}_{a}: a^{\vee} \otimes a \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,r" Name="EvaluationForDualWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes a, 1 )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a^{\vee} \otimes a</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = 1</Math>.
 The output is the evaluation morphism <Math>\mathrm{ev}_{a}: a^{\vee} \otimes a \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="MorphismToBidual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, (a^{\vee})^{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the morphism to the bidual <Math>a \rightarrow (a^{\vee})^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, r" Name="MorphismToBidualWithGivenBidual" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, (a^{\vee})^{\vee})</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>a</Math>,
 and an object <Math>r = (a^{\vee})^{\vee}</Math>.
 The output is the morphism to the bidual <Math>a \rightarrow (a^{\vee})^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="list" Name="TensorProductInternalHomCompatibilityMorphism" Label="for IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b'), \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b'))</Math>.
</Returns>
 <Description>
 The argument is a list of four objects <Math>[ a, a', b, b' ]</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductInternalHomCompatibilityMorphismWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b') \rightarrow \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, list, r" Name="TensorProductInternalHomCompatibilityMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b'), \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b'))</Math>.
</Returns>
 <Description>
 The arguments are a list of four objects <Math>[ a, a', b, b' ]</Math>,
 and two objects <Math>s = \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b')</Math> and <Math>r = \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b')</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductInternalHomCompatibilityMorphismWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b') \rightarrow \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="TensorProductDualityCompatibilityMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes b^{\vee}, (a \otimes b)^{\vee} )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductDualityCompatibilityMorphismWithGivenObjects}: a^{\vee} \otimes b^{\vee} \rightarrow (a \otimes b)^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="TensorProductDualityCompatibilityMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes b^{\vee}, (a \otimes b)^{\vee} )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a^{\vee} \otimes b^{\vee}</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = (a \otimes b)^{\vee}</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductDualityCompatibilityMorphismWithGivenObjects}_{a,b}: a^{\vee} \otimes b^{\vee} \rightarrow (a \otimes b)^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="MorphismFromTensorProductToInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes b, \mathrm{\underline{Hom}}(a,b) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism <Math>\mathrm{MorphismFromTensorProductToInternalHomWithGivenObjects}_{a,b}: a^{\vee} \otimes b \rightarrow \mathrm{\underline{Hom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="MorphismFromTensorProductToInternalHomWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes b, \mathrm{\underline{Hom}}(a,b) )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a^{\vee} \otimes b</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}}(a,b)</Math>.
 The output is the natural morphism <Math>\mathrm{MorphismFromTensorProductToInternalHomWithGivenObjects}_{a,b}: a^{\vee} \otimes b \rightarrow \mathrm{\underline{Hom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromDualObjectToInternalHomIntoTensorUnit" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a^{\vee}, \mathrm{\underline{Hom}}(a,1))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the isomorphism
 <Math>\mathrm{IsomorphismFromDualObjectToInternalHomIntoTensorUnit}_{a}: a^{\vee} \rightarrow \mathrm{\underline{Hom}}(a,1)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromInternalHomIntoTensorUnitToDualObject" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{Hom}}(a,1), a^{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the isomorphism
 <Math>\mathrm{IsomorphismFromInternalHomIntoTensorUnitToDualObject}_{a}: \mathrm{\underline{Hom}}(a,1) \rightarrow a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="t, a, alpha" Name="UniversalPropertyOfDual" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(t, a^{\vee})</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>t,a</Math>,
 and a morphism <Math>\alpha: t \otimes a \rightarrow 1</Math>.
 The output is the morphism <Math>t \rightarrow a^{\vee}</Math>
 given by the universal property of <Math>a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="LambdaIntroduction" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( 1, \mathrm{\underline{Hom}}(a,b) )</Math>.
</Returns>
 <Description>
 The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
 The output is the corresponding morphism <Math>1 \rightarrow \mathrm{\underline{Hom}}(a,b)</Math>
 under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,alpha" Name="LambdaElimination" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>,
 and a morphism <Math>\alpha: 1 \rightarrow \mathrm{\underline{Hom}}(a,b)</Math>.
 The output is a morphism <Math>a \rightarrow b</Math> corresponding to <Math>\alpha</Math>
 under the tensor hom adjunction.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromObjectToInternalHom" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, \mathrm{\underline{Hom}}(1,a))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the natural isomorphism <Math>a \rightarrow \mathrm{\underline{Hom}}(1,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,r" Name="IsomorphismFromObjectToInternalHomWithGivenInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, \mathrm{\underline{Hom}}(1,a))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>r = \mathrm{\underline{Hom}}(1,a)</Math>.
 The output is the natural isomorphism <Math>a \rightarrow \mathrm{\underline{Hom}}(1,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromInternalHomToObject" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{Hom}}(1,a),a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the natural isomorphism <Math>\mathrm{\underline{Hom}}(1,a) \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,s" Name="IsomorphismFromInternalHomToObjectWithGivenInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{Hom}}(1,a),a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>s = \mathrm{\underline{Hom}}(1,a)</Math>.
 The output is the natural isomorphism <Math>\mathrm{\underline{Hom}}(1,a) \rightarrow a</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Coclosed_Monoidal_Categories">
<Heading>Coclosed Monoidal Categories</Heading>

<P/>
A monoidal category <Math>\mathbf{C}</Math>
which has for each functor <Math>- \otimes b: \mathbf{C} \rightarrow \mathbf{C}</Math>
a left adjoint (denoted by <Math>\mathrm{\underline{coHom}}(-,b)</Math>)
is called a <Emph>coclosed monoidal category</Emph>.
<P/>
If no operations involving coduals are installed manually, the codual objects will be derived as <Math>a_\vee \coloneqq \mathrm{\underline{coHom}}(1,a)</Math>.
<P/>
The corresponding GAP property is called
<C>IsCoclosedMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="a, b" Name="InternalCoHomOnObjects" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the internal cohom object <Math>\mathrm{\underline{coHom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="alpha, beta" Name="InternalCoHomOnMorphisms" Label="for IsCapCategoryMorphism, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b'), \mathrm{\underline{coHom}}(a',b) )</Math>
</Returns>
 <Description>
 The arguments are two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>.
 The output is the internal cohom morphism
 <Math>\mathrm{\underline{coHom}}(\alpha,\beta): \mathrm{\underline{coHom}}(a,b') \rightarrow \mathrm{\underline{coHom}}(a',b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, alpha, beta, r" Name="InternalCoHomOnMorphismsWithGivenInternalCoHoms" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b'), \mathrm{\underline{coHom}}(a',b) )</Math>
</Returns>
 <Description>
 The arguments are an object <Math>s = \mathrm{\underline{coHom}}(a,b')</Math>,
 two morphisms <Math>\alpha: a \rightarrow a', \beta: b \rightarrow b'</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}}(a',b)</Math>.
 The output is the internal cohom morphism
 <Math>\mathrm{\underline{coHom}}(\alpha,\beta): \mathrm{\underline{coHom}}(a,b') \rightarrow \mathrm{\underline{coHom}}(a',b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="CoclosedEvaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, \mathrm{\underline{coHom}}(a,b) \otimes b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a, b</Math>.
 The output is the coclosed evaluation morphism <Math>\mathrm{coclev}_{a,b}: a \rightarrow \mathrm{\underline{coHom}}(a,b) \otimes b</Math>, i.e.,
 the unit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, r" Name="CoclosedEvaluationMorphismWithGivenRange" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a, \mathrm{\underline{coHom}}(a,b) \otimes b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>r = \mathrm{\underline{coHom}}(a,b) \otimes b</Math>.
 The output is the coclosed evaluation morphism <Math>\mathrm{coclev}_{a,b}: a \rightarrow \mathrm{\underline{coHom}}(a,b) \otimes b</Math>, i.e.,
 the unit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="CoclosedCoevaluationMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a \otimes b, b), a )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the coclosed coevaluation morphism <Math>\mathrm{coclcoev}_{a,b}: \mathrm{\underline{coHom}}(a \otimes b, b) \rightarrow a</Math>, i.e.,
 the counit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, s" Name="CoclosedCoevaluationMorphismWithGivenSource" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a \otimes b, b), b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and an object <Math>s = \mathrm{\underline{coHom}(a \otimes b, b)}</Math>.
 The output is the coclosed coevaluation morphism <Math>\mathrm{coclcoev}_{a,b}: \mathrm{\underline{coHom}}(a \otimes b, b) \rightarrow a</Math>, i.e.,
 the unit of the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="c, b, g" Name="TensorProductToInternalCoHomAdjunctionMap" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b), c )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>c,b</Math> and a morphism <Math>g: a \rightarrow c \otimes b</Math>.
 The output is a morphism <Math>f: \mathrm{\underline{coHom}}(a,b) \rightarrow c</Math>
 corresponding to <Math>g</Math> under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="c, b, g, i" Name="TensorProductToInternalCoHomAdjunctionMapWithGivenInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b), c )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>c,b</Math>, a morphism <Math>g: a \rightarrow c \otimes b</Math> and an object <Math>i = \mathrm{\underline{coHom}(a,b)}</Math>.
 The output is a morphism <Math>f: \mathrm{\underline{coHom}}(a,b) \rightarrow c</Math>
 corresponding to <Math>g</Math> under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, f" Name="InternalCoHomToTensorProductAdjunctionMap" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, c \otimes b)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math> and a morphism <Math>f: \mathrm{\underline{coHom}}(a,b) \rightarrow c</Math>.
 The output is a morphism <Math>g: a \rightarrow c \otimes b</Math> corresponding to <Math>f</Math> under the
 cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b, f, t" Name="InternalCoHomToTensorProductAdjunctionMapWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, c \otimes b)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>, a morphism <Math>f: \mathrm{\underline{coHom}}(a,b) \rightarrow c</Math> and an object <Math>t = c \otimes b</Math>.
 The output is a morphism <Math>g: a \rightarrow c \otimes b</Math> corresponding to <Math>f</Math> under the
 cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,c" Name="MonoidalPreCoComposeMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,c), \mathrm{\underline{coHom}}(b,c) \otimes \mathrm{\underline{coHom}}(a,b) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the precocomposition morphism
 <Math>\mathrm{MonoidalPreCoComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{coHom}}(a,c) \rightarrow \mathrm{\underline{coHom}}(b,c) \otimes \mathrm{\underline{coHom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,c,r" Name="MonoidalPreCoComposeMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,c), \mathrm{\underline{coHom}}(b,c) \otimes \mathrm{\underline{coHom}}(a,b) )</Math>.
</Returns>
 <Description>
 The arguments are
 an object <Math>s = \mathrm{\underline{coHom}}(a,c)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(b,c)</Math>.
 The output is the precocomposition morphism
 <Math>\mathrm{MonoidalPreCoComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{coHom}}(a,c) \rightarrow \mathrm{\underline{coHom}}(b,c) \otimes \mathrm{\underline{coHom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,c" Name="MonoidalPostCoComposeMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,c), \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(b,c) )</Math>.
</Returns>
 <Description>
 The arguments are three objects <Math>a,b,c</Math>.
 The output is the postcocomposition morphism
 <Math>\mathrm{MonoidalPostCoComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{coHom}}(a,c) \rightarrow \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(b,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,c,r" Name="MonoidalPostCoComposeMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,c), \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(b,c) )</Math>.
</Returns>
 <Description>
 The arguments are
 an object <Math>s = \mathrm{\underline{coHom}}(a,c)</Math>,
 three objects <Math>a,b,c</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}}(b,c) \otimes \mathrm{\underline{coHom}}(a,b)</Math>.
 The output is the postcocomposition morphism
 <Math>\mathrm{MonoidalPostCoComposeMorphismWithGivenObjects}_{a,b,c}: \mathrm{\underline{coHom}}(a,c) \rightarrow \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(b,c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="CoDualOnObjects" Label="for IsCapCategoryObject"/>
 <Returns>an object
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is its codual object <Math>a_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="CoDualOnMorphisms" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b_{\vee}, a_{\vee} )</Math>.
</Returns>
 <Description>
 The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
 The output is its codual morphism <Math>\alpha_{\vee}: b_{\vee} \rightarrow a_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,alpha,r" Name="CoDualOnMorphismsWithGivenCoDuals" Label="for IsCapCategoryObject, IsCapCategoryMorphism, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( b_{\vee}, a_{\vee} )</Math>.
</Returns>
 <Description>
 The argument is an object <Math>s = b_{\vee}</Math>,
 a morphism <Math>\alpha: a \rightarrow b</Math>,
 and an object <Math>r = a_{\vee}</Math>.
 The output is the dual morphism <Math>\alpha_{\vee}: b^{\vee} \rightarrow a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="CoclosedEvaluationForCoDual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( 1, a_{\vee} \otimes a )</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the coclosed evaluation morphism <Math>\mathrm{coclev}_{a}: 1 \rightarrow a_{\vee} \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,r" Name="CoclosedEvaluationForCoDualWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( 1, a_{\vee} \otimes a )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = 1</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = a_{\vee} \otimes a</Math>.
 The output is the coclosed evaluation morphism <Math>\mathrm{coclev}_{a}: 1 \rightarrow a_{\vee} \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="MorphismFromCoBidual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}((a_{\vee})_{\vee}, a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the morphism from the cobidual <Math>(a_{\vee})_{\vee} \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, s" Name="MorphismFromCoBidualWithGivenCoBidual" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}((a_{\vee})_{\vee}, a)</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>a</Math>,
 and an object <Math>s = (a_{\vee})_{\vee}</Math>.
 The output is the morphism from the cobidual <Math>(a_{\vee})_{\vee} \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="list" Name="InternalCoHomTensorProductCompatibilityMorphism" Label="for IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a \otimes a', b \otimes b'), \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b'))</Math>.
</Returns>
 <Description>
 The argument is a list of four objects <Math>[ a, a', b, b' ]</Math>.
 The output is the natural morphism
 <Math>\mathrm{InternalCoHomTensorProductCompatibilityMorphismWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{coHom}}(a \otimes a', b \otimes b') \rightarrow \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, list, r" Name="InternalCoHomTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a \otimes a', b \otimes b'), \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b') )</Math>.
</Returns>
 <Description>
 The arguments are a list of four objects <Math>[ a, a', b, b' ]</Math>,
 and two objects <Math>s = \mathrm{\underline{coHom}}(a \otimes a', b \otimes b')</Math> and <Math>r = \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b')</Math>.
 The output is the natural morphism
 <Math>\mathrm{InternalCoHomTensorProductCompatibilityMorphismWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{coHom}}(a \otimes a', b \otimes b') \rightarrow \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="CoDualityTensorProductCompatibilityMorphism" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (a \otimes b)_{\vee}, a_{\vee} \otimes b_{\vee} )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism
 <Math>\mathrm{CoDualityTensorProductCompatibilityMorphismWithGivenObjects}: (a \otimes b)_{\vee} \rightarrow a_{\vee} \otimes b_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="CoDualityTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( (a \otimes b)_{\vee}, a_{\vee} \otimes b_{\vee} )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = (a \otimes b)_{\vee}</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = a_{\vee} \otimes b_{\vee}</Math>.
 The output is the natural morphism
 <Math>\mathrm{CoDualityTensorProductCompatibilityMorphismWithGivenObjects}_{a,b}: (a \otimes b)_{\vee} \rightarrow a_{\vee} \otimes b_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="MorphismFromInternalCoHomToTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b), b_{\vee} \otimes a )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism <Math>\mathrm{MorphismFromInternalCoHomToTensorProductWithGivenObjects}_{a,b}: \mathrm{\underline{coHom}}(a,b) \rightarrow b_{\vee} \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="MorphismFromInternalCoHomToTensorProductWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b), a \otimes b_{\vee} )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = \mathrm{\underline{coHom}}(a,b)</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = b_{\vee} \otimes a</Math>.
 The output is the natural morphism <Math>\mathrm{MorphismFromInternalCoHomToTensorProductWithGivenObjects}_{a,b}: \mathrm{\underline{coHom}}(a,b) \rightarrow a \otimes b_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromCoDualObjectToInternalCoHomFromTensorUnit" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a_{\vee}, \mathrm{\underline{coHom}}(1,a))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the isomorphism
 <Math>\mathrm{IsomorphismFromCoDualObjectToInternalCoHomFromTensorUnit}_{a}: a_{\vee} \rightarrow \mathrm{\underline{coHom}}(1,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromInternalCoHomFromTensorUnitToCoDualObject" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{coHom}}(1,a), a_{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the isomorphism
 <Math>\mathrm{IsomorphismFromInternalCoHomFromTensorUnitToCoDualObject}_{a}: \mathrm{\underline{coHom}}(1,a) \rightarrow a_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="t, a, alpha" Name="UniversalPropertyOfCoDual" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a_{\vee}, t)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>t,a</Math>,
 and a morphism <Math>\alpha: 1 \rightarrow t \otimes a</Math>.
 The output is the morphism <Math>a_{\vee} \rightarrow t</Math>
 given by the universal property of <Math>a_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="CoLambdaIntroduction" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b), 1 )</Math>.
</Returns>
 <Description>
 The argument is a morphism <Math>\alpha: a \rightarrow b</Math>.
 The output is the corresponding morphism <Math> \mathrm{\underline{coHom}}(a,b) \rightarrow 1</Math>
 under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b,alpha" Name="CoLambdaElimination" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,b)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>,
 and a morphism <Math>\alpha: \mathrm{\underline{coHom}}(a,b) \rightarrow 1</Math>.
 The output is a morphism <Math>a \rightarrow b</Math> corresponding to <Math>\alpha</Math>
 under the cohom tensor adjunction.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromObjectToInternalCoHom" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, \mathrm{\underline{coHom}}(a,1))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the natural isomorphism <Math>a \rightarrow \mathrm{\underline{coHom}}(a,1)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,r" Name="IsomorphismFromObjectToInternalCoHomWithGivenInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, \mathrm{\underline{coHom}}(a,1))</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}}(a,1)</Math>.
 The output is the natural isomorphism <Math>a \rightarrow \mathrm{\underline{coHom}}(a,1)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="IsomorphismFromInternalCoHomToObject" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{coHom}}(a,1), a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the natural isomorphism <Math>\mathrm{\underline{coHom}}(a,1) \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,s" Name="IsomorphismFromInternalCoHomToObjectWithGivenInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(\mathrm{\underline{coHom}}(a,1), a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>s = \mathrm{\underline{coHom}}(a,1)</Math>.
 The output is the natural isomorphism <Math>\mathrm{\underline{coHom}}(a,1) \rightarrow a</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Symmetric_Closed_Monoidal_Categories">
<Heading>Symmetric Closed Monoidal Categories</Heading>

<P/>
A monoidal category <Math>\mathbf{C}</Math>
which is symmetric and closed
is called a <Emph>symmetric closed monoidal category</Emph>.
<P/>
The corresponding GAP property is given by
<C>IsSymmetricClosedMonoidalCategory</C>.
<P/>
</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Symmetric_Coclosed_Monoidal_Categories">
<Heading>Symmetric Coclosed Monoidal Categories</Heading>

<P/>
A monoidal category <Math>\mathbf{C}</Math>
which is symmetric and coclosed
is called a <Emph>symmetric coclosed monoidal category</Emph>.
<P/>
The corresponding GAP property is given by
<C>IsSymmetricCoclosedMonoidalCategory</C>.
<P/>
</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Rigid_Symmetric_Closed_Monoidal_Categories">
<Heading>Rigid Symmetric Closed Monoidal Categories</Heading>

<P/>
A symmetric closed monoidal category <Math>\mathbf{C}</Math> satisfying
<List>
<Item>
the natural morphism
</Item>
</List>
 <Math>\mathrm{\underline{Hom}}(a, a') \otimes \mathrm{\underline{Hom}}(b, b') \rightarrow \mathrm{\underline{Hom}}(a \otimes b, a' \otimes b')</Math>
 is an isomorphism,
<List>
<Item>
the natural morphism
</Item>
</List>
 <Math>a \rightarrow \mathrm{\underline{Hom}}(\mathrm{\underline{Hom}}(a, 1), 1)</Math>
 is an isomorphism
is called a <Emph>rigid symmetric closed monoidal category</Emph>.
<P/>
If no operations involving the closed structure are installed manually, the internal hom objects will be derived as
<Math>\mathrm{\underline{Hom}}(a,b) \coloneqq a^\vee \otimes b</Math> and, in particular, <Math>\mathrm{\underline{Hom}}(a,1) \coloneqq a^\vee \otimes 1</Math>.
<P/>
The corresponding GAP property is given by
<C>IsRigidSymmetricClosedMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="a,b" Name="IsomorphismFromTensorProductWithDualObjectToInternalHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a^{\vee} \otimes b, \mathrm{\underline{Hom}}(a,b) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism <Math>\mathrm{IsomorphismFromTensorProductWithDualObjectToInternalHom}_{a,b}: a^{\vee} \otimes b \rightarrow \mathrm{\underline{Hom}}(a,b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="IsomorphismFromInternalHomToTensorProductWithDualObject" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,b), a^{\vee} \otimes b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the inverse of <Math>\mathrm{IsomorphismFromTensorProductWithDualObjectToInternalHom}</Math>, namely
 <Math>\mathrm{IsomorphismFromInternalHomToTensorProductWithDualObject}_{a,b}: \mathrm{\underline{Hom}}(a,b) \rightarrow a^{\vee} \otimes b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="MorphismFromInternalHomToTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,b), a^{\vee} \otimes b )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the inverse of <Math>\mathrm{MorphismFromTensorProductToInternalHomWithGivenObjects}</Math>, namely
 <Math>\mathrm{MorphismFromInternalHomToTensorProductWithGivenObjects}_{a,b}: \mathrm{\underline{Hom}}(a,b) \rightarrow a^{\vee} \otimes b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="MorphismFromInternalHomToTensorProductWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a,b), a^{\vee} \otimes b )</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = \mathrm{\underline{Hom}}(a,b)</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = a^{\vee} \otimes b</Math>.
 The output is the inverse of <Math>\mathrm{MorphismFromTensorProductToInternalHomWithGivenObjects}</Math>, namely
 <Math>\mathrm{MorphismFromInternalHomToTensorProductWithGivenObjects}_{a,b}: \mathrm{\underline{Hom}}(a,b) \rightarrow a^{\vee} \otimes b</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="list" Name="TensorProductInternalHomCompatibilityMorphismInverse" Label="for IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b'), \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b') )</Math>.
</Returns>
 <Description>
 The argument is a list of four objects <Math>[ a, a', b, b' ]</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductInternalHomCompatibilityMorphismInverseWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b') \rightarrow \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, list, r" Name="TensorProductInternalHomCompatibilityMorphismInverseWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b'), \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b') )</Math>.
</Returns>
 <Description>
 The arguments are a list of four objects <Math>[ a, a', b, b' ]</Math>,
 and two objects <Math>s = \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b')</Math> and <Math>r = \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b')</Math>.
 The output is the natural morphism
 <Math>\mathrm{TensorProductInternalHomCompatibilityMorphismInverseWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{Hom}}(a \otimes b,a' \otimes b') \rightarrow \mathrm{\underline{Hom}}(a,a') \otimes \mathrm{\underline{Hom}}(b,b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="CoevaluationForDual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1,a \otimes a^{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the coevaluation morphism <Math>\mathrm{coev}_{a}:1 \rightarrow a \otimes a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,r" Name="CoevaluationForDualWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1,a \otimes a^{\vee})</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = 1</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = a \otimes a^{\vee}</Math>.
 The output is the coevaluation morphism <Math>\mathrm{coev}_{a}:1 \rightarrow a \otimes a^{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="TraceMap" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1,1)</Math>.
</Returns>
 <Description>
 The argument is an endomorphism <Math>\alpha: a \rightarrow a</Math>.
 The output is the trace morphism <Math>\mathrm{trace}_{\alpha}: 1 \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="RankMorphism" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1,1)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the rank morphism <Math>\mathrm{rank}_a: 1 \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="MorphismFromBidual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}((a^{\vee})^{\vee},a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the inverse of the morphism to the bidual <Math>(a^{\vee})^{\vee} \rightarrow a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, s" Name="MorphismFromBidualWithGivenBidual" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}((a^{\vee})^{\vee},a)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>s = (a^{\vee})^{\vee}</Math>.
 The output is the inverse of the morphism to the bidual <Math>(a^{\vee})^{\vee} \rightarrow a</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Rigid_Symmetric_Coclosed_Monoidal_Categories">
<Heading>Rigid Symmetric Coclosed Monoidal Categories</Heading>

<P/>
A symmetric coclosed monoidal category <Math>\mathbf{C}</Math> satisfying
<List>
<Item>
the natural morphism
</Item>
</List>
 <Math>\mathrm{\underline{coHom}}(a \otimes a', b \otimes b') \rightarrow \mathrm{\underline{coHom}}(a, b) \otimes \mathrm{\underline{coHom}}(a', b')</Math>
 is an isomorphism,
<List>
<Item>
the natural morphism
</Item>
</List>
 <Math>\mathrm{\underline{coHom}}(1, \mathrm{\underline{coHom}}(1, a)) \rightarrow a</Math>
 is an isomorphism
is called a <Emph>rigid symmetric coclosed monoidal category</Emph>.
<P/>
If no operations involving the coclosed structure are installed manually, the internal cohom objects will be derived as
<Math>\mathrm{\underline{coHom}}(a,b) \coloneqq a \otimes b_\vee</Math> and, in particular, <Math>\mathrm{\underline{coHom}}(1,a) \coloneqq 1 \otimes a_\vee</Math>.
<P/>
The corresponding GAP property is given by
<C>IsRigidSymmetricCoclosedMonoidalCategory</C>.
<P/>
<ManSection>
  <Oper Arg="a,b" Name="IsomorphismFromInternalCoHomToTensorProductWithCoDualObject" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b), b_{\vee} \otimes a )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the natural morphism <Math>\mathrm{IsomorphismFromInternalCoHomToTensorProductWithCoDualObjectWithGivenObjects}_{a,b}: \mathrm{\underline{coHom}}(a,b) \rightarrow b_{\vee} \otimes a</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="IsomorphismFromTensorProductWithCoDualObjectToInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a_{\vee} \otimes b, \mathrm{\underline{coHom}}(b,a)</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the inverse of <Math>\mathrm{IsomorphismFromInternalCoHomToTensorProductWithCoDualObject}</Math>, namely
 <Math>\mathrm{IsomorphismFromTensorProductWithCoDualObjectToInternalCoHom}_{a,b}: a_{\vee} \otimes b \rightarrow \mathrm{\underline{coHom}}(b,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a,b" Name="MorphismFromTensorProductToInternalCoHom" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a_{\vee} \otimes b, \mathrm{\underline{coHom}}(b,a) )</Math>.
</Returns>
 <Description>
 The arguments are two objects <Math>a,b</Math>.
 The output is the inverse of <Math>\mathrm{MorphismFromInternalCoHomToTensorProductWithGivenObjects}</Math>, namely
 <Math>\mathrm{MorphismFromTensorProductToInternalCoHomWithGivenObjects}_{a,b}: a_{\vee} \otimes b \rightarrow \mathrm{\underline{coHom}}(b,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,b,r" Name="MorphismFromTensorProductToInternalCoHomWithGivenObjects" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( a_{\vee} \otimes b, \mathrm{\underline{coHom}}(b,a)</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s_{\vee} = a \otimes b</Math>,
 two objects <Math>a,b</Math>,
 and an object <Math>r = \mathrm{\underline{coHom}}(b,a)</Math>.
 The output is the inverse of <Math>\mathrm{MorphismFromInternalCoHomToTensorProductWithGivenObjects}</Math>, namely
 <Math>\mathrm{MorphismFromTensorProductToInternalCoHomWithGivenObjects}_{a,b}: a_{\vee} \otimes b \rightarrow \mathrm{\underline{coHom}}(b,a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="list" Name="InternalCoHomTensorProductCompatibilityMorphismInverse" Label="for IsList"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b'), \mathrm{\underline{coHom}}(a \otimes a', b \otimes b' )</Math>.
</Returns>
 <Description>
 The argument is a list of four objects <Math>[ a, a', b, b' ]</Math>.
 The output is the natural morphism
 <Math>\mathrm{InternalCoHomTensorProductCompatibilityMorphismInverseWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b') \rightarrow \mathrm{\underline{coHom}}(a \otimes a', b \otimes b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s, list, r" Name="InternalCoHomTensorProductCompatibilityMorphismInverseWithGivenObjects" Label="for IsCapCategoryObject, IsList, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}( \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b'), \mathrm{\underline{coHom}}(a \otimes a', b \otimes b' )</Math>.
</Returns>
 <Description>
 The arguments are a list of four objects <Math>[ a, a', b, b' ]</Math>,
 and two objects <Math>s = \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b')</Math> and <Math>r = \mathrm{\underline{coHom}}(a \otimes a', b \otimes b')</Math>.
 The output is the natural morphism
 <Math>\mathrm{InternalCoHomTensorProductCompatibilityMorphismInverseWithGivenObjects}_{a,a',b,b'}: \mathrm{\underline{coHom}}(a,b) \otimes \mathrm{\underline{coHom}}(a',b') \rightarrow \mathrm{\underline{coHom}}(a \otimes a', b \otimes b')</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="CoclosedCoevaluationForCoDual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes a_{\vee}, 1)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the coclosed coevaluation morphism <Math>\mathrm{coclcoev}_{a}: a \otimes a_{\vee} \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="s,a,r" Name="CoclosedCoevaluationForCoDualWithGivenTensorProduct" Label="for IsCapCategoryObject, IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a \otimes a_{\vee}, 1)</Math>.
</Returns>
 <Description>
 The arguments are an object <Math>s = a \otimes a_{\vee}</Math>,
 an object <Math>a</Math>,
 and an object <Math>r = 1</Math>.
 The output is the coclosed coevaluation morphism <Math>\mathrm{coclcoev}_{a}: a \otimes a_{\vee} \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="alpha" Name="CoTraceMap" Label="for IsCapCategoryMorphism"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1,1)</Math>.
</Returns>
 <Description>
 The argument is an endomorphism <Math>\alpha: a \rightarrow a</Math>.
 The output is the cotrace morphism <Math>\mathrm{cotrace}_{\alpha}: 1 \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="CoRankMorphism" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(1,1)</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the corank morphism <Math>\mathrm{corank}_a: 1 \rightarrow 1</Math>.
 </Description>
</ManSection>


<ManSection>
  <Attr Arg="a" Name="MorphismToCoBidual" Label="for IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a, (a_{\vee})_{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>.
 The output is the inverse of the morphism from the cobidual <Math>a \rightarrow (a_{\vee})_{\vee}</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, r" Name="MorphismToCoBidualWithGivenCoBidual" Label="for IsCapCategoryObject, IsCapCategoryObject"/>
 <Returns>a morphism in <Math>\mathrm{Hom}(a,(a_{\vee})_{\vee})</Math>.
</Returns>
 <Description>
 The argument is an object <Math>a</Math>,
 and an object <Math>r = (a_{\vee})_{\vee}</Math>.
 The output is the inverse of the morphism from the cobidual <Math>a \rightarrow (a_{\vee})_{\vee}</Math>.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Convenience_Methods">
<Heading>Convenience Methods</Heading>

<P/>
<ManSection>
  <Oper Arg="a, b" Name="InternalHom" Label="for IsCapCategoryCell, IsCapCategoryCell"/>
 <Returns>a cell
</Returns>
 <Description>
 This is a convenience method.
 The arguments are two cells <Math>a,b</Math>.
 The output is the internal hom cell.
 If <Math>a,b</Math> are two CAP objects the output is the internal Hom object
 <Math>\mathrm{\underline{Hom}}(a,b)</Math>.
 If at least one of the arguments is a CAP morphism the output is a CAP morphism,
 namely the internal hom on morphisms, where any object is replaced by its identity morphism.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="a, b" Name="InternalCoHom" Label="for IsCapCategoryCell, IsCapCategoryCell"/>
 <Returns>a cell
</Returns>
 <Description>
 This is a convenience method.
 The arguments are two cells <Math>a,b</Math>.
 The output is the internal cohom cell.
 If <Math>a,b</Math> are two CAP objects the output is the internal cohom object
 <Math>\mathrm{\underline{coHom}}(a,b)</Math>.
 If at least one of the arguments is a CAP morphism the output is a CAP morphism,
 namely the internal cohom on morphisms, where any object is replaced by its identity morphism.
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Monoidal_Categories_Section_Add-methods">
<Heading>Add-methods</Heading>

<P/>
<ManSection>
  <Oper Arg="C, F" Name="AddLeftDistributivityExpanding" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftDistributivityExpanding</Code>.
 <Math>F: ( a, L ) \mapsto \mathtt{LeftDistributivityExpanding}(a, L)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddLeftDistributivityExpandingWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftDistributivityExpandingWithGivenObjects</Code>.
 <Math>F: ( s, a, L, r ) \mapsto \mathtt{LeftDistributivityExpandingWithGivenObjects}(s, a, L, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddLeftDistributivityFactoring" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftDistributivityFactoring</Code>.
 <Math>F: ( a, L ) \mapsto \mathtt{LeftDistributivityFactoring}(a, L)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddLeftDistributivityFactoringWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftDistributivityFactoringWithGivenObjects</Code>.
 <Math>F: ( s, a, L, r ) \mapsto \mathtt{LeftDistributivityFactoringWithGivenObjects}(s, a, L, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRightDistributivityExpanding" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightDistributivityExpanding</Code>.
 <Math>F: ( L, a ) \mapsto \mathtt{RightDistributivityExpanding}(L, a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRightDistributivityExpandingWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightDistributivityExpandingWithGivenObjects</Code>.
 <Math>F: ( s, L, a, r ) \mapsto \mathtt{RightDistributivityExpandingWithGivenObjects}(s, L, a, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRightDistributivityFactoring" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightDistributivityFactoring</Code>.
 <Math>F: ( L, a ) \mapsto \mathtt{RightDistributivityFactoring}(L, a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRightDistributivityFactoringWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightDistributivityFactoringWithGivenObjects</Code>.
 <Math>F: ( s, L, a, r ) \mapsto \mathtt{RightDistributivityFactoringWithGivenObjects}(s, L, a, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddBraiding" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>Braiding</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{Braiding}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddBraidingInverse" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>BraidingInverse</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{BraidingInverse}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddBraidingInverseWithGivenTensorProducts" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>BraidingInverseWithGivenTensorProducts</Code>.
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{BraidingInverseWithGivenTensorProducts}(s, a, b, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddBraidingWithGivenTensorProducts" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>BraidingWithGivenTensorProducts</Code>.
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{BraidingWithGivenTensorProducts}(s, a, b, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoevaluationMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoevaluationMorphism</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{CoevaluationMorphism}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoevaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoevaluationMorphismWithGivenRange</Code>.
 <Math>F: ( a, b, r ) \mapsto \mathtt{CoevaluationMorphismWithGivenRange}(a, b, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddDualOnMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>DualOnMorphisms</Code>.
 <Math>F: ( alpha ) \mapsto \mathtt{DualOnMorphisms}(alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddDualOnMorphismsWithGivenDuals" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>DualOnMorphismsWithGivenDuals</Code>.
 <Math>F: ( s, alpha, r ) \mapsto \mathtt{DualOnMorphismsWithGivenDuals}(s, alpha, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddDualOnObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>DualOnObjects</Code>.
 <Math>F: ( a ) \mapsto \mathtt{DualOnObjects}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddEvaluationForDual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>EvaluationForDual</Code>.
 <Math>F: ( a ) \mapsto \mathtt{EvaluationForDual}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddEvaluationForDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>EvaluationForDualWithGivenTensorProduct</Code>.
 <Math>F: ( s, a, r ) \mapsto \mathtt{EvaluationForDualWithGivenTensorProduct}(s, a, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddEvaluationMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>EvaluationMorphism</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{EvaluationMorphism}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddEvaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>EvaluationMorphismWithGivenSource</Code>.
 <Math>F: ( a, b, s ) \mapsto \mathtt{EvaluationMorphismWithGivenSource}(a, b, s)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalHomOnMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomOnMorphisms</Code>.
 <Math>F: ( alpha, beta ) \mapsto \mathtt{InternalHomOnMorphisms}(alpha, beta)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalHomOnMorphismsWithGivenInternalHoms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomOnMorphismsWithGivenInternalHoms</Code>.
 <Math>F: ( s, alpha, beta, r ) \mapsto \mathtt{InternalHomOnMorphismsWithGivenInternalHoms}(s, alpha, beta, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalHomOnObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomOnObjects</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{InternalHomOnObjects}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalHomToTensorProductAdjunctionMap" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomToTensorProductAdjunctionMap</Code>.
 <Math>F: ( b, c, g ) \mapsto \mathtt{InternalHomToTensorProductAdjunctionMap}(b, c, g)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalHomToTensorProductAdjunctionMapWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalHomToTensorProductAdjunctionMapWithGivenTensorProduct</Code>.
 <Math>F: ( b, c, g, t ) \mapsto \mathtt{InternalHomToTensorProductAdjunctionMapWithGivenTensorProduct}(b, c, g, t)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromDualObjectToInternalHomIntoTensorUnit" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromDualObjectToInternalHomIntoTensorUnit</Code>.
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromDualObjectToInternalHomIntoTensorUnit}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalHomIntoTensorUnitToDualObject" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalHomIntoTensorUnitToDualObject</Code>.
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromInternalHomIntoTensorUnitToDualObject}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalHomToObject" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalHomToObject</Code>.
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromInternalHomToObject}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalHomToObjectWithGivenInternalHom" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalHomToObjectWithGivenInternalHom</Code>.
 <Math>F: ( a, s ) \mapsto \mathtt{IsomorphismFromInternalHomToObjectWithGivenInternalHom}(a, s)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromObjectToInternalHom" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromObjectToInternalHom</Code>.
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromObjectToInternalHom}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromObjectToInternalHomWithGivenInternalHom" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromObjectToInternalHomWithGivenInternalHom</Code>.
 <Math>F: ( a, r ) \mapsto \mathtt{IsomorphismFromObjectToInternalHomWithGivenInternalHom}(a, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddLambdaElimination" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LambdaElimination</Code>.
 <Math>F: ( a, b, alpha ) \mapsto \mathtt{LambdaElimination}(a, b, alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddLambdaIntroduction" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LambdaIntroduction</Code>.
 <Math>F: ( alpha ) \mapsto \mathtt{LambdaIntroduction}(alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMonoidalPostComposeMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPostComposeMorphism</Code>.
 <Math>F: ( a, b, c ) \mapsto \mathtt{MonoidalPostComposeMorphism}(a, b, c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMonoidalPostComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPostComposeMorphismWithGivenObjects</Code>.
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{MonoidalPostComposeMorphismWithGivenObjects}(s, a, b, c, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMonoidalPreComposeMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPreComposeMorphism</Code>.
 <Math>F: ( a, b, c ) \mapsto \mathtt{MonoidalPreComposeMorphism}(a, b, c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMonoidalPreComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPreComposeMorphismWithGivenObjects</Code>.
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{MonoidalPreComposeMorphismWithGivenObjects}(s, a, b, c, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismFromTensorProductToInternalHom" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromTensorProductToInternalHom</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{MorphismFromTensorProductToInternalHom}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismFromTensorProductToInternalHomWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromTensorProductToInternalHomWithGivenObjects</Code>.
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{MorphismFromTensorProductToInternalHomWithGivenObjects}(s, a, b, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismToBidual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismToBidual</Code>.
 <Math>F: ( a ) \mapsto \mathtt{MorphismToBidual}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismToBidualWithGivenBidual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismToBidualWithGivenBidual</Code>.
 <Math>F: ( a, r ) \mapsto \mathtt{MorphismToBidualWithGivenBidual}(a, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorProductDualityCompatibilityMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductDualityCompatibilityMorphism</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{TensorProductDualityCompatibilityMorphism}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorProductDualityCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductDualityCompatibilityMorphismWithGivenObjects</Code>.
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{TensorProductDualityCompatibilityMorphismWithGivenObjects}(s, a, b, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorProductInternalHomCompatibilityMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductInternalHomCompatibilityMorphism</Code>.
 <Math>F: ( list ) \mapsto \mathtt{TensorProductInternalHomCompatibilityMorphism}(list)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorProductInternalHomCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductInternalHomCompatibilityMorphismWithGivenObjects</Code>.
 <Math>F: ( source, list, range ) \mapsto \mathtt{TensorProductInternalHomCompatibilityMorphismWithGivenObjects}(source, list, range)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorProductToInternalHomAdjunctionMap" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalHomAdjunctionMap</Code>.
 <Math>F: ( a, b, f ) \mapsto \mathtt{TensorProductToInternalHomAdjunctionMap}(a, b, f)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorProductToInternalHomAdjunctionMapWithGivenInternalHom" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalHomAdjunctionMapWithGivenInternalHom</Code>.
 <Math>F: ( a, b, f, i ) \mapsto \mathtt{TensorProductToInternalHomAdjunctionMapWithGivenInternalHom}(a, b, f, i)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddUniversalPropertyOfDual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>UniversalPropertyOfDual</Code>.
 <Math>F: ( t, a, alpha ) \mapsto \mathtt{UniversalPropertyOfDual}(t, a, alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoDualOnMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoDualOnMorphisms</Code>.
 <Math>F: ( alpha ) \mapsto \mathtt{CoDualOnMorphisms}(alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoDualOnMorphismsWithGivenCoDuals" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoDualOnMorphismsWithGivenCoDuals</Code>.
 <Math>F: ( s, alpha, r ) \mapsto \mathtt{CoDualOnMorphismsWithGivenCoDuals}(s, alpha, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoDualOnObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoDualOnObjects</Code>.
 <Math>F: ( a ) \mapsto \mathtt{CoDualOnObjects}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoDualityTensorProductCompatibilityMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoDualityTensorProductCompatibilityMorphism</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{CoDualityTensorProductCompatibilityMorphism}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoDualityTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoDualityTensorProductCompatibilityMorphismWithGivenObjects</Code>.
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{CoDualityTensorProductCompatibilityMorphismWithGivenObjects}(s, a, b, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoLambdaElimination" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoLambdaElimination</Code>.
 <Math>F: ( a, b, alpha ) \mapsto \mathtt{CoLambdaElimination}(a, b, alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoLambdaIntroduction" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoLambdaIntroduction</Code>.
 <Math>F: ( alpha ) \mapsto \mathtt{CoLambdaIntroduction}(alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoclosedCoevaluationMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedCoevaluationMorphism</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{CoclosedCoevaluationMorphism}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoclosedCoevaluationMorphismWithGivenSource" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedCoevaluationMorphismWithGivenSource</Code>.
 <Math>F: ( a, b, s ) \mapsto \mathtt{CoclosedCoevaluationMorphismWithGivenSource}(a, b, s)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoclosedEvaluationForCoDual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedEvaluationForCoDual</Code>.
 <Math>F: ( a ) \mapsto \mathtt{CoclosedEvaluationForCoDual}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoclosedEvaluationForCoDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedEvaluationForCoDualWithGivenTensorProduct</Code>.
 <Math>F: ( s, a, r ) \mapsto \mathtt{CoclosedEvaluationForCoDualWithGivenTensorProduct}(s, a, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoclosedEvaluationMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedEvaluationMorphism</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{CoclosedEvaluationMorphism}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoclosedEvaluationMorphismWithGivenRange" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedEvaluationMorphismWithGivenRange</Code>.
 <Math>F: ( a, b, r ) \mapsto \mathtt{CoclosedEvaluationMorphismWithGivenRange}(a, b, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalCoHomOnMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomOnMorphisms</Code>.
 <Math>F: ( alpha, beta ) \mapsto \mathtt{InternalCoHomOnMorphisms}(alpha, beta)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalCoHomOnMorphismsWithGivenInternalCoHoms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomOnMorphismsWithGivenInternalCoHoms</Code>.
 <Math>F: ( s, alpha, beta, r ) \mapsto \mathtt{InternalCoHomOnMorphismsWithGivenInternalCoHoms}(s, alpha, beta, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalCoHomOnObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomOnObjects</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{InternalCoHomOnObjects}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalCoHomTensorProductCompatibilityMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomTensorProductCompatibilityMorphism</Code>.
 <Math>F: ( list ) \mapsto \mathtt{InternalCoHomTensorProductCompatibilityMorphism}(list)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalCoHomTensorProductCompatibilityMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomTensorProductCompatibilityMorphismWithGivenObjects</Code>.
 <Math>F: ( source, list, range ) \mapsto \mathtt{InternalCoHomTensorProductCompatibilityMorphismWithGivenObjects}(source, list, range)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalCoHomToTensorProductAdjunctionMap" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomToTensorProductAdjunctionMap</Code>.
 <Math>F: ( a, b, f ) \mapsto \mathtt{InternalCoHomToTensorProductAdjunctionMap}(a, b, f)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalCoHomToTensorProductAdjunctionMapWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomToTensorProductAdjunctionMapWithGivenTensorProduct</Code>.
 <Math>F: ( a, b, f, t ) \mapsto \mathtt{InternalCoHomToTensorProductAdjunctionMapWithGivenTensorProduct}(a, b, f, t)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromCoDualObjectToInternalCoHomFromTensorUnit" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromCoDualObjectToInternalCoHomFromTensorUnit</Code>.
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromCoDualObjectToInternalCoHomFromTensorUnit}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalCoHomFromTensorUnitToCoDualObject" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalCoHomFromTensorUnitToCoDualObject</Code>.
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromInternalCoHomFromTensorUnitToCoDualObject}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalCoHomToObject" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalCoHomToObject</Code>.
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromInternalCoHomToObject}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalCoHomToObjectWithGivenInternalCoHom" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalCoHomToObjectWithGivenInternalCoHom</Code>.
 <Math>F: ( a, s ) \mapsto \mathtt{IsomorphismFromInternalCoHomToObjectWithGivenInternalCoHom}(a, s)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromObjectToInternalCoHom" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromObjectToInternalCoHom</Code>.
 <Math>F: ( a ) \mapsto \mathtt{IsomorphismFromObjectToInternalCoHom}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromObjectToInternalCoHomWithGivenInternalCoHom" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromObjectToInternalCoHomWithGivenInternalCoHom</Code>.
 <Math>F: ( a, r ) \mapsto \mathtt{IsomorphismFromObjectToInternalCoHomWithGivenInternalCoHom}(a, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMonoidalPostCoComposeMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPostCoComposeMorphism</Code>.
 <Math>F: ( a, b, c ) \mapsto \mathtt{MonoidalPostCoComposeMorphism}(a, b, c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMonoidalPostCoComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPostCoComposeMorphismWithGivenObjects</Code>.
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{MonoidalPostCoComposeMorphismWithGivenObjects}(s, a, b, c, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMonoidalPreCoComposeMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPreCoComposeMorphism</Code>.
 <Math>F: ( a, b, c ) \mapsto \mathtt{MonoidalPreCoComposeMorphism}(a, b, c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMonoidalPreCoComposeMorphismWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MonoidalPreCoComposeMorphismWithGivenObjects</Code>.
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{MonoidalPreCoComposeMorphismWithGivenObjects}(s, a, b, c, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismFromCoBidual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromCoBidual</Code>.
 <Math>F: ( a ) \mapsto \mathtt{MorphismFromCoBidual}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismFromCoBidualWithGivenCoBidual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromCoBidualWithGivenCoBidual</Code>.
 <Math>F: ( a, s ) \mapsto \mathtt{MorphismFromCoBidualWithGivenCoBidual}(a, s)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismFromInternalCoHomToTensorProduct" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromInternalCoHomToTensorProduct</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{MorphismFromInternalCoHomToTensorProduct}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismFromInternalCoHomToTensorProductWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromInternalCoHomToTensorProductWithGivenObjects</Code>.
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{MorphismFromInternalCoHomToTensorProductWithGivenObjects}(s, a, b, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorProductToInternalCoHomAdjunctionMap" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalCoHomAdjunctionMap</Code>.
 <Math>F: ( c, b, g ) \mapsto \mathtt{TensorProductToInternalCoHomAdjunctionMap}(c, b, g)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorProductToInternalCoHomAdjunctionMapWithGivenInternalCoHom" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductToInternalCoHomAdjunctionMapWithGivenInternalCoHom</Code>.
 <Math>F: ( c, b, g, i ) \mapsto \mathtt{TensorProductToInternalCoHomAdjunctionMapWithGivenInternalCoHom}(c, b, g, i)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddUniversalPropertyOfCoDual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>UniversalPropertyOfCoDual</Code>.
 <Math>F: ( t, a, alpha ) \mapsto \mathtt{UniversalPropertyOfCoDual}(t, a, alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddAssociatorLeftToRight" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>AssociatorLeftToRight</Code>.
 <Math>F: ( a, b, c ) \mapsto \mathtt{AssociatorLeftToRight}(a, b, c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddAssociatorLeftToRightWithGivenTensorProducts" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>AssociatorLeftToRightWithGivenTensorProducts</Code>.
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{AssociatorLeftToRightWithGivenTensorProducts}(s, a, b, c, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddAssociatorRightToLeft" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>AssociatorRightToLeft</Code>.
 <Math>F: ( a, b, c ) \mapsto \mathtt{AssociatorRightToLeft}(a, b, c)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddAssociatorRightToLeftWithGivenTensorProducts" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>AssociatorRightToLeftWithGivenTensorProducts</Code>.
 <Math>F: ( s, a, b, c, r ) \mapsto \mathtt{AssociatorRightToLeftWithGivenTensorProducts}(s, a, b, c, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddLeftUnitor" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftUnitor</Code>.
 <Math>F: ( a ) \mapsto \mathtt{LeftUnitor}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddLeftUnitorInverse" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftUnitorInverse</Code>.
 <Math>F: ( a ) \mapsto \mathtt{LeftUnitorInverse}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddLeftUnitorInverseWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftUnitorInverseWithGivenTensorProduct</Code>.
 <Math>F: ( a, r ) \mapsto \mathtt{LeftUnitorInverseWithGivenTensorProduct}(a, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddLeftUnitorWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>LeftUnitorWithGivenTensorProduct</Code>.
 <Math>F: ( a, s ) \mapsto \mathtt{LeftUnitorWithGivenTensorProduct}(a, s)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRightUnitor" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightUnitor</Code>.
 <Math>F: ( a ) \mapsto \mathtt{RightUnitor}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRightUnitorInverse" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightUnitorInverse</Code>.
 <Math>F: ( a ) \mapsto \mathtt{RightUnitorInverse}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRightUnitorInverseWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightUnitorInverseWithGivenTensorProduct</Code>.
 <Math>F: ( a, r ) \mapsto \mathtt{RightUnitorInverseWithGivenTensorProduct}(a, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRightUnitorWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RightUnitorWithGivenTensorProduct</Code>.
 <Math>F: ( a, s ) \mapsto \mathtt{RightUnitorWithGivenTensorProduct}(a, s)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorProductOnMorphisms" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductOnMorphisms</Code>.
 <Math>F: ( alpha, beta ) \mapsto \mathtt{TensorProductOnMorphisms}(alpha, beta)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorProductOnMorphismsWithGivenTensorProducts" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductOnMorphismsWithGivenTensorProducts</Code>.
 <Math>F: ( s, alpha, beta, r ) \mapsto \mathtt{TensorProductOnMorphismsWithGivenTensorProducts}(s, alpha, beta, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoevaluationForDual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoevaluationForDual</Code>.
 <Math>F: ( a ) \mapsto \mathtt{CoevaluationForDual}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoevaluationForDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoevaluationForDualWithGivenTensorProduct</Code>.
 <Math>F: ( s, a, r ) \mapsto \mathtt{CoevaluationForDualWithGivenTensorProduct}(s, a, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalHomToTensorProductWithDualObject" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalHomToTensorProductWithDualObject</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{IsomorphismFromInternalHomToTensorProductWithDualObject}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromTensorProductWithDualObjectToInternalHom" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromTensorProductWithDualObjectToInternalHom</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{IsomorphismFromTensorProductWithDualObjectToInternalHom}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismFromBidual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromBidual</Code>.
 <Math>F: ( a ) \mapsto \mathtt{MorphismFromBidual}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismFromBidualWithGivenBidual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromBidualWithGivenBidual</Code>.
 <Math>F: ( a, s ) \mapsto \mathtt{MorphismFromBidualWithGivenBidual}(a, s)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismFromInternalHomToTensorProduct" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromInternalHomToTensorProduct</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{MorphismFromInternalHomToTensorProduct}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismFromInternalHomToTensorProductWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromInternalHomToTensorProductWithGivenObjects</Code>.
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{MorphismFromInternalHomToTensorProductWithGivenObjects}(s, a, b, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddRankMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>RankMorphism</Code>.
 <Math>F: ( a ) \mapsto \mathtt{RankMorphism}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorProductInternalHomCompatibilityMorphismInverse" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductInternalHomCompatibilityMorphismInverse</Code>.
 <Math>F: ( list ) \mapsto \mathtt{TensorProductInternalHomCompatibilityMorphismInverse}(list)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTensorProductInternalHomCompatibilityMorphismInverseWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TensorProductInternalHomCompatibilityMorphismInverseWithGivenObjects</Code>.
 <Math>F: ( source, list, range ) \mapsto \mathtt{TensorProductInternalHomCompatibilityMorphismInverseWithGivenObjects}(source, list, range)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddTraceMap" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>TraceMap</Code>.
 <Math>F: ( alpha ) \mapsto \mathtt{TraceMap}(alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoRankMorphism" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoRankMorphism</Code>.
 <Math>F: ( a ) \mapsto \mathtt{CoRankMorphism}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoTraceMap" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoTraceMap</Code>.
 <Math>F: ( alpha ) \mapsto \mathtt{CoTraceMap}(alpha)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoclosedCoevaluationForCoDual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedCoevaluationForCoDual</Code>.
 <Math>F: ( a ) \mapsto \mathtt{CoclosedCoevaluationForCoDual}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddCoclosedCoevaluationForCoDualWithGivenTensorProduct" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>CoclosedCoevaluationForCoDualWithGivenTensorProduct</Code>.
 <Math>F: ( s, a, r ) \mapsto \mathtt{CoclosedCoevaluationForCoDualWithGivenTensorProduct}(s, a, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalCoHomTensorProductCompatibilityMorphismInverse" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomTensorProductCompatibilityMorphismInverse</Code>.
 <Math>F: ( list ) \mapsto \mathtt{InternalCoHomTensorProductCompatibilityMorphismInverse}(list)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddInternalCoHomTensorProductCompatibilityMorphismInverseWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>InternalCoHomTensorProductCompatibilityMorphismInverseWithGivenObjects</Code>.
 <Math>F: ( source, list, range ) \mapsto \mathtt{InternalCoHomTensorProductCompatibilityMorphismInverseWithGivenObjects}(source, list, range)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromInternalCoHomToTensorProductWithCoDualObject" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromInternalCoHomToTensorProductWithCoDualObject</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{IsomorphismFromInternalCoHomToTensorProductWithCoDualObject}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddIsomorphismFromTensorProductWithCoDualObjectToInternalCoHom" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>IsomorphismFromTensorProductWithCoDualObjectToInternalCoHom</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{IsomorphismFromTensorProductWithCoDualObjectToInternalCoHom}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismFromTensorProductToInternalCoHom" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromTensorProductToInternalCoHom</Code>.
 <Math>F: ( a, b ) \mapsto \mathtt{MorphismFromTensorProductToInternalCoHom}(a, b)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismFromTensorProductToInternalCoHomWithGivenObjects" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismFromTensorProductToInternalCoHomWithGivenObjects</Code>.
 <Math>F: ( s, a, b, r ) \mapsto \mathtt{MorphismFromTensorProductToInternalCoHomWithGivenObjects}(s, a, b, r)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismToCoBidual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismToCoBidual</Code>.
 <Math>F: ( a ) \mapsto \mathtt{MorphismToCoBidual}(a)</Math>.
 </Description>
</ManSection>


<ManSection>
  <Oper Arg="C, F" Name="AddMorphismToCoBidualWithGivenCoBidual" Label="for IsCapCategory, IsFunction"/>
 <Returns>nothing
</Returns>
 <Description>
 The arguments are a category <Math>C</Math> and a function <Math>F</Math>.
 This operation adds the given function <Math>F</Math>
 to the category for the basic operation <Code>MorphismToCoBidualWithGivenCoBidual</Code>.
 <Math>F: ( a, r ) \mapsto \mathtt{MorphismToCoBidualWithGivenCoBidual}(a, r)</Math>.
 </Description>
</ManSection>


</Section>


</Chapter>

