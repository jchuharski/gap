<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Examples_and_Tests">
<Heading>Examples and Tests</Heading>

<P/>
<Section Label="Chapter_Examples_and_Tests_Section_Test_functions">
<Heading>Test functions</Heading>

<P/>
<ManSection>
  <Func Arg="cat, a, L" Name="AdditiveMonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
an object <Math>a</Math>
</Item>
<Item>
a list <Math>L</Math> of objects
</Item>
</List>
 This function checks for every operation
 declared in AdditiveMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b" Name="BraidedMonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b</Math>
</Item>
</List>
 This function checks for every operation
 declared in BraidedMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha, beta, gamma, delta, epsilon, zeta" Name="ClosedMonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c, d</Math>
</Item>
<Item>
a morphism <Math>\alpha: a \rightarrow b</Math>
</Item>
<Item>
a morphism <Math>\beta: c \rightarrow d</Math>
</Item>
<Item>
a morphism <Math>\gamma: a \otimes b \rightarrow 1</Math>
</Item>
<Item>
a morphism <Math>\delta: c \otimes d \rightarrow 1</Math>
</Item>
<Item>
a morphism <Math>\epsilon: 1 \rightarrow \mathrm{Hom}(a,b)</Math>
</Item>
<Item>
a morphism <Math>\zeta: 1 \rightarrow \mathrm{Hom}(c,d)</Math>
</Item>
</List>
 This function checks for every operation
 declared in ClosedMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha, beta, gamma, delta, epsilon, zeta" Name="CoclosedMonoidalCategoriesTest" />
 <Description>
 The arguments are
 a CAP category <Math>cat</Math>
 objects <Math>a, b, c, d</Math>
<List>
<Item>
a morphism <Math>\alpha: a \rightarrow b</Math>
</Item>
<Item>
a morphism <Math>\beta: c \rightarrow d</Math>
</Item>
<Item>
a morphism <Math>\gamma: 1 \rightarrow a \otimes b</Math>
</Item>
<Item>
a morphism <Math>\delta: 1 \rightarrow c \otimes d</Math>
</Item>
<Item>
a morphism <Math>\epsilon: \mathrm{coHom}(a,b) \rightarrow 1</Math>
</Item>
<Item>
a morphism <Math>\zeta: \mathrm{coHom}(c,d) \rightarrow 1</Math>
</Item>
</List>
 This function checks for every operation
 declared in CoclosedMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b" Name="MonoidalCategoriesTensorProductAndUnitTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b</Math>
</Item>
</List>
 This function checks for every operation
 declared in MonoidalCategoriesTensorProductAndUnit.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, alpha, beta" Name="MonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c</Math>
</Item>
<Item>
a morphism <Math>\alpha: a \rightarrow b</Math>
</Item>
<Item>
a morphism <Math>\beta: c \rightarrow d</Math>
</Item>
</List>
 This function checks for every operation
 declared in MonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha" Name="RigidSymmetricClosedMonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c, d</Math>
</Item>
<Item>
an endomorphism <Math>\alpha: a \rightarrow a</Math>
</Item>
</List>
 This function checks for every object and morphism
 declared in RigidSymmetricClosedMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


<ManSection>
  <Func Arg="cat, a, b, c, d, alpha" Name="RigidSymmetricCoclosedMonoidalCategoriesTest" />
 <Description>
 The arguments are
<List>
<Item>
a CAP category <Math>cat</Math>
</Item>
<Item>
objects <Math>a, b, c, d</Math>
</Item>
<Item>
an endomorphism <Math>\alpha: a \rightarrow a</Math>
</Item>
</List>
 This function checks for every object and morphism
 declared in RigidSymmetricCoclosedMonoidalCategories.gd
 if it is computable in the CAP category <Math>cat</Math>.
 If yes, then the operation is executed
 with the parameters given above and
 compared to the equivalent computation in
 the opposite category of <Math>cat</Math>.
 Pass the options
<List>
<Item>
<Code>verbose := true</Code> to output more information.
</Item>
<Item>
<Code>only_primitive_operations := true</Code>,
    which is passed on to Opposite(),
    to only primitively install
    dual operations for primitively
    installed operations in <Math>cat</Math>.
    The advantage is, that more derivations might be tested.
    On the downside, this might test fewer dual_pre/postprocessor_funcs.
</Item>
</List>
 </Description>
</ManSection>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Basics">
<Heading>Basics</Heading>

<Example><![CDATA[
gap> LoadPackage( "MonoidalCategories" );
true
gap> vecspaces := CreateCapCategory( "VectorSpaces" );
VectorSpaces
gap> ReadPackage( "MonoidalCategories",
>         "examples/VectorSpacesMonoidalCategory.gi" );
true
gap> z := ZeroObject( vecspaces );
<A rational vector space of dimension 0>
gap> a := QVectorSpace( 1 );
<A rational vector space of dimension 1>
gap> b := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> c := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> alpha := VectorSpaceMorphism( a, [ [ 1, 0 ] ], b );
A rational vector space homomorphism with matrix:
[ [  1,  0 ] ]
gap> beta := VectorSpaceMorphism( b,
>                 [ [ 1, 0, 0 ], [ 0, 1, 0 ] ], c );
A rational vector space homomorphism with matrix:
[ [  1,  0,  0 ],
  [  0,  1,  0 ] ]
gap> gamma := VectorSpaceMorphism( c,
>                  [ [ 0, 1, 1 ], [ 1, 0, 1 ], [ 1, 1, 0 ] ], c );
A rational vector space homomorphism with matrix:
[ [  0,  1,  1 ],
  [  1,  0,  1 ],
  [  1,  1,  0 ] ]
gap> IsCongruentForMorphisms(
>         TensorProductOnMorphisms( alpha, beta ),
>         TensorProductOnMorphisms( beta, alpha ) );
false
gap> IsOne( AssociatorRightToLeft( a, b, c ) );
true
gap> IsCongruentForMorphisms(
>         gamma, LambdaElimination( c, c, LambdaIntroduction( gamma ) ) );
true
gap> IsZero( TraceMap( gamma ) );
true
gap> IsCongruentForMorphisms(
>         RankMorphism( DirectSum( a, b ) ), RankMorphism( c ) );
true
gap> IsOne( Braiding( b, c ) );
false
gap> IsOne( PreCompose( Braiding( b, c ), Braiding( c, b ) ) );
true
]]></Example>


</Section>


</Chapter>

