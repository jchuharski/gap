
<!-- %W  ctblcons.xml    GAP 4 package CTblLib              Thomas Breuer -->
<!-- %Y  Copyright 2004, Lehrstuhl D für Mathematik, RWTH Aachen, Germany -->

<Chapter Label="chap:ctblcons">
<Heading>Using Table Automorphisms for Constructing Character Tables in &GAP;</Heading>

Date: June 27th, 2004

<P/>

This chapter has three aims.
First it shows how character table automorphisms can be utilized to
construct certain character tables from others
using the &GAP; system&nbsp;<Cite Key="GAP"/>;
the &GAP; functions used for that are part of the &GAP; Character Table
Library&nbsp;<Cite Key="CTblLib"/>.
Second it documents several constructions of character tables which are
contained in the &GAP; Character Table Library.
Third it serves as a testfile for the involved &GAP; functions.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:overview_ctblcons">
<Heading>Overview</Heading>

Several types of constructions of character tables of finite groups
from known tables of smaller groups are described in
Section&nbsp;<Ref Sect="sect:constr"/>.
Selecting suitable character table automorphisms is an important
ingredient of these constructions.

<P/>

Section&nbsp;<Ref Sect="sect:theory"/> collects the few
representation theoretical facts on which these constructions are based.

<P/>

The remaining sections show examples of the constructions in &GAP;.
These examples use the &GAP; Character Table Library,
therefore we load this package first.

<P/>

<Example><![CDATA[
gap> LoadPackage( "ctbllib", "1.1.4", false );
true
]]></Example>

</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:theory">
<Heading>Theoretical Background</Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Character Table Automorphisms">
<Heading>Character Table Automorphisms</Heading>

Let <M>G</M> be a finite group,
<M>&Irr;(G)</M> be the matrix of ordinary irreducible characters of <M>G</M>,
<M>Cl(G)</M> be the set of conjugacy classes of elements in <M>G</M>,
<M>g^G</M> the <M>G</M>-conjugacy class of <M>g \in G</M>,
and let

<Display Mode="M">
   pow_p \colon Cl(G) \rightarrow Cl(G), 
                     g^G \mapsto (g^p)^G
</Display>

be the <M>p</M>-th power map, for each prime integer <M>p</M>.

<P/>

A <E>table automorphism</E> of <M>G</M> is a permutation
<M>\sigma \colon Cl(G) \rightarrow Cl(G)</M> with the properties that
<M>\chi \circ \sigma \in &Irr;(G)</M> holds for all <M>\chi \in &Irr;(G)</M>
and that <M>\sigma</M> commutes with <M>pow_p</M>,
for all prime integers <M>p</M> that divide the order of <M>G</M>.
Note that for prime integers <M>p</M> that are coprime to the order of <M>G</M>,
<M>pow_p</M> commutes with each <M>\sigma</M> that permutes <M>&Irr;(G)</M>,
since <M>pow_p</M> acts as a field automorphism on the character values.

<P/>

In &GAP;, a character table covers the irreducible characters
&ndash;a matrix <M>M</M> of character values&ndash;
as well as the power maps of the underlying group
&ndash;each power map <M>pow_p</M> being represented as a list
<M>pow_p^{\prime}</M> of positive integers denoting the positions of the image
classes.
The group of table automorphisms of a character table is represented
as a permutation group on the column positions of the table;
it can be computed with the &GAP; function
<Ref Func="AutomorphismsOfTable" BookName="ref"/>.

<P/>

In the following, we will mainly use that each <E>group automorphism</E>
<M>\sigma</M>
of <M>G</M> induces a table automorphism that maps the class of each element
in <M>G</M> to the class of its image under <M>\sigma</M>.

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="sect:Permutation Equivalence of Character Tables">
<Heading>Permutation Equivalence of Character Tables</Heading>

Two character tables with matrices <M>M_1</M>, <M>M_2</M> of irreducibles
and <M>p</M>-th power maps <M>pow_{{1,p}}</M>, <M>pow_{{2,p}}</M> are
<E>permutation equivalent</E>
if permutations <M>\psi</M> and <M>\pi</M> of row and column positions
of the <M>M_i</M> exist such that
<M>[ M_1 ]_{{i,j}} = [ M_2 ]_{{i \psi, j \pi}}</M>
holds for all indices <M>i</M>, <M>j</M>,
and such that
<M>\pi \cdot pow_{{2,p}}^{\prime} = pow_{{1,p}}^{\prime} \cdot \pi</M>
holds for all primes <M>p</M> that divide the (common) group order.
The first condition is equivalent to the existence of a permutation <M>\pi</M>
such that permuting the columns of <M>M_1</M> with <M>\pi</M> maps
the set of rows of <M>M_1</M> to the set of rows of <M>M_2</M>.

<P/>

<M>\pi</M> is of course determined only up to table automorphisms of the two
character tables, that is,
two transforming permutations <M>\pi_1</M>, <M>\pi_2</M>
satisfy that <M>\pi_1 \cdot \pi_2^{-1}</M> is a table automorphism of the first
table, and <M>\pi_1^{-1} \cdot \pi_2</M> is a table automorphism of the second.

<P/>

Clearly two isomorphic groups have permutation equivalent character tables.

<P/>

<!-- %T Interpret table automorphisms and transforming permutations in the -->
<!-- %T language of permutation group algorithms. -->
<!-- %T The table automorphisms are the stabilizer of the set of rows in the -->
<!-- %T symmetric group acting on the columns, -->
<!-- %T and the transforming permutations form a coset in this group, -->
<!-- %T or the empty set. -->
<!-- %T (Cite Butler's book?) -->

The &GAP; library function
<Ref Func="TransformingPermutationsCharacterTables" BookName="ref"/>
returns a record that contains transforming permutations of rows and columns
if the two argument tables are permutation equivalent,
and <K>fail</K> otherwise.

<P/>

In the example sections, the following function for computing representatives
from a list of character tables w.r.t.&nbsp;permutation equivalence
will be used.
More precisely, the input is either a list of character tables
or a list of records which have a component <C>table</C> whose value
is a character table, and the output is a sublist of the input.

<P/>

<Ignore Remark="gapfilecomments">
#############################################################################
##
#W  ctblcons.g      examples of character table constructions   Thomas Breuer
##
#Y  Copyright (C)  2006,  Lehrstuhl D fuer Mathematik,  RWTH Aachen,  Germany
##
</Ignore>
<Example><![CDATA[
gap> RepresentativesCharacterTables:= function( list )
>    local reps, entry, r;
> 
>    reps:= [];
>    for entry in list do
>      if ForAll( reps, r -> ( IsCharacterTable( r ) and
>             TransformingPermutationsCharacterTables( entry, r ) = fail )
>           or ( IsRecord( r ) and TransformingPermutationsCharacterTables(
>                                    entry.table, r.table ) = fail ) ) then
>        Add( reps, entry );
>      fi;
>    od;
>    return reps;
>    end;;
]]></Example>

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:class_fusions">
<Heading>Class Fusions</Heading>

For two groups <M>H</M>, <M>G</M> such that <M>H</M> is isomorphic with
a subgroup of <M>G</M>,
any embedding <M>\iota \colon H \rightarrow G</M> induces a class function

<Display Mode="M">
   fus_{\iota} \colon Cl(H) \rightarrow Cl(G), 
                     h^G   \mapsto    (\iota(h))^G
</Display>

the <E>class fusion</E> of <M>H</M> in <M>G</M> via <M>\iota</M>.
Analogously, for a normal subgroup <M>N</M> of <M>G</M>,
any epimorphism <M>\pi \colon G \rightarrow G/N</M> induces a class function

<Display Mode="M">
   fus_{\pi} \colon Cl(G) \rightarrow Cl(G/N),
                     g^G   \mapsto     (\pi(g))^G
</Display>

the <E>class fusion</E> of <M>G</M> onto <M>G/N</M> via <M>\pi</M>.

<P/>

When one works only with character tables and not with groups,
these class fusions are the objects that describe subgroup and factor group
relations between character tables.
Technically, class fusions are necessary for restricting, inducing, and
inflating characters from one character table to another.
If one is faced with the problem to compute the class fusion between the
character tables of two groups <M>H</M> and <M>G</M> for which it is known
that <M>H</M> can be embedded into <M>G</M>
then one can use character-theoretic necessary conditions,
concerning that the restriction of all irreducible characters of <M>G</M> to
<M>H</M> (via the class fusion) must decompose into the irreducible
characters of <M>H</M>,
and that the class fusion must commute with the power maps of <M>H</M> and
<M>G</M>.

<P/>

With this character-theoretic approach, one can clearly determine
possible class fusions only up to character table automorphisms.
Note that one can interpret each character table automorphism of <M>G</M>
as a class fusion from the table of <M>G</M> to itself.

<P/>

If <M>N</M> is a normal subgroup in <M>G</M> then the class fusion of
<M>N</M> in <M>G</M> determines the orbits of the conjugation action of
<M>G</M> on the classes of <M>N</M>.
Often the knowledge of these orbits suffices to identify the subgroup of
table automorphisms of <M>N</M> that corresponds to this action of <M>G</M>;
for example, this is always the case if <M>N</M> has index <M>2</M> in
<M>G</M>.

<P/>

&GAP; library functions for dealing with class fusions, power maps,
and character table automorphisms are described in the chapter
<Q>Maps Concerning Character Tables</Q> in the &GAP; Reference Manual.

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:isoclinism">
<Heading>Constructing Character Tables of Certain Isoclinic Groups</Heading>

As is stated in&nbsp;<Cite Key="CCN85" Where="p.&nbsp;xxiii"/>,
two groups <M>G</M>, <M>H</M> are called <E>isoclinic</E> if they can be
embedded into a group <M>K</M> such that <M>K</M> is generated by <M>Z(K)</M>
and <M>G</M>, and also by <M>Z(K)</M> and <M>H</M>.
In the following, two special cases of isoclinism will be used,
where the character tables of the isoclinic groups are closely related.

<P/>

<List>
<Mark>(1)</Mark>
<Item>
    <M>G \cong 2 \times U</M> for a group <M>U</M> that has a central
    subgroup <M>N</M> of order <M>2</M>,
    and <M>H</M> is the central product of <M>U</M> and a cyclic group
    of order four.
    Here we can set <M>K = 2 \times H</M>.
</Item>
<Mark>(2)</Mark>
<Item>
    <M>G \cong 2 \times U</M> for a group <M>U</M> that has a normal
    subgroup <M>N</M> of index <M>2</M>,
    and <M>H</M> is the subdirect product of <M>U</M> and a cyclic
    group of order four,
    Here we can set <M>K = 4 \times U</M>.
</Item>
</List>

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons01.png" alt="two constructions of K"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
           .───────────── K                     K
          ╱│╲            ╱│╲                   ╱│╲
         ╱ │ ╲          ╱ │ ╲                 ╱ │ ╲
        ╱  │  .────────╱──│─ H               .  H  G
       ╱ ⟨z⟩─╱────────╱──.  ╱               ╱ ╲ │ ╱│╲
      .──│──╱─────── G  │  ╱               ╱   ╲│╱ │ ╲
     ╱│╲ │ ╱          ╲ │ ╱               ╱     S  .  U
    ╱ │ ╲│╱            ╲│╱               ╱     ╱ ╲ │ ╱
   ╱  │  N ──────────── U = S          ⟨z⟩    ╱   ╲│╱
  ╱  .  ╱                                ╲   ╱     N
 .  │  ╱                                  ╲ ╱     ╱
  ╲ │ ╱                                    .     ╱
   ╲│╱                                      ╲   ╱
    1                                        ╲ ╱
                                              1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons01 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(110,55)
\put(0,0){\begin{picture}(40,55)
\put(15, 5){\circle*{1}}
\put( 5,15){\circle*{1}}
\put(10,15){\circle*{1}}
\put(15,15){\circle*{1}} \put(18,15){\makebox(0,0){$N$}}
\put( 5,25){\circle*{1}}
\put(10,25){\circle*{1}} \put( 8,25){\makebox(0,0){$\langle z \rangle$}}
\put(15,25){\circle*{1}}
\put( 5,35){\circle*{1}}
\put(30,30){\circle*{1}} \put(36,30){\makebox(0,0){$U = S$}}

\put(20,40){\circle*{1}} \put(17,40){\makebox(0,0){$G$}}
\put(25,40){\circle*{1}}
\put(30,40){\circle*{1}} \put(33,40){\makebox(0,0){$H$}}
\put(20,50){\circle*{1}} \put(20,53){\makebox(0,0){$K$}}

\put( 5,15){\line(0,1){20}}
\put(15, 5){\line(-1,2){10}}
\put(15, 5){\line(-1,1){10}}
\put(15, 5){\line(0,1){20}}
\put(15,15){\line(-1,2){10}}
\put(15,15){\line(-1,1){10}}
\put(15,25){\line(-1,1){10}}

\put(15,15){\line(1,1){15}}
\put( 5,25){\line(1,1){15}}
\put(10,25){\line(1,1){15}}
\put(15,25){\line(1,1){15}}
\put( 5,35){\line(1,1){15}}

\put(20,40){\line(0,1){10}}
\put(30,30){\line(-1,2){10}}
\put(30,30){\line(-1,1){10}}
\put(30,30){\line(0,1){10}}
\put(30,40){\line(-1,1){10}}
\end{picture}}
\put(50,0){\begin{picture}(60,55)
\put(25, 5){\circle*{1}}
\put(17,13){\circle*{1}}
\put( 9,21){\circle*{1}} \put(6,21){\makebox(0,0){$\langle z \rangle$}}

\put(46,26){\circle*{1}} \put(49,26){\makebox(0,0){$N$}}
\put(54,34){\circle*{1}} \put(57,34){\makebox(0,0){$U$}}
\put(38,34){\circle*{1}} \put(35,34){\makebox(0,0){$S$}}
\put(30,42){\circle*{1}}
\put(38,42){\circle*{1}} \put(35,42){\makebox(0,0){$H$}}
\put(46,42){\circle*{1}} \put(49,42){\makebox(0,0){$G$}}
\put(38,50){\circle*{1}} \put(38,53){\makebox(0,0){$K$}}
\put(46,34){\circle*{1}}

\put(25, 5){\line(-1,1){16}}
\put(46,26){\line(-1,1){16}}
\put(54,34){\line(-1,1){16}}

\put(46,26){\line(0,1){16}}
\put(38,34){\line(0,1){16}}

\put(25, 5){\line(1,1){29}}
\put(17,13){\line(1,1){29}}
\put( 9,21){\line(1,1){29}}
\end{picture}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

Starting from the group <M>K</M> containing both <M>G</M> and <M>H</M>,
we first note that each irreducible representation of <M>G</M> or <M>H</M>
extends to <M>K</M>.
More specifically,
if <M>\rho_G</M> is an irreducible representation of <M>G</M> then
we can define an extension <M>\rho</M> of <M>K</M> by defining it suitably
on <M>Z(K)</M>
and then form <M>\rho_H</M>, the restriction of <M>\rho</M> to <M>H</M>.

<P/>

In our two cases, we set <M>S = G \cap H</M>,
so <M>K = S \cup G \setminus S \cup H \setminus S \cup z S</M> holds for some
element <M>z \in Z(K) \setminus ( G \cup H )</M> of order four,
and <M>G = S \cup g S</M> for some <M>g \in G \setminus S</M>,
and <M>H = S \cup h S</M> where <M>h = z \cdot g \in H \setminus S</M>.
For defining <M>\rho_H</M>,
it suffices to consider <M>\rho(h) = \rho(z) \rho(g)</M>,
where <M>\rho(z) = \epsilon_{\rho}(z) \cdot I</M> is a scalar matrix.

<P/>

As for the character table heads of <M>G</M> and <M>H</M>,
we have <M>s^G = s^H</M> and <M>z (g \cdot s)^G = (h \cdot s)^H</M> for each
<M>s \in S</M>,
so this defines a bijection of the conjugacy classes of <M>G</M> and <M>H</M>.
For a prime integer <M>p</M>,
<M>(h \cdot s)^p = (z \cdot g \cdot s)^p = z^p \cdot (g \cdot s)^p</M> holds
for all <M>s \in S</M>,
so the <M>p</M>-th power maps of <M>G</M> and <M>H</M> are related as follows:
Inside <M>S</M> they coincide for any <M>p</M>.
If <M>p \equiv 1 \bmod 4</M> they coincide also outside <M>S</M>,
if <M>p \equiv -1 \bmod 4</M> the images differ by exchanging the classes
of <M>(h \cdot s)^p</M> and <M>z^2 \cdot (h \cdot s)^p</M> (if these elements
lie in different classes),
and for <M>p = 2</M> the images (which lie inside <M>S</M>) differ by
exchanging the classes of <M>(h \cdot s)^2</M> and
<M>z^2 \cdot (g \cdot s)^2</M>
(if these elements lie in different classes).

<P/>

Let <M>\rho</M> be an irreducible representation of <M>K</M>.
Then <M>\rho_G</M> and <M>\rho_H</M> are related as follows:
<M>\rho_G(s) = \rho_H(s)</M>
and <M>\rho(z) \cdot \rho_G(g \cdot s) = \rho_H(h \cdot s)</M>
for all <M>s \in S</M>.
If <M>\chi_G</M> and <M>\chi_H</M> are the characters afforded by
<M>\rho_G</M> and <M>\rho_H</M>, respectively,
then <M>\chi_G(s) = \chi_H(s)</M> and
<M>\epsilon_{\rho}(z) \cdot \chi_G(g \cdot s) = \chi_H(h \cdot s)</M> hold
for all <M>s \in S</M>.
In the case <M>\chi_G(z^2) = \chi(1)</M> we have
<M>\epsilon_{\rho}(z) = \pm 1</M>,
and both cases actually occur if one considers all irreducible
representations of <M>K</M>.
In the case <M>\chi_G(z^2) = - \chi(1)</M> we have
<M>\epsilon_{\rho}(z) = \pm i</M>,
and again both cases occur.
So we obtain the irreducible characters of <M>H</M> from those of <M>G</M> by
multiplying the values outside <M>S</M> in all those characters by <M>i</M>
that do not have <M>z^2</M> in their kernels.

<P/>

In &GAP;, the function
<Ref Func="CharacterTableIsoclinic" BookName="ref"/>
can be used for computing the character table of <M>H</M> from that of
<M>G</M>, and vice versa.
(Note that in the above two cases, also the groups <M>U</M> and <M>H</M> are
isoclinic by definition, but
<Ref Func="CharacterTableIsoclinic" BookName="ref"/>
does not transfer the character table of <M>U</M> to that of <M>H</M>.)

<P/>

One could construct the character tables mentioned above by forming the
character tables of certain factor groups or normal subgroups of direct
products.
However,
the construction via <Ref Func="CharacterTableIsoclinic" BookName="ref"/>
has the advantage that the result stores from which sources it arose,
and this information can be used to derive also the Brauer character tables,
provided that the Brauer character tables of the source tables are known.

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:isoclinicP">
<Heading>Character Tables of Isoclinic Groups of the Structure <M>p.G.p</M>
(October 2016)</Heading>

Since the release of &GAP; 4.11,
<Ref Func="CharacterTableIsoclinic" BookName="ref"/>
admits the construction of the character tables of the
isoclinic variants of groups of the structure <M>p.G.p</M>,
also for odd primes <M>p</M>.

<P/>

This feature will be used in the construction of the character table of
<M>9.U_3(8).3_3</M>,
in order to construct the table of the subgroup <M>3.(3 \times U_3(8))</M>
and of the factor group <M>(3 \times U_3(8)).3_3</M>,
see Section&nbsp;<Ref Subsect="subsect:9.U_3(8).3_3"/>.
These constructions are a straightforward generalization of those described
in detail in Section&nbsp;<Ref Subsect="subsect:isoclinism"/>.

<P/>

There are several examples of &ATLAS; groups of the structure <M>3.G.3</M>.
The character table of one such group is shown in the &ATLAS;,
the tables of their isoclinic variants can now be obtained from
<Ref Func="CharacterTableIsoclinic" BookName="ref"/>.

<P/>

For example, the group GL<M>(3,4)</M> has the structure <M>3.L_3(4).3</M>.
There are three pairwise nonisomorphic isoclinic variants
of groups of this structure.

<Example><![CDATA[
gap> t:= CharacterTable( "3.L3(4).3" );
CharacterTable( "3.L3(4).3" )
gap> iso1:= CharacterTableIsoclinic( t );
CharacterTable( "Isoclinic(3.L3(4).3,1)" )
gap> iso2:= CharacterTableIsoclinic( t, rec( k:= 2 ) );
CharacterTable( "Isoclinic(3.L3(4).3,2)" )
gap> TransformingPermutationsCharacterTables( t, iso1 );
fail
gap> TransformingPermutationsCharacterTables( t, iso2 );
fail
gap> TransformingPermutationsCharacterTables( iso1, iso2 );
fail
]]></Example>

<P/>

The character table of GL<M>(3,4)</M> is in fact the one which is shown
in the &ATLAS;.

<P/>

<Example><![CDATA[
gap> IsRecord( TransformingPermutationsCharacterTables( t,
>                  CharacterTable( GL( 3, 4 ) ) ) );
true
]]></Example>

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:isoclinicATLAS">
<Heading>Isoclinic Double Covers of Almost Simple Groups</Heading>

The function
<Ref Func="CharacterTableIsoclinic" BookName="ref"/>
can also be used to switch between the character tables of double covers
of groups of the type <M>G.2</M>, where <M>G</M> is a perfect group,
see&nbsp;<Cite Key="CCN85" Where="Section 6.7"/>.
Typical examples are the double covers of symmetric groups.

<P/>

Note that these double covers may be isomorphic.
This happens for <M>2.S_6</M>.
More generally, this happens for all semilinear groups
<M>\Sigma</M>L<M>(2,p^2)</M>, for odd primes <M>p</M>.
The smallest examples are <M>\Sigma</M>L<M>(2,9) = 2.A_6.2_1</M> and
<M>\Sigma</M>L<M>(2,25) = 2.L_2(25).2_2</M>.
This implies that the character table and its isoclinic variant are
permutation isomorphic.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "2.A6.2_1" );
CharacterTable( "2.A6.2_1" )
gap> TransformingPermutationsCharacterTables( t,
>        CharacterTableIsoclinic( t ) );
rec( columns := (4,6)(5,7)(11,12)(14,16)(15,17), 
  group := Group([ (16,17), (14,15) ]), 
  rows := (3,5)(4,6)(10,11)(12,15,13,14) )
gap> t:= CharacterTable( "2.L2(25).2_2" );
CharacterTable( "2.L2(25).2_2" )
gap> TransformingPermutationsCharacterTables( t,
>        CharacterTableIsoclinic( t ) );
rec( columns := (7,9)(8,10)(20,21)(23,24)(25,27)(26,28), 
  group := <permutation group with 4 generators>, 
  rows := (3,5)(4,6)(14,15)(16,17)(19,22,20,21) )
]]></Example>

<P/>

For groups of the type <M>4.G.2</M>, two different situations can occur.
Either the distinguished central cyclic subgroup of order four in <M>4.G</M>
is inverted by the elements in <M>4.G.2 \setminus 4.G</M>,
or this subgroup is central in <M>4.G.2</M>.
In the first case, calling
<Ref Func="CharacterTableIsoclinic" BookName="ref"/>
with the character table of <M>4.G.2</M> yields a character table with the
same set of irreducibles,
only the <M>2</M>-power map will in general differ from that of the input
table.
In the second case, the one argument version of
<Ref Func="CharacterTableIsoclinic" BookName="ref"/>
returns a permutation isomorphic table.
By supplying additional arguments, there is a chance to construct tables of
different groups.

<P/>

We demonstrate this phenomenon with the various groups of the structure
<M>4.L_3(4).2</M>.

<P/>

<Example><![CDATA[
gap> tbls:= [];;
gap> for m in [ "4_1", "4_2" ] do
>      for a in [ "2_1", "2_2", "2_3" ] do
>        Add( tbls, CharacterTable( Concatenation( m, ".L3(4).", a ) ) );
>      od;
>    od;
gap> tbls;
[ CharacterTable( "4_1.L3(4).2_1" ), CharacterTable( "4_1.L3(4).2_2" )
    , CharacterTable( "4_1.L3(4).2_3" ), 
  CharacterTable( "4_2.L3(4).2_1" ), CharacterTable( "4_2.L3(4).2_2" )
    , CharacterTable( "4_2.L3(4).2_3" ) ]
gap> case1:= Filtered( tbls, t -> Size( ClassPositionsOfCentre( t ) ) = 2 );
[ CharacterTable( "4_1.L3(4).2_1" ), CharacterTable( "4_1.L3(4).2_2" )
    , CharacterTable( "4_2.L3(4).2_1" ), 
  CharacterTable( "4_2.L3(4).2_3" ) ]
gap> case2:= Filtered( tbls, t -> Size( ClassPositionsOfCentre( t ) ) = 4 );
[ CharacterTable( "4_1.L3(4).2_3" ), 
  CharacterTable( "4_2.L3(4).2_2" ) ]
]]></Example>

<P/>

The centres of the groups <M>4_1.L_3(4).2_1</M>, <M>4_1.L_3(4).2_2</M>,
<M>4_2.L_3(4).2_1</M>, and <M>4_2.L_3(4).2_3</M> have order two,
that is, these groups belong to the first case.
Each of these groups is not permutation equivalent to its isoclinic
variant but has the same irreducible characters.

<P/>

<Example><![CDATA[
gap> isos1:= List( case1, CharacterTableIsoclinic );;
gap> List( [ 1 .. 4 ], i -> Irr( case1[i] ) = Irr( isos1[i] ) );
[ true, true, true, true ]
gap> List( [ 1 .. 4 ],
>      i -> TransformingPermutationsCharacterTables( case1[i], isos1[i] ) );
[ fail, fail, fail, fail ]
]]></Example>

<P/>

The groups <M>4_1.L_3(4).2_3</M> and <M>4_2.L_3(4).2_2</M> belong to the
second case because their centres have order four.

<P/>

<Example><![CDATA[
gap> isos2:= List( case2, CharacterTableIsoclinic );;
gap> List( [ 1, 2 ],
>      i -> TransformingPermutationsCharacterTables( case2[i], isos2[i] ) );
[ rec( columns := (26,27,28,29)(30,31,32,33)(38,39,40,41)(42,43,44,45)
        , group := <permutation group with 5 generators>, 
      rows := (16,17)(18,19)(20,21)(22,23)(28,29)(32,33)(36,37)(40,
        41) ), 
  rec( columns := (28,29,30,31)(32,33)(34,35,36,37)(38,39,40,41)(42,
        43,44,45)(46,47,48,49), 
      group := <permutation group with 3 generators>, 
      rows := (15,16)(17,18)(20,21)(22,23)(24,25)(26,27)(28,29)(34,
        35)(38,39)(42,43)(46,47) ) ]
gap> isos3:= List( case2, t -> CharacterTableIsoclinic( t,
>                                ClassPositionsOfCentre( t ) ) );;
gap> List( [ 1, 2 ],
>      i -> TransformingPermutationsCharacterTables( case2[i], isos3[i] ) );
[ fail, fail ]
]]></Example>

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:theorClifford">
<Heading>Characters of Normal Subgroups</Heading>

Let <M>G</M> be a group and <M>N</M> be a normal subgroup of <M>G</M>.
We will need the following well-known facts about the relation
between the irreducible characters of <M>G</M> and <M>N</M>.

<P/>

For an irreducible (Brauer) character <M>\chi</M> of <M>N</M> and
<M>g \in G</M>,
we define <M>\chi^g</M> by <M>\chi^g(n) = \chi(n^g)</M> for all
<M>n \in N</M>,
and set <M>I_G(\chi) = \{ g \in G; \chi^g = \chi \}</M>
(see&nbsp;<Cite Key="Feit82" Where="p. 86"/>).

<P/>

If <M>I_G(\chi) = N</M> then the induced character <M>\chi^G</M> is an
irreducible (Brauer) character of <M>G</M>
(see&nbsp;<Cite Key="Feit82" Where="Lemma III 2.11"/>
or <Cite Key="Nav98" Where="Theorem 8.9"/>
or <Cite Key="LP10" Where="Corollary 4.3.8"/>).

<P/>

If <M>G/N</M> is cyclic and if <M>I_G(\chi) = G</M> then <M>\chi = \psi_N</M>
for an irreducible (Brauer) character <M>\psi</M> of <M>G</M>,
and each irreducible (Brauer) character <M>\theta</M> with the property
<M>\chi = \theta_N</M> is of the form <M>\theta = \psi \cdot \epsilon</M>,
where <M>\epsilon</M> is an irreducible (Brauer) character of <M>G/N</M>
(see&nbsp;<Cite Key="Feit82" Where="Theorem III 2.14"/>
or <Cite Key="Nav98" Where="Theorem 8.12"/>
or <Cite Key="LP10" Where="Theorem 3.6.13"/>).

<P/>

Clifford's theorem
(<Cite Key="Feit82" Where="Theorem III 2.12"/> or
<Cite Key="Nav98" Where="Corollary 8.7"/> or
<Cite Key="LP10" Where="Theorem 3.6.2"/>) states
that the restriction of an irreducible (Brauer) character of <M>G</M> to
<M>N</M> has the form <M>e \sum_{i=1}^t \varphi_i</M> for a positive integer
<M>e</M> and irreducible (Brauer) characters <M>\varphi_i</M> of <M>N</M>,
where <M>t</M> is the index of <M>I_G(\varphi_1)</M> in <M>G</M>.

<P/>

Now assume that <M>G</M> is a normal subgroup in a larger group <M>H</M>,
that <M>G/N</M> is an abelian chief factor of <M>H</M> and that <M>\psi</M>
is an ordinary irreducible character of <M>G</M> such that
<M>I_H(\psi) = H</M>.
Then either <M>t = 1</M> and <M>e^2</M> is one of <M>1</M>, <M>|G/N|</M>,
or <M>t = |G/N|</M> and <M>e = 1</M>
(see&nbsp;<Cite Key="Isa76" Where="Theorem 6.18"/>).

</Subsection>
</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:constr">
<Heading>The Constructions</Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:theorMGA">
<Heading>Character Tables of Groups of the Structure <M>M.G.A</M></Heading>

(This kind of table construction is described in <Cite Key="Bre11"/>.)

<P/>

Let <M>N</M> denote a downward extension of the finite group <M>G</M>
by a finite group <M>M</M>,
let <M>H</M> denote an automorphic (upward) extension of <M>N</M> by
a finite cyclic group <M>A</M> such that <M>M</M> is normal in <M>H</M>,
and set <M>F = H / M</M>.
We consider the situation that each irreducible character of <M>N</M>
that does not contain <M>M</M> in its kernel induces irreducibly to <M>H</M>.
Equivalently, the action of <M>A = \langle a \rangle</M> on the characters of
<M>N</M>,
via <M>\chi \mapsto \chi^a</M>, has only orbits of length exactly <M>|A|</M>
on the set <M>\{ \chi \in &Irr;(N); M \nsubseteq \ker(\chi) \}</M>.

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons02.png" alt="groups of the structure M.G.A"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
                  H
                  │
                  │ A           G  ───▶  F
                  │
                  N             ▲        ▲
                  │             │        │
                  │ G           │        │
                  │
                  M             N  ───▶  H
                  │
                  1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons02 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(55,40)
\put(0,0){\begin{picture}(20,40)
\put(10, 5){\circle*{1}}
\put(10,10){\circle*{1}} \put(7,10){\makebox(0,0){$M$}}
                         \put(13,17.5){\makebox(0,0){$G$}}
\put(10,25){\circle*{1}} \put(7,25){\makebox(0,0){$N$}}
                         \put(13,27.5){\makebox(0,0){$A$}}
\put(10,30){\circle*{1}} \put(10,33){\makebox(0,0){$H$}}
\put(10, 5){\line(0,1){25}}
\end{picture}}
\put(30,7){\begin{picture}(25,25)
\put( 5, 5){\makebox(0,0){$N$}}
\put( 5,20){\makebox(0,0){$G$}}
\put(20, 5){\makebox(0,0){$H$}}
\put(20,20){\makebox(0,0){$F$}}
\put( 7, 5){\vector(1,0){11}}
\put( 5, 7){\vector(0,1){11}}
\put( 7,20){\vector(1,0){11}}
\put(20, 7){\vector(0,1){11}}
\end{picture}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

This occurs for example if <M>M</M> is central in <M>N</M> and <M>A</M> acts
fixed-point freely on <M>M</M>,
we have <M>|M| \equiv 1 \bmod |A|</M> in this case.
If <M>M</M> has prime order then it is sufficient that <M>A</M> does not
centralize <M>M</M>.

<P/>

The ordinary (or <M>p</M>-modular) irreducible characters of <M>H</M> are
then given by the ordinary (or <M>p</M>-modular) irreducible characters of
<M>F</M> and <M>N</M>,
the class fusions from the table of <M>N</M> onto the table of <M>G</M>
and from the table of <M>G</M> into that of <M>F</M>,
and the permutation <M>\pi</M> that is induced by the action of <M>A</M> on
the conjugacy classes of <M>N</M>.

<P/>

In general, the action of <M>A</M> on the classes of <M>M</M> is not the
right thing to look at, one really must consider the action on the relevant
characters of <M>M.G</M>.
For example, take <M>H</M> the quaternion group or the dihedral group of
order eight, <M>N</M> a cyclic subgroup of index two,
and <M>M</M> the centre of <M>H</M>;
here <M>A</M> acts trivially on <M>M</M>, but the relevant fact is that the
action of <M>A</M> swaps those two irreducible characters of <M>N</M> that
take the value <M>-1</M> on the involution in <M>M</M>
&ndash;these are the faithful irreducible characters of <M>N</M>.

<P/>

If the orders of <M>M</M> and <M>A</M> are coprime then also the power maps
of <M>H</M> can be computed from the above data.
For each prime <M>p</M> that divides the orders of both <M>M</M> and
<M>A</M>,
the <M>p</M>-th power map is in general not uniquely determined by these
input data.
In this case, we can compute the (finitely many) candidates for the
character table of <M>H</M> that are described by these data.
One possible reason for ambiguities is the existence of several isoclinic
but nonisomorphic groups that can arise from the input tables
(cf. Section&nbsp;<Ref Subsect="subsect:isoclinism"/>,
see Section&nbsp;<Ref Subsect="subsect:HN2"/> for an example).

<P/>

With the &GAP; function
<Ref Func="PossibleActionsForTypeMGA" BookName="ctbllib"/>,
one can compute the possible orbit structures induced by <M>G.A</M> on the
classes of <M>M.G</M>, and
<Ref Func="PossibleCharacterTablesOfTypeMGA" BookName="ctbllib"/>
computes the possible ordinary character tables for a given orbit structure.
For constructing the <M>p</M>-modular Brauer table of a group <M>H</M> of
the structure <M>M.G.A</M>,
the &GAP; function
<Ref Func="BrauerTableOfTypeMGA" BookName="ctbllib"/>
takes the ordinary
character table of <M>H</M> and the <M>p</M>-modular tables of the subgroup
<M>M.G</M> and the factor group <M>G.A</M> as its input.
The <M>p</M>-modular table of <M>G</M> is not explicitly needed in the
construction,
it is implicitly given by the class fusions from <M>M.G</M> into <M>M.G.A</M>
and from <M>M.G.A</M> onto <M>G.A</M>;
these class fusions must of course be available.

<P/>

The &GAP; Character Table Library contains many tables of groups of the
structure <M>M.G.A</M> as described above, which are encoded by references to
the tables of the groups <M>M.G</M> and <M>G.A</M>, plus the fusion and
action information.
This reduces the space needed for storing these character tables.

<P/>

For examples, see Section&nbsp;<Ref Sect="sect:explMGA"/>.

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="sect:Character Tables of Groups of the Structure G.S_3">
<Heading>Character Tables of Groups of the Structure <M>G.S_3</M></Heading>

Let <M>G</M> be a finite group, and <M>H</M> be an upward extension of
<M>G</M> such that the factor group <M>H / G</M> is a Frobenius group
<M>F = K C</M> with abelian kernel <M>K</M> and cyclic complement <M>C</M> of
prime order <M>c</M>.
(Typical cases for <M>F</M> are the symmetric group <M>S_3</M> on three
points and the alternating group <M>A_4</M> on four points.)
Let <M>N</M> and <M>U</M> denote the preimages of <M>K</M> and <M>C</M> under
the natural epimorphism from <M>H</M> onto <M>F</M>.

<P/>

<!-- what we need:
     <M>K</M> is normal in <M>F</M>, <M>C</M> is cyclic and acts
     semiregularly on <M>K</M> and ... -->

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons03.png" alt="Groups of the structure G.3.2"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
           H
          ╱ ╲
         ╱   ╲                       N  ───▶  H
        N     ╲
         ╲     U                     ▲        ▲
          ╲   ╱                      │        │
           ╲ ╱                       │        │
            G
            │                        G  ───▶  U
            │
            1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons03 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(70,40)
\put(0,0){\begin{picture}(25,40)
\put(15, 5){\circle*{1}}
\put(15,15){\circle*{1}} \put(12,15){\makebox(0,0){$G$}}
\put( 5,25){\circle*{1}} \put(2,25){\makebox(0,0){$N$}}
\put(20,20){\circle{1}} \put(23,20){\makebox(0,0){$U$}}
\put(10,30){\circle*{1}} \put(10,33){\makebox(0,0){$H$}}
\put(15, 5){\line(0,1){10}}
\put(15,15){\line(-1,1){10}}
\put(20,20){\line(-1,1){10}}
\put(15,15){\line(1,1){5}}
\put( 5,25){\line(1,1){5}}
\end{picture}}
\put(35,2){\begin{picture}(35,35)
\put( 5,15){\makebox(0,0){$G$}}
\put(15, 5){\makebox(0,0){$U$}}
\put(20,30){\makebox(0,0){$N$}}
\put(30,20){\makebox(0,0){$H$}}
\put( 7,17){\vector(1,1){11}}
\put( 7,13){\vector(1,-1){6}}
\put(17, 7){\vector(1,1){11}}
\put(22,28){\vector(1,-1){6}}
\end{picture}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

For certain isomorphism types of <M>F</M>,
the ordinary (or <M>p</M>-modular) character table of <M>H</M> can be
computed from the ordinary (or <M>p</M>-modular) character tables of
<M>G</M>, <M>U</M>, and <M>N</M>,
the class fusions from the table of <M>G</M> into those of <M>U</M> and
<M>N</M>,
and the permutation <M>\pi</M> induced by <M>H</M> on the conjugacy classes
of <M>N</M>.
This holds for example for <M>F = S_3</M> and in the ordinary case also
for <M>F = A_4</M>.

<P/>

Each class of <M>H</M> is either a union of <M>\pi</M>-orbits or an
<M>H</M>-class of <M>U \setminus G</M>;
the latter classes are in bijection with the <M>U</M>-classes of
<M>U \setminus G</M>, they are just <M>|K|</M> times larger
since the <M>|K|</M> conjugates of <M>U</M> in <M>H</M> are fused.
The power maps of <M>H</M> are uniquely determined from the power maps of
<M>U</M> and <M>N</M>,
because each element in <M>F</M> lies in <M>K</M> or in an <M>F</M>-conjugate
of <M>C</M>.

<P/>

Concerning the computation of the ordinary irreducible characters of
<M>H</M>,
we could induce the irreducible characters of <M>U</M> and <M>N</M> to
<M>H</M>,
and then take the union of the irreducible characters among those
and the irreducible differences of those.
(For the case <M>F = S_3</M>, this approach has been described in the
Appendix of&nbsp;<Cite Key="HL94"/>.)

<P/>

The &GAP; function
<Ref Func="CharacterTableOfTypeGS3" BookName="ctbllib"/>
proceeds in a different way,
which is suitable also for the construction of <M>p</M>-modular character
tables of <M>H</M>.

<P/>

By the facts listed in Section&nbsp;<Ref Subsect="subsect:theorClifford"/>,
for an irreducible (Brauer) character <M>\chi</M> of <M>N</M>,
we have <M>I_H(\chi)</M> equal to either <M>N</M> or <M>H</M>.
In the former case, <M>\chi</M> induces irreducibly to <M>H</M>.
In the latter case, there are extensions <M>\psi^{(i)}</M>,
<M>1 \leq i \leq |C|</M> (or <M>|C|_{p^\prime}</M>), to <M>H</M>,
and we have the following possibilities,
depending on the restriction <M>\chi_G</M>.

<P/>

If <M>\chi_G = e \varphi</M>, for an irreducible character <M>\varphi</M> of
<M>G</M>, then <M>I_U(\varphi) = U</M> holds,
hence the <M>\psi^{(i)}_U</M> are <M>|C|</M> (or <M>|C|_{p^\prime}</M>)
extensions of <M>\chi_G</M> to <M>U</M>.
Moreover, we have either <M>e = 1</M> or <M>e^2 = |K|</M>.
In the case <M>e = 1</M>, this determines the values of the <M>\psi^{(i)}</M>
on the classes of <M>U</M> outside <M>G</M>.
In the case <M>e &noteq; 1</M>,
we have the problem to combine <M>e</M> extensions
of <M>\varphi</M> to a character of <M>U</M> that extends to <M>H</M>.

<P/>

(One additional piece of information in the case of ordinary character tables
is that the norm of this linear combination equals <M>1 + (|K|-1)/|C|</M>,
<!-- This follows from the decomposition
     <M>H = N \cup \bigcup_{n \in N/G} ( U^n \setminus G )</M>
     which implies
     \[
        \sum_{h \in H} |\psi(h)|^2 = \sum_{h \in N} |\psi(h)|^2
        + |N/G| ( \sum_{h \in U} |\psi(h)|^2 - \sum_{h \in G} |\psi(h)|^2 )
     \]
     and thus
     \[
        |H| = |N| + |N/G| ( |U| (\psi_U, \psi_U) - |G| e^2 ) .
     \] -->
which determines the <M>\psi^{(i)}_U</M> if <M>F = A_4 \cong 2^2:3</M> or
<M>F = 2^3:7</M> holds;
in the former case, the sum of each two out of the three different extensions
of <M>\varphi</M> extends to <M>U</M>;
in the latter case, the sum of all different extensions plus one of the
extensions extends.
Note that for <M>F = S_3</M>, the case <M>e &noteq; 1</M> does not occur.)

<P/>

The remaining case is that <M>\chi_G</M> is not a multiple of an irreducible
character of <M>G</M>.
Then <M>\chi_G = \varphi_1 + \varphi_2 + \ldots + \varphi_{|K|}</M>,
for pairwise different irreducible characters <M>\varphi_i</M>,
<M>1 \leq i \leq |K|</M>,
of <M>G</M> with the property <M>\varphi_i^N = \chi</M>.
The action of <M>U</M> on <M>G</M> fixes at least one of the
<M>\varphi_i</M>,
since <M>|K| \equiv 1 \bmod |C|</M>.
Without loss of generality, let <M>I_U(\varphi_1) = U</M>,
and let <M>\varphi_1^{(i)}</M>, <M>1 \leq i \leq |C|</M>,
be the extensions of <M>\varphi_1</M> to <M>U</M>.
(In fact exactly <M>\varphi_1</M> is fixed by <M>U</M>
since otherwise <M>k \in K</M>
would exist with <M>\varphi_1^k &noteq; \varphi_1</M> and such that also
<M>\varphi_1^k</M> would be invariant in <M>U</M>;
but then <M>\varphi_1</M> would be invariant under both <M>C</M> and
<M>C^k</M>, which generate <M>F</M>.
So each of the <M>|K|</M> constituents is invariant in exactly one of the
<M>|K|</M> subgroups of type <M>U</M> above <M>G</M>.)

<P/>

Then
<M>((\varphi_1^{(i)})^H)_N = \varphi_1^N = \chi</M>,
hence the values of <M>\psi^{(i)}</M> on the classes of <M>U \setminus G</M>
are given by those of <M>(\varphi_1^{(i)})^H</M>.
(These are exactly the values of <M>\varphi_1^{(i)}</M>.
So in both cases, we take the values of <M>\chi</M> on <M>N</M>,
and on the classes of <M>U \setminus G</M> the values of the extensions
of the unique extendible constituent of <M>\chi_G</M>.)

<P/>

For examples, see Section&nbsp;<Ref Sect="sect:GS3"/>.

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:theorGV4">
<Heading>Character Tables of Groups of the Structure <M>G.2^2</M></Heading>

Let <M>G</M> be a finite group, and <M>H</M> be an upward extension of
<M>G</M> such that the factor group <M>H / G</M> is a Klein four group.
We assume that the ordinary character tables of <M>G</M> and of the three
index two subgroups <M>U_1</M>, <M>U_2</M>, and <M>U_3</M>
(of the structures <M>G.2_1</M>, <M>G.2_2</M>, and <M>G.2_3</M>,
respectively) of <M>H</M> above <M>G</M> are known,
as well as the class fusions of <M>G</M> into these groups.
The idea behind the method that is described in this section is that
in this situation,
there are only few possibilities for the ordinary character table of
<M>H</M>.

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons04.png" alt="groups of the structure G.V4"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
               H
              ╱│╲
             ╱ │ ╲               G  ───▶  U_1  ───▶  H
            ╱  │  ╲
          U_1 U_2 U_3            G  ───▶  U_2  ───▶  H
            ╲  │  ╱
             ╲ │ ╱               G  ───▶  U_3  ───▶  H
              ╲│╱
               G
               │
               │
               1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons04 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(70,30)
\put(0,0){\begin{picture}(40,30)(0,0)
\put(20,0){\circle*{1}}
\put(20,10){\circle*{1}} \put(17,10){\makebox(0,0){$G$}}
\put(13,17){\circle*{1}} \put(10,17){\makebox(0,0){$U_1$}}
\put(20,17){\circle*{1}} \put(17,17){\makebox(0,0){$U_2$}}
\put(27,17){\circle*{1}} \put(30,17){\makebox(0,0){$U_3$}}
\put(20,24){\circle*{1}} \put(20,27){\makebox(0,0){$H$}}
\put(20,0){\line(0,1){24}}
\put(20,10){\line(-1,1){7}}
\put(20,10){\line(1,1){7}}
\put(27,17){\line(-1,1){7}}
\put(13,17){\line(1,1){7}}
\end{picture}}
\put(40,2){\begin{picture}(35,30)
\put( 5,15){\makebox(0,0){$G$}}
\put(16,25){\makebox(0,0){$U_1$}}
\put(16,15){\makebox(0,0){$U_2$}}
\put(16, 5){\makebox(0,0){$U_3$}}
\put(28,15){\makebox(0,0){$H$}}
\put( 7,17){\vector(1,1){6}}
\put( 7,15){\vector(1,0){6}}
\put( 7,13){\vector(1,-1){6}}
\put(19,23){\vector(1,-1){6}}
\put(19,15){\vector(1,0){6}}
\put(19, 7){\vector(1,1){6}}
\end{picture}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

Namely, the action of <M>H</M> on the classes of <M>G.2_i</M> is given by
a table automorphism <M>\pi_i</M> of <M>G.2_i</M>,
and <M>H</M> realizes compatible choices of such
automorphisms <M>\pi_1</M>, <M>\pi_2</M>, <M>\pi_3</M> in the sense that
the orbits of all three <M>\pi_i</M> on the classes of <M>G</M> inside the
groups <M>G.2_i</M> coincide.
Furthermore, if <M>G.2_i</M> has <M>n_i</M> conjugacy classes then an action
<M>\pi_i</M> that is a product of <M>f_i</M> disjoint transpositions leads
to a character table candidate for <M>G.2^2</M> that has <M>2 n_i - 3 f_i</M>
classes,
so also the <M>f_i</M> must be compatible.

<P/>

Taking the <Q>inner</Q> classes, i.e., the orbit sums of the classes inside
<M>G</M> under the <M>\pi_i</M>, plus the union of the <M>\pi_i</M>-orbits of
the classes of <M>G.2_i \setminus G</M> gives a possibility for the classes
of <M>H</M>.
Furthermore, the power maps of the groups <M>G.2_i</M> determine the
power maps of the candidate table constructed this way.

<P/>

Concerning the computation of the irreducible characters of <M>H</M>,
we consider also the case of <M>p</M>-modular characters tables,
where we assume that the ordinary character table of <M>H</M> is already
known and the only task is to compute the irreducible <M>p</M>-modular
Brauer characters.

<P/>

Let <M>\chi</M> be an irreducible (<M>p</M>-modular Brauer) character of
<M>G</M>.
By the facts that are listed in
Section&nbsp;<Ref Subsect="subsect:theorClifford"/>,
there are three possibilities.

<List>
<Mark>1.</Mark>
<Item>
   <M>I_H(\chi) = G</M>; then <M>\chi^H</M> is irreducible.
</Item>
<Mark>2.</Mark>
<Item>
   <M>I_H(\chi) = G.2_i</M> for <M>i</M> one of <M>1</M>, <M>2</M>, <M>3</M>;
   then <M>I_{G.2_i}(\chi) = G.2_i</M> for this <M>i</M>,
   so <M>\chi</M> extends to <M>G.2_i</M>;
   none of these extensions extends to <M>H</M>
   (because otherwise <M>\chi</M> would be invariant in <M>H</M>),
   so they induce irreducible characters of <M>H</M>.
</Item>
<Mark>3.</Mark>
<Item>
   <M>I_H(\chi) = H</M>;
   then <M>\chi</M> extends to each of the three groups <M>G.2_i</M>,
   and either all these extensions induce the same character of <M>H</M>
   (which vanishes on <M>H \setminus G</M>) or they are invariant in <M>H</M>
   and thus extend to <M>H</M>.
</Item>
</List>

<P/>

In the latter part of case&nbsp;3. (except if <M>p  = 2</M>),
the problem is to combine the values of six irreducible characters
of the groups <M>G.2_i</M> to four characters of <M>H</M>.
This yields essentially two choices, and we try to exclude one possibility
by forming scalar products with the <M>2</M>-nd symmetrizations of the known
irreducibles.
If several possibilities remain then we get several possible tables.

<P/>

So we end up with a list of possible character tables of <M>H</M>.

<!-- In certain situations it is clear from the beginning that there will be
     several solutions, for example if <M>G</M> has a central involution
     and thus several (in general not isomorphic) isoclinic variants of
     <M>H</M> exist.
     An as example, consider <M>G = C_2</M>, the cyclic group of order two,
     and <M>H</M> a nonabelian group of order <M>8</M>. -->

The first step is to specify a list of possible triples
<M>(\pi_1, \pi_2, \pi_3)</M>, using the table automorphisms of the groups
<M>G.2_i</M>;
this can be done using the &GAP; function
<Ref Func="PossibleActionsForTypeGV4" BookName="ctbllib"/>.
Then the &GAP; function
<Ref Func="PossibleCharacterTablesOfTypeGV4" BookName="ctbllib"/>
can be used
for computing the character table candidates for each given triple of
permutations; it may of course happen that some triples of automorphisms
are excluded in this second step.

<P/>

For examples, see Section&nbsp;<Ref Sect="sect:xplGV4"/>.

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:theorV4G">
<Heading>Character Tables of Groups of the Structure <M>2^2.G</M>
(August 2005)</Heading>

Let <M>G</M> be a finite group, and <M>H</M> be a central extension of
<M>G</M> by a Klein four group <M>Z = \langle z_1, z_2 \rangle</M>;
set <M>z_3 = z_1 z_2</M> and <M>Z_i = \langle z_i \rangle</M>,
for <M>1 \leq i \leq 3</M>.
We assume that the ordinary character tables of the three factor groups
<M>2_i.G = H / Z_i</M> of <M>H</M> are known,
as well as the class fusions from these groups to <M>G</M>.
The idea behind the method described in this section is that
in this situation,
there are only few possibilities for the ordinary character table of
<M>H</M>.

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons05.png" alt="groups of the structure V4.G"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
               H
               │
             G │
               │
               Z
              ╱│╲
             ╱ │ ╲               H  ───▶  H / Z_1  ───▶  G
            ╱  │  ╲
          Z_1 Z_2 Z_3            H  ───▶  H / Z_2  ───▶  G
            ╲  │  ╱
             ╲ │ ╱               H  ───▶  H / Z_3  ───▶  G
              ╲│╱
               1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons05 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(70,30)
\put(0,0){\begin{picture}(40,30)(0,0)
\put(20,0){\circle*{1}}
\put(20,14){\circle*{1}} \put(17,19){\makebox(0,0){$G$}}
\put(13, 7){\circle*{1}} \put(10, 7){\makebox(0,0){$Z_1$}}
\put(20, 7){\circle*{1}} \put(17, 7){\makebox(0,0){$Z_2$}}
\put(27, 7){\circle*{1}} \put(30, 7){\makebox(0,0){$Z_3$}}
\put(20,24){\circle*{1}} \put(20,27){\makebox(0,0){$H$}}
\put(20,0){\line(0,1){24}}
\put(20, 0){\line(-1,1){7}}
\put(20, 0){\line(1,1){7}}
\put(27, 7){\line(-1,1){7}}
\put(13, 7){\line(1,1){7}} 
\end{picture}}
\put(40,2){\begin{picture}(35,30)
\put( 5,15){\makebox(0,0){$H$}}
\put(18,25){\makebox(0,0){$H/Z_1$}}
\put(18,15){\makebox(0,0){$H/Z_2$}}
\put(18, 5){\makebox(0,0){$H/Z_3$}}
\put(32,15){\makebox(0,0){$G$}}
\put( 7,17){\vector(1,1){6}}
\put( 7,15){\vector(1,0){6}}
\put( 7,13){\vector(1,-1){6}}
\put(23,23){\vector(1,-1){6}}
\put(23,15){\vector(1,0){6}}
\put(23, 7){\vector(1,1){6}}
\end{picture}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

Namely,
the irreducible (<M>p</M>-modular) characters of <M>H</M> are exactly the
inflations of the irreducible (<M>p</M>-modular) characters of the three
factor groups <M>H / Z_i</M>.
(Note that for any noncyclic central subgroup <M>C</M> of <M>H</M>
and any <M>\chi \in &Irr;(H)</M>, we have <M>|\ker(\chi) \cap C| > 1</M>.
To see this, let <M>N = \ker(\chi)</M>.
Then clearly <M>|N| > 1</M>,
and <M>\chi</M> can be regarded as a faithful irreducible character of
<M>H/N</M>.
If <M>N \cap C</M> would be trivial then <M>N C / N \cong C</M> would be
a noncyclic central subgroup of <M>H/N</M>.
This cannot happen by&nbsp;<Cite Key="Isa76" Where="Thm. 2.32 (a)"/>,
so the statement can be regarded as an obvious refinement of this theorem.)
So all we have to construct is the character table head of <M>H</M>
&ndash;classes and power maps&ndash; and the factor fusions from <M>H</M>
to these groups.

<P/>

For fixed <M>h \in H</M>, we consider the question in which <M>H</M>-classes
the elements <M>h</M>, <M>h z_1</M>, <M>h z_2</M>, and <M>h z_3</M> lie.
There are three possibilities.

<P/>

<Enum>
<Item>
   The four elements are all conjugate in <M>H</M>.
   Then in each of the three groups <M>H/Z_i</M>,
   the two preimages of <M>h Z \in H/Z</M> are conjugate.
</Item>
<Item>
   We are not in case 1. but two of the four elements are conjugate in
   <M>H</M>, i.&nbsp;e.,
   <M>g^{-1} h g = h z_i</M> for some <M>g \in H</M> and some <M>i</M>;
   then <M>g^{-1} h z_j g = h z_i z_j</M> for each <M>j</M>,
   so the four elements lie in exactly two <M>H</M>-classes.
   This implies that for <M>i &noteq; j</M>, the elements <M>h</M> and
   <M>h z_j</M> are not <M>H</M>-conjugate,
   so <M>h Z_i</M> is not conjugate to <M>h z_j Z_i</M> in <M>H/Z_i</M>
   and <M>h Z_j</M> is conjugate to <M>h z_i Z_j</M> in <M>H/Z_j</M>.
</Item>
<Item>
   The four elements are pairwise nonconjugate in <M>H</M>.
   Then in each of the three groups <M>H/Z_i</M>,
   the two preimages of <M>h Z \in H/Z</M> are nonconjugate.
</Item>
</Enum>

<P/>

We observe that the question which case actually applies for <M>h \in H</M>
can be decided from the three factor fusions from <M>H/Z_i</M> to <M>G</M>.
So we attempt to construct the table head of <M>H</M> and the three factor
fusions from <M>H</M> to the groups <M>H/Z_i</M>, as follows.
Each class <M>g^G</M> of <M>G</M> yields either one or two or four preimage
classes in <M>H</M>.

<P/>

In case 1., we get one preimage class in <M>H</M>,
and have no choice for the factor fusions.

<P/>

In case 2., we get two preimage classes,
there is exactly one group <M>H/Z_i</M> in which <M>g^G</M> has two preimage
classes
&ndash;which are in bijection with the two preimage classes of
<M>H</M>&ndash;
and for the other two groups <M>H/Z_j</M>, the factor fusions from <M>H</M>
map the two classes of <M>H</M> to the unique preimage class of <M>g^G</M>.
(In the following picture, this is shown for <M>i = 1</M>.)

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons06.png" alt="Two preimages for a class"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
   H/Z        hZ             H/Z      hZ           H/Z      hZ
             ╱ ╲                      │                     │
            ╱   ╲                     │                     │
   H/Z_1  hZ_1 (hz_2)Z_1     H/Z_2    hZ_2         H/Z_3    hZ_3
           │     │                   ╱ ╲                   ╱ ╲
           │     │                  ╱   ╲                 ╱   ╲
   H       h     hz_2              h     hz_2            h     hz_2
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons06 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(110,30)
\put( 3, 5){\makebox(0,0){$H$}}
\put( 3,15){\makebox(0,0){$H/Z_1$}}
\put( 3,25){\makebox(0,0){$H/Z$}}
\put(10, 5){\circle*{1}} \put(12, 5){\makebox(0,0){$h$}}
\put(10,15){\circle*{1}} \put(14,15){\makebox(0,0){$h Z_1$}}
\put(20, 5){\circle*{1}} \put(24, 5){\makebox(0,0){$h z_2$}}
\put(20,15){\circle*{1}} \put(25,15){\makebox(0,0){$h z_2 Z_1$}}
\put(15,25){\circle*{1}} \put(18,25){\makebox(0,0){$h Z$}}
\put(10, 5){\line(0,1){10}}
\put(20, 5){\line(0,1){10}}
\put(10,15){\line(1,2){5}}
\put(20,15){\line(-1,2){5}}
\put(43, 5){\makebox(0,0){$H$}}
\put(43,15){\makebox(0,0){$H/Z_2$}}
\put(43,25){\makebox(0,0){$H/Z$}}
\put(50, 5){\circle*{1}} \put(52, 5){\makebox(0,0){$h$}}
\put(55,15){\circle*{1}} \put(59,15){\makebox(0,0){$h Z_2$}}
\put(60, 5){\circle*{1}} \put(64, 5){\makebox(0,0){$h z_2$}}
\put(55,25){\circle*{1}} \put(58,25){\makebox(0,0){$h Z$}}
\put(50,5){\line(1,2){5}}
\put(60,5){\line(-1,2){5}}
\put(55,15){\line(0,1){10}}
\put(83, 5){\makebox(0,0){$H$}}
\put(83,15){\makebox(0,0){$H/Z_3$}}
\put(83,25){\makebox(0,0){$H/Z$}}
\put(90, 5){\circle*{1}} \put(92, 5){\makebox(0,0){$h$}}
\put(95,15){\circle*{1}} \put(99,15){\makebox(0,0){$h Z_3$}}
\put(100, 5){\circle*{1}} \put(104, 5){\makebox(0,0){$h z_2$}}
\put(95,25){\circle*{1}} \put(98,25){\makebox(0,0){$h Z$}}
\put(90,5){\line(1,2){5}}
\put(100,5){\line(-1,2){5}}
\put(95,15){\line(0,1){10}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

In case 3., the three factor fusions are in general not uniquely determined:
We get four classes, which are defined as two pairs of preimages of the two
preimages of <M>g^G</M> in <M>H/Z_1</M> and in <M>H/Z_2</M>
&ndash;so we choose the relevant images in the two factor fusions to
<M>H/Z_1</M> and <M>H/Z_2</M>, respectively.
Note that the class of <M>h</M> in <M>H</M> is the unique class
that maps to the class of <M>h Z_1</M> in <M>H/Z_1</M> and to the class of
<M>h Z_2</M> in <M>H/Z_2</M>, and so on,
and we define four classes of <M>H</M> via the four possible combinations of
image classes in <M>H/Z_1</M> and <M>H/Z_2</M> (see the picture below).

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons07.png" alt="Four preimages for a class (part 1)"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
   H/Z           hZ             H/Z           hZ
                ╱ ╲                          ╱ ╲
               ╱   ╲                        ╱   ╲
   H/Z_1     hZ_1 (hz_2)Z_1     H/Z_2     hZ_2 (hz_1)Z_2
             ╱│     │╲                    ╱   ╲╱  ╲  
            ╱ │     │ ╲                  ╱    ╱╲   ╲  
   H       h hz_1 hz_2 hz_3             h hz_1 hz_2 hz_3
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons07 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(110,30)
\put( 3, 5){\makebox(0,0){$H$}}
\put( 3,15){\makebox(0,0){$H/Z_1$}}
\put( 3,25){\makebox(0,0){$H/Z$}}
\put(10, 5){\circle*{1}} \put(12, 5){\makebox(0,0){$h$}}
\put(20, 5){\circle*{1}} \put(23, 5){\makebox(0,0){$h z_1$}}
\put(30, 5){\circle*{1}} \put(33, 5){\makebox(0,0){$h z_2$}}
\put(40, 5){\circle*{1}} \put(43, 5){\makebox(0,0){$h z_3$}}
\put(15,15){\circle*{1}} \put(19,15){\makebox(0,0){$h Z_1$}}
\put(35,15){\circle*{1}} \put(40,15){\makebox(0,0){$h z_2 Z_1$}}
\put(25,25){\circle*{1}} \put(29,25){\makebox(0,0){$h Z$}}
\put(10, 5){\line(1,2){5}}
\put(20, 5){\line(-1,2){5}}
\put(30, 5){\line(1,2){5}}
\put(40, 5){\line(-1,2){5}}
\put(15,15){\line(1,1){10}}
\put(35,15){\line(-1,1){10}}
\put(63, 5){\makebox(0,0){$H$}}
\put(63,15){\makebox(0,0){$H/Z_2$}}
\put(63,25){\makebox(0,0){$H/Z$}} 
\put(70, 5){\circle*{1}} \put(72, 5){\makebox(0,0){$h$}}
\put(80, 5){\circle*{1}} \put(84, 5){\makebox(0,0){$h z_1$}}
\put(90, 5){\circle*{1}} \put(93, 5){\makebox(0,0){$h z_2$}}
\put(100, 5){\circle*{1}} \put(103, 5){\makebox(0,0){$h z_3$}}
\put(75,15){\circle*{1}} \put(80,15){\makebox(0,0){$h Z_2$}}
\put(95,15){\circle*{1}} \put(100,15){\makebox(0,0){$h z_1 Z_2$}}
\put(85,25){\circle*{1}} \put(89,25){\makebox(0,0){$h Z$}}
\put(70, 5){\line(1,2){5}}
\put(80, 5){\line(3,2){15}}
\put(90, 5){\line(-3,2){15}}
\put(100, 5){\line(-1,2){5}}
\put(75,15){\line(1,1){10}}
\put(95,15){\line(-1,1){10}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

Due to the fact that in general we do not know which of the two
preimage classes of <M>g^G</M> in <M>H/Z_3</M> is the class of <M>h Z_3</M>,
there are in general the following <E>two</E> possibilities
for the fusion from <M>H</M> to <M>H/Z_3</M>.

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons08.png" alt="Four preimages for a class (part 2)"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
   H/Z           hZ             H/Z           hZ
                ╱ ╲                          ╱ ╲
               ╱   ╲                        ╱   ╲
   H/Z_3     hZ_3 (hz_1)Z_3     H/Z_3     hZ_3 (hz_1)Z_3
             ╱ └──╱│────┐               ┌───│╲──┘ ╲  
            ╱    ╱ │    │               │   │ ╲    ╲  
   H       h hz_1 hz_2 hz_3             h hz_1 hz_2 hz_3
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons08 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(110,30)
\put( 3, 5){\makebox(0,0){$H$}}
\put( 3,15){\makebox(0,0){$H/Z_3$}}
\put( 3,25){\makebox(0,0){$H/Z$}}
\put(10, 5){\circle*{1}} \put(12, 5){\makebox(0,0){$h$}}
\put(20, 5){\circle*{1}} \put(24, 5){\makebox(0,0){$h z_1$}}
\put(30, 5){\circle*{1}} \put(33, 5){\makebox(0,0){$h z_2$}}
\put(40, 5){\circle*{1}} \put(43, 5){\makebox(0,0){$h z_3$}}
\put(15,15){\circle*{1}} \put(20,15){\makebox(0,0){$h Z_3$}}
\put(35,15){\circle*{1}} \put(40,15){\makebox(0,0){$h z_1 Z_3$}}
\put(25,25){\circle*{1}} \put(29,25){\makebox(0,0){$h Z$}}
\put(10, 5){\line(1,2){5}}
\put(20, 5){\line(3,2){15}}
\put(30, 5){\line(1,2){5}}
\put(40, 5){\line(-5,2){25}}
\put(15,15){\line(1,1){10}}
\put(35,15){\line(-1,1){10}}
\put(63, 5){\makebox(0,0){$H$}}
\put(63,15){\makebox(0,0){$H/Z_3$}}
\put(63,25){\makebox(0,0){$H/Z$}}
\put(70, 5){\circle*{1}} \put(74, 5){\makebox(0,0){$h$}}
\put(80, 5){\circle*{1}} \put(83, 5){\makebox(0,0){$h z_1$}}
\put(90, 5){\circle*{1}} \put(93, 5){\makebox(0,0){$h z_2$}}
\put(100, 5){\circle*{1}} \put(103, 5){\makebox(0,0){$h z_3$}}
\put(75,15){\circle*{1}} \put(81,15){\makebox(0,0){$h z_1 Z_3$}}
\put(95,15){\circle*{1}} \put(99,15){\makebox(0,0){$h Z_3$}}
\put(85,25){\circle*{1}} \put(89,25){\makebox(0,0){$h Z$}}
\put(70, 5){\line(5,2){25}}
\put(80, 5){\line(-1,2){5}}
\put(90, 5){\line(-3,2){15}}
\put(100, 5){\line(-1,2){5}}
\put(75,15){\line(1,1){10}}
\put(95,15){\line(-1,1){10}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

This means that we can inflate the irreducible characters of <M>H/Z_1</M> and
of <M>H/Z_2</M> to <M>H</M> but that for the inflations of those irreducible
characters of <M>H/Z_3</M> to <M>H</M> that are not characters of <M>G</M>,
the values on classes where case 3.&nbsp;applies are determined only up to
sign.

<P/>

The &GAP; function
<Ref Func="PossibleCharacterTablesOfTypeV4G" BookName="ctbllib"/>
computes the
candidates for the table of <M>H</M> from the tables of the groups
<M>H/Z_i</M>
by setting up the character table head of <M>H</M> using the class fusions
from <M>H/Z_1</M> and <M>H/Z_2</M> to <M>G</M>,
and then forming the possible class fusions from <M>H</M> to <M>H/Z_3</M>.

<P/>

If case 3.&nbsp;applies for a class <M>g^G</M> with <M>g</M> of <E>odd</E>
element order
then exactly one preimage class in <M>H</M> has odd element order,
and we can identify this class in the groups <M>H/Z_i</M>,
which resolves the ambiguity in this situation.
More generally, if <M>g = k^2</M> holds for some <M>k \in G</M> then all
preimages of <M>k^G</M> in <M>H</M> square to the same class of <M>H</M>,
so again this class can be identified.
In fact
<Ref Func="PossibleCharacterTablesOfTypeV4G" BookName="ctbllib"/>
checks whether the
<M>p</M>-th power maps of the candidate table for <M>H</M> and the
<M>p</M>-th power map of <M>H/Z_3</M>
together with the fusion candidate form a commutative diagram.

<P/>

An additional criterion used by
<Ref Func="PossibleCharacterTablesOfTypeV4G" BookName="ctbllib"/>
is given by the property that the product of two characters inflated from
<M>H/Z_1</M> and <M>H/Z_2</M>, respectively, that are not characters of
<M>G</M> is a character of <M>H</M> that contains <M>Z_3</M> in its kernel,
so it is checked whether the scalar products of these characters
with all characters that are inflated from <M>H/Z_3</M> via the candidate
fusion are nonnegative integers.

<P/>

Once the fusions from <M>H</M> to the groups <M>H/Z_i</M> are known,
the computation of the irreducible <M>p</M>-modular characters of <M>H</M>
from those of the groups <M>H/Z_i</M> is straightforward.

<P/>

The only open question is why this construction is described in this note.
That is, how is it related to table automorphisms?

<P/>

The answer is that in several interesting cases,
the three subgroups <M>Z_1</M>, <M>Z_2</M>, <M>Z_3</M> are conjugate
under an order three automorphism <M>\sigma</M>, say, of <M>H</M>.
In this situation, the three factor groups <M>2_i.G = H/Z_i</M> are
isomorphic,
and we can describe the input tables and fusions by the character table of
<M>2_1.G</M>, the factor fusion from this group to <M>G</M>,
and the automorphism <M>\sigma'</M> of <M>G</M>
that is induced by <M>\sigma</M>.
Assume that <M>\sigma(Z_1) = Z_2</M> holds, and choose <M>h \in H</M>.
Then <M>\sigma(h Z_1) = \sigma(h) Z_2</M> is mapped to
<M>\sigma(h) Z = \sigma'(h Z)</M> under the factor fusion from <M>2_2.G</M>
to <M>G</M>.
Let us start with the character table of <M>2_1.G</M>,
and fix the class fusion to the character table of <M>G</M>.
We may choose the identity map as isomorphism from the table of <M>2_1.G</M>
to the tables of <M>2_2.G</M> and <M>2_3.G</M>,
which implies that the class of <M>h Z_1</M> is identified with the class
of <M>h Z_2</M> and in turn the class fusion from the table of <M>2_2.G</M>
to that of <M>G</M> can be chosen as the class fusion from the table of
<M>2_1.G</M> followed by the permutation of classes of <M>G</M> induced by
<M>\sigma'</M>;
analogously, the fusion from the table of <M>2_3.G</M> is obtained
by applying this permutation twice to the class fusion from the table of
<M>2_1.G</M>.

<P/>

For examples, see Section&nbsp;<Ref Sect="sect:xplV4G"/>.

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:theorpsing">
<Heading><M>p</M>-Modular Tables of Extensions by <M>p</M>-singular Automorphisms</Heading>

Let <M>G</M> be a finite group, and <M>H</M> be an upward extension of
<M>G</M> by an automorphism of prime order <M>p</M>, say.
<M>H</M> induces a table automorphism of the <M>p</M>-modular character table
of <M>G</M>;
let <M>\pi</M> denote the corresponding permutation of classes of <M>G</M>.
The columns of the <M>p</M>-modular character table of <M>H</M> are given by
the orbits of <M>\pi</M>,
and the irreducible Brauer characters of <M>H</M> are exactly the orbit sums
of <M>\pi</M> on the irreducible Brauer characters of <M>G</M>.

<P/>

Note that for computing the <M>p</M>-modular character table of <M>H</M> from
that of <M>G</M>,
it is sufficient to know the orbits of <M>\pi</M> and not <M>\pi</M> itself.
Also the ordinary character table of <M>H</M> is not needed,
but since &GAP; stores Brauer character tables relative to their ordinary
tables, we are interested mainly in cases where the ordinary character
tables of <M>G</M> and <M>H</M> and the <M>p</M>-modular character table of
<M>G</M> are known.
Assuming that the class fusion between the ordinary tables of <M>G</M> and
<M>H</M> is stored on the table of <M>G</M>,
the orbits of the action of <M>H</M> on the <M>p</M>-regular classes of
<M>G</M> can be read off from it.

<P/>

The &GAP; function
<Ref Func="IBrOfExtensionBySingularAutomorphism" BookName="ctbllib"/>
can be used to compute the <M>p</M>-modular irreducibles of <M>H</M>.

<P/>

For examples, see Section&nbsp;<Ref Sect="sect:xplpsing"/>.

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:theorsubdir">
<Heading>Character Tables of Subdirect Products of Index Two (July 2007)</Heading>

Let <M>C_2</M> denote the cyclic group of order two,
let <M>G_1</M>, <M>G_2</M> be two finite groups,
and for <M>i \in \{ 1, 2 \}</M>,
let <M>\varphi_i\colon G_i \rightarrow C_2</M>
be an epimorphism with kernel <M>H_i</M>.
Let <M>G</M> be the subdirect product (pullback) of <M>G_1</M> and <M>G_2</M>
w.r.t. the epimorphisms <M>\varphi_i</M>, i.e.,

<Display Mode="M">
   G = \{ (g_1, g_2) \in G_1 \times G_2; \varphi_1(g_1) = \varphi_2(g_2) \} .
</Display>

The group <M>G</M> has index two in the direct product <M>G_1 \times G_2</M>,
and <M>G</M> contains <M>H_1 \times H_2</M> as a subgroup of index two.

<P/>

In the following,
we describe how the ordinary (or <M>p</M>-modular) character table of
<M>G</M> can be computed from the ordinary (or <M>p</M>-modular)
character tables of the groups <M>G_i</M> and <M>H_i</M>,
and the class fusions from <M>H_i</M> to <M>G_i</M>.

<P/>

(For the case that one of the groups <M>G_i</M> is a cyclic group of order
four,
an alternative way to construct the character table of <M>G</M> is described
in Section&nbsp;<Ref Subsect="subsect:isoclinism"/>.
For the case that one of the groups <M>G_i</M> acts fixed point freely on the
nontrivial irreducible characters of <M>H_i</M>, an alternative construction
is described in Section&nbsp;<Ref Subsect="subsect:theorMGA"/>.)

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons09.png" alt="Subdirect products of index two"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
                                G1xG2
                                 ╱│╲
                                ╱ │ ╲
                           G1xH2  G  H1xG2
                              ╱ ╲ │ ╱ ╲
                             ╱   ╲│╱   ╲
                            ╱   H1xH2   ╲
                          G1     ╱ ╲     G2
                            ╲   ╱   ╲   ╱
                             ╲ ╱     ╲ ╱
                             H1       H2
                               ╲     ╱
                                ╲   ╱
                                 ╲ ╱
                                  1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons09 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(100,45)
\put(0,0){\begin{picture}(45,45)
\put(20, 0){\circle*{1}}
\put( 7,13){\circle*{1}} \put( 4,13){\makebox(0,0){$H_1$}}
\put( 0,20){\circle*{1}} \put(-3,20){\makebox(0,0){$G_1$}}
\put(33,13){\circle*{1}} \put(36,13){\makebox(0,0){$H_2$}}
\put(40,20){\circle*{1}} \put(43,20){\makebox(0,0){$G_2$}}
\put(20,26){\circle*{1}} \put(27,26){\makebox(0,0){$H_1 \times H_2$}}
\put(13,33){\circle*{1}} \put( 5,33){\makebox(0,0){$G_1 \times H_2$}}
\put(27,33){\circle*{1}} \put(35,33){\makebox(0,0){$H_1 \times G_2$}}
\put(20,33){\circle*{1}} \put(23,33){\makebox(0,0){$G$}}
\put(20,40){\circle*{1}} \put(20,43){\makebox(0,0){$G_1 \times G_2$}}
\put(20, 0){\line(1,1){20}}
\put(20, 0){\line(-1,1){20}}
\put( 7,13){\line(1,1){20}}
\put(33,13){\line(-1,1){20}}
\put( 0,20){\line(1,1){20}}
\put(40,20){\line(-1,1){20}}
\put(20,26){\line(0,1){14}}
\end{picture}}
\put(60,2){\begin{picture}(45,45)
\put( 0, 5){\makebox(0,0){$H_2$}}
\put( 0,20){\makebox(0,0){$H_1 \times H_2$}}
\put( 0,35){\makebox(0,0){$H_1$}}
\put(20,20){\makebox(0,0){$G$}}
\put(40, 5){\makebox(0,0){$G_2$}}
\put(40,20){\makebox(0,0){$G_1 \times G_2$}}
\put(40,35){\makebox(0,0){$G_1$}}
\put( 0, 7){\vector(0,1){11}}
\put( 0,33){\vector(0,-1){11}}
\put(40, 7){\vector(0,1){11}}
\put(40,33){\vector(0,-1){11}}
\put( 2, 5){\vector(1,0){35}}
\put( 2,35){\vector(1,0){35}}
\put( 7,20){\vector(1,0){11}}
\put(22,20){\vector(1,0){11}}
\end{picture}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

Each conjugacy class of <M>G</M> is either contained in <M>H_1 \times H_2</M>
or not.
In the former case, let <M>h_i \in H_i</M> and
<M>g_i \in G_i \setminus H_i</M>;
in particular, <M>(g_1, g_2) \in G</M> because both <M>\varphi_1(g_1)</M> and
<M>\varphi_2(g_2)</M> are not the identity.
There are four possibilities.

<P/>

<List>
<Mark>1.</Mark>
<Item>
   If <M>h_1^{{H_1}} = h_1^{{G_1}}</M> and <M>h_2^{{H_2}} = h_2^{{G_2}}</M>
   then <M>(h_1, h_2)^{{H_1 \times H_2}} = (h_1, h_2)^{{G_1 \times G_2}}</M>
   holds,
   hence this class is equal to <M>(h_1, h_2)^G</M>.
</Item>
<Mark>2.</Mark>
<Item>
   If <M>h_1^{{H_1}} &noteq; h_1^{{G_1}}</M> and
   <M>h_2^{{H_2}} &noteq; h_2^{{G_2}}</M> then the four
   <M>H_1 \times H_2</M>-classes with the representatives <M>(h_1, h_2)</M>,
   <M>(h_1^{{g_1}}, h_2)</M>, <M>(h_1, h_2^{{g_2}})</M>,
   and <M>(h_1^{{g_1}}, h_2^{{g_2}})</M>
   fall into two <M>G</M>-classes,
   where <M>(h_1, h_2)</M> is <M>G</M>-conjugate with
   <M>(h_1^{{g_1}}, h_2^{{g_2}})</M>,
   and <M>(h_1^{{g_1}}, h_2)</M> is <M>G</M>-conjugate with
   <M>(h_1, h_2^{{g_2}})</M>.
</Item>
<Mark>3.</Mark>
<Item>
   If <M>h_1^{{H_1}} = h_1^{{G_1}}</M> and
   <M>h_2^{{H_2}} &noteq; h_2^{{G_2}}</M> then
   the two <M>H_1 \times H_2</M>-classes with the representatives
   <M>(h_1, h_2)</M>
   and <M>(h_1, h_2^{{g_2}})</M> fuse in <M>G</M>;
   note that there is <M>\tilde{g}_1 \in C_{{G_1}}(h_1) \setminus H_1</M>,
   so <M>(\tilde{g}_1, g_2) \in G</M> holds.
</Item>
<Mark>4.</Mark>
<Item>
   The case of <M>h_1^{{H_1}} &noteq; h_1^{{G_1}}</M> and
   <M>h_2^{{H_2}} = h_2^{{G_2}}</M>
   is analogous to case 3.
</Item>
</List>

<P/>

It remains to deal with the <M>G</M>-classes that are not contained in
<M>H_1 \times H_2</M>.
Each such class is in fact a conjugacy class of <M>G_1 \times G_2</M>.
Note that two elements <M>g_1, g_2 \in G_1 \setminus H_1</M> are
<M>G_1</M>-conjugate if and only if they are <M>H_1</M>-conjugate.
(If <M>g_1^x = g_2</M> for <M>x \in G_1 \setminus H_1</M>
then <M>g_1^{{g_1 x}} = g_2</M> holds, and <M>g_1 x \in H_1</M>.)
This implies
<M>(g_1, g_2)^{{G_1 \times G_2}} = (g_1, g_2)^{{H_1 \times H_2}}</M>,
and thus this class is equal to <M>(g_1, g_2)^G</M>.

<P/>

The (ordinary or <M>p</M>-modular) irreducible characters of <M>G</M> are
given by the restrictions <M>\chi_G</M> of all those irreducible characters
<M>\chi</M> of <M>G_1 \times G_2</M> whose restriction to
<M>H_1 \times H_2</M> is irreducible,
plus the induced characters <M>\varphi^G</M>, where <M>\varphi</M> runs over
all those irreducible characters of <M>H_1 \times H_2</M> that do not occur
as restrictions of characters of <M>G_1 \times G_2</M>.

<P/>

In other words, no irreducible character of <M>H_1 \times H_2</M>
has inertia subgroup <M>G</M> inside <M>G_1 \times G_2</M>.
This can be seen as follows.
Let <M>\varphi</M> be an irreducible character of <M>H_1 \times H_2</M>.
Then <M>\varphi = \varphi_1 \cdot \varphi_2</M>,
where <M>\varphi_1</M>, <M>\varphi_2</M> are irreducible characters of
<M>H_1 \times H_2</M>
with the properties that <M>H_2 \subseteq \ker(\varphi_1)</M> and
<M>H_1 \subseteq \ker(\varphi_2)</M>.
Sloppy speaking, <M>\varphi_i</M> is an irreducible character of <M>H_i</M>.

<P/>

There are four possibilities.

<Enum>
<Item>
   If <M>\varphi_1</M> extends to <M>G_1</M> and <M>\varphi_2</M> extends to
   <M>G_2</M> then <M>\varphi</M> extends to <M>G</M>,
   so <M>\varphi</M> has inertia subgroup <M>G_1 \times G_2</M>.
</Item>
<Item>
   If <M>\varphi_1</M> does not extend to <M>G_1</M> and <M>\varphi_2</M>
   does not extend to <M>G_2</M>
   then <M>\varphi^{{G_1 \times G_2}}</M> is irreducible,
   so <M>\varphi</M> has inertia subgroup <M>H_1 \times H_2</M>.
</Item>
<Item>
   If <M>\varphi_1</M> extends to <M>G_1</M> and <M>\varphi_2</M>
   does not extend to <M>G_2</M>
   then <M>\varphi</M> extends to <M>G_1 \times H_2</M>
   but not to <M>G_1 \times G_2</M>,
   so <M>\varphi</M> has inertia subgroup <M>G_1 \times H_2</M>.
</Item>
<Item>
   The case that <M>\varphi_1</M> does not extend to <M>G_1</M>
   and <M>\varphi_2</M> extends to <M>G_2</M> is analogous to case 3,
   <M>\varphi</M> has inertia subgroup <M>H_1 \times G_2</M>.
</Item>
</Enum>

<P/>

For examples, see Section&nbsp;<Ref Sect="sect:Gsubdir"/>.

</Subsection>
</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:explMGA">
<Heading>Examples for the Type <M>M.G.A</M></Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:dihedralMGA">
<Heading>Character Tables of Dihedral Groups</Heading>

Let <M>n = 2^k \cdot m</M> where <M>k</M> is a nonnegative integer and
<M>m</M> is an odd integer,
and consider the dihedral group <M>D_{2n}</M> of order <M>2n</M>.
Let <M>N</M> denote the derived subgroup of <M>D_{2n}</M>.

<P/>

If <M>k = 0</M> then <M>D_{2n}</M> has the structure <M>M.G.A</M>,
with <M>M = N</M> and <M>G</M> the trivial group,
and <M>A</M> a cyclic group of order two that inverts each element of
<M>N</M> and hence acts fixed-point freely on <M>N</M>.
The smallest nontrivial example is of course that of <M>D_6 \cong S_3</M>.

<P/>

<Example><![CDATA[
gap> tblMG:= CharacterTable( "Cyclic", 3 );;
gap> tblG:= CharacterTable( "Cyclic", 1 );;
gap> tblGA:= CharacterTable( "Cyclic", 2 );;
gap> StoreFusion( tblMG, [ 1, 1, 1 ], tblG );
gap> StoreFusion( tblG, [ 1 ], tblGA );
gap> elms:= Elements( AutomorphismsOfTable( tblMG ) );
[ (), (2,3) ]
gap> orbs:= [ [ 1 ], [ 2, 3 ] ];;
gap> new:= PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, orbs,
>              "S3" );
[ rec( MGfusMGA := [ 1, 2, 2 ], table := CharacterTable( "S3" ) ) ]
gap> Display( new[1].table );
S3

     2  1  .  1
     3  1  1  .

       1a 3a 2a
    2P 1a 3a 1a
    3P 1a 1a 2a

X.1     1  1  1
X.2     1  1 -1
X.3     2 -1  .
]]></Example>

<P/>

If <M>k > 0</M> then <M>D_{2n}</M> has the structure <M>M.G.A</M>,
with <M>M = N</M> and <M>G</M> a cyclic group of order two such that
<M>M.G</M> is cyclic,
and <M>A</M> is a cyclic group of order two that inverts each element of
<M>M.G</M> and hence acts fixed-point freely on <M>M.G</M>.
The smallest nontrivial example is of course that of <M>D_8</M>.

<P/>

<Example><![CDATA[
gap> tblMG:= CharacterTable( "Cyclic", 4 );;
gap> tblG:= CharacterTable( "Cyclic", 2 );;
gap> tblGA:= CharacterTable( "2^2" );;           
gap> OrdersClassRepresentatives( tblMG );
[ 1, 4, 2, 4 ]
gap> StoreFusion( tblMG, [ 1, 2, 1, 2 ], tblG ); 
gap> StoreFusion( tblG, [ 1, 2 ], tblGA );      
gap> elms:= Elements( AutomorphismsOfTable( tblMG ) );
[ (), (2,4) ]
gap> orbs:= Orbits( Group( elms[2] ), [ 1 ..4 ] );;
gap> new:= PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, orbs,
>              "order8" );
[ rec( MGfusMGA := [ 1, 2, 3, 2 ], 
      table := CharacterTable( "order8" ) ), 
  rec( MGfusMGA := [ 1, 2, 3, 2 ], 
      table := CharacterTable( "order8" ) ) ]
]]></Example>

<P/>

Here we get two possible tables, which are the character tables of the
dihedral and the quaternion group of order eight, respectively.

<P/>

<Example><![CDATA[
gap> List( new, x -> OrdersClassRepresentatives( x.table ) );
[ [ 1, 4, 2, 2, 2 ], [ 1, 4, 2, 4, 4 ] ]
gap> Display( new[1].table );
order8

     2  3  2  3  2  2

       1a 4a 2a 2b 2c
    2P 1a 2a 1a 1a 1a

X.1     1  1  1  1  1
X.2     1  1  1 -1 -1
X.3     1 -1  1  1 -1
X.4     1 -1  1 -1  1
X.5     2  . -2  .  .
]]></Example>

<P/>

For each <M>k > 1</M> and <M>m = 1</M>, we get two possible tables this way,
that of the dihedral group of order <M>2^{k+1}</M> and that of the
generalized quaternion group of order <M>2^{k+1}</M>.

<!-- Note that the groups in question are <M>2</M>-groups of maximal class,
     where each element in the cyclic subgroup of index two is conjugate
     to its inverse.
     So the only thing one has to show is that no other candidate tables
     arise.
     So why does the third group of maximal class not arise? -->

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:A12N7">
<Heading>An <M>M.G.A</M> Type Example with <M>M</M> noncentral in <M>M.G</M> (May 2004)</Heading>

The Sylow <M>7</M> normalizer in the symmetric group <M>S_{12}</M> has the
structure <M>7:6 \times S_5</M>,
its intersection <M>N</M> with the alternating group <M>A_{12}</M>
is of index two,
it has the structure <M>(7:3 \times A_5):2</M>.

<P/>

Let <M>M</M> denote the normal subgroup of order <M>7</M> in <M>N</M>,
let <M>G</M> denote the normal subgroup of the type <M>3 \times A_5</M>
in <M>F = N/M \cong 3 \times S_5</M>,
and <M>A = F/G</M>, the cyclic group of order two.
Then <M>N</M> has the structure <M>M.G.A</M>,
where <M>A</M> acts fixed-point freely
on the irreducible characters of <M>M.G = 7:3 \times A_5</M>
that do not contain <M>M</M> in their kernels,
hence the character table of <M>N</M> is determined by the character tables
of <M>M.G</M> and <M>F</M>, and the action of <M>A</M> on <M>M.G</M>.

<P/>

Note that in this example, the group <M>M</M> is not central in <M>M.G</M>,
unlike in most of our examples.

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons10.png" alt="The structure of (7:3 x A_5):2)"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
                                 N
                                 │╲
                                 │ (7xA_5):2
                           7:3xA_5 │
                                ╱ ╲│
                               ╱   7xA_5
                              ╱   ╱ ╲
                           7:3   ╱   A_5
                              ╲ ╱   ╱
                               7   ╱
                                ╲ ╱
                                 1 
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons10 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(45,40)(0,0)
\put(20,0){\circle*{1}}
\put(14,6){\circle*{1}} \put(12,5){\makebox(0,0){$7$}}
\put(10,10){\circle*{1}} \put(5,10){\makebox(0,0){$7:3$}}
\put(35,15){\circle*{1}} \put(38,15){\makebox(0,0){$A_5$}}
\put(29,21){\circle*{1}} \put(35,21){\makebox(0,0){$7 \times A_5$}}
\put(25,25){\circle*{1}} \put(17,26){\makebox(0,0){$7:3 \times A_5$}}
\put(29,31){\circle*{1}} \put(38,31){\makebox(0,0){$(7 \times A_5):2$}}
\put(25,35){\circle*{1}} \put(25,38){\makebox(0,0){$N$}}
\put(20,0){\line(-1,1){10}}
\put(20,0){\line(1,1){15}}
\put(35,15){\line(-1,1){10}}
\put(14,6){\line(1,1){15}}
\put(10,10){\line(1,1){15}}
\put(25,25){\line(0,1){10}}
\put(29,21){\line(0,1){10}}
\put(29,31){\line(-1,1){4}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

<Example><![CDATA[
gap> tblMG:= CharacterTable( "7:3" ) * CharacterTable( "A5" );;
gap> nsg:= ClassPositionsOfNormalSubgroups( tblMG );
[ [ 1 ], [ 1, 6 .. 11 ], [ 1 .. 5 ], [ 1, 6 .. 21 ], [ 1 .. 15 ], 
  [ 1 .. 25 ] ]
gap> List( nsg, x -> Sum( SizesConjugacyClasses( tblMG ){ x } ) );
[ 1, 7, 60, 21, 420, 1260 ]
gap> tblG:= tblMG / nsg[2];;
gap> tblGA:= CharacterTable( "Cyclic", 3 ) * CharacterTable( "A5.2" );;
gap> GfusGA:= PossibleClassFusions( tblG, tblGA );
[ [ 1, 2, 3, 4, 4, 8, 9, 10, 11, 11, 15, 16, 17, 18, 18 ], 
  [ 1, 2, 3, 4, 4, 15, 16, 17, 18, 18, 8, 9, 10, 11, 11 ] ]
gap> reps:= RepresentativesFusions( Group(()), GfusGA, tblGA );
[ [ 1, 2, 3, 4, 4, 8, 9, 10, 11, 11, 15, 16, 17, 18, 18 ] ]
gap> StoreFusion( tblG, reps[1], tblGA );
gap> acts:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );
[ [ [ 1 ], [ 2 ], [ 3 ], [ 4, 5 ], [ 6, 11 ], [ 7, 12 ], [ 8, 13 ], 
      [ 9, 15 ], [ 10, 14 ], [ 16 ], [ 17 ], [ 18 ], [ 19, 20 ], 
      [ 21 ], [ 22 ], [ 23 ], [ 24, 25 ] ] ]
gap> poss:= PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA,
>               acts[1], "A12N7" );
[ rec( 
      MGfusMGA := [ 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 5, 6, 7, 9, 8, 10, 
          11, 12, 13, 13, 14, 15, 16, 17, 17 ], 
      table := CharacterTable( "A12N7" ) ) ]
]]></Example>

<P/>

Let us compare the result table with the table of the Sylow <M>7</M>
normalizer in <M>A_{12}</M>.

<P/>

<Example><![CDATA[
gap> g:= AlternatingGroup( 12 );;
gap> IsRecord( TransformingPermutationsCharacterTables( poss[1].table,
>                CharacterTable( Normalizer( g, SylowSubgroup( g, 7 ) ) ) ) );
true
]]></Example>

<P/>

Since July 2007,
an alternative way to construct the character table of <M>N</M> from other
character tables is to exploit its structure as a subdirect product
of index two in the group <M>7:6 \times S_5</M>,
see Section&nbsp;<Ref Subsect="subsect:theorsubdir"/>.

<P/>

<Example><![CDATA[
gap> tblh1:= CharacterTable( "7:3" );;
gap> tblg1:= CharacterTable( "7:6" );;
gap> tblh2:= CharacterTable( "A5" );;
gap> tblg2:= CharacterTable( "A5.2" );;
gap> subdir:= CharacterTableOfIndexTwoSubdirectProduct( tblh1, tblg1,
>                 tblh2, tblg2, "(7:3xA5).2" );;
gap> IsRecord( TransformingPermutationsCharacterTables( poss[1].table,
>                subdir.table ) );
true
]]></Example>

<P/>

For storing the table of <M>N</M> in the &GAP; Character Table Library,
the construction as a subdirect product is more suitable,
since the <Q>auxiliary table</Q> of the direct product <M>7:3 \times A_5</M>
need not be stored in the library.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:ATLASMGA">
<Heading>&ATLAS; Tables of the Type <M>M.G.A</M></Heading>

We show the construction of some character tables of groups of the type
<M>M.G.A</M> that are contained in the &GAP; Character Table Library.
Each entry in the following input list contains the names of the library
character tables of <M>M.G</M>, <M>G</M>, <M>G.A</M>, and <M>M.G.A</M>.

<P/>

First we consider the situation where <M>G</M> is a simple group or a central
extension of a simple group whose character table is shown in the &ATLAS;,
and <M>M</M> and <M>A</M> are cyclic groups such that <M>M</M> is central in
<M>M.G</M>.

<P/>

In the following cases,
the character tables are uniquely determined by the input tables.
Note that in each of these cases, <M>|A|</M> and <M>|M|</M> are coprime.

<P/>

<Example><![CDATA[
gap> listMGA:= [
> [ "3.A6",        "A6",        "A6.2_1",        "3.A6.2_1"       ],
> [ "3.A6",        "A6",        "A6.2_2",        "3.A6.2_2"       ],
> [ "6.A6",        "2.A6",      "2.A6.2_1",      "6.A6.2_1"       ],
> [ "6.A6",        "2.A6",      "2.A6.2_2",      "6.A6.2_2"       ],
> [ "3.A7",        "A7",        "A7.2",          "3.A7.2"         ],
> [ "6.A7",        "2.A7",      "2.A7.2",        "6.A7.2"         ],
> [ "3.L3(4)",     "L3(4)",     "L3(4).2_2",     "3.L3(4).2_2"    ],
> [ "3.L3(4)",     "L3(4)",     "L3(4).2_3",     "3.L3(4).2_3"    ],
> [ "6.L3(4)",     "2.L3(4)",   "2.L3(4).2_2",   "6.L3(4).2_2"    ],
> [ "6.L3(4)",     "2.L3(4)",   "2.L3(4).2_3",   "6.L3(4).2_3"    ],
> [ "12_1.L3(4)",  "4_1.L3(4)", "4_1.L3(4).2_2", "12_1.L3(4).2_2" ],
> [ "12_1.L3(4)",  "4_1.L3(4)", "4_1.L3(4).2_3", "12_1.L3(4).2_3" ],
> [ "12_2.L3(4)",  "4_2.L3(4)", "4_2.L3(4).2_2", "12_2.L3(4).2_2" ],
> [ "12_2.L3(4)",  "4_2.L3(4)", "4_2.L3(4).2_3", "12_2.L3(4).2_3" ],
> [ "3.U3(5)",     "U3(5)",     "U3(5).2",       "3.U3(5).2"      ],
> [ "3.M22",       "M22",       "M22.2",         "3.M22.2"        ],
> [ "6.M22",       "2.M22",     "2.M22.2",       "6.M22.2"        ],
> [ "12.M22",      "4.M22",     "4.M22.2",       "12.M22.2"       ],
> [ "3.L3(7)",     "L3(7)",     "L3(7).2",       "3.L3(7).2"      ],
> [ "3_1.U4(3)",   "U4(3)",     "U4(3).2_1",     "3_1.U4(3).2_1"  ],
> [ "3_1.U4(3)",   "U4(3)",     "U4(3).2_2'",    "3_1.U4(3).2_2'" ],
> [ "3_2.U4(3)",   "U4(3)",     "U4(3).2_1",     "3_2.U4(3).2_1"  ],
> [ "3_2.U4(3)",   "U4(3)",     "U4(3).2_3'",    "3_2.U4(3).2_3'" ],
> [ "6_1.U4(3)",   "2.U4(3)",   "2.U4(3).2_1",   "6_1.U4(3).2_1"  ],
> [ "6_1.U4(3)",   "2.U4(3)",   "2.U4(3).2_2'",  "6_1.U4(3).2_2'" ],
> [ "6_2.U4(3)",   "2.U4(3)",   "2.U4(3).2_1",   "6_2.U4(3).2_1"  ],
> [ "6_2.U4(3)",   "2.U4(3)",   "2.U4(3).2_3'",  "6_2.U4(3).2_3'" ],
> [ "12_1.U4(3)",  "4.U4(3)",   "4.U4(3).2_1",   "12_1.U4(3).2_1" ],
> [ "12_2.U4(3)",  "4.U4(3)",   "4.U4(3).2_1",   "12_2.U4(3).2_1" ],
> [ "3.G2(3)",     "G2(3)",     "G2(3).2",       "3.G2(3).2"      ],
> [ "3.U3(8)",     "U3(8)",     "U3(8).2",       "3.U3(8).2"      ],
> [ "3.U3(8).3_1", "U3(8).3_1", "U3(8).6",       "3.U3(8).6"      ],
> [ "3.J3",        "J3",        "J3.2",          "3.J3.2"         ],
> [ "3.U3(11)",    "U3(11)",    "U3(11).2",      "3.U3(11).2"     ],
> [ "3.McL",       "McL",       "McL.2",         "3.McL.2"        ],
> [ "3.O7(3)",     "O7(3)",     "O7(3).2",       "3.O7(3).2"      ],
> [ "6.O7(3)",     "2.O7(3)",   "2.O7(3).2",     "6.O7(3).2"      ],
> [ "3.U6(2)",     "U6(2)",     "U6(2).2",       "3.U6(2).2"      ],
> [ "6.U6(2)",     "2.U6(2)",   "2.U6(2).2",     "6.U6(2).2"      ],
> [ "3.Suz",       "Suz",       "Suz.2",         "3.Suz.2"        ],
> [ "6.Suz",       "2.Suz",     "2.Suz.2",       "6.Suz.2"        ],
> [ "3.ON",        "ON",        "ON.2",          "3.ON.2"         ],
> [ "3.Fi22",      "Fi22",      "Fi22.2",        "3.Fi22.2"       ],
> [ "6.Fi22",      "2.Fi22",    "2.Fi22.2",      "6.Fi22.2"       ],
> [ "3.2E6(2)",    "2E6(2)",    "2E6(2).2",      "3.2E6(2).2"     ],
> [ "6.2E6(2)",    "2.2E6(2)",  "2.2E6(2).2",    "6.2E6(2).2"     ],
> [ "3.F3+",       "F3+",       "F3+.2",         "3.F3+.2"        ],
> ];;
]]></Example>

<P/>

(We need not consider groups <M>3.U_3(8).6'</M> and <M>3.U_3(8).6'</M>,
see Section <Ref Subsect="subsect:struct3U3831"/>.)

<P/>

Note that the groups of the types <M>12_1.L_3(4).2_1</M> and
<M>12_2.L_3(4).2_1</M> have central subgroups of order six,
so we cannot choose <M>G</M> equal to <M>4_1.L_3(4)</M> and
<M>4_2.L_3(4)</M>, respectively, in these cases.
See Section&nbsp;<Ref Subsect="subsect:MoreATLASMGA"/> for the construction
of these tables.

<P/>

Also in the following cases, <M>|A|</M> and <M>|M|</M> are coprime,
we have <M>|M| = 3</M> and <M>|A| = 2</M>.
The group <M>M.G</M> has a central subgroup of the type <M>2^2 \times 3</M>,
and <M>A</M> acts on this group by inverting the elements in the subgroup
of order <M>3</M> and by swapping two involutions in the Klein four group.

<P/>

<Example><![CDATA[
gap> Append( listMGA, [
> [ "(2^2x3).L3(4)",  "2^2.L3(4)",   "2^2.L3(4).2_2", "(2^2x3).L3(4).2_2" ],
> [ "(2^2x3).L3(4)",  "2^2.L3(4)",   "2^2.L3(4).2_3", "(2^2x3).L3(4).2_3" ],
> [ "(2^2x3).U6(2)",  "2^2.U6(2)",   "2^2.U6(2).2",   "(2^2x3).U6(2).2"   ],
> [ "(2^2x3).2E6(2)", "2^2.2E6(2)",  "2^2.2E6(2).2",  "(2^2x3).2E6(2).2"  ],
> ] );
]]></Example>

<P/>

Additionally, there are a few cases where <M>A</M> has order two,
and <M>G.A</M> has a factor group of the type <M>2^2</M>,
and a few cases where <M>M</M> has the type <M>2^2</M> and <M>A</M>
is of order three and acts transitively on the involutions in <M>M</M>.

<P/>

<Example><![CDATA[
gap> Append( listMGA, [
> [ "3.A6.2_3",       "A6.2_3",    "A6.2^2",      "3.A6.2^2"          ],
> [ "3.L3(4).2_1",    "L3(4).2_1", "L3(4).2^2",   "3.L3(4).2^2"       ],
> [ "3_1.U4(3).2_2",  "U4(3).2_2", "U4(3).(2^2)_{122}",
>                                             "3_1.U4(3).(2^2)_{122}" ],
> [ "3_2.U4(3).2_3",  "U4(3).2_3", "U4(3).(2^2)_{133}",
>                                             "3_2.U4(3).(2^2)_{133}" ],
> [ "3^2.U4(3).2_3'", "3_2.U4(3).2_3'", "3_2.U4(3).(2^2)_{133}",
>                                             "3^2.U4(3).(2^2)_{133}" ],
> [ "2^2.L3(4)",      "L3(4)",     "L3(4).3",     "2^2.L3(4).3"       ],
> [ "(2^2x3).L3(4)",  "3.L3(4)",   "3.L3(4).3",   "(2^2x3).L3(4).3"   ],
> [ "2^2.L3(4).2_1",  "L3(4).2_1", "L3(4).6",     "2^2.L3(4).6"       ],
> [ "2^2.Sz(8)",      "Sz(8)",     "Sz(8).3",     "2^2.Sz(8).3"       ],
> [ "2^2.U6(2)",      "U6(2)",     "U6(2).3",     "2^2.U6(2).3"       ],
> [ "(2^2x3).U6(2)",  "3.U6(2)",   "3.U6(2).3",   "(2^2x3).U6(2).3"   ],
> [ "2^2.O8+(2)",     "O8+(2)",    "O8+(2).3",    "2^2.O8+(2).3"      ],
> [ "2^2.O8+(3)",     "O8+(3)",    "O8+(3).3",    "2^2.O8+(3).3"      ],
> [ "2^2.2E6(2)",     "2E6(2)",    "2E6(2).3",    "2^2.2E6(2).3"      ],
> ] );
]]></Example>

<!-- %T as soon as 3.2E6(2).3 is available:
     %T > [ "(2^2x3).2E6(2)", "3.2E6(2)",  "3.2E6(2).3",  "(2^2x3).2E6(2).3"  ], -->

<P/>

The constructions of the character tables of groups of the types
<M>4_2.L_3(4).2_3</M>, <M>12_2.L_3(4).2_3</M>,
<M>12_1.U_4(3).2_2'</M> and <M>12_2.U_4(3).2_3'</M>
is described in Section&nbsp;<Ref Subsect="subsect:4_2.L_3(4).2_3"/>
and&nbsp;<Ref Subsect="subsect:12_i.U_4(3).2_jdash"/>,
in these cases the &GAP; functions return several possible tables.

<P/>

The construction of the various character table of groups of the types
<M>4_1.L_3(4).2^2</M> and <M>4_2.L_3(4).2^2</M> are described in
Section&nbsp;<Ref Subsect="subsect:41L34V4"/>.

<P/>

The following function takes the ordinary character tables of the groups
<M>M.G</M>, <M>G</M>, and <M>G.A</M>, a string to be used as the
<Ref Func="Identifier" BookName="ref"/>
value of the character table of <M>M.G.A</M>,
and the character table of <M>M.G.A</M> that is
contained in the &GAP; Character Table Library;
the function first computes the possible actions of <M>G.A</M> on the classes
of <M>M.G</M>, using the function
<Ref Func="PossibleActionsForTypeMGA" BookName="ctbllib"/>,
then computes the union of possible character tables for these actions,
and then representatives up to permutation equivalence;
if there is only one solution then the result table is compared with the
library table.

<P/>

<Ignore Remark="gapfilecomments">
</Ignore>
<Example><![CDATA[
gap> ConstructOrdinaryMGATable:= function( tblMG, tblG, tblGA, name, lib )
>      local acts, poss, trans;
> 
>      acts:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );
>      poss:= Concatenation( List( acts, pi ->
>                 PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, pi,
>                     name ) ) );
>      poss:= RepresentativesCharacterTables( poss );
>      if Length( poss ) = 1 then
>        # Compare the computed table with the library table.
>        if not IsCharacterTable( lib ) then
>          List( poss, x -> AutomorphismsOfTable( x.table ) );
>          Print( "#I  no library table for ", name, "\n" );
>        else
>          trans:= TransformingPermutationsCharacterTables( poss[1].table,
>                      lib );
>          if not IsRecord( trans ) then
>            Print( "#E  computed table and library table for ", name,
>                   " differ\n" );
>          fi;
>          # Compare the computed fusion with the stored one.
>          if OnTuples( poss[1].MGfusMGA, trans.columns )
>                 <> GetFusionMap( tblMG, lib ) then
>            Print( "#E  computed and stored fusion for ", name,
>                   " differ\n" );
>          fi;
>        fi;
>      elif Length( poss ) = 0 then
>        Print( "#E  no solution for ", name, "\n" );
>      else
>        Print( "#E  ", Length( poss ), " possibilities for ", name, "\n" );
>      fi;
>      return poss;
>    end;;
]]></Example>

<P/>

The following function takes the ordinary character tables of the groups
<M>M.G</M>, <M>G.A</M>, and <M>M.G.A</M>,
and tries to construct the <M>p</M>-modular character tables of <M>M.G.A</M>
from the <M>p</M>-modular character tables of the first two of these tables,
for all prime divisors <M>p</M> of the order of <M>M.G.A</M>.
Note that the tables of <M>G</M> are not needed in the construction,
only the class fusions from <M>M.G</M> to <M>M.G.A</M> and from <M>M.G.A</M>
to <M>G.A</M> must be stored.

<P/>

<Ignore Remark="gapfilecomments">
</Ignore>
<Example><![CDATA[
gap> ConstructModularMGATables:= function( tblMG, tblGA, ordtblMGA )
>    local name, poss, p, modtblMG, modtblGA, modtblMGA, modlib, trans;
> 
>    name:= Identifier( ordtblMGA );
>    poss:= [];
>    for p in PrimeDivisors( Size( ordtblMGA ) ) do
>      modtblMG := tblMG mod p;
>      modtblGA := tblGA mod p;
>      if ForAll( [ modtblMG, modtblGA ], IsCharacterTable ) then
>        modtblMGA:= BrauerTableOfTypeMGA( modtblMG, modtblGA, ordtblMGA );
>        Add( poss, modtblMGA );
>        modlib:= ordtblMGA mod p;
>        if IsCharacterTable( modlib ) then
>          trans:= TransformingPermutationsCharacterTables( modtblMGA.table,
>                      modlib );
>          if not IsRecord( trans ) then
>            Print( "#E  computed table and library table for ", name,
>                   " mod ", p, " differ\n" );
>          fi;
>        else
>          AutomorphismsOfTable( modtblMGA.table );
>          Print( "#I  no library table for ", name, " mod ", p, "\n" );
>        fi;
>      else
>        Print( "#I  not all input tables for ", name, " mod ", p,
>               " available\n" );
>      fi;
>    od;
> 
>    return poss;
>    end;;
]]></Example>

<P/>

Now we run the constructions for the cases in the list.
Note that in order to avoid conflicts of the class fusions that arise in
the construction with the class fusions that are already stored on the
library tables, we choose identifiers for the result tables that are
different from the identifiers of the library tables.

<P/>

<Example><![CDATA[
gap> for  input in listMGA do
>      tblMG := CharacterTable( input[1] );
>      tblG  := CharacterTable( input[2] );
>      tblGA := CharacterTable( input[3] );
>      name  := Concatenation( "new", input[4] );
>      lib   := CharacterTable( input[4] );
>      poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );
>      if 1 <> Length( poss ) then
>        Print( "#I  ", Length( poss ), " possibilities for ", name, "\n" );
>      elif lib = fail then
>        Print( "#I  no library table for ", input[4], "\n" );
>      else
>        ConstructModularMGATables( tblMG, tblGA, lib );
>      fi;
>    od;
#I  not all input tables for 3.2E6(2).2 mod 2 available
#I  not all input tables for 3.2E6(2).2 mod 3 available
#I  not all input tables for 3.2E6(2).2 mod 5 available
#I  not all input tables for 3.2E6(2).2 mod 7 available
#I  not all input tables for 3.2E6(2).2 mod 11 available
#I  not all input tables for 3.2E6(2).2 mod 13 available
#I  not all input tables for 3.2E6(2).2 mod 17 available
#I  not all input tables for 3.2E6(2).2 mod 19 available
#I  not all input tables for 6.2E6(2).2 mod 2 available
#I  not all input tables for 6.2E6(2).2 mod 3 available
#I  not all input tables for 6.2E6(2).2 mod 5 available
#I  not all input tables for 6.2E6(2).2 mod 7 available
#I  not all input tables for 6.2E6(2).2 mod 11 available
#I  not all input tables for 6.2E6(2).2 mod 13 available
#I  not all input tables for 6.2E6(2).2 mod 17 available
#I  not all input tables for 6.2E6(2).2 mod 19 available
#I  not all input tables for 3.F3+.2 mod 2 available
#I  not all input tables for 3.F3+.2 mod 3 available
#I  not all input tables for 3.F3+.2 mod 5 available
#I  not all input tables for 3.F3+.2 mod 7 available
#I  not all input tables for 3.F3+.2 mod 13 available
#I  not all input tables for 3.F3+.2 mod 17 available
#I  not all input tables for 3.F3+.2 mod 29 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 2 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 3 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 5 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 7 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 11 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 13 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 17 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 19 available
#I  not all input tables for 3^2.U4(3).(2^2)_{133} mod 2 available
#I  not all input tables for 3^2.U4(3).(2^2)_{133} mod 5 available
#I  not all input tables for 3^2.U4(3).(2^2)_{133} mod 7 available
#I  not all input tables for 2^2.O8+(3).3 mod 5 available
#I  not all input tables for 2^2.O8+(3).3 mod 7 available
#I  not all input tables for 2^2.O8+(3).3 mod 13 available
#I  not all input tables for 2^2.2E6(2).3 mod 2 available
#I  not all input tables for 2^2.2E6(2).3 mod 3 available
#I  not all input tables for 2^2.2E6(2).3 mod 5 available
#I  not all input tables for 2^2.2E6(2).3 mod 7 available
#I  not all input tables for 2^2.2E6(2).3 mod 11 available
#I  not all input tables for 2^2.2E6(2).3 mod 13 available
#I  not all input tables for 2^2.2E6(2).3 mod 17 available
#I  not all input tables for 2^2.2E6(2).3 mod 19 available
]]></Example>

<P/>

We do not get any unexpected output, so the character tables in question are
determined by the inputs.

<P/>

Alternative constructions of the character tables of <M>3.A_6.2^2</M>,
<M>3.L_3(4).2^2</M>, and <M>3_2.U_4(3).(2^2)_{133}</M> can be found
in Section&nbsp;<Ref Subsect="subsect:xplGV43.A6.V4"/>.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:MoreATLASMGA">
<Heading>More &ATLAS; Tables of the Type <M>M.G.A</M></Heading>

In the following situations, we have <M>|A| = 2</M>,
and <M>|M|</M> is a multiple of <M>2</M>.
The result turns out to be unique up to isoclinism,
see Section&nbsp;<Ref Subsect="subsect:theorMGA"/>.

<P/>

First, there are some cases where the centre of <M>M.G</M> is a cyclic group
of order four, and <M>|M| = 2</M> holds.

<P/>

<Example><![CDATA[
gap> listMGA2:= [
> [ "4_1.L3(4)",  "2.L3(4)",   "2.L3(4).2_1",   "4_1.L3(4).2_1"  ],
> [ "4_1.L3(4)",  "2.L3(4)",   "2.L3(4).2_2",   "4_1.L3(4).2_2"  ],
> [ "4_2.L3(4)",  "2.L3(4)",   "2.L3(4).2_1",   "4_2.L3(4).2_1"  ],
> [ "4.M22",      "2.M22",     "2.M22.2",       "4.M22.2"        ],
> [ "4.U4(3)",    "2.U4(3)",   "2.U4(3).2_2",   "4.U4(3).2_2"    ],
> [ "4.U4(3)",    "2.U4(3)",   "2.U4(3).2_3",   "4.U4(3).2_3"    ],
> ];;
]]></Example>

<P/>

Note that the groups <M>4_1.L3(4).2_3</M> and <M>4_2.L3(4).2_2</M> and their
isoclinic variants have centres of order four, so they do not appear here.
The construction of the character table of <M>4_2.L_3(4).2_3</M> is more
involved, it is described in
Section&nbsp;<Ref Subsect="subsect:4_2.L_3(4).2_3"/>.

<P/>

Also in the following cases, we have <M>|M| = 2</M>,
but the situation is different because <M>M.G</M> has a central subgroup of
the type <M>2^2</M> containing a unique subgroup of order <M>2</M> that is
central in <M>M.G.A</M>.

<P/>

<Example><![CDATA[
gap> Append( listMGA2, [
> [ "2^2.L3(4)",     "2.L3(4)",     "2.L3(4).2_2",         "2^2.L3(4).2_2" ],
> [ "2^2.L3(4)",     "2.L3(4)",     "2.L3(4).2_3",         "2^2.L3(4).2_3" ],
> [ "2^2.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{123}", "2^2.L3(4).2^2" ],
> [ "2^2.O8+(2)",    "2.O8+(2)",    "2.O8+(2).2",          "2^2.O8+(2).2"  ],
> [ "2^2.U6(2)",     "2.U6(2)",     "2.U6(2).2",           "2^2.U6(2).2"   ],
> [ "2^2.2E6(2)",    "2.2E6(2)",    "2.2E6(2).2",          "2^2.2E6(2).2"  ],
> ] );
]]></Example>

<P/>

Next there are two constructions for <M>G = 6.L_3(4)</M>,
with <M>|M| = 12</M> and <M>|A| = 2</M>.
Note that the groups <M>12_1.L3(4).2_1</M> and <M>12_2.L3(4).2_1</M> have
central subgroups of the order six, so we cannot use the factor groups
<M>4_1.L3(4).2_1</M> and <M>4_2.L3(4).2_1</M>, respectively,
for the constructions.

<P/>

<Example><![CDATA[
gap> Append( listMGA2, [
> [ "12_1.L3(4)", "6.L3(4)", "6.L3(4).2_1", "12_1.L3(4).2_1" ],
> [ "12_2.L3(4)", "6.L3(4)", "6.L3(4).2_1", "12_2.L3(4).2_1" ],
> ] );
]]></Example>

<P/>

Next there are alternative constructions for tables which have been
constructed in Section&nbsp;<Ref Subsect="subsect:ATLASMGA"/>.
There we had viewed the groups of the structure <M>12.S.2</M>,
for a simple group <M>S</M>, as <M>3.G.2</M> with <M>G = 4.S</M>.
Here we view these groups as <M>2.G.2</M> with <M>G = 6.S</M>,
which means that we do not prescribe the <M>4.S.2</M> type factor group.
So it is not surprising that we get more than one solution,
and that the computation of the <M>2</M>-power map of <M>12.S.2</M> is more
involved.
Note that the construction of the character table of <M>12_2.L_3(4).2_3</M>
is more involved,
it is described in Section&nbsp;<Ref Subsect="subsect:4_2.L_3(4).2_3"/>.

<P/>

<Example><![CDATA[
gap> Append( listMGA2, [
> [ "12.M22",     "6.M22",     "6.M22.2",       "12.M22.2"       ],
> [ "12_1.L3(4)", "6.L3(4)",   "6.L3(4).2_2",   "12_1.L3(4).2_2" ],
> [ "12_1.U4(3)", "6_1.U4(3)", "6_1.U4(3).2_2", "12_1.U4(3).2_2" ],
> [ "12_2.U4(3)", "6_2.U4(3)", "6_2.U4(3).2_3", "12_2.U4(3).2_3" ],
> ] );
]]></Example>

<P/>

Finally, there are alternative constructions for the cases where
the group <M>M.G</M> has a central subgroup of the type <M>2^2 \times 3</M>,
and <M>A</M> acts on this group by inverting the elements in the subgroup
of order <M>3</M> and by swapping two involutions in the Klein four group.

<P/>

<Example><![CDATA[
gap> Append( listMGA2, [
> [ "(2^2x3).L3(4)",  "6.L3(4)",   "6.L3(4).2_2", "(2^2x3).L3(4).2_2" ],
> [ "(2^2x3).L3(4)",  "6.L3(4)",   "6.L3(4).2_3", "(2^2x3).L3(4).2_3" ],
> [ "(2^2x3).U6(2)",  "6.U6(2)",   "6.U6(2).2",   "(2^2x3).U6(2).2"   ],
> [ "(2^2x3).2E6(2)", "6.2E6(2)",  "6.2E6(2).2",  "(2^2x3).2E6(2).2"  ],
> ] );
]]></Example>

<P/>

Now we run the constructions for the cases in the list.

<P/>

<Example><![CDATA[
gap> for  input in listMGA2 do
>      tblMG := CharacterTable( input[1] );
>      tblG  := CharacterTable( input[2] );
>      tblGA := CharacterTable( input[3] );
>      name  := Concatenation( "new", input[4] );
>      lib   := CharacterTable( input[4] );
>      poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );
>      if Length( poss ) = 2 then
>        iso:= CharacterTableIsoclinic( poss[1].table );
>        if IsRecord( TransformingPermutationsCharacterTables( poss[2].table,
>                         iso ) ) then
>          Unbind( poss[2] );
>        fi;
>      elif Length( poss ) = 1 then
>        Print( "#I  unique up to permutation equivalence: ", name, "\n" );
>      fi;
>      if 1 <> Length( poss ) then
>        Print( "#I  ", Length( poss ), " possibilities for ", name, "\n" );
>      elif lib = fail then
>        Print( "#I  no library table for ", input[4], "\n" );
>      else
>        ConstructModularMGATables( tblMG, tblGA, lib );
>      fi;
>    od;
#E  2 possibilities for new4_1.L3(4).2_1
#E  2 possibilities for new4_1.L3(4).2_2
#E  2 possibilities for new4_2.L3(4).2_1
#E  2 possibilities for new4.M22.2
#E  2 possibilities for new4.U4(3).2_2
#E  2 possibilities for new4.U4(3).2_3
#I  unique up to permutation equivalence: new2^2.L3(4).2_2
#I  unique up to permutation equivalence: new2^2.L3(4).2_3
#I  unique up to permutation equivalence: new2^2.L3(4).2^2
#I  unique up to permutation equivalence: new2^2.O8+(2).2
#I  unique up to permutation equivalence: new2^2.U6(2).2
#I  unique up to permutation equivalence: new2^2.2E6(2).2
#I  not all input tables for 2^2.2E6(2).2 mod 2 available
#I  not all input tables for 2^2.2E6(2).2 mod 3 available
#I  not all input tables for 2^2.2E6(2).2 mod 5 available
#I  not all input tables for 2^2.2E6(2).2 mod 7 available
#E  2 possibilities for new12_1.L3(4).2_1
#E  2 possibilities for new12_2.L3(4).2_1
#E  2 possibilities for new12.M22.2
#E  2 possibilities for new12_1.L3(4).2_2
#E  2 possibilities for new12_1.U4(3).2_2
#E  2 possibilities for new12_2.U4(3).2_3
#I  unique up to permutation equivalence: new(2^2x3).L3(4).2_2
#I  unique up to permutation equivalence: new(2^2x3).L3(4).2_3
#I  unique up to permutation equivalence: new(2^2x3).U6(2).2
#I  unique up to permutation equivalence: new(2^2x3).2E6(2).2
#I  not all input tables for (2^2x3).2E6(2).2 mod 2 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 3 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 5 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 7 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 11 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 13 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 17 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 19 available
]]></Example>

<P/>

Again,
we do not get any unexpected output, so the character tables in question are
determined up to isoclinism by the inputs.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:4_2.L_3(4).2_3">
<Heading>The Character Tables of <M>4_2.L_3(4).2_3</M> and <M>12_2.L_3(4).2_3</M></Heading>

In the construction of the character table of <M>M.G.A = 4_2.L_3(4).2_3</M>
from the tables of <M>M.G = 4_2.L_3(4)</M> and <M>G.A = 2.L_3(4).2_3</M>,
the action of <M>A</M> on the classes of <M>M.G</M> is uniquely determined,
but we get four possible character tables.

<P/>

<Example><![CDATA[
gap> tblMG := CharacterTable( "4_2.L3(4)" );;
gap> tblG  := CharacterTable( "2.L3(4)" );;
gap> tblGA := CharacterTable( "2.L3(4).2_3" );;
gap> name  := "new4_2.L3(4).2_3";;
gap> lib   := CharacterTable( "4_2.L3(4).2_3" );;
gap> poss  := ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );
#E  4 possibilities for new4_2.L3(4).2_3
[ rec( 
      MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 11, 10, 12, 
          12, 13, 14, 15, 14, 16, 17, 18, 17, 19, 20, 21, 22, 19, 22, 
          21, 20 ], table := CharacterTable( "new4_2.L3(4).2_3" ) ), 
  rec( 
      MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 11, 10, 12, 
          12, 13, 14, 15, 14, 16, 17, 18, 17, 19, 20, 21, 22, 19, 22, 
          21, 20 ], table := CharacterTable( "new4_2.L3(4).2_3" ) ), 
  rec( 
      MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 11, 10, 12, 
          12, 13, 14, 15, 14, 16, 17, 18, 17, 19, 20, 21, 22, 19, 22, 
          21, 20 ], table := CharacterTable( "new4_2.L3(4).2_3" ) ), 
  rec( 
      MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 11, 10, 12, 
          12, 13, 14, 15, 14, 16, 17, 18, 17, 19, 20, 21, 22, 19, 22, 
          21, 20 ], table := CharacterTable( "new4_2.L3(4).2_3" ) ) ]
]]></Example>

<P/>

The centre of <M>4_2.L_3(4)</M> is inverted by the action of the outer
automorphism, so the existence of <E>two</E> possible tables can be expected
because two isoclinic groups of the type <M>4_2.L_3(4).2_3</M> exist,
see Section&nbsp;<Ref Subsect="subsect:isoclinicATLAS"/>.

<P/>

Indeed the result consists of two pairs of isoclinic tables,
so we have to decide which pair of tables belongs to the groups of the
type <M>4_2.L_3(4).2_3</M>.

<!-- % The tables in a pair have the same irreducibles -->
<!-- % but different 2-power map, as for <M>4.M_{22}.2</M> etc. -->

<P/>

<Example><![CDATA[
gap> IsRecord( TransformingPermutationsCharacterTables( poss[1].table,
>                  CharacterTableIsoclinic( poss[4].table ) ) );
true
gap> IsRecord( TransformingPermutationsCharacterTables( poss[2].table,
>                  CharacterTableIsoclinic( poss[3].table ) ) );
true
]]></Example>

<P/>

The possible tables differ only w.r.t.&nbsp;the <M>2</M>-power map
and perhaps the element orders.
The &ATLAS; prints the table of the split extension of <M>M.G</M>,
this table is one of the first two possibilities.

<P/>

<Example><![CDATA[
gap> List( poss, x -> PowerMap( x.table, 2 ) );
[ [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 
      21, 19, 21, 1, 1, 6, 6, 9, 9, 11, 11, 16, 16, 13, 13 ], 
  [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 
      21, 19, 21, 1, 1, 6, 6, 11, 11, 9, 9, 16, 16, 13, 13 ], 
  [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 
      21, 19, 21, 3, 3, 8, 8, 9, 9, 11, 11, 18, 18, 15, 15 ], 
  [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 
      21, 19, 21, 3, 3, 8, 8, 11, 11, 9, 9, 18, 18, 15, 15 ] ]
]]></Example>

<P/>

The <M>2</M>-power map is not determined by the irreducible characters
(and by the <M>2</M>-power map of the factor group <M>2.L_3(4).2_3</M>).
We determine this map using the embedding of <M>4_2.L_3(4).2_3</M> into
<M>4.U_4(3).2_3</M>.
Note that <M>L_3(4).2_3</M> is a maximal subgroup of <M>U_4(3).2_3</M>
(see&nbsp;<Cite Key="CCN85" Where="p. 52"/>),
and that the subgroup <M>L_3(4)</M> of <M>U_4(3)</M> lifts
to <M>4_2.L_3(4)</M> in <M>4.U_4(3)</M>
because no embedding of <M>L_3(4)</M>, <M>2.L_3(4)</M>,
or <M>4_1.L_3(4)</M> into <M>4.U_4(3)</M> is possible.

<P/>

<Example><![CDATA[
gap> PossiblePowerMaps( poss[1].table, 2 );
[ [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 
      21, 19, 21, 1, 1, 6, 6, 11, 11, 9, 9, 16, 16, 13, 13 ], 
  [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 
      21, 19, 21, 1, 1, 6, 6, 9, 9, 11, 11, 16, 16, 13, 13 ] ]
gap> t:= CharacterTable( "4.U4(3)" );;
gap> List( [ "L3(4)", "2.L3(4)", "4_1.L3(4)", "4_2.L3(4)" ], name ->
>          Length( PossibleClassFusions( CharacterTable( name ), t ) ) );
[ 0, 0, 0, 4 ]
]]></Example>

<P/>

So the split extension <M>4_2.L_3(4).2_3</M> of <M>4_2.L_3(4)</M> is a
subgroup of the split extension <M>4.U_4(3).2_3</M> of <M>4.U_4(3)</M>,
and only one of the two possible tables of <M>4_2.L_3(4).2_3</M> admits a
class fusion into the &ATLAS; table of <M>4.U_3(4).2_3</M>;
the construction of the latter table is shown in
Section&nbsp;<Ref Subsect="subsect:ATLASMGA"/>.

<P/>

<Example><![CDATA[
gap> t2:= CharacterTable( "4.U4(3).2_3" );;
gap> List( poss, x -> Length( PossibleClassFusions( x.table, t2 ) ) );
[ 0, 16, 0, 0 ]
]]></Example>

<P/>

I do not know a character theoretic argument that would disprove the
existence of a group whose character table is the other candidate (or its
isoclinic variant).
For example,
the table passes the tests from Section&nbsp;<Ref Subsect="subsect:pseudo"/>.

<P/>

(It is straightforward to compute all extensions of <M>4_2.L_3(4)</M> by an
automorphism of order two.  The extensions with <M>34</M> conjugacy classes
belong to the second candidate and its isoclinic variant.)

<!-- construction:
     g:= AtlasGroup( "4_2.L3(4)" );
     LoadPackage( "grpconst", false );
     cand:= CyclicExtensions( g, 2 );; # 12 groups, with 64, 49, 34, 31 classes
     # the two groups with 34 classes belong to the two 4_2.L34).2_3 type groups
     # from the library, so the stored power maps are correct.
     List( cand, x -> Size( Centre( x ) ) );
     t:= CharacterTable( cand[5] );;  Irr( t );;
     NameOfEquivalentLibraryCharacterTable( t );
     -> yields "Isoclinic(4_2.L3(4).2_3)"
     t:= CharacterTable( cand[6] );;  Irr( t );;
     NameOfEquivalentLibraryCharacterTable( t );
     -> yields "4_2.L3(4).2_3" -->

<P/>

The correct table is the one that is contained in the &GAP; Character
Table Library.

<P/>

<Example><![CDATA[
gap> IsRecord( TransformingPermutationsCharacterTables( poss[2].table,
>                  lib ) );
true
gap> ConstructModularMGATables( tblMG, tblGA, lib );;
]]></Example>

<P/>

In the construction of the character table of <M>12_2.L_3(4).2_3</M>,
the same ambiguity arises.
We resolve it using the fact that <M>4_2.L_3(4).2_3</M> occurs as a factor
group, modulo the unique normal subgroup of order three.

<P/>

<Example><![CDATA[
gap> tblMG := CharacterTable( "12_2.L3(4)" );;
gap> tblG  := CharacterTable( "6.L3(4)" );;
gap> tblGA := CharacterTable( "6.L3(4).2_3" );;
gap> name  := "new12_2.L3(4).2_3";;
gap> lib   := CharacterTable( "12_2.L3(4).2_3" );;
gap> poss  := ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );;
#E  4 possibilities for new12_2.L3(4).2_3
gap> Length( poss );
4
gap> nsg:= ClassPositionsOfNormalSubgroups( poss[1].table );
[ [ 1 ], [ 1, 5 ], [ 1, 7 ], [ 1, 4 .. 7 ], [ 1, 3 .. 7 ], 
  [ 1 .. 7 ], [ 1 .. 50 ], [ 1 .. 62 ] ]
gap> List( nsg, x -> Sum( SizesConjugacyClasses( poss[1].table ){ x } ) );
[ 1, 3, 2, 4, 6, 12, 241920, 483840 ]
gap> factlib:= CharacterTable( "4_2.L3(4).2_3" );;
gap> List( poss, x -> IsRecord( TransformingPermutationsCharacterTables(
>                         x.table / [ 1, 5 ], factlib ) ) );
[ false, true, false, false ]
gap> IsRecord( TransformingPermutationsCharacterTables( poss[2].table,
>                  lib ) );
true
gap> ConstructModularMGATables( tblMG, tblGA, lib );;
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:12_i.U_4(3).2_jdash">
<Heading>The Character Tables of <M>12_1.U_4(3).2_2'</M> and
<M>12_2.U_4(3).2_3'</M> (December&nbsp;2015)</Heading>

In the construction of the character table of <M>M.G.A = 12_1.U_4(3).2_2'</M>
from the tables of <M>M.G = 12_1.U_4(3)</M> and <M>G.A = 2.U_4(3).2_2'</M>,
the action of <M>A</M> on the classes of <M>M.G</M> is uniquely determined,
but we get two possible character tables.

<P/>

(Note that the groups <M>2.U_4(3).2_2</M> and <M>2.U_4(3).2_2'</M> are
isomorphic, but we have to take the latter one because the stored factor
fusion from <M>12_1.U_4(3)</M> to <M>2.U_4(3)</M> must be combined with
the class fusion from <M>2.U_4(3)</M> to <M>2.U_4(3).2_2'</M>;
using the library table of <M>2.U_4(3).2_2</M> would be technically
more involved.)

<P/>

<Example><![CDATA[
gap> tblMG := CharacterTable( "12_1.U4(3)" );;
gap> tblG  := CharacterTable( "2.U4(3)" );;
gap> tblGA := CharacterTable( "2.U4(3).2_2'" );;
gap> name  := "new12_1.U4(3).2_2'";;
gap> lib   := CharacterTable( "12_1.U4(3).2_2'" );;
gap> poss  := ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );;
#E  2 possibilities for new12_1.U4(3).2_2'
gap> ConstructModularMGATables( tblMG, tblGA, lib );;
]]></Example>

<P/>

This is not surprising,
the two tables involve the two isoclinic variants of <M>4.U_4(3).2_2'</M>
(which is isomorphic with <M>4.U_4(3).2_2</M>) as tables of factor groups.
The irreducible characters of the two tables are equal,
only the <M>2</M>-power map and the element orders are different.

<P/>

<Example><![CDATA[
gap> Irr( poss[1].table ) = Irr( poss[2].table );
true
gap> iso:= CharacterTableIsoclinic( poss[1].table );;
gap> TransformingPermutationsCharacterTables( iso, poss[2].table );
rec( columns := (), group := <permutation group with 5 generators>, 
  rows := () )
]]></Example>

<P/>

The same phenomenon occurs
in the construction of the character table of <M>M.G.A = 12_2.U_4(3).2_3'</M>
from the tables of <M>M.G = 12_2.U_4(3)</M> and <M>G.A = 2.U_4(3).2_3'</M>.

<P/>

<Example><![CDATA[
gap> tblMG := CharacterTable( "12_2.U4(3)" );;
gap> tblG  := CharacterTable( "2.U4(3)" );;
gap> tblGA := CharacterTable( "2.U4(3).2_3'" );;
gap> name  := "new12_2.U4(3).2_3'";;
gap> lib   := CharacterTable( "12_2.U4(3).2_3'" );;
gap> poss  := ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );;
#E  2 possibilities for new12_2.U4(3).2_3'
gap> ConstructModularMGATables( tblMG, tblGA, lib );;
gap> iso:= CharacterTableIsoclinic( poss[1].table );;
gap> TransformingPermutationsCharacterTables( iso, poss[2].table );
rec( columns := (), group := <permutation group with 8 generators>, 
  rows := () )
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:struct3U3831">
<Heading>Groups of the Structures <M>3.U_3(8).3_1</M> and <M>3.U_3(8).6</M>
(February 2017)</Heading>

The list of Improvements to the &ATLAS; of Finite Groups
<Cite Key="BN95"/> states the following,
concerning the group <M>G = U_3(8)</M>.

<P/>

<Q>There is a unique group of type <M>3.G.6</M>
which contains the group of type <M>3.G.3</M> shown.
But the (unique) groups of type <M>3.G.6'</M> and <M>3.G.6''</M>
contain not this <M>3.G.3</M> but its <E>isoclines</E>.</Q>

<P/>

In this section we will show that this statement is not correct,
in the sense that the three isoclinic variants of groups
of the structure <M>3.U_3(8).3_1</M> are in fact isomorphic.

<P/>

As a consequence, there is a unique group of the structure
<M>3.U_3(8).6</M>, up to isomorphism.
Note that otherwise the strange situation of nonisomorphic groups
<M>3.G.6</M>, <M>3.G.6'</M>, and <M>3.G.6''</M> would happen,
which would be also not isoclinic because their centres are trivial.

<P/>

A group of the structure <M>3.U_3(8).3_1</M> can be obtained
as the semidirect product <M>G</M>, say, of the group SU<M>(3,8)</M>
with the automorphism of the field with <M>64</M> elements
that raises each field element to its fourth power.
Note that the semidirect product of SU<M>(3,8)</M>
with the field automorphism that squares each field element
yields a group of the structure <M>3.U_3(8).6</M>.

<P/>

First we create a permutation representation of <M>G</M>.

<P/>

<Example><![CDATA[
gap> s:= SU(3,8);;
gap> gens:= GeneratorsOfGroup( s );;
gap> imgs1:= List( gens, m -> List( m, v -> List( v, x -> x^4 ) ) );;
gap> imgs2:= List( gens, m -> List( m, v -> List( v, x -> x^16 ) ) );;
gap> f:= GF(64);;
gap> mats:= List( gens, m -> IdentityMat( 9, f ) );;
gap> for i in [ 1 .. Length( gens ) ] do
>      mats[i]{ [ 1 .. 3 ] }{ [ 1 .. 3 ] }:= gens[i];
>      mats[i]{ [ 4 .. 6 ] }{ [ 4 .. 6 ] }:= imgs1[i];
>      mats[i]{ [ 7 .. 9 ] }{ [ 7 .. 9 ] }:= imgs2[i];
>    od;
gap> fieldaut:= NullMat( 9, 9, f );;
gap> fieldaut{ [ 4 .. 6 ] }{ [ 1 .. 3 ] }:= IdentityMat( 3, f );;
gap> fieldaut{ [ 7 .. 9 ] }{ [ 4 .. 6 ] }:= IdentityMat( 3, f );;
gap> fieldaut{ [ 1 .. 3 ] }{ [ 7 .. 9 ] }:= IdentityMat( 3, f );;
gap> v:= [ 1, 0, 0, 1, 0, 0, 1, 0, 0 ] * One( f );;
gap> g:= Group( Concatenation( mats, [ fieldaut ] ) );;
gap> orb:= Orbit( g, v );;
gap> Length( orb );
32319
gap> act:= Action( g, orb );;
gap> Size( act ) = 3 * Size( s );
true
gap> sm:= SmallerDegreePermutationRepresentation( act );;
gap> NrMovedPoints( Image( sm ) );
4617
gap> g:= Image( sm );;
]]></Example>

<P/>

The next step is the construction of the central product
of <M>G</M> and a cyclic group of order nine,
of the structure <M>3.(3 \times U_3(8).3_1)</M>.
We could try to create the factor group of <M>9 \times 3.U_3(8).3_1</M>
modulo a diagonal subgroup of order three, by just applying the <C>/</C>
operation.
Since &GAP; would need too much time for that,
and since we know better in which situation we are,
we create the desired action directly on suitable sets on pairs.

<P/>

<Example><![CDATA[
gap> c:= CyclicGroup( IsPermGroup, 9 );;
gap> dp:= DirectProduct( g, c );;
gap> u:= Image( Embedding( dp, 1 ) );;
gap> c:= Image( Embedding( dp, 2 ) );;
gap> c3:= c.1^3;
(4618,4621,4624)(4619,4622,4625)(4620,4623,4626)
gap> z:= Centre( u );;
gap> Size( z );  Length( GeneratorsOfGroup( z ) );
3
1
gap> diag:= Subgroup( dp, [ c3 * z.1 ] );;
gap> orb:= Orbit( dp, [ 1, 4618 ], OnPairs );;
gap> Length( orb );
41553
gap> orb:= Set( orb );;
gap> orbs:= List( OrbitsDomain( diag, orb, OnSets ), Set );;
gap> Length( orbs );
13851
gap> cp:= Action( dp, orbs, OnSetsSets );;
gap> Size( cp );
148925952
]]></Example>

<P/>

The three isoclinic variants of the structure <M>3.U_3(8).3_1</M>
appear as subgroups of index three in this central product.
(The fourth subgroup of index three is of course a central product of
the structure <M>3.(3 \times U_3(8))</M>.)

<P/>

<Example><![CDATA[
gap> der:= DerivedSubgroup( cp );;
gap> Index( cp, der );
9
gap> inter:= IntermediateSubgroups( cp, der ).subgroups;;
gap> z:= Centre( cp );;
gap> Size( z );
9
gap> inter:= Filtered( inter, x -> not IsSubset( x, z ) );;
gap> List( inter, Size );
[ 49641984, 49641984, 49641984 ]
]]></Example>

<P/>

Finally, we check that the three groups are isomorphic.

<P/>

<Example><![CDATA[
gap> IsomorphismGroups( inter[1], inter[2] ) <> fail;
true
gap> IsomorphismGroups( inter[1], inter[3] ) <> fail;
true
]]></Example>

<!-- These computations take about 12 minutes on gemma. -->

<P/>

<E>Remark:</E>

<P/>

An indication that the groups might be isomorphic is the fact
that their character tables are equivalent,
which can be shown much easier, as follows.

<P/>

<Example><![CDATA[
gap> t1:= CharacterTable( "3.U3(8).3_1" );;
gap> t2:= CharacterTableIsoclinic( t1, rec( k:= 1 ) );;
gap> t3:= CharacterTableIsoclinic( t1, rec( k:= 2 ) );;
gap> TransformingPermutationsCharacterTables( t1, t2 ) <> fail;
true
gap> TransformingPermutationsCharacterTables( t1, t3 ) <> fail;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:BM6">
<Heading>The Character Table of <M>(2^2 \times F_4(2)):2 &lt; B</M>
(March&nbsp;2003)</Heading>

The sporadic simple group <M>B</M> contains a maximal subgroup
<M>\overline{N}</M>
of the type <M>(2^2 \times F_4(2)):2</M>,
which is the normalizer of a <C>2C</C> element <M>\overline{x}</M> in
<M>B</M> (see&nbsp;<Cite Key="CCN85" Where="p. 217"/>).

<P/>

We will see below that the normal Klein four group <M>V</M> in
<M>\overline{N}</M> contains two <C>2A</C> elements in <M>B</M>.
The <C>2A</C> centralizer in <M>B</M>,
a group of the structure <M>2.{}^2E_6(2).2</M>,
contains maximal subgroups of the type <M>2^2 \times F_4(2)</M>.
So the two <C>2A</C> type subgroups <M>C_1</M>, <M>C_2</M> in <M>V</M>
are conjugate in <M>\overline{N}</M>,
and <M>Z = \langle x \rangle</M> is the centre of <M>\overline{N}</M>.

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons11.png" alt="The structure of (2^2 x F_4(2)):2)"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
                                 Nbar
                                ╱│╲
                               U . .
                              ╱ ╲│╱
                             ╱   .
                            ╱   ╱
                           V   ╱
                          ╱│╲ ╱
                        C1 . Z
                          ╲│╱
                           1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons11 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(45,20)(-5,5)
\put(15,0){\circle*{1}}
\put(10,5){\circle{1}} \put(7,5){\makebox(0,0){$C_1$}}
\put(15,5){\circle{1}} \put(13,5){\makebox(0,0){$C_2$}}
\put(20,5){\circle*{1}} \put(23,4){\makebox(0,0){$Z$}}
\put(15,10){\circle*{1}} \put(12,11){\makebox(0,0){$V$}}
\put(30,15){\circle*{1}}
\put(25,20){\circle*{1}} \put(22,21){\makebox(0,0){$U$}}
\put(30,20){\circle*{1}}
\put(35,20){\circle*{1}}
\put(30,25){\circle*{1}} \put(30,28){\makebox(0,0){$\overline{N}$}}
\put(15,0){\line(1,1){20}}
\put(10,5){\line(1,1){20}}
\put(15,0){\line(0,1){10}}
\put(30,15){\line(0,1){10}}
\put(15,0){\line(-1,1){5}}
\put(20,5){\line(-1,1){5}}
\put(30,15){\line(-1,1){5}}
\put(35,20){\line(-1,1){5}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

We start with computing the class fusion of the <M>2^2 \times F_4(2)</M> type
subgroup <M>U</M> of <M>\overline{N}</M> into <M>B</M>;
in order to speed this up,
we first compute the class fusion of the <M>F_4(2)</M>
subgroup of <M>U</M> into <M>B</M> (which is unique),
and use it and the stored embedding into <M>U</M> for prescribing an
approximation of the desired class fusion.
Additionally, we prescribe (without loss of generality) that the
<E>first</E> involution class in <M>V</M> is mapped to the class <C>2C</C> of
<M>B</M>.

<P/>

<Example><![CDATA[
gap> f42:= CharacterTable( "F4(2)" );;
gap> v4:= CharacterTable( "2^2" );;
gap> dp:= v4 * f42;
CharacterTable( "V4xF4(2)" )
gap> b:= CharacterTable( "B" );;
gap> f42fusb:= PossibleClassFusions( f42, b );;
gap> Length( f42fusb );
1
gap> f42fusdp:= GetFusionMap( f42, dp );;
gap> comp:= CompositionMaps( f42fusb[1], InverseMap( f42fusdp ) );
[ 1, 3, 3, 3, 5, 6, 6, 7, 9, 9, 9, 9, 14, 14, 13, 13, 10, 14, 14, 12, 
  14, 17, 15, 18, 22, 22, 22, 22, 26, 26, 22, 22, 27, 27, 28, 31, 31, 
  39, 39, 36, 36, 33, 33, 39, 39, 35, 41, 42, 47, 47, 49, 49, 49, 58, 
  58, 56, 56, 66, 66, 66, 66, 58, 58, 66, 66, 69, 69, 60, 72, 72, 75, 
  79, 79, 81, 81, 85, 86, 83, 83, 91, 91, 94, 94, 104, 104, 109, 109, 
  116, 116, 114, 114, 132, 132, 140, 140 ]
gap> v4fusdp:= GetFusionMap( v4, dp );
[ 1, 96 .. 286 ]
gap> comp[ v4fusdp[2] ]:= 4;;
gap> dpfusb:= PossibleClassFusions( dp, b, rec( fusionmap:= comp ) );;
gap> Length( dpfusb );
4
gap> Set( dpfusb, x -> x{ v4fusdp } );
[ [ 1, 4, 2, 2 ] ]
]]></Example>

<!-- % time needed: 8164910 msec. -->

<P/>

As announced above, we see that <M>V</M> contains two <C>2A</C> involutions.

<P/>

Set <M>G = U / Z</M>, <M>M.G = U</M>, and <M>G.A = \overline{N} / Z</M>.
The latter group is the direct product of <M>F_4(2).2</M> and a cyclic group
of order <M>2</M>.
Next we compute the class fusion from <M>G</M> into <M>G.A</M>.

<P/>

<Example><![CDATA[
gap> tblG:= dp / v4fusdp{ [ 1, 2 ] };;
gap> tblMG:= dp;;
gap> c2:= CharacterTable( "Cyclic", 2 );;
gap> tblGA:= c2 * CharacterTable( "F4(2).2" );
CharacterTable( "C2xF4(2).2" )
gap> GfusGA:= PossibleClassFusions( tblG, tblGA );;
gap> Length( GfusGA );
4
gap> Length( RepresentativesFusions( tblG, GfusGA, tblGA ) );
1
]]></Example>

<P/>

In principle, we have to be careful which of these equivalent maps
we choose, since the underlying symmetries may be broken in the central
extension <M>M.G \rightarrow G</M>,
for which we choose the default factor fusion.

<P/>

However, in this situation the fusion <M>G</M> into <M>G.A</M> is unique
already up to table automorphisms of the table of <M>G.A</M>,
so we are free to choose one map.

<P/>

<Example><![CDATA[
gap> Length( RepresentativesFusions( Group( () ), GfusGA, tblGA ) );
1
gap> StoreFusion( tblG, GfusGA[1], tblGA );
]]></Example>
<P/>
The tables involved determine the character table of
<M>M.G.A \cong \overline{N}</M> uniquely.
<P/>
<Example><![CDATA[
gap> elms:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );;
gap> Length( elms );
1
gap> poss:= PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, elms[1],
>               "(2^2xF4(2)):2" );;
gap> Length( poss );
1
gap> tblMGA:= poss[1].table;;
]]></Example>

<!-- % The class fusion into the table of <M>B</M> is difficult to determine,
     % see (ambigfus.xpl). -->

<P/>

Finally, we compare the table we constructed with the one that is contained
in the &GAP; Character Table Library.

<P/>

<Example><![CDATA[
gap> IsRecord( TransformingPermutationsCharacterTables( tblMGA,
>                  CharacterTable( "(2^2xF4(2)):2" ) ) );
true
]]></Example>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %<Subsection Label="sect:The Character Table of <M>2.(2^2 \times F_4(2)):2 \leq 2.B</M> -->
<!-- %(March&nbsp;2003)">
<Heading>The Character Table of <M>2.(2^2 \times F_4(2)):2 \leq 2.B</M> -->
<!-- %(March&nbsp;2003)</Heading> -->
<!-- % -->
<!-- %The sporadic simple group <M>B</M> contains a maximal subgroup <M>\overline{N}</M> -->
<!-- %of type <M>(2^2 \times F_4(2)):2</M>, which is the normalizer of a <C>2C</C> -->
<!-- %element <M>\overline{x}</M> in <M>B</M>. -->
<!-- %The construction of the character table of <M>\overline{N}</M> is described -->
<!-- %in Section&nbsp;<Ref Subsect="BM6"/>. -->
<!-- %The preimage <M>N</M> of <M>\overline{N}</M> in <M>2.B</M> is the normalizer in <M>2.B</M> -->
<!-- %of the preimage of <M>\langle \overline{x} \rangle</M>. -->
<!-- %This preimage is a cyclic group of order <M>4</M>, -->
<!-- %whose generators lie in the class <C>4B</C> of the Monster group <M>M</M>, -->
<!-- %in fact <M>N</M> occurs as the full normalizer of this <C>4B</M> element in <M>M</M>, -->
<!-- %with an intermediate group of type <M>2.B</M>. -->
<!-- % -->
<!-- %The centralizer of this element in <M>M</M> (and in <M>2.B</M>) is a group <M>C</M> -->
<!-- %which has index <M>2</M> in <M>N</M>. -->
<!-- %So <M>\overline{N}</M> acts nontrivially on the centre of <M>C</M>, -->
<!-- %and hence the character table of <M>N</M> is determined by the tables of -->
<!-- %<M>\overline{N}</M> and <M>C</M>, and the action of <M>N</M> on the classes of <M>C</M>. -->
<!-- %(The character table of <M>C</M> has been computed by Simon Norton.) -->
<!-- % -->
<!-- %Thus we first compute the character table of <M>\overline{N}</M>. -->
<!-- %For that, we do <E>not</E> start with the subgroup which is obtained -->
<!-- %as the factor group of <M>C</M> by the central subgroup of order <M>2</M>. -->
<!-- %Instead, we use that the structure of <M>\overline{N}</M> is -->
<!-- %<M>(2^2 \times F_4(2)):2</M>, -->
<!-- %and that the table of this group is determined by the character tables -->
<!-- %of the subgroup <M>H</M> of type <M>2^2 \times F_4(2)</M> -->
<!-- %and of the factor group <M>2 \times F_4(2).2</M>, -->
<!-- %and the action of <M>\overline{N}</M> on the classes of <M>H</M>. -->
<!-- % -->
<!-- <Example> ... </Example> -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:2.BM9">
<Heading>The Character Table of <M>2.(S_3 \times Fi_{22}.2) &lt; 2.B</M> (March&nbsp;2003)</Heading>

The sporadic simple group <M>B</M> contains a maximal subgroup
<M>\overline{M}</M> of type <M>S_3 \times Fi_{22}.2</M>.
In order to compute the character table of its preimage <M>M</M>
in the Schur cover <M>2.B</M>,
we first analyse the structure of <M>M</M> and then describe
the construction of the character table from known character tables.

<P/>

Let <M>Z</M> denote the centre of <M>2.B</M>.
We start with <M>\overline{M} = M/Z</M>.
Its class fusion into <M>B</M> is uniquely determined by the character
tables.

<P/>

<Example><![CDATA[
gap> s3:= CharacterTable( "Dihedral", 6 );;
gap> fi222:= CharacterTable( "Fi22.2" );;
gap> tblMbar:= s3 * fi222;;
gap> b:= CharacterTable( "B" );;
gap> Mbarfusb:= PossibleClassFusions( tblMbar, b );;
gap> Length( Mbarfusb );
1
]]></Example>

<P/>

The subgroup of type <M>Fi_{22}</M> lifts to the double cover
<M>2.Fi_{22}</M> (that is, a group that is <E>not</E> a direct product
<M>2 \times Fi_{22}</M>)
in <M>2.B</M> since <M>2.B</M> admits no class fusion from <M>Fi_{22}</M>.

<P/>

<Example><![CDATA[
gap> 2b:= CharacterTable( "2.B" );;
gap> PossibleClassFusions( CharacterTable( "Fi22" ), 2b );
[  ]
]]></Example>

<P/>

So the preimage of <M>Fi_{22}.2</M> is one of the two nonisomorphic but
isoclinic groups of type <M>2.Fi_{22}.2</M>,
and we have to decide which one really occurs.
For that, we consider the subgroup of type <M>3 \times Fi_{22}.2</M> in
<M>B</M>,
which is a <C>3A</C> centralizer in <M>B</M>.
Its preimage has the structure <M>3 \times 2.Fi_{22}.2</M> because the
preimage of the central group of order <M>3</M> is a cyclic group of order
<M>6</M> and thus
contains a normal complement of the <M>2.Fi_{22}</M> type subgroup.
And a class fusion into <M>2.B</M> is possible only from the direct product
containing the <M>2.Fi_{22}.2</M> group that is printed in the &ATLAS;.

<P/>

<Example><![CDATA[
gap> c3:= CharacterTable( "Cyclic", 3 );;
gap> 2fi222:= CharacterTable( "2.Fi22.2" );;
gap> PossibleClassFusions( c3 * CharacterTableIsoclinic( 2fi222 ), 2b );
[  ]
]]></Example>

<P/>

Next we note that the involutions in the normal subgroup <M>\overline{S}</M>
of type <M>S_3</M> in <M>\overline{M}</M> lift to involutions in <M>2.B</M>.

<P/>

<Example><![CDATA[
gap> s3inMbar:= GetFusionMap( s3, tblMbar );
[ 1, 113 .. 225 ]
gap> s3inb:= Mbarfusb[1]{ s3inMbar };
[ 1, 6, 2 ]
gap> 2bfusb:= GetFusionMap( 2b, b );;
gap> 2s3in2B:= InverseMap( 2bfusb ){ s3inb };
[ [ 1, 2 ], [ 8, 9 ], 3 ]
gap> CompositionMaps( OrdersClassRepresentatives( 2b ), 2s3in2B );
[ [ 1, 2 ], [ 3, 6 ], 2 ]
]]></Example>

<P/>

Thus the preimage <M>S</M> of <M>\overline{S}</M> contains elements of order
<M>6</M> but no elements of order <M>4</M>,
which implies that <M>S</M> is a direct product <M>2 \times S_3</M>.

<P/>

The two complements <M>C_1</M>, <M>C_2</M> of <M>Z</M> in <M>S</M> are normal
in the preimage <M>N</M> of <M>\overline{N} = S_3 \times Fi_{22}</M>,
which is thus of type <M>S_3 \times 2.Fi_{22}</M>.
However, they are conjugate under the action of <M>2.Fi_{22}.2</M>,
as no class fusion from <M>S_3 \times 2.Fi_{22}.2</M> into <M>2.B</M> is
possible.

<P/>

<Example><![CDATA[
gap> PossibleClassFusions( s3 * 2fi222, 2b );
[  ]
]]></Example>

<P/>

(More specifically, the classes of element order <M>36</M> in
<M>2.Fi_{22}.2</M> have centralizer orders <M>36</M> and <M>72</M>,
so their centralizer orders in
<M>S_3 \times 2.Fi_{22}.2</M> are <M>216</M> and <M>432</M>;
but the centralizers of order <M>36</M> elements in <M>2.B</M> have
centralizer order at most <M>216</M>.)

<P/>

Now let us see how the character table of <M>M</M> can be constructed.

<P/>

Let <M>Y</M> denote the normal subgroup of order <M>3</M> in <M>M</M>,
and <M>U</M> its centralizer in <M>M</M>, which has index <M>2</M> in
<M>M</M>.
Then the character table of <M>M</M> is determined by the tables of
<M>M/Y</M>, <M>U</M>, <M>U/Y \cong 2.Fi_{22}.2</M>, and the action of
<M>M</M> on the classes of <M>U</M>.

<P/>

As for <M>M/Y</M>, consider the normal subgroup <M>N = N_M(C_1)</M> of index
<M>2</M> in <M>M</M>.
In particular, <M>S/Y</M> is central in <M>N/Y</M> but not in <M>M/Y</M>,
so the character table of <M>M/Y</M> is determined by the tables of
<M>M/(YZ)</M>, <M>N/Y \cong 2 \times 2.Fi_{22}</M>,
<M>N/(YZ) \cong 2 \times Fi_{22}</M>,
and the action of <M>M/Y</M> on the classes of <M>N/Y</M>.

<P/>

Thus we proceed in two steps, starting with the computation of the
character table of <M>M/Y</M>, for which we choose the name according to the
structure <M>2^2.Fi_{22}.2</M>.

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons12.png" alt="The structure of 2.(S_3 x Fi_22.2)"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
                                 M
                                ╱│╲
                               N . U
                              ╱ ╲│╱│
                             ╱   . │
                            ╱   ╱│ .
                           S   ╱ │╱
                          ╱│╲ ╱  .
                        C1 . 6  ╱
                          ╲│╱│ ╱
                           Y │╱
                           │ Z
                           │╱
                           1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons12 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(45,40)(0,0)
\put(15,0){\circle*{1}}
\put(15,10){\circle*{1}} \put(18,9){\makebox(0,0){$Y$}}
\put(10,15){\circle{1}} \put(7,15){\makebox(0,0){$C_1$}}
\put(15,15){\circle{1}} \put(13,15){\makebox(0,0){$C_2$}}
\put(20,15){\circle*{1}} \put(23,14){\makebox(0,0){$6$}}
\put(15,20){\circle*{1}} \put(12,21){\makebox(0,0){$S$}}
\put(20,5){\circle*{1}} \put(23,4){\makebox(0,0){$Z$}}
\put(30,15){\circle*{1}}
\put(35,20){\circle*{1}}
\put(30,25){\circle*{1}}
\put(35,30){\circle*{1}} \put(38,30){\makebox(0,0){$U$}}
\put(30,30){\circle*{1}}
\put(25,30){\circle*{1}} \put(22,31){\makebox(0,0){$N$}}
\put(30,35){\circle*{1}} \put(30,38){\makebox(0,0){$M$}}
\put(15,0){\line(1,1){20}}
\put(15,10){\line(1,1){20}}
\put(10,15){\line(1,1){20}}
\put(15,0){\line(0,1){20}}
\put(20,5){\line(0,1){10}}
\put(30,15){\line(0,1){20}}
\put(35,20){\line(0,1){10}}
\put(15,10){\line(-1,1){5}}
\put(20,15){\line(-1,1){5}}
\put(30,25){\line(-1,1){5}}
\put(35,30){\line(-1,1){5}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

<Example><![CDATA[
gap> c2:= CharacterTable( "Cyclic", 2 );;
gap> 2fi22:= CharacterTable( "2.Fi22" );;
gap> tblNmodY:= c2 * 2fi22;;
gap> centre:= GetFusionMap( 2fi22, tblNmodY ){
>                 ClassPositionsOfCentre( 2fi22 ) };
[ 1, 2 ]
gap> tblNmod6:= tblNmodY / centre;;
gap> tblMmod6:= c2 * fi222;;
gap> fus:= PossibleClassFusions( tblNmod6, tblMmod6 );;
gap> Length( fus );
1
gap> StoreFusion( tblNmod6, fus[1], tblMmod6 );
gap> elms:= PossibleActionsForTypeMGA( tblNmodY, tblNmod6, tblMmod6 );;
gap> Length( elms );
1
gap> poss:= PossibleCharacterTablesOfTypeMGA( tblNmodY, tblNmod6, tblMmod6,
>               elms[1], "2^2.Fi22.2" );;
gap> Length( poss );
1
gap> tblMmodY:= poss[1].table;
CharacterTable( "2^2.Fi22.2" )
]]></Example>

<P/>

So we found a unique solution for the character table of <M>M/Y</M>.
Now we compute the table of <M>M</M>.
For that, we have to specify the class fusion of <M>U/Y</M> into <M>M/Y</M>;
it is unique up to table automorphisms of <M>M/Y</M>.

<P/>

<Example><![CDATA[
gap> tblU:= c3 * 2fi222;;
gap> tblUmodY:= tblU / GetFusionMap( c3, tblU );;
gap> fus:= PossibleClassFusions( tblUmodY, tblMmodY );;
gap> Length( RepresentativesFusions( Group( () ), fus, tblMmodY ) );
1
gap> StoreFusion( tblUmodY, fus[1], tblMmodY );
gap> elms:= PossibleActionsForTypeMGA( tblU, tblUmodY, tblMmodY );;
gap> Length( elms );
1
gap> poss:= PossibleCharacterTablesOfTypeMGA( tblU, tblUmodY, tblMmodY,
>               elms[1], "(S3x2.Fi22).2" );;
gap> Length( poss );
1
gap> tblM:= poss[1].table;
CharacterTable( "(S3x2.Fi22).2" )
gap> mfus2b:= PossibleClassFusions( tblM, 2b );;
gap> Length( RepresentativesFusions( tblM, mfus2b, 2b ) );
1
]]></Example>

<P/>

We did not construct <M>M</M> as a central extension of <M>\overline{M}</M>,
so we verify that the tables fit together; note that this way we get also
the class fusion from <M>M</M> onto <M>\overline{M}</M>.

<P/>

<Example><![CDATA[
gap> Irr( tblM / ClassPositionsOfCentre( tblM ) ) = Irr( tblMbar );
true
]]></Example>

<P/>

Finally, we compare the table we constructed with the one that is contained
in the &GAP; Character Table Library.

<P/>

<Example><![CDATA[
gap> IsRecord( TransformingPermutationsCharacterTables( tblM,
>                  CharacterTable( "(S3x2.Fi22).2" ) ) );
true
]]></Example>

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:(2x2.Fi22):2_in_Fi24">
<Heading>The Character Table of <M>(2 \times 2.Fi_{22}):2 &lt; Fi_{24}</M> (November&nbsp;2008)</Heading>

The automorphism group <M>Fi_{24}</M> of the sporadic simple group
<M>Fi_{24}^{\prime}</M> contains a maximal subgroup
<M>N</M> of the type <M>(2 \times 2.Fi_{22}):2</M>,
whose intersection with <M>Fi_{24}^{\prime}</M> is <M>2.Fi_{22}.2</M>
(see&nbsp;<Cite Key="CCN85" Where="p. 207"/>).

<P/>

The normal Klein four group <M>V</M> in <M>N</M>
contains two <C>2C</C> elements in <M>Fi_{24}</M>,
because the <C>2C</C> centralizer in <M>Fi_{24}</M>, a group of the structure
<M>2 \times Fi_{23}</M>,
contains maximal subgroups of the type <M>2 \times 2.Fi_{22}</M>,
and so the two <C>2C</C> type subgroups <M>C_1</M>, <M>C_2</M> in <M>V</M>
are conjugate in <M>N</M>,
and <M>Z = Z(N)</M> is the centre of <M>N \cap Fi_{24}^{\prime}</M>.

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons13.png" alt="The structure of (2 x 2.Fi_22):2"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
                                 N
                                ╱│╲
                               U . N ⌒ Fi_24'
                              ╱ ╲│╱
                             ╱   .
                            ╱   ╱
                           V   ╱
                          ╱│╲ ╱
                        C1 . Z
                          ╲│╱
                           1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons13 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(45,25)(0,17)
\put(15,15){\circle*{1}}
\put(10,20){\circle{1}} \put(7,20){\makebox(0,0){$C_1$}}
\put(15,20){\circle{1}} \put(13,20){\makebox(0,0){$C_2$}}
\put(20,20){\circle*{1}} \put(23,19){\makebox(0,0){$Z$}}
\put(15,25){\circle*{1}} \put(12,26){\makebox(0,0){$V$}}
\put(30,30){\circle*{1}}
\put(25,35){\circle*{1}} \put(22,36){\makebox(0,0){$U$}}
\put(30,35){\circle*{1}}
\put(35,35){\circle*{1}} \put(43,35){\makebox(0,0){$N \cap Fi_{24}^{\prime}$}}
\put(30,40){\circle*{1}} \put(30,43){\makebox(0,0){$N$}}
\put(15,15){\line(1,1){20}}
\put(10,20){\line(1,1){20}}
\put(15,15){\line(0,1){10}}
\put(30,30){\line(0,1){10}}
\put(15,15){\line(-1,1){5}}
\put(20,20){\line(-1,1){5}}
\put(30,30){\line(-1,1){5}}
\put(35,35){\line(-1,1){5}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

With <M>U = C_N(C_1)</M>, a group of the type <M>2 \times 2.Fi_{22}</M>,
we set <M>G = U / Z</M>, <M>M.G = U</M>, and <M>G.A = N / Z</M>.
The latter group is the direct product of <M>Fi_{22}.2</M> and a cyclic group
of order <M>2</M>.

<P/>

This is exactly the situation of the construction of the character table of
the group that is called <M>2^2.Fi_{22}.2</M> in
Section&nbsp;<Ref Subsect="subsect:2.BM9"/>,
where this group occurs as <Q><M>M/Y</M></Q>.
Since the character table is uniquely determined by the input data,
it is the table we are interested in here.

<P/>

So all we have to do is to compute the class fusion from this table into
that of <M>Fi_{24}</M>.

<P/>

<Example><![CDATA[
gap> fi24:= CharacterTable( "Fi24" );;
gap> t:= CharacterTable( "2^2.Fi22.2" );;
gap> fus:= PossibleClassFusions( t, fi24 );;
gap> Length( fus );
4
gap> Length( RepresentativesFusions( t, fus, fi24 ) );
1
]]></Example>

<P/>

(It should be noted that we did not need the character table of the
<M>2.Fi_{22}.2</M> type subgroup of <M>N</M> in the above construction,
only the tables of <M>2.Fi_{22}</M> and <M>Fi_{22}.2</M> were used.)

<P/>

The fact that the character table of a factor of a subgroup of <M>2.B</M>
occurs as the character table of a subgroup of <M>Fi_{24}</M>
is not a coincidence.
In fact, the groups <M>3.Fi_{24}</M> and <M>2.B</M> are subgroups of the
Monster group <M>M</M>,
and the subgroup <M>U = 2.(S_3 \times Fi_{22}.2)</M> of <M>2.B</M>
normalizes an element of order three.
The full normalizer of this element in <M>M</M> is <M>3.Fi_{24}</M>,
which means that we have established <M>U</M> as a (maximal) subgroup of
<M>3.Fi_{24}</M>.
Note that we have constructed the character table of <M>U</M>
in Section&nbsp;<Ref Subsect="subsect:2.BM9"/>.

<P/>

Let us compute the class fusion of <M>U</M> into <M>3.Fi_{24}</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "(S3x2.Fi22).2" );;
gap> 3fi24:= CharacterTable( "3.Fi24" );;                        
gap> fus:= PossibleClassFusions( t, 3fi24 );;
gap> Length( fus );
16
gap> Length( RepresentativesFusions( t, fus, 3fi24 ) );
1
gap> GetFusionMap( t, 3fi24 ) in fus; 
true
]]></Example>

<P/>

Moreover, <M>U</M> turns out to be the full normalizer of a <C>6A</C> element
in <M>M</M>,

<P/>

<Example><![CDATA[
gap> m:= CharacterTable( "M" );;
gap> tfusm:= PossibleClassFusions( t, m );;
gap> Length( tfusm );
4
gap> Length( RepresentativesFusions( t, tfusm, m ) );
1
gap> nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
>        x -> Sum( SizesConjugacyClasses( t ){ x } ) = 6 );
[ [ 1, 2, 142, 143 ] ]
gap> Set( tfusm, x -> x{ nsg[1] } );
[ [ 1, 2, 4, 13 ] ]
gap> OrdersClassRepresentatives( t ){ nsg[1] };
[ 1, 2, 3, 6 ]
gap> PowerMap( m, -1 )[13];
13
gap> Size( t ) = 2 * SizesCentralizers( m )[13];
true
]]></Example>

<!-- % Computing the fusion into M takes 2042788 msec ... -->

<P/>

(Thus <M>U</M> is also the full normalizer of an element of order six in
<M>2.B</M> and in <M>3.Fi_{24}</M>.)

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:S_3x2.U_4(3).2_2_in_2.Fi22">
<Heading>The Character Table of <M>S_3 \times 2.U_4(3).2_2 \leq 2.Fi_{22}</M> (September 2002)</Heading>

The sporadic simple Fischer group <M>Fi_{22}</M> contains a maximal subgroup
<M>\overline{M}</M> of type <M>S_3 \times U_4(3).2_2</M>
(see&nbsp;<Cite Key="CCN85" Where="p. 163"/>).
We claim that the preimage <M>M</M> of <M>\overline{M}</M> in the central
extension <M>2.Fi_{22}</M> has the structure <M>S_3 \times 2.U_4(3).2_2</M>,
where the factor of type <M>2.U_4(3).2_2</M> is the one printed in the
&ATLAS;.

<P/>

For that, we first note that the normal subgroup <M>\overline{S}</M> of type
<M>S_3</M> in <M>\overline{M}</M> lifts to a group <M>S</M> which has the
structure <M>2 \times S_3</M>.
This follows from the fact that all involutions in <M>Fi_{22}</M> lift to
involutions in <M>2.Fi_{22}</M> or, equivalently, the central involution in
<M>2.Fi_{22}</M> is not a square.

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons14.png" alt="The structure of S_3 x 2.U_4(3).2_2"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
                                 M
                                ╱ ╲
                               .   ╲
                              ╱ ╲   U
                             ╱   ╲ ╱
                            S     U'
                           ╱ ╲   ╱
                         S_3  ╲ ╱
                           ╲   .
                            ╲ ╱
                             1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons14 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(45,35)(0,0)
\put(15,0){\circle*{1}}
\put(5,10){\circle*{1}} \put(2,10){\makebox(0,0){$S_3$}}
\put(10,15){\circle*{1}} \put(8,16){\makebox(0,0){$S$}}
\put(20,25){\circle*{1}}
\put(20,5){\circle*{1}}
\put(30,15){\circle*{1}} \put(33,14){\makebox(0,0){$U^{\prime}$}}
\put(35,20){\circle*{1}} \put(38,20){\makebox(0,0){$U$}}
\put(25,30){\circle*{1}} \put(25,33){\makebox(0,0){$M$}}
\put(15,0){\line(1,1){20}}
\put(5,10){\line(1,1){20}}
\put(15,0){\line(-1,1){10}}
\put(20,5){\line(-1,1){10}}
\put(30,15){\line(-1,1){10}}
\put(35,20){\line(-1,1){10}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

<Example><![CDATA[
gap> 2Fi22:= CharacterTable( "2.Fi22" );;
gap> ClassPositionsOfCentre( 2Fi22 );
[ 1, 2 ]
gap> 2 in PowerMap( 2Fi22, 2 );
false
]]></Example>

<P/>

Second, the normal subgroup <M>\overline{U} \cong U_4(3).2_2</M> of <M>Fi_{22}</M>
lifts to a nonsplit extension <M>U</M> in <M>2.Fi_{22}</M>,
since <M>2.Fi_{22}</M> contains no <M>U_4(3)</M> type subgroup.
Furthermore, <M>U</M> is the <M>2.U_4(3).2_2</M> type group printed in the &ATLAS;
because the isoclinic variant does not admit a class fusion into <M>2.Fi_{22}</M>.

<P/>

<Example><![CDATA[
gap> PossibleClassFusions( CharacterTable( "U4(3)" ), 2Fi22 );
[  ]
gap> tblU:= CharacterTable( "2.U4(3).2_2" );;
gap> iso:= CharacterTableIsoclinic( tblU );
CharacterTable( "Isoclinic(2.U4(3).2_2)" )
gap> PossibleClassFusions( iso, 2Fi22 );                      
[  ]
]]></Example>

<P/>

Now there are just two possibilities.
Either the two <M>S_3</M> type subgroups in <M>S</M> are normal in <M>M</M>
(and thus <M>M</M> is the direct product of any such <M>S_3</M> with the preimage
of the <M>U_4(3).2_2</M> type subgroup),
or they are conjugate in <M>M</M>.

<P/>

Suppose we are in the latter situation,
let <M>z</M> be a generator of the centre of <M>2.Fi_{22}</M>,
and let <M>\tau</M>, <M>\sigma</M> be an involution and an order three element
respectively, in one of the <M>S_3</M> type subgroups.

<P/>

Each element <M>g \in U \setminus U^{\prime}</M> conjugates <M>\tau</M> to an
involution in the other <M>S_3</M> type subgroup of <M>S</M>,
so <M>g^{-1} \tau g = \tau \sigma^{i} z</M> for some <M>i \in \{ 0, 1, 2 \}</M>.
Furthermore, it is possible to choose <M>g</M> as an involution.

<P/>

<Example><![CDATA[
gap> derpos:= ClassPositionsOfDerivedSubgroup( tblU );;
gap> outer:= Difference( [ 1 .. NrConjugacyClasses( tblU ) ], derpos );;
gap> 2 in OrdersClassRepresentatives( tblU ){ outer };
true
]]></Example>

<P/>

With this choice, <M>(g \tau)^2 = \tau \sigma^{i} z \tau = \sigma^{-i} z</M>
holds, which means that <M>(g \tau)^3</M> squares to <M>z</M>.
As we have seen above, this is impossible,
hence <M>M</M> is a direct product, as claimed.

<P/>

The class fusion of <M>M</M> into <M>2.Fi_{22}</M> is determined by the character
tables, up to table automorphisms.

<P/>

<Example><![CDATA[
gap> tblM:= CharacterTable( "Dihedral", 6 ) * tblU;;
gap> fus:= PossibleClassFusions( tblM, 2Fi22 );;
gap> Length( RepresentativesFusions( tblM, fus, 2Fi22 ) );
1
gap> IsRecord( TransformingPermutationsCharacterTables( tblM,
>                  CharacterTable( "2.Fi22M8" ) ) );
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:HN2">
<Heading>The Character Table of <M>4.HS.2 \leq HN.2</M> (May 2002)</Heading>

<!-- % Eamonn needed this table but did not ask for it ... -->

The maximal subgroup <M>U</M> of type <M>2.HS.2</M> in the sporadic simple group <M>HN</M>
extends to a group <M>N</M> of structure <M>4.HS.2</M> in the automorphism group
<M>HN.2</M> of <M>HN</M> (see&nbsp;<Cite Key="CCN85" Where="p. 166"/>).

<P/>

<M>N</M> is the normalizer of a <C>4D</C> element <M>g \in HN.2 \setminus HN</M>.
The centralizer <M>C</M> of <M>g</M> is of type <M>4.HS</M>, which is the central product of
<M>2.HS</M> and the cyclic group <M>\langle g \rangle</M> of order <M>4</M>.
We have <M>Z = Z(N) = \langle g^2 \rangle</M>.
Since <M>U/Z \cong HS.2</M> is a complement of <M>\langle g \rangle / Z</M>
in <M>N/Z</M>,
the factor group <M>N/Z</M> is a direct product of <M>HS.2</M> and a cyclic
group of order <M>2</M>.

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons15.png" alt="The structure of 4.HS.2"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
                                 N
                                ╱│╲
                               C . U
                              ╱ ╲│╱
                             ╱   .
                            ╱   ╱
                          ⟨g⟩  ╱
                            ╲ ╱
                             Z
                             │ 
                             1
</Verb>
</Alt>


<Alt Only='LaTeX'>
<!-- BP ctblcons15 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(45,25)(0,0)
\put(15,0){\circle*{1}}
\put(15,5){\circle*{1}} \put(18,4){\makebox(0,0){$Z$}}
\put(10,10){\circle*{1}} \put(7,10){\makebox(0,0){$\langle g \rangle$}}
\put(25,15){\circle*{1}}
\put(20,20){\circle*{1}} \put(18,22){\makebox(0,0){$C$}}
\put(25,20){\circle*{1}}
\put(30,20){\circle*{1}} \put(33,20){\makebox(0,0){$U$}}
\put(25,25){\circle*{1}} \put(25,28){\makebox(0,0){$N$}}
\put(15,5){\line(1,1){15}}
\put(10,10){\line(1,1){15}}
\put(15,0){\line(0,1){5}}
\put(25,15){\line(0,1){10}}
\put(15,5){\line(-1,1){5}}
\put(25,15){\line(-1,1){5}}
\put(30,20){\line(-1,1){5}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

Thus <M>N</M> has the structure <M>2.G.2</M>, the normal subgroup <M>2.G</M> being <M>C</M>,
the factor group <M>G.2</M> being <M>2 \times HS.2</M>,
and <M>G</M> being <M>2 \times HS</M>.
Each element in <M>N \setminus C</M> inverts <M>g</M>, so <M>N</M> acts fixed point
freely on the faithful irreducible characters of <M>C</M>.
Hence we can use
<Ref Func="PossibleCharacterTablesOfTypeMGA" BookName="ctbllib"/>
for constructing the character table of <M>N</M> from the tables of <M>C</M>
and <M>N/Z</M> and the action of <M>N</M> on the classes of <M>C</M>.

<P/>

We start with the table of the central product <M>C</M>.
It can be viewed as an isoclinic table of the direct product of
<M>2.HS</M> and a cyclic group of order <M>2</M>, see&nbsp;<Ref Subsect="subsect:isoclinism"/>.

<P/>

<Example><![CDATA[
gap> c2:= CharacterTable( "Cyclic", 2 );;
gap> tblC:= CharacterTableIsoclinic( CharacterTable( "2.HS" ) * c2 );;
]]></Example>

<P/>

The table of <M>G</M> is given as that of the factor group by the unique
normal subgroup of <M>C</M> that consists of two conjugacy classes.

<P/>

<Example><![CDATA[
gap> ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),
>               x -> Length( x ) = 2 );
[ [ 1, 3 ] ]
gap> tblCbar:= tblC / ord2[1];;
]]></Example>

<P/>

Finally, we construct the table of the extension <M>G.2</M>
and the class fusion of <M>G</M> into this table (which is uniquely determined
by the character tables).

<P/>

<Example><![CDATA[
gap> tblNbar:= CharacterTable( "HS.2" ) * c2;;
gap> fus:= PossibleClassFusions( tblCbar, tblNbar );
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 
      19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 29, 30, 31, 32, 
      33, 34, 35, 36, 35, 36, 37, 38, 39, 40, 41, 42, 41, 42 ] ]
gap> StoreFusion( tblCbar, fus[1], tblNbar );
]]></Example>

<P/>

Now we compute the table automorphisms of the table of <M>C</M> that are
compatible with the extension <M>N</M>; we get two solutions.

<P/>

<Example><![CDATA[
gap> elms:= PossibleActionsForTypeMGA( tblC, tblCbar, tblNbar );
[ [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6, 8 ], [ 7 ], [ 9 ], [ 10 ], 
      [ 11 ], [ 12, 14 ], [ 13 ], [ 15 ], [ 16, 18 ], [ 17 ], [ 19 ], 
      [ 20 ], [ 21 ], [ 22 ], [ 23 ], [ 24, 26 ], [ 25 ], [ 27 ], 
      [ 28, 30 ], [ 29 ], [ 31 ], [ 32, 34 ], [ 33 ], [ 35 ], 
      [ 36, 38 ], [ 37 ], [ 39 ], [ 40, 42 ], [ 41 ], [ 43 ], 
      [ 44, 46 ], [ 45 ], [ 47 ], [ 48, 50 ], [ 49 ], [ 51, 53 ], 
      [ 52, 54 ], [ 55 ], [ 56, 58 ], [ 57 ], [ 59 ], [ 60 ], 
      [ 61, 65 ], [ 62, 68 ], [ 63, 67 ], [ 64, 66 ], [ 69 ], 
      [ 70, 72 ], [ 71 ], [ 73 ], [ 74, 76 ], [ 75 ], [ 77, 81 ], 
      [ 78, 84 ], [ 79, 83 ], [ 80, 82 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6, 8 ], [ 7 ], [ 9 ], [ 10 ], 
      [ 11 ], [ 12, 14 ], [ 13 ], [ 15, 17 ], [ 16 ], [ 18 ], [ 19 ], 
      [ 20 ], [ 21 ], [ 22 ], [ 23 ], [ 24, 26 ], [ 25 ], [ 27 ], 
      [ 28, 30 ], [ 29 ], [ 31 ], [ 32, 34 ], [ 33 ], [ 35, 37 ], 
      [ 36 ], [ 38 ], [ 39 ], [ 40, 42 ], [ 41 ], [ 43 ], [ 44, 46 ], 
      [ 45 ], [ 47, 49 ], [ 48 ], [ 50 ], [ 51, 53 ], [ 52, 54 ], 
      [ 55 ], [ 56, 58 ], [ 57 ], [ 59 ], [ 60 ], [ 61, 65 ], 
      [ 62, 68 ], [ 63, 67 ], [ 64, 66 ], [ 69, 71 ], [ 70 ], [ 72 ], 
      [ 73 ], [ 74, 76 ], [ 75 ], [ 77, 83 ], [ 78, 82 ], [ 79, 81 ], 
      [ 80, 84 ] ] ]
]]></Example>

<P/>

We compute the possible character tables arising from these two actions.

<P/>

<Example><![CDATA[
gap> poss:= List( elms, pi -> PossibleCharacterTablesOfTypeMGA(
>                 tblC, tblCbar, tblNbar, pi, "4.HS.2" ) );;
gap> List( poss, Length );
[ 0, 2 ]
]]></Example>

<P/>

So one of the two table automorphisms turned out to be impossible;
the reason is that the corresponding <Q>character table</Q> would not admit
a <M>2</M>-power map.
(Alternatively, we could exclude this action on <M>C</M> by the fact
that it is not compatible with the action of <M>2.HS.2</M> on its subgroup
<M>2.HS</M>, which occurs here as the restriction of the action of <M>N</M> on <M>C</M>
to that of <M>U</M> on <M>C \cap U</M>.)

<P/>

The other table automorphism leads to two possible character tables.
This is not surprising since <M>N</M> contains a subgroup of type
<M>2.HS.2</M>, and the above setup does not determine which of the two isoclinism
types of this group occurs.
Let us look at the possible class fusions from these tables into that of
<M>HN.2</M>:

<P/>

<Example><![CDATA[
gap> result:= poss[2];;
gap> hn2:= CharacterTable( "HN.2" );;
gap> possfus:= List( result, r -> PossibleClassFusions( r.table, hn2 ) );;
gap> List( possfus, Length );
[ 32, 0 ]
gap> RepresentativesFusions( result[1].table, possfus[1], hn2 );
[ [ 1, 46, 2, 2, 47, 3, 7, 45, 4, 58, 13, 6, 46, 47, 6, 47, 7, 48, 
      10, 62, 20, 9, 63, 21, 12, 64, 24, 27, 49, 50, 13, 59, 14, 16, 
      70, 30, 18, 53, 52, 17, 54, 20, 65, 22, 36, 56, 26, 76, 39, 77, 
      28, 59, 58, 31, 78, 41, 34, 62, 35, 65, 2, 45, 3, 45, 6, 48, 7, 
      47, 17, 54, 13, 49, 13, 50, 14, 50, 18, 53, 18, 52, 21, 56, 25, 
      57, 27, 59, 30, 60, 44, 72, 34, 66, 35, 66, 41, 71 ] ]
]]></Example>

<P/>

Only one of the candidates admits an embedding,
and the class fusion is unique up to table automorphisms.
So we are done.

<P/>

Finally, we compare the table we have constructed with the one that is
contained in the &GAP; Character Table Library.

<P/>

<Example><![CDATA[
gap> libtbl:= CharacterTable( "4.HS.2" );;
gap> IsRecord( TransformingPermutationsCharacterTables( result[1].table,
>                  libtbl ) );
true
]]></Example>

<P/>

(The following paragraphs have been added in May 2006.)

<P/>

The Brauer tables of <M>N = 2.G.2</M> can be constructed as in
Section&nbsp;<Ref Subsect="subsect:ATLASMGA"/>.
Note that the Brauer tables of <M>C = 2.G</M> and of <M>N / Z = G.2</M>
are automatically available because the ordinary tables constructed above
arose as a direct product and as an isoclinic table of a direct product,
and the &GAP; Character Table Library contains the Brauer tables of the
direct factors involved.

<P/>

<Example><![CDATA[
gap> StoreFusion( tblC, result[1].MGfusMGA, result[1].table );
gap> ForAll( PrimeDivisors( Size( result[1].table ) ),
>            p -> IsRecord( TransformingPermutationsCharacterTables(
>                     BrauerTableOfTypeMGA( tblC mod p, tblNbar mod p,
>                         result[1].table ).table, libtbl mod p ) ) );
true
]]></Example>

<P/>

Here it is advantageous that the Brauer table of <M>C / Z = G</M> is not needed
in the construction,
since &GAP; does not know how to compute the <M>p</M>-modular table of the
ordinary table of <M>G</M> constructed above.
Of course we have <M>G \cong 2 \times HS</M>,
and the <M>p</M>-modular table of <M>HS</M> is known,
but in the construction of the table of <M>G</M> as a factor of
the table of <M>2.G</M>,
the information is missing that the nonsolvable simple direct factor of
<M>2.G</M> corresponds to the library table of <M>HS</M>.

<!--
 The missing information could be provided by setting the attribute
 that tells &GAP; about the decomposition as a direct product,
 and storing the factor fusions to the library table of the two factors.
-->

<!--

% <Example><![CDATA[
% gap> tblCbar;
% CharacterTable( "Isoclinic(2.HSxC2)/[ 1, 3 ]" )
% gap> cen:= ClassPositionsOfCentre( tblCbar );;
% gap> simp:= tblCbar / cen;
% CharacterTable( "Isoclinic(2.HSxC2)/[ 1, 3 ]/[ 1, 2 ]" )
% gap> libsimp:= CharacterTable( "HS" );;
% gap> TransformingPermutationsCharacterTables( simp, libsimp );
% rec( columns := (), rows := (), group := Group([ (23,24), (19,20), (15,16) ]) 
%  )
% gap> StoreFusion( tblCbar, GetFusionMap( tblCbar, simp ), libsimp );
% gap> SetFactorsOfDirectProduct( tblCbar, [ libsimp, c2 ] );
% gap> dpdecomp:= ClassPositionsOfDirectProductDecompositions( tblCbar );
% [ [ [ 1, 2 ], [ 1, 3 .. 47 ] ] ]
% gap> factc2:= tblCbar / dpdecomp[1][2];;
% gap> StoreFusion( tblCbar, GetFusionMap( tblCbar, factc2 ), c2 );
% ]]></Example>

-->

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:4.A_6.2_3, 12.A_6.2_3, 4.L_2(25).2_3">
<Heading>The Character Tables of <M>4.A_6.2_3</M>, <M>12.A_6.2_3</M>,
and <M>4.L_2(25).2_3</M></Heading>

For the <Q>broken box</Q> cases in the &ATLAS;
(see&nbsp;<Cite Key="CCN85" Where="p. xxiv"/>),
the character tables can be constructed with the <M>M.G.A</M> construction
method from Section&nbsp;<Ref Subsect="subsect:theorMGA"/>.
(The situation with <M>9.U_3(8).3_3</M> is more complicated,
this group will be considered in
Section&nbsp;<Ref Subsect="subsect:9.U_3(8).3_3"/>.)

<P/>

The group <M>N = 4.A_6.2_3</M> (see&nbsp;<Cite Key="CCN85" Where="p. 5"/>)
can be described as an upward extension of the normal subgroup
<M>C \cong 4.A_6</M>
&ndash;which is a central product of <M>U = 2.A_6</M> and a cyclic group
<M>\langle g \rangle</M> of order <M>4</M>&ndash;
by a cyclic group of order <M>2</M>,
such that the factor group of <M>N</M> by the central subgroup
<M>Z = \langle g^2 \rangle</M> of order <M>2</M>
is isomorphic to a subdirect product
<M>\overline{N}</M> of <M>M_{10} = A_6.2_3</M>
and a cyclic group of order <M>4</M>
and that <M>N</M> acts nontrivially on its normal subgroup
<M>\langle g \rangle</M>.

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons16.png" alt="The structure of 4.A_6.2_3"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
                                 N
                                 │
                                 C
                                ╱ ╲
                               ╱   U
                             ⟨g⟩  ╱
                               ╲ ╱
                                Z
                                │
                                1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons16 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(25,30)(0,0)
\put(10,0){\circle*{1}}
\put(10,5){\circle*{1}} \put(7,4){\makebox(0,0){$Z$}}
\put(5,10){\circle*{1}} \put(2,10){\makebox(0,0){$\langle g \rangle$}}
\put(20,15){\circle*{1}} \put(23,15){\makebox(0,0){$U$}}
\put(15,20){\circle*{1}} \put(12,20){\makebox(0,0){$C$}}
\put(15,25){\circle*{1}} \put(15,28){\makebox(0,0){$N$}}
\put(10,5){\line(1,1){10}}
\put(5,10){\line(1,1){10}}
\put(10,0){\line(0,1){5}}
\put(15,20){\line(0,1){5}}
\put(10,5){\line(-1,1){5}}
\put(20,15){\line(-1,1){5}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

Thus <M>N</M> has the structure <M>2.G.2</M>,
with <M>2.G = C</M> and <M>G.2 = \overline{N}</M>.
These two groups are isoclinic variants of <M>2 \times 2.A_6</M> and of
<M>2 \times M_{10}</M>, respectively.
Each element in <M>N \setminus C</M> inverts <M>g</M>, so it acts fixed point
freely on the faithful irreducible characters of <M>C</M>.
Hence we can use
<Ref Func="PossibleCharacterTablesOfTypeMGA" BookName="ctbllib"/>
for constructing the character table of <M>N</M>
from the tables of <M>C</M> and <M>N/Z</M>
and the action of <M>N</M> on the classes of <M>C</M>.

<P/>

<Example><![CDATA[
gap> c2:= CharacterTable( "Cyclic", 2 );;
gap> 2a6:= CharacterTable( "2.A6" );;
gap> tblC:= CharacterTableIsoclinic( 2a6 * c2 );;
gap> ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),
>               x -> Length( x ) = 2 );
[ [ 1, 3 ] ]
gap> tblG:= tblC / ord2[1];;
gap> tblNbar:= CharacterTableIsoclinic( CharacterTable( "A6.2_3" ) * c2 );;
gap> fus:= PossibleClassFusions( tblG, tblNbar );
[ [ 1, 2, 3, 4, 5, 6, 5, 6, 7, 8, 9, 10, 9, 10 ] ]
gap> StoreFusion( tblG, fus[1], tblNbar );
gap> elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );
[ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 12 ], 
      [ 9, 13 ], [ 10, 14 ], [ 15, 17 ], [ 16, 18 ], [ 19, 23 ], 
      [ 20, 24 ], [ 21, 25 ], [ 22, 26 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 14 ], 
      [ 9, 13 ], [ 10, 12 ], [ 15 ], [ 16, 18 ], [ 17 ], [ 19, 23 ], 
      [ 20, 26 ], [ 21, 25 ], [ 22, 24 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 14 ], 
      [ 9, 13 ], [ 10, 12 ], [ 15, 17 ], [ 16 ], [ 18 ], [ 19, 23 ], 
      [ 20, 26 ], [ 21, 25 ], [ 22, 24 ] ] ]
gap> poss:= List( elms, pi -> PossibleCharacterTablesOfTypeMGA(
>                 tblC, tblG, tblNbar, pi, "4.A6.2_3" ) );
[ [  ], [  ], 
  [ 
      rec( 
          MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 9, 6, 9, 8, 7, 10, 
              11, 10, 12, 13, 14, 15, 16, 13, 16, 15, 14 ], 
          table := CharacterTable( "4.A6.2_3" ) ) ] ]
]]></Example>

<P/>

So we get a unique solution.
It coincides with the character table of <M>4.A_6.2_3</M> that is stored
in the &GAP; Character Table Library.

<P/>

<Example><![CDATA[
gap> t:= poss[3][1].table;;
gap> IsRecord( TransformingPermutationsCharacterTables( t,
>                  CharacterTable( "4.A6.2_3" ) ) );
true
]]></Example>

<P/>

Note that the first two candidates for the action lead to tables
that do not admit a <M>2</M>-power map.
In fact the <M>2</M>-power map of the character table of <M>4.A_6.2_3</M> is not
uniquely determined by the matrix of character values.
However, the <M>2</M>-power map is unique up to automorphisms of this matrix;
the function
<Ref Func="PossibleCharacterTablesOfTypeMGA" BookName="ctbllib"/>
takes this into account, and returns only representatives,
in this case one table.

<!-- %T Show this explicitly! -->
<!-- % The four classes of order <M>16</M> elements square to a pair of -->
<!-- % Galois conjugate classes of element order <M>8</M>, -->
<!-- % which differ only on two irreducible characters -->
<!-- % that are equal on all other classes. -->

<P/>

As is mentioned in the &ATLAS; (see <Cite Key="CCN85" Where="Section 6.7"/>),
the group <M>\Gamma L(2,9)</M> contains subgroups of the structure
<M>4.A_6.2_3</M>.
We can find them as follows.

<P/>

<Example><![CDATA[
gap> g:= GammaL(2,9);;
gap> phi:= IsomorphismPermGroup( g );;
gap> img:= Image( phi );;
gap> der:= DerivedSubgroup( img );;
gap> derder:= DerivedSubgroup( der );;
gap> Index( img, derder );
16
gap> inter:= Filtered( IntermediateSubgroups( img, derder ).subgroups,
>                s -> Size( s ) = 4 * Size( derder ) and
>                     IsCyclic( CommutatorFactorGroup( s ) ) and
>                     Size( Centre( s ) ) = 2 );;
gap> Length( inter );
2
gap> ForAll( inter, x -> IsConjugate( img, inter[1], x ) );
true
gap> IsRecord( TransformingPermutationsCharacterTables( t,
>                  CharacterTable( inter[1] ) ) );
true
]]></Example>

<P/>

The &ATLAS; states in&nbsp;<Cite Key="CCN85" Where="Section 6.7"/>
that there is a group of the structure <M>2^2.A_6.2_3</M>
that is isoclinic with <M>4.A_6.2_3</M>.
We construct also the character table of the <M>2^2.A_6.2_3</M> type group
with the <M>M.G.A</M> construction method
from Section&nbsp;<Ref Subsect="subsect:theorMGA"/>.

<P/>

The group <M>N = 2^2.A_6.2_3</M> can be described as an
upward extension of the normal subgroup <M>C \cong 2 \times 2.A_6</M>
by a cyclic group of order <M>2</M>,
such that the factor group of <M>N</M> by the central subgroup
<M>Z</M> of order <M>2</M> that is contained in <M>U = C' \cong 2.A_6</M>
is isomorphic to a subdirect product <M>\overline{N}</M>
of <M>M_{10} = A_6.2_3</M> and a cyclic group of order <M>4</M>
and that <M>N</M> acts nontrivially on the centre of <M>C</M>,
which is a Klein four group.

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons17.png" alt="The structure of 2^2.A_6.2_3"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
                                 N
                                 │
                                 C
                                ╱ ╲
                               ╱   U
                              .   ╱
                             ╱│╲ ╱
                            . . Z
                             ╲│╱
                              1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons17 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(25,30)(0,0)
\put(5,0){\circle*{1}}
\put(0,5){\circle{1}}
\put(5,5){\circle{1}}
\put(10,5){\circle*{1}} \put(7,4){\makebox(0,0){$Z$}}
\put(5,10){\circle*{1}}
\put(20,15){\circle*{1}} \put(23,15){\makebox(0,0){$U$}}
\put(15,20){\circle*{1}} \put(12,20){\makebox(0,0){$C$}}
\put(15,25){\circle*{1}} \put(15,28){\makebox(0,0){$N$}}
\put(5,0){\line(1,1){15}}
\put(0,5){\line(1,1){15}}
\put(5,0){\line(0,1){10}}
\put(15,20){\line(0,1){5}}
\put(5,0){\line(-1,1){5}}
\put(10,5){\line(-1,1){5}}
\put(20,15){\line(-1,1){5}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

Thus <M>N</M> has the structure <M>2.G.2</M>,
with <M>2.G = C</M> and <M>G.2 = \overline{N}</M>.
These latter group is an isoclinic variant of <M>2 \times M_{10}</M>,
as in the construction of <M>4.A_6.2_3</M>.
Each element in <M>N \setminus C</M> swaps the two involutions in
<M>Z(C) \setminus Z</M>, so it acts fixed point freely
on those irreducible characters of <M>C</M>
whose kernels do not contain <M>Z</M>.
Hence we can use
<Ref Func="PossibleCharacterTablesOfTypeMGA" BookName="ctbllib"/>
for constructing the character table of <M>N</M> from the tables of <M>C</M>
and <M>N/Z</M> and the action of <M>N</M> on the classes of <M>C</M>.

<P/>

<Example><![CDATA[
gap> tblC:= 2a6 * c2;;
gap> z:= GetFusionMap( 2a6, tblC ){ ClassPositionsOfCentre( 2a6 ) };
[ 1, 3 ]
gap> tblG:= tblC / z;;
gap> tblNbar:= CharacterTableIsoclinic( CharacterTable( "A6.2_3" ) * c2 );;
gap> fus:= PossibleClassFusions( tblG, tblNbar );
[ [ 1, 2, 3, 4, 5, 6, 5, 6, 7, 8, 9, 10, 9, 10 ] ]
gap> StoreFusion( tblG, fus[1], tblNbar );
gap> elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );
[ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 12 ], 
      [ 9, 13 ], [ 10, 14 ], [ 15, 17 ], [ 16, 18 ], [ 19, 23 ], 
      [ 20, 24 ], [ 21, 25 ], [ 22, 26 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 14 ], 
      [ 9, 13 ], [ 10, 12 ], [ 15 ], [ 16, 18 ], [ 17 ], [ 19, 23 ], 
      [ 20, 26 ], [ 21, 25 ], [ 22, 24 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 14 ], 
      [ 9, 13 ], [ 10, 12 ], [ 15, 17 ], [ 16 ], [ 18 ], [ 19, 23 ], 
      [ 20, 26 ], [ 21, 25 ], [ 22, 24 ] ] ]
gap> poss:= List( elms, pi -> PossibleCharacterTablesOfTypeMGA(
>                 tblC, tblG, tblNbar, pi, "2^2.A6.2_3" ) );
[ [  ], [  ], 
  [ 
      rec( 
          MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 9, 6, 9, 8, 7, 10, 
              11, 10, 12, 13, 14, 15, 16, 13, 16, 15, 14 ], 
          table := CharacterTable( "2^2.A6.2_3" ) ) ] ]
]]></Example>

<P/>

So we get a unique solution.

<!-- %T Transform between the two tables, -->
<!-- %T using that 2^2.A6.2_3 and 4.A6.2_3 can be embedded into -->
<!-- %T 8 Y 4.A6.2_3 = 8 Y 2^2.A6.2_3. -->

<P/>

The group <M>N = 12.A_6.2_3</M> (see&nbsp;<Cite Key="CCN85" Where="p. 5"/>) can be described as an
upward extension of the normal subgroup <M>C \cong 12.A_6</M>
&ndash;which is a central product of <M>U = 6.A_6</M> and a cyclic group
<M>\langle g \rangle</M> of order <M>4</M>&ndash;
by a cyclic group of order <M>2</M>,
such that the factor group of <M>N</M> by the central subgroup
<M>Z = \langle g^2 \rangle</M> of order <M>2</M>
is isomorphic to a subdirect product <M>\overline{N}</M> of <M>3.M_{10} = 3.A_6.2_3</M>
and a cyclic group of order <M>4</M>
and that <M>N</M> acts nontrivially on its normal subgroup <M>\langle g \rangle</M>.

<P/>

Note that <M>N</M> has a central subgroup <M>Y</M>, say, of order <M>3</M>,
so the situation here differs from that for groups of the type <M>12.G.2</M> with
<M>G</M> one of <M>L_3(4)</M>, <M>U_4(3)</M>, where the action on the normal subgroup
of order three is nontrivial.

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons18.png" alt="The structure of 12.A_6.2_3"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
                                 N
                                 │
                                 C
                                ╱ ╲
                               ╱   U
                              .   ╱
                             ╱ ╲ ╱
                           ⟨g⟩  .
                             ╲ ╱│
                              Z Y
                              │╱
                              1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons18 -->
<![CDATA[
\begin{center} 
\setlength{\unitlength}{3pt}
\begin{picture}(45,31)(0,0)
\put(15,0){\circle*{1}}
\put(15,5){\circle*{1}} \put(12,4){\makebox(0,0){$Z$}}
\put(10,10){\circle*{1}} \put(7,10){\makebox(0,0){$\langle g \rangle$}}
\put(21,6){\circle*{1}} \put(24,6){\makebox(0,0){$Y$}}
\put(21,11){\circle*{1}}
\put(30,20){\circle*{1}} \put(33,20){\makebox(0,0){$U$}}
\put(16,16){\circle*{1}}
\put(25,25){\circle*{1}} \put(22,25){\makebox(0,0){$C$}}
\put(25,30){\circle*{1}} \put(25,33){\makebox(0,0){$N$}}
\put(15,5){\line(1,1){15}}
\put(10,10){\line(1,1){15}}
\put(15,0){\line(1,1){6}}
\put(15,0){\line(0,1){5}}
\put(21,6){\line(0,1){5}}
\put(25,25){\line(0,1){5}}
\put(15,5){\line(-1,1){5}}
\put(21,11){\line(-1,1){5}}
\put(30,20){\line(-1,1){5}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

Thus <M>N</M> has the structure <M>2.G.2</M>, with <M>2.G = C</M> and <M>G.2 = \overline{N}</M>.
These two groups are isoclinic variants of <M>2 \times 6.A_6</M> and of
<M>2 \times 3.M_{10}</M>, respectively.
Each element in <M>N \setminus C</M> inverts <M>g</M>, so it acts fixed point
freely on the faithful irreducible characters of <M>C</M>.
Hence we can use
<Ref Func="PossibleCharacterTablesOfTypeMGA" BookName="ctbllib"/>
for constructing the character table of <M>N</M> from the tables of <M>C</M>
and <M>N/Z</M> and the action of <M>N</M> on the classes of <M>C</M>.

<P/>

<Example><![CDATA[
gap> c2:= CharacterTable( "Cyclic", 2 );;
gap> tblC:= CharacterTableIsoclinic( CharacterTable( "6.A6" ) * c2 );;
gap> ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),
>               x -> Length( x ) = 2 );
[ [ 1, 7 ] ]
gap> tblG:= tblC / ord2[1];;
gap> tblNbar:= CharacterTableIsoclinic( CharacterTable( "3.A6.2_3" ) * c2 );;
gap> fus:= PossibleClassFusions( tblG, tblNbar );
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 13, 14, 15, 16, 
      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 21, 22, 23, 24, 25, 26 ]
    , 
  [ 1, 2, 5, 6, 3, 4, 7, 8, 11, 12, 9, 10, 13, 14, 13, 14, 15, 16, 
      19, 20, 17, 18, 21, 22, 25, 26, 23, 24, 21, 22, 25, 26, 23, 24 
     ] ]
gap> rep:= RepresentativesFusions( Group( () ), fus, tblNbar );
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 13, 14, 15, 16, 
      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 21, 22, 23, 24, 25, 26 
     ] ]
gap> StoreFusion( tblG, rep[1], tblNbar );
gap> elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );
[ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7 ], [ 8 ], [ 9 ], 
      [ 10 ], [ 11 ], [ 12 ], [ 13 ], [ 14 ], [ 15 ], [ 16 ], [ 17 ], 
      [ 18 ], [ 19, 23 ], [ 20, 24 ], [ 21, 25 ], [ 22, 26 ], 
      [ 27, 33 ], [ 28, 34 ], [ 29, 35 ], [ 30, 36 ], [ 31, 37 ], 
      [ 32, 38 ], [ 39, 51 ], [ 40, 52 ], [ 41, 53 ], [ 42, 54 ], 
      [ 43, 55 ], [ 44, 56 ], [ 45, 57 ], [ 46, 58 ], [ 47, 59 ], 
      [ 48, 60 ], [ 49, 61 ], [ 50, 62 ] ], 
  [ [ 1 ], [ 2, 8 ], [ 3 ], [ 4, 10 ], [ 5 ], [ 6, 12 ], [ 7 ], 
      [ 9 ], [ 11 ], [ 13 ], [ 14 ], [ 15 ], [ 16 ], [ 17 ], [ 18 ], 
      [ 19, 23 ], [ 20, 26 ], [ 21, 25 ], [ 22, 24 ], [ 27 ], 
      [ 28, 34 ], [ 29 ], [ 30, 36 ], [ 31 ], [ 32, 38 ], [ 33 ], 
      [ 35 ], [ 37 ], [ 39, 51 ], [ 40, 58 ], [ 41, 53 ], [ 42, 60 ], 
      [ 43, 55 ], [ 44, 62 ], [ 45, 57 ], [ 46, 52 ], [ 47, 59 ], 
      [ 48, 54 ], [ 49, 61 ], [ 50, 56 ] ], 
  [ [ 1 ], [ 2, 8 ], [ 3 ], [ 4, 10 ], [ 5 ], [ 6, 12 ], [ 7 ], 
      [ 9 ], [ 11 ], [ 13 ], [ 14 ], [ 15 ], [ 16 ], [ 17 ], [ 18 ], 
      [ 19, 23 ], [ 20, 26 ], [ 21, 25 ], [ 22, 24 ], [ 27, 33 ], 
      [ 28 ], [ 29, 35 ], [ 30 ], [ 31, 37 ], [ 32 ], [ 34 ], [ 36 ], 
      [ 38 ], [ 39, 51 ], [ 40, 58 ], [ 41, 53 ], [ 42, 60 ], 
      [ 43, 55 ], [ 44, 62 ], [ 45, 57 ], [ 46, 52 ], [ 47, 59 ], 
      [ 48, 54 ], [ 49, 61 ], [ 50, 56 ] ] ]
gap> poss:= List( elms, pi -> PossibleCharacterTablesOfTypeMGA(
>                 tblC, tblG, tblNbar, pi, "12.A6.2_3" ) );
[ [  ], [  ], 
  [ 
      rec( 
          MGfusMGA := [ 1, 2, 3, 4, 5, 6, 7, 2, 8, 4, 9, 6, 10, 11, 12, 
              13, 14, 15, 16, 17, 18, 19, 16, 19, 18, 17, 20, 21, 22, 
              23, 24, 25, 20, 26, 22, 27, 24, 28, 29, 30, 31, 32, 33, 
              34, 35, 36, 37, 38, 39, 40, 29, 36, 31, 38, 33, 40, 35, 
              30, 37, 32, 39, 34 ], 
          table := CharacterTable( "12.A6.2_3" ) ) ] ]
]]></Example>

<P/>

So we get again a unique solution.
It coincides with the character table that is stored in the &GAP;
Character Table Library.

<P/>

<Example><![CDATA[
gap> IsRecord( TransformingPermutationsCharacterTables( poss[3][1].table,
>                  CharacterTable( "12.A6.2_3" ) ) );
true
]]></Example>

<P/>

The construction of the character table of <M>4.L_2(25).2_3</M> is analogous
to that of the table of <M>4.A_6.2_3</M>.
We get a unique table that coincides with the table in the &GAP; library.

<P/>

<Example><![CDATA[
gap> c2:= CharacterTable( "Cyclic", 2 );;
gap> tblC:= CharacterTableIsoclinic( CharacterTable( "2.L2(25)" ) * c2 );;
gap> ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),
>               x -> Length( x ) = 2 );
[ [ 1, 3 ] ]
gap> tblG:= tblC / ord2[1];;
gap> tblNbar:= CharacterTableIsoclinic( CharacterTable( "L2(25).2_3" ) * c2 );;
gap> fus:= PossibleClassFusions( tblG, tblNbar );
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 10, 11, 12, 13, 14, 13, 14, 15, 
      16, 15, 16, 17, 18, 17, 18, 19, 20, 19, 20 ], 
  [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 10, 11, 12, 13, 14, 13, 14, 17, 
      18, 17, 18, 19, 20, 19, 20, 15, 16, 15, 16 ], 
  [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 10, 11, 12, 13, 14, 13, 14, 19, 
      20, 19, 20, 15, 16, 15, 16, 17, 18, 17, 18 ] ]
gap> rep:= RepresentativesFusions( Group( () ), fus, tblNbar );
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 10, 11, 12, 13, 14, 13, 14, 15, 
      16, 15, 16, 17, 18, 17, 18, 19, 20, 19, 20 ] ]
gap> StoreFusion( tblG, rep[1], tblNbar );
gap> elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );
[ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7 ], [ 8 ], [ 9 ], 
      [ 10 ], [ 11, 13 ], [ 12, 14 ], [ 15, 19 ], [ 16, 20 ], 
      [ 17, 21 ], [ 18, 22 ], [ 23, 25 ], [ 24, 26 ], [ 27, 33 ], 
      [ 28, 34 ], [ 29, 31 ], [ 30, 32 ], [ 35, 39 ], [ 36, 40 ], 
      [ 37, 41 ], [ 38, 42 ], [ 43, 47 ], [ 44, 48 ], [ 45, 49 ], 
      [ 46, 50 ], [ 51, 55 ], [ 52, 56 ], [ 53, 57 ], [ 54, 58 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7 ], [ 8, 10 ], [ 9 ], 
      [ 11 ], [ 12, 14 ], [ 13 ], [ 15, 19 ], [ 16, 22 ], [ 17, 21 ], 
      [ 18, 20 ], [ 23, 25 ], [ 24 ], [ 26 ], [ 27, 31 ], [ 28, 34 ], 
      [ 29, 33 ], [ 30, 32 ], [ 35, 39 ], [ 36, 42 ], [ 37, 41 ], 
      [ 38, 40 ], [ 43, 47 ], [ 44, 50 ], [ 45, 49 ], [ 46, 48 ], 
      [ 51, 55 ], [ 52, 58 ], [ 53, 57 ], [ 54, 56 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7 ], [ 8, 10 ], [ 9 ], 
      [ 11, 13 ], [ 12 ], [ 14 ], [ 15, 19 ], [ 16, 22 ], [ 17, 21 ], 
      [ 18, 20 ], [ 23, 25 ], [ 24 ], [ 26 ], [ 27, 33 ], [ 28, 32 ], 
      [ 29, 31 ], [ 30, 34 ], [ 35, 39 ], [ 36, 42 ], [ 37, 41 ], 
      [ 38, 40 ], [ 43, 47 ], [ 44, 50 ], [ 45, 49 ], [ 46, 48 ], 
      [ 51, 55 ], [ 52, 58 ], [ 53, 57 ], [ 54, 56 ] ] ]
gap> poss:= List( elms, pi -> PossibleCharacterTablesOfTypeMGA(
>                 tblC, tblG, tblNbar, pi, "4.L2(25).2_3" ) );
[ [  ], [  ], 
  [ 
      rec( 
          MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 9, 11, 12, 
              13, 14, 15, 12, 15, 14, 13, 16, 17, 16, 18, 19, 20, 21, 
              22, 21, 20, 19, 22, 23, 24, 25, 26, 23, 26, 25, 24, 27, 
              28, 29, 30, 27, 30, 29, 28, 31, 32, 33, 34, 31, 34, 33, 
              32 ], table := CharacterTable( "4.L2(25).2_3" ) ) ] ]
gap> IsRecord( TransformingPermutationsCharacterTables( poss[3][1].table,
>                  CharacterTable( "4.L2(25).2_3" ) ) );
true
]]></Example>

<P/>

Note that the group <M>\Gamma L(2,25)</M> does <E>not</E> contain subgroups
of the structure <M>4.L_2(25).2_3</M>,
since <M>\Gamma L(2,25)</M> acts on its subgroup of scalar matrices
via mapping each element to its fifth power,
thus the central subgroup of order four in GL<M>(2,25)</M> is central also
in <M>\Gamma L(2,25)</M>.

<P/>

<Example><![CDATA[
gap> g:= GammaL(2,25);;
gap> phi:= IsomorphismPermGroup( g );;
gap> img:= Image( phi );;
gap> der:= DerivedSubgroup( img );;
gap> derder:= DerivedSubgroup( der );;
gap> Index( img, derder );
48
gap> inter:= Filtered( IntermediateSubgroups( img, derder ).subgroups,
>                s -> Size( s ) = 4 * Size( derder ) and
>                     IsCyclic( CommutatorFactorGroup( s ) ) and
>                     Size( Centre( s ) ) = 2 );
[  ]
]]></Example>

<P/>

In order to construct a representation of a group of the structure
<M>4.L_2(25).2_3</M>,
we can use the function <C>CyclicExtensions</C> from the &GAP; package
<Package>GrpConst</Package>.
We start from the index two subgroup <M>4.L_2(25)</M>,
which is a central product of <M>SL(2,25)</M> and a cyclic group
of order four,
and find exactly one upwards extension by a cyclic group of order two,
up to isomorphism, with the required properties.

<P/>

<Example><![CDATA[
gap> c:= Centralizer( img, derder );;
gap> Size( c );  IsCyclic( c );
24
true
gap> cgen:= MinimalGeneratingSet( c );;
gap> four:= cgen[1]^6;;
gap> s:= ClosureGroup( derder, four );;
gap> LoadPackage( "GrpConst", false );
true
gap> filt:= Filtered( CyclicExtensions( s, 2 ),
>               x -> Size( Centre( x ) ) = 2 and
>                    IsCyclic( CommutatorFactorGroup( x ) ) );;
gap> Length( filt );
2
gap> IsomorphismGroups( filt[1], filt[2] ) <> fail;
true
]]></Example>

<P/>

The character table of this group coincides with the library table.

<P/>

<Example><![CDATA[
gap> TransformingPermutationsCharacterTables( CharacterTable( filt[1] ),
>        CharacterTable( "4.L2(25).2_3" ) ) <> fail;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:4.L_2(49).2_3">
<Heading>The Character Table of <M>4.L_2(49).2_3</M> (December 2020)</Heading>

The character tables of the simple group <M>L_2(49)</M> and of its extensions
do not appear in the &ATLAS; of Finite Groups <Cite Key="CCN85"/>,
but they may be regarded as &ATLAS; tables because a data file in the
format used to produce the &ATLAS; has been available for a long time,
as is stated in <Cite Key="JLPW95" Where="Appendix 2"/>.

<P/>

Analogous to <M>L_2(9) \cong A_6</M> and <M>L_2(25)</M>,
see Section <Ref Subsect="subsect:4.A_6.2_3, 12.A_6.2_3, 4.L_2(25).2_3"/>,
the &ATLAS; map for <M>G = L_2(49)</M> shows a <Q>broken box</Q>,
since there is no group of the form <M>2.G.2_3</M>,
and a group of the structure <M>4.G.2_3</M> can be considered instead,
which has a normal subgroup isomorphic with <M>2.(2 \times G)</M>
and a factor group isomorphic with <M>(2 \times G).2_3</M>,
see Section <Ref Subsect="subsect:4.A_6.2_3, 12.A_6.2_3, 4.L_2(25).2_3"/>.
Having its character table available has the effect that the functions
<Ref Func="DisplayAtlasMap" BookName="ctbllib"/> and
<Ref Func="BrowseAtlasTable" BookName="ctbllib"/> work with input
<C>"L2(49)"</C>.

<P/>

We construct the character table of <M>4.L_2(49).2_3</M> in the same way
as for the extensions of <M>L_2(9)</M> and <M>L_2(25)</M>.
There is a unique solution.

<P/>

<Example><![CDATA[
gap> c2:= CharacterTable( "Cyclic", 2 );;
gap> 2l:= CharacterTable( "2.L2(49)" );;
gap> tblC:= CharacterTableIsoclinic( 2l * c2 );;
gap> ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),
>               x -> Length( x ) = 2 );
[ [ 1, 3 ] ]
gap> tblG:= tblC / ord2[1];;
gap> tblNbar:= CharacterTableIsoclinic(
>                  CharacterTable( "L2(49).2_3" ) * c2 );;
gap> fus:= PossibleClassFusions( tblG, tblNbar );;
gap> Length( fus );
10
gap> StoreFusion( tblG, fus[1], tblNbar );
gap> elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );;
gap> poss:= List( elms, pi -> PossibleCharacterTablesOfTypeMGA(
>                 tblC, tblG, tblNbar, pi, "4.L2(49).2_3" ) );;
gap> List( poss, Length );
[ 0, 0, 1 ]
gap> t:= poss[3][1].table;
CharacterTable( "4.L2(49).2_3" )
]]></Example>

<P/>

Analogous to the situation with <M>L_2(9)</M>,
a group of the desired structure can be found inside the semilinear group
<M>\Gamma</M>L<M>(2,49)</M>.
In fact, there is a unique class of subgroups in <M>\Gamma</M>L<M>(2,49)</M>
that contain SL<M>(2,49) \cong 2.G</M>, have the right order,
have cyclic commutator factor group, and centre of order <M>2</M>.

<P/>

<Example><![CDATA[
gap> g:= GammaL(2,49);;
gap> phi:= IsomorphismPermGroup( g );;
gap> img:= Image( phi );;
gap> der:= DerivedSubgroup( img );;
gap> derder:= DerivedSubgroup( der );;
gap> Index( img, derder );
96
gap> inter:= Filtered( IntermediateSubgroups( img, derder ).subgroups,
>                s -> Size( s ) = 4 * Size( derder ) and
>                     IsCyclic( CommutatorFactorGroup( s ) ) and
>                     Size( Centre( s ) ) = 2 );;
gap> Length( inter );                                        
4
gap> ForAll( inter, x -> IsConjugate( img, inter[1], x ) );
true
]]></Example>

<P/>

The character tables of these groups coincide with the table constructed
above, and with the library table.

<P/>

<Example><![CDATA[
gap> TransformingPermutationsCharacterTables( t,
>        CharacterTable( inter[1] ) ) <> fail;
true
gap> TransformingPermutationsCharacterTables( t,
>        CharacterTable( "4.L2(49).2_3" ) ) <> fail;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:4.L_2(81).2_3">
<Heading>The Character Table of <M>4.L_2(81).2_3</M> (December 2020)</Heading>

We start with the character-theoretic construction of this table,
analogous to the cases of <M>L_2(9)</M>, <M>L_2(25)</M>, <M>L_2(49)</M>.

<P/>

<Example><![CDATA[
gap> c2:= CharacterTable( "Cyclic", 2 );;
gap> 2l:= CharacterTable( "2.L2(81)" );;
gap> tblC:= CharacterTableIsoclinic( 2l * c2 );;
gap> ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),
>               x -> Length( x ) = 2 );
[ [ 1, 3 ] ]
gap> tblG:= tblC / ord2[1];;
gap> tblNbar:= CharacterTableIsoclinic(
>                  CharacterTable( "L2(81).2_3" ) * c2 );;
gap> fus:= PossibleClassFusions( tblG, tblNbar );;
gap> Length( fus );
40
gap> fusreps:= RepresentativesFusions( tblG, fus, tblNbar );;
gap> Length( fusreps );
1
gap> StoreFusion( tblG, fusreps[1], tblNbar );
gap> elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );;
gap> poss:= List( elms, pi -> PossibleCharacterTablesOfTypeMGA(
>                 tblC, tblG, tblNbar, pi, "4.L2(81).2_3" ) );;
gap> List( poss, Length );
[ 0, 0, 1 ]
gap> TransformingPermutationsCharacterTables( poss[3][1].table,
>        CharacterTable( "4.L2(81).2_3" ) ) <> fail;
true
]]></Example>

<P/>

Like in the case of <M>L_2(25)</M>,
there are <E>no</E> <M>4.L_2(81).2_3</M> type subgroups in
<M>\Gamma L(2,81)</M>.

<P/>

<Example><![CDATA[
gap> g:= GammaL(2,81);;
gap> phi:= IsomorphismPermGroup( g );;
gap> img:= Image( phi );;
gap> der:= DerivedSubgroup( img );;
gap> derder:= DerivedSubgroup( der );;
gap> Index( img, derder );
320
gap> inter:= Filtered( IntermediateSubgroups( img, derder ).subgroups,
>                s -> Size( s ) = 4 * Size( derder ) and
>                     IsCyclic( CommutatorFactorGroup( s ) ) and
>                     Size( Centre( s ) ) = 2 );;
gap> ForAll( inter, x -> IsConjugate( img, inter[1], x ) );
true
gap> NrConjugacyClasses( inter[1] );
52
gap> NrConjugacyClasses( CharacterTable( "4.L2(81).2_3" ) );
112
]]></Example>

<P/>

The subgroups of <M>\Gamma L(2,81)</M> constructed above have the
structure <M>2.L_2(81).4_1</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "2.L2(81).4_1" );;
gap> NrConjugacyClasses( t );
52
gap> TransformingPermutationsCharacterTables( t,
>        CharacterTable( inter[1] ) ) <> fail;
true
]]></Example>

<P/>

Like in the case of <M>L_2(25)</M>,
we can construct a group with the structure <M>4.L_2(81).2_3</M>
via the function <C>CyclicExtensions</C> from the &GAP; package
<Package>GrpConst</Package>.

<P/>

<Example><![CDATA[
gap> c:= Centralizer( img, derder );;
gap> Size( c );  IsCyclic( c );
80
true
gap> cgen:= MinimalGeneratingSet( c );;
gap> four:= cgen[1]^20;;
gap> s:= ClosureGroup( derder, four );;
gap> LoadPackage( "GrpConst", false );
true
gap> filt:= Filtered( CyclicExtensions( s, 2 ),
>               x -> Size( Centre( x ) ) = 2 and
>                    IsCyclic( CommutatorFactorGroup( x ) ) );;
gap> Length( filt );
2
gap> IsomorphismGroups( filt[1], filt[2] ) <> fail;
true
gap> TransformingPermutationsCharacterTables( CharacterTable( filt[1] ),
>        CharacterTable( "4.L2(81).2_3" ) ) <> fail;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!--

<Subsection Label="subsect:4.L_2(81).4_2">
<Heading>The Character Table of <M>4.L_2(81).4_2</M> (January 2021)</Heading>

we find <M>4.L_2(81).4_2</M> in <M>\Gamma L(2,81)</M>.

gap> g:= GammaL(2,81);
GammaL(2,81)
gap> phi:= IsomorphismPermGroup( g );;
gap> img:= Image( phi );
<permutation group of size 170035200 with 3 generators>
gap> NrMovedPoints( img );
4592
gap> der:= DerivedSubgroup( img );
<permutation group with 3 generators>
gap> derder:= DerivedSubgroup( der );
<permutation group with 3 generators>
gap> inter:= IntermediateSubgroups( img, derder );;
gap> Length( inter.subgroups );
200
gap> List( inter.subgroups, x -> Size(x) /Size(derder ) );
[ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 10, 10, 10, 16, 16, 16, 16, 16, 
  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
  16, 16, 16, 16, 16, 16, 16, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 32, 
  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 40, 40, 40, 40, 40, 
  40, 40, 40, 40, 40, 40, 64, 64, 64, 64, 64, 80, 80, 80, 80, 80, 80, 80, 
  160, 160, 160 ]
gap> Positions( last, 8);
[ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 
  83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 
  101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114 ]
gap> cand:= inter.subgroups{last};;
gap> List( cand, x -> IdGroup( x/DerivedSubgroup(x)));
[ [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], 
  [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], 
  [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], [ 8, 1 ], 
  [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], 
  [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], 
  [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], 
  [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 2 ], [ 8, 2 ], [ 8, 2 ], 
  [ 8, 2 ], [ 8, 2 ] ]
gap> List( cand, x -> Size( FittingSubgroup( x ) ) );
[ 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8, 
  16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 
  8 ]
gap> Positions( last, 4 );
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 27, 
  28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46 ]
gap> cand:= cand{last};;
gap> facts:= List( cand, x -> x / FittingSubgroup(x) );;
gap> List( facts, NrConjugacyClasses );
[ 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 
  34, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
  28, 28 ]
gap> NrConjugacyClasses( CharacterTable( "L2(81).4_2" ) );
28
gap> NrConjugacyClasses( CharacterTable( "L2(81).4_1" ) );
34
gap> Position( last3, 28 );
21
gap> List( [ 21 .. Length( cand ) ], i -> IsConjugate( img, cand[i], cand[21] ) );
[ true, true, true, true, true, true, true, true, true, true, true, true, 
  true, true, true, true, true, true, true, true ]
gap> g:= cand[21];;
gap> Length( GeneratorsOfGroup( g ) );
4
gap> sm:= SmallGeneratingSet( g );;
gap> Length( sm );
3
gap> gg:= GroupWithGenerators( sm );;
gap> smm:= SmallGeneratingSet( gg );;
gap> Length( smm );
2
gap> pre:= List( smm, x -> PreImagesRepresentative( phi, x ) );
[ < immutable compressed matrix 8x8 over GF(3) >, 
  < immutable compressed matrix 8x8 over GF(3) > ]
gap> List( pre, x -> MeatAxeString( x, 3 ) );
[ "1 3 8 8\n00012020\n10010202\n11012022\n11112201\n10100221\n01011020\n101101\
02\n11022012\n", 
  "1 3 8 8\n02000000\n20020000\n22210000\n20110000\n00002000\n00000002\n000022\
22\n00000122\n" ]
gap> t:= CharacterTable( g );
CharacterTable( <permutation group of size 4250880 with 4 generators> )
gap> NrConjugacyClasses( t );
80
gap> Size( SL(2,81) );
531360
gap> 4250880/last;
8
gap> Irr( t );;
gap> time;
307423
gap> # sort the table according to the factor group L2(81).4_2
gap> nsg:= ClassPositionsOfFittingSubgroup( t );
[ 1, 2, 3 ]
gap> facttbl:= CharacterTable( "L2(81).4_2" );
CharacterTable( "L2(81).4_2" )
gap> sort:= SortedCharacterTable( t, facttbl, nsg );
CharacterTable( <permutation group of size 4250880 with 4 generators> )


Browse( sort );
Browse( sort, rec( powermap:= false ) );
nsg:= ClassPositionsOfNormalSubgroups( sort );
nsg:= nsg{[1,2,3,5,6,7]};
sort2:= SortedCharacterTable( sort, nsg );
Browse( sort2, rec( powermap:= false ) );
x:= Irr(sort2 );;
sub:= x{[29..56]};;
reord:= List( x{[1..28]}, chi -> x[32] * chi );;
Set( reord ) = Set( sub );
xx:= Concatenation( x{[1..28]}, reord, x{[57..Length(x)]} );;
Set( x ) = Set( xx );
ResetFilterObj(sort2, HasIrr);
SetIrr( sort2, xx );
Irr( sort2 ) = xx;
AutomorphismsOfTable( sort2 );;
PrintToLib( "4L28142", sort2 );

now construct 4.L_2(81).4_2 character-theoretically
(which will in principle enable us to compute also Brauer tables):

subgroup 4.L2(81).2_1 of 4.L2(81).2_1, from the group:

gap> s1:= "1 3 8 8\n00012020\n10010202\n11012022\n11112201\n10100221\n01011020\n101101\
> 02\n11022012\n";
"1 3 8 8\n00012020\n10010202\n11012022\n11112201\n10100221\n01011020\n10110102\
\n11022012\n"
gap> ScanMeatAxeFile;
function( arg... ) ... end
gap> ScanMeatAxeFile( s1, "string" );
< immutable compressed matrix 8x8 over GF(3) >
gap> m1:= last;
< immutable compressed matrix 8x8 over GF(3) >
gap> m2:= ScanMeatAxeFile( 
> "1 3 8 8\n02000000\n20020000\n22210000\n20110000\n00002000\n00000002\n000022\
> 22\n00000122\n", "string" );
< immutable compressed matrix 8x8 over GF(3) >
gap> g:= Group( m1, m2 );
<matrix group with 2 generators>
gap> iso:= IsomorphismPermGroup( g );
<action isomorphism>
gap> img:= Image( iso );
<permutation group of size 4250880 with 2 generators>
gap> NrMovedPoints( img );
1312
gap> Size( img );
4250880
gap> last / 531360;
8
gap> inter:= IntermediateSubgroups( img, DerivedSubgroup( img ) );
rec( inclusions := [ [ 0, 1 ], [ 1, 2 ], [ 2, 3 ] ], 
  subgroups := [ <permutation group of size 1062720 with 2 generators>, 
      <permutation group of size 2125440 with 3 generators> ] )
gap> u:= inter.subgroups[2];
<permutation group of size 2125440 with 3 generators>
gap> Index( img, u );
2

try whether this is a suitable subquotient of C8 x 2.L2(81).2_1
(take the diagonals in both V4 subquotients)

gap> dp:= CharacterTable( "Cyclic", 8 ) * CharacterTable( "2.L2(81).2_1" );
CharacterTable( "C8x2.L2(81).2_1" )
gap> nsg:= ClassPositionsOfNormalSubgroups( dp );;
gap> nsg:= Filtered( nsg, x -> Sum( SizesConjugacyClasses(dp){x} ) = Size(dp)/2 );;
gap> Length( nsg );
3
gap> nsg:= Filtered( nsg, x -> not IsSubset( x, Set( GetFusionMap( CharacterTable( "2.L2(81).2_1" ), dp ) ) ) );;
gap> Length( nsg );
2
gap> nsg:= Filtered( nsg, x -> not IsSubset( x, ClassPositionsOfCentre( dp ) ) );
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 
      21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 
      39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 112, 113, 114, 115, 116, 
      117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 
      131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 
      145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 
      159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 
      173, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 
      249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 
      263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 
      277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 
      291, 292, 293, 294, 295, 296, 297, 360, 361, 362, 363, 364, 365, 366, 
      367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 
      381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 
      395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 
      409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 484, 
      485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496 ] ]
gap> sub:= CharacterTableOfNormalSubgroup( dp, nsg[1] );;
gap> cen:= ClassPositionsOfCentre( sub );
[ 1, 2, 63, 64, 125, 126, 187, 188 ]
gap> OrdersClassRepresentatives( sub ){ cen };
[ 1, 2, 4, 4, 2, 2, 4, 4 ]
gap> nsg:= ClassPositionsOfNormalSubgroups( sub );;
gap> PowerMap( sub, 2 ){ cen };
[ 1, 1, 125, 125, 1, 1, 125, 125 ]
gap> Filtered( nsg, x -> Sum( SizesConjugacyClasses(sub){x} ) = Size( sub )/8);
[ [ 1 .. 49 ] ]
gap> # so factor by 126
gap> subquo:= sub / [1,126];;
gap> NrConjugacyClasses( subquo );
124
gap> NrConjugacyClasses( u );
124
gap> utbl:= CharacterTable( u );;
gap> Irr( utbl );;
gap> time;
154766
gap> TransformingPermutationsCharacterTables( subquo, utbl );
rec( columns := (3,38,102,107,115,12,29,59,81,52,80,51,20,56,24,65,37,99,98,
    97,96,95,89,72,25,66,10,28,60,84,70,41,106,116,11,27,73,26,74,31,88,71,42,
    109,120,76,50,6,15,47,118,21,55,23,67,9,40,105,112,5,7,16,46,117,22,68,17,
    44,114,79,43,110,123,35,94,90,62,33,92,86,64,4,8,39,101,103,108,119,77,48,
    121,82,58,75,32,91,61,36,100,104,111,124,34,93,85,69,18,54,14,49,122,83,
    57,78,45,113,19,53,13,30,87,63), 
  group := <permutation group with 10 generators>, 
  rows := (3,13,53,100,103,5,14,57,121,111,73,69,71,64,4,16,62,120,115,98,104,
    6,15,55,124,116,97,101,10,56,118,114,82,28,42,7,61,122,113,75,63)(8,58,
    119,109,79,24,43,91,37,108,76,67,20,26,41)(9,54,99,102)(11,59,123,110,80,
    23,49,83,33,96,94,40)(12,60,117,112,77,65,18,22,44,88,31,47,89,30,46,86,
    36,106,78,72,66,17,21,50,87,29,48,90,32,45,84,35,107,74,70,68,19,25,51,85,
    34,95,93,38,105,81,27,52,92,39) )

now try to construct the character table of 4.L2(81).4_2 as MGA
of MG = 4.L2(81).2_1 and GA = (2xL2(81)).4_2 < C8 x L2(81).4_2 (subdirect)

gap> tblMG:= subquo;;
gap> ClassPositionsOfCentre( tblMG );
[ 1, 2, 63, 64 ]
gap> OrdersClassRepresentatives( tblMG ){ last };
[ 1, 2, 4, 4 ]
gap> tblG:= tblMG / [ 1, 2 ];;
gap> # this is 2xL2(81)
gap> dp:= CharacterTable( "Cyclic", 8 ) * CharacterTable( "L2(81).4_2" );
CharacterTable( "C8xL2(81).4_2" )
gap> nsg:= ClassPositionsOfNormalSubgroups( dp );;
gap> nsg:= Filtered( nsg, x -> Sum( SizesConjugacyClasses(dp){x} ) = Size(dp)/4 );;
gap> Length( nsg );
7
gap> # we need one that does not contain the direct 4 or the direct L2(81).2!
gap> FactorsOfDirectProduct( dp );
[ CharacterTable( "C8" ), CharacterTable( "L2(81).4_2" ) ]
gap> f:= last[1];;
gap> ClassPositionsOfNormalSubgroups( f );
[ [ 1 ], [ 1, 5 ], [ 1, 3 .. 7 ], [ 1 .. 8 ] ]
gap> GetFusionMap( f, dp ){ last[3] };
[ 1, 57 .. 169 ]
gap> nsg:= Filtered( nsg, x -> not IsSubset( x, last ) );;
gap> Length( nsg );
4
gap> f:= FactorsOfDirectProduct( dp )[2];;
gap> ClassPositionsOfNormalSubgroups( f );
[ [ 1 ], [ 1 .. 15 ], [ 1 .. 22 ], [ 1 .. 28 ] ]
gap> GetFusionMap( f, dp ){ last[3] };
[ 1 .. 22 ]
gap> nsg:= Filtered( nsg, x -> not IsSubset( x, last ) );;
gap> Length( nsg );
2
gap> # I suspect both are equally good!
gap> cand:= List( nsg, x -> CharacterTableOfNormalSubgroup( dp, x ) );;
gap> TransformingPermutationsCharacterTables( cand[1], cand[2] );
rec( columns := (), group := <permutation group with 6 generators>, 
  rows := (2,4)(13,15)(16,18)(30,32)(41,43)(44,46) )



alternativer Ansatz (?) für (2xL2(81)).4_2 (s.t. there is a factor C8):

c8:= CharacterTable( "Cyclic", 8 );
t:= CharacterTable( "L2(81).4_2" );
dp:= t * c8;
NrConjugacyClasses( dp );
nsg:= ClassPositionsOfNormalSubgroups( dp );;
Length( nsg );
filt:= Filtered( nsg, x -> Sum( SizesConjugacyClasses(dp){x}) = Size(dp)/4);
fff:= List( filt, x -> CharacterTableOfNormalSubgroup( dp, x ) );
Length( last );
fff:= Filtered( fff, IsCharacterTable );
Filtered( fff, x -> IsCyclic( x / ClassPositionsOfDerivedSubgroup(x) ) );
Length( last );
fff:= last2;;
List( fff, NrConjugacyClasses );
224/56;
TransformingPermutationsCharacterTables( fff[1], fff[2] );



gap> tblNbar:= cand[1];;
gap> fus:= PossibleClassFusions( tblG, tblNbar );;
gap> Length( fus );
80
gap> RepresentativesFusions( tblG, fus, tblNbar );
[ [ 1, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 
      13, 14, 14, 15, 15, 19, 19, 20, 21, 21, 22, 23, 24, 25, 25, 24, 29, 30, 
      31, 31, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37, 38, 38, 39, 39, 40, 
      40, 41, 41, 42, 42, 43, 43, 47, 47, 48, 49, 49, 50, 51, 52, 53, 53, 52 
     ] ]
gap> StoreFusion( tblG, fus[1], tblNbar );
gap> elms:= PossibleActionsForTypeMGA( tblMG, tblG, tblNbar );;
gap> Length( elms );
4
gap> poss:= List( elms, pi -> PossibleCharacterTablesOfTypeMGA(
>                 tblMG, tblG, tblNbar, pi, "4.L2(81).4_2" ) );;
gap> List( poss, Length );
[ 1, 1, 1, 1 ]
gap> poss:= Concatenation( poss );;
gap> TransformingPermutationsCharacterTables( poss[1].table, poss[2].table );
rec( columns := (), group := <permutation group with 8 generators>, 
  rows := (59,60) )
gap> TransformingPermutationsCharacterTables( poss[1].table, poss[3].table );
fail
gap> TransformingPermutationsCharacterTables( poss[1].table, poss[4].table );
fail
gap> TransformingPermutationsCharacterTables( poss[3].table, poss[4].table );
rec( columns := (), group := <permutation group with 8 generators>, 
  rows := (59,60) )

# thus we have two tables!

gap> t:= CharacterTable( img );
CharacterTable( <permutation group of size 4250880 with 2 generators> )
gap> Irr( t );;
gap> time;
181269
gap> TransformingPermutationsCharacterTables( t, poss[1].table );
rec( columns := (3,35,11,69,25,70,26,76,4)(5,36,12,6,28,73,37,45,49,67,57,20,
    9,72,59,53,18,32,7,62,21,71,60,54,17,66,23,74,38,46,50,33,10,75)(8,78,30,
    42,14,39,48,27,79,63,55,51,68,58,19,43,15,31)(13,40,47,61,22,77,29,41)(16,
    65,24,80,64,56,52,34,44), group := <permutation group with 8 generators>, 
  rows := (2,3,30,18,42,50,39,24,33,20,15,41,51,38,52,37,53,35,48,7)(4,32,17,
    40,25,46,10,58,67,72,28,45,11,60,70,55,63,61,66,54,36,49,8)(5,29,16,43,23,
    34,21)(6,31,19,13,14,12,59,69,56,64,62,65,26,47,9,57,68,71,27,44,22)(73,
    80,79,75)(74,76,77,78) )

# the first one belongs to our group
# - and the second: does it have a group???


-> not obviously isoclinic:

gap> iso:= CharacterTableIsoclinic( poss[1].table );
CharacterTable( "Isoclinic(4.L2(81).4_2)" )
gap> TransformingPermutationsCharacterTables( iso, poss[3].table );
fail
gap> TransformingPermutationsCharacterTables( iso, poss[1].table );
rec( columns := (), group := <permutation group with 8 generators>, 
  rows := () )


-> different character fields:

gap> diff1:= Difference( Irr( poss[1].table ), Irr( poss[3].table ) );;
gap> diff2:= Difference( Irr( poss[3].table ), Irr( poss[1].table ) );;
gap> List( diff1, x -> x[1] );
[ 328, 328, 328, 328, 328, 328, 328, 328 ]
gap> List( diff2, x -> x[1] );
[ 328, 328, 328, 328, 328, 328, 328, 328 ]
gap> List( diff2, x -> Field( Rationals, x ) );
[ NF(80,[ 1, 9, 43, 67 ]), NF(80,[ 1, 9, 43, 67 ]), NF(80,[ 1, 9, 43, 67 ]), 
  NF(80,[ 1, 9, 43, 67 ]), NF(80,[ 1, 9, 43, 67 ]), NF(80,[ 1, 9, 43, 67 ]), 
  NF(80,[ 1, 9, 43, 67 ]), NF(80,[ 1, 9, 43, 67 ]) ]
gap> List( diff1, x -> Field( Rationals, x ) );
[ NF(80,[ 1, 3, 9, 27 ]), NF(80,[ 1, 3, 9, 27 ]), NF(80,[ 1, 3, 9, 27 ]), 
  NF(80,[ 1, 3, 9, 27 ]), NF(80,[ 1, 3, 9, 27 ]), NF(80,[ 1, 3, 9, 27 ]), 
  NF(80,[ 1, 3, 9, 27 ]), NF(80,[ 1, 3, 9, 27 ]) ]

-> same element orders (obviously different power maps)

gap> OrdersClassRepresentatives( poss[1].table ) = 
> OrdersClassRepresentatives( poss[3].table );
true

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

now 4.L2(81).4_2 ?
-> try group as an extension of 4.L2(81).2_1
-> first get 4.L2(81).2_1 as another one of the extensions from above,
   with centre of order 4

gap> NrConjugacyClasses( CharacterTable( "L2(81).2_1" ) );
38
gap> List( ext, x -> NrConjugacyClasses( x / FittingSubgroup(x) ) );
[ 43, 43, 43, 43, 83, 83, 38, 38, 43, 43, 83, 83, 83, 83, 38, 38, 38, 38, 35,
  35 ]
gap> List( ext, x -> Size( FittingSubgroup(x) ) );
[ 8, 8, 8, 8, 4, 4, 4, 4, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 ]
gap> List( ext, x -> Size( Centre(x) ) );
[ 8, 8, 8, 8, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2 ]
gap> iso:= IsomorphismGroups( ext[15], ext[16] );; iso <> fail;
true
gap> iso:= IsomorphismGroups( ext[15], ext[17] );; iso <> fail;
false
gap> iso:= IsomorphismGroups( ext[15], ext[18] );; iso <> fail;
false
gap> iso:= IsomorphismGroups( ext[17], ext[18] );; iso <> fail;
true

-> so there are two candidates, up to isomorphism

gap> ext4a:= CyclicExtensions( ext[15], 2 );;
gap> Length( ext4a );
18
gap> ext4b:= CyclicExtensions( ext[17], 2 );;
gap> Length( ext4b );
18
gap> List( ext4a, x -> Size( Centre(x) ) );
[ 8, 8, 8, 8, 2, 2, 2, 2, 4, 4, 4, 4, 2, 2, 4, 4, 4, 4 ]
gap> List( ext4a, x -> IsCyclic( x / DerivedSubgroup( x ) ) );
[ false, false, false, false, false, false, false, false, false, false,
  false, false, false, false, false, false, false, false ]
gap> List( ext4a, x -> Size( FittingSubgroup(x) ) );
[ 8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 4, 4 ]
gap> List( ext4a, x -> Index( x, DerivedSubgroup( x ) ) );
[ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8 ]
gap>
gap> List( ext4b, x -> Size( Centre(x) ) );
[ 8, 8, 8, 8, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2 ]
gap> List( ext4b, x -> IsCyclic( x / DerivedSubgroup( x ) ) );
[ false, false, false, false, true, true, true, true, false, false, false,
  false, false, false, false, false, true, true ]
gap> List( ext4b, x -> Size( FittingSubgroup(x) ) );
[ 8, 8, 8, 8, 4, 4, 4, 4, 8, 8, 8, 8, 4, 4, 8, 8, 4, 4 ]
gap> List( ext4b, x -> Index( x, DerivedSubgroup( x ) ) );
[ 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 4, 8, 8 ]

-> take the last 2 from ext4b!

gap> s:= ext4b[17];
<permutation group of size 4250880 with 3 generators>
gap> IsomorphismGroups( s, ext4b[18] ) = fail;
-> no answer in reasonable time ...

gap> fact:= s / FittingSubgroup( s );;
gap> NrMovedPoints( fact );
82
gap> lib:= CharacterTable( "L2(81).4_2" );
CharacterTable( "L2(81).4_2" )
gap> t:= CharacterTable( fact );;
gap> Irr( t );;
gap> TransformingPermutationsCharacterTables( lib, t );
rec( columns := (3,19,21,27,25,23,4,12,7,13,8,14,9,16,18,20,22,28,26,24,5,11,
    6,15,10,17), group := <permutation group with 5 generators>,
  rows := (2,4,3)(5,9,21,16,12,6,10,23,19,14)(7,22,20,15)(8,24,17,13)(11,25,
    18) )

gap> ss:= ext4b[18];
<permutation group of size 4250880 with 3 generators>
gap> factt:= ss / FittingSubgroup( ss );;
gap> NrMovedPoints( factt );
82
gap> tt:= CharacterTable( factt );;
gap> Irr( tt );;
gap> TransformingPermutationsCharacterTables( lib, tt );
rec( columns := (3,27,8,18,28,9,20,5,14,25,6,19,4)(7,17,10,21,15,26)(11,22,16,
    13,24,12,23), group := <permutation group with 5 generators>,
  rows := (2,4,3)(5,9,21,16,12)(6,10,23,19,14)(7,22,20,15,8,24,17,13)(11,25,
    18) )

-> Aha, established 4.L2(81).4_2 !

gap> PrintTo( "groups4l2814_2", List( [ s, ss ], GeneratorsOfGroup ) );

</Subsection>
-->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:9.U_3(8).3_3">
<Heading>The Character Table of <M>9.U_3(8).3_3</M> (March 2017)</Heading>

The group that is called <M>9.U_3(8).3_3</M> in the &ATLAS; of Finite Groups
occurs as a subgroup of <M>\Gamma</M>U<M>(3, 8)</M>.
Note that GU<M>(3, 8)</M> has the structure <M>3.(3 \times U_3(8)).3_2</M>
(see <Cite Key="CCN85" Where="p.&nbsp;66"/>),
and extending the subgroup <M>C = 3.(3 \times U_3(8))</M> by the product of
an element outside <M>C</M> with the field automorphism of order three of
GF<M>(64)</M> yields a group <M>N</M> of the structure
<M>3.(3 \times U_3(8)).3_3</M> whose centre has order three.

<P/>

The character table of <M>N</M> can be constructed with the <M>M.G.A</M>
construction method from Section&nbsp;<Ref Subsect="subsect:theorMGA"/>.
The situation is similar to that with <M>4.A_6.2_3</M>, see
Section&nbsp;<Ref Subsect="subsect:4.A_6.2_3, 12.A_6.2_3, 4.L_2(25).2_3"/>,
in particular the situation is described by the same picture that is shown
for <M>4.A_6.2_3</M> in this section,
just the subgroups <M>Z</M> and <M>\langle g \rangle</M> have the orders
three and nine, respectively, and <M>C</M> has index three in <M>N</M>.

<P/>

The normal subgroup <M>C \cong 9.U_3(8)</M>
is a central product of <M>U = 3.U_3(8)</M> and a cyclic group
<M>\langle g \rangle</M> of order <M>9</M>,
and the factor group of <M>N</M> by the central subgroup
<M>Z = \langle g^3 \rangle</M> of order <M>3</M>
is isomorphic to a subdirect product
<M>\overline{N}</M> of <M>U_3(8).3_3</M>
and a cyclic group of order <M>9</M>,
such that <M>N</M> acts nontrivially on its normal subgroup
<M>\langle g \rangle</M>.

<P/>

Thus <M>N</M> has the structure <M>3.G.3</M>,
with <M>3.G = C</M> and <M>G.3 = \overline{N}</M>.
Each element in <M>N \setminus C</M> raises <M>g</M> to its fourth or
seventh power, so it acts fixed point
freely on the faithful irreducible characters of <M>C</M>.
Hence we can use
<Ref Func="PossibleCharacterTablesOfTypeMGA" BookName="ctbllib"/>
for constructing the character table of <M>N</M>
from the tables of <M>C</M> and <M>N/Z</M>
and the action of <M>N</M> on the classes of <M>C</M>.

<P/>

Since we want to construct also <E>Brauer tables</E> of <M>N</M>,
we have to choose the class fusion that describes the embedding of
<M>C / Z</M> into <M>\overline{N}</M> compatibly with the known
Brauer tables of <M>U_3(8)</M> and <M>U_3(8).3_3</M>.
Note that the <M>2</M>-modular tables of these groups impose additional
conditions on the class fusion.

<P/>

<Example><![CDATA[
gap> s:= CharacterTable( "U3(8)" );;
gap> s3:= CharacterTable( "U3(8).3_3" );;
gap> poss:= PossibleClassFusions( s, s3 );;
gap> Length( poss );
4
gap> Length( RepresentativesFusions( s, poss, s3 ) );
1
gap> smod2:= s mod 2;;
gap> s3mod2:= s3 mod 2;;
gap> good:= [];;  modmap:= 0;;
gap> for map in poss do
>      modmap:= CompositionMaps( InverseMap( GetFusionMap( s3mod2, s3 ) ),
>                   CompositionMaps( map, GetFusionMap( smod2, s ) ) );
>      rest:= List( Irr( s3mod2 ), x -> x{ modmap } );
>      if not fail in Decomposition( Irr( smod2 ), rest, "nonnegative" ) then
>        Add( good, map );
>      fi;
>    od;
gap> Length( good );
2
]]></Example>

<P/>

The class fusion from <M>U_3(8)</M> to <M>U_3(8).3_3</M> is determined
up to complex conjugation by the <M>2</M>-modular Brauer tables.
We choose the fusion that is stored on the library tables.

<P/>

<Example><![CDATA[
gap> good[2] = CompositionMaps( PowerMap( s3, -1 ), good[1] );
true
gap> GetFusionMap( s, s3 ) in good;
true
gap> sfuss3:= GetFusionMap( s, s3 );;
]]></Example>

<P/>

In the next step, we construct the character tables of
<M>C / Z \cong U_3(8) \times 3</M>
and <M>N / Z \cong (U_3(8) \times 3).3_3</M>,
and those class fusions between the two tables that are compatible with
the fusion between the factors that was chosen above
(w.&nbsp;r.&nbsp;t.&nbsp;the stored factor fusions).

<P/>

In order not to leave out some candidates, we have to consider also the
table of <M>N/Z</M> that is obtained from the <Q>other</Q> construction
as an isoclinic table of <M>3 \times U_3(8).3_3</M>.

<P/>

(This may look complicated.
It would perhaps be more natural to construct the ordinary tables first,
by considering the possible fusions, and later to adjust the choices to the
conditions that are imposed by the Brauer tables.
However, the technical complications of that construction would not be
smaller in the end.)

<P/>

We get four candidates, two for each of the two tables of <M>N/Z</M>.

<P/>

<Example><![CDATA[
gap> c3:= CharacterTable( "Cyclic", 3 );;
gap> tblG:= s * c3;;
gap> dp:= s3 * c3;;
gap> tblGA1:= CharacterTableIsoclinic( dp, rec( k:= 1 ) );;
gap> tblGA2:= CharacterTableIsoclinic( dp, rec( k:= 2 ) );;
gap> good:= [];;
gap> tblGmod2:= tblG mod 2;;
gap> for tblGA in [ tblGA1, tblGA2 ] do
>      tblGAmod2:= tblGA mod 2;
>      for map in PossibleClassFusions( tblG, tblGA ) do
>        modmap:= CompositionMaps(
>            InverseMap( GetFusionMap( tblGAmod2, tblGA ) ),
>            CompositionMaps( map, GetFusionMap( tblGmod2, tblG ) ) );
>        rest:= List( Irr( tblGAmod2 ), x -> x{ modmap } );
>        if not fail in Decomposition( Irr( tblGmod2 ), rest,
>                           "nonnegative" ) and
>           CompositionMaps( GetFusionMap( tblGA, s3 ), map ) =
>           CompositionMaps( sfuss3, GetFusionMap( tblG, s ) ) then
>          Add( good, [ tblGA, map ] );
>        fi;
>      od;
>    od;
gap> List( good, x -> x[1] );
[ CharacterTable( "Isoclinic(U3(8).3_3xC3,1)" ), 
  CharacterTable( "Isoclinic(U3(8).3_3xC3,1)" ), 
  CharacterTable( "Isoclinic(U3(8).3_3xC3,2)" ), 
  CharacterTable( "Isoclinic(U3(8).3_3xC3,2)" ) ]
]]></Example>

<!-- No library fusion must be considered since tblG is not in the library. -->

<P/>

The character table of <M>C</M> can be constructed with
<Ref Func="CharacterTableIsoclinic" BookName="ref"/>
from the character table of <M>3 \times 3.U_3(8)</M>.
(Here we need to consider only one variant of the table.)

<P/>

<Example><![CDATA[
gap> 3s:= CharacterTable( "3.U3(8)" );;
gap> dp:= 3s * c3;;
gap> tblMG:= CharacterTableIsoclinic( dp );;
]]></Example>

<P/>

The construction of this table does not automatically yield a factor fusion
to the table of <M>C/Z</M>.
We form the relevant factor table, which has the same ordering of
irreducible characters, and use the factor fusion to this table.

<P/>

<Example><![CDATA[
gap> GetFusionMap( tblMG, tblG );
fail
gap> cen:= ClassPositionsOfCentre( tblMG );
[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
gap> OrdersClassRepresentatives( tblMG ){ cen };
[ 1, 9, 9, 3, 9, 9, 3, 9, 9 ]
gap> facttbl:= tblMG / [ 1, 4, 7 ];;
gap> tr:= TransformingPermutationsCharacterTables( facttbl, tblG );;
gap> tr.rows;  tr.columns;
()
()
gap> StoreFusion( tblMG, GetFusionMap( tblMG, facttbl ), tblG );
]]></Example>

<P/>

Now we compute the orbits of the possible actions of <M>N</M> on the
classes of <M>C</M>,
and the resulting candidates for the character table of <M>N</M>.

<P/>

<Example><![CDATA[
gap> posstbls:= [];;
gap> for pair in good do
>      tblGA:= pair[1];
>      GfusGA:= pair[2];
>      tblG:= s * c3;
>      StoreFusion( tblG, GfusGA, tblGA );
>      for pi in PossibleActionsForTypeMGA( tblMG, tblG, tblGA ) do
>        for cand in PossibleCharacterTablesOfTypeMGA(
>                        tblMG, tblG, tblGA, pi, "test" ) do
>          Add( posstbls, [ tblGA, cand ] );
>        od;
>      od;
>    od;
gap> Length( posstbls );
32
]]></Example>

<P/>

Now we discard all those candidates that are not compatible with
the <M>2</M>-modular character tables.

<P/>

<Example><![CDATA[
gap> compatible:= [];;  r:= 0;;  modr:= 0;;
gap> for pair in posstbls do
>      tblGA:= pair[1];
>      r:= pair[2];
>      comp:= ComputedClassFusions( tblMG );
>      pos:= PositionProperty( comp, x -> x.name = Identifier( r.table ) );
>      if pos = fail then
>        StoreFusion( tblMG, r.MGfusMGA, r.table );
>      else
>        comp[ pos ]:= ShallowCopy( comp[ pos ] );
>        comp[ pos ].map:= r.MGfusMGA;
>      fi;
>      Unbind( ComputedBrauerTables( tblMG )[2] );
>      modr:= BrauerTableOfTypeMGA( tblMG mod 2, tblGA mod 2, r.table );
>      rest:= List( Irr( modr.table ), x -> x{ modr.MGfusMGA } );
>      dec:= Decomposition( Irr( tblMG mod 2 ), rest, "nonnegative" );
>      if not fail in dec then
>        Add( compatible, pair );
>      fi;
>    od;
gap> Length( compatible );
8
]]></Example>

<P/>

The remaining candidates fall into two equivalence classes.

<P/>

<Example><![CDATA[
gap> tbls:= [];;
gap> for pair in compatible do
>      if ForAll( tbls, t -> TransformingPermutationsCharacterTables(
>                                t, pair[2].table ) = fail ) then
>        Add( tbls, pair[2].table );
>      fi;
>    od;
gap> Length( tbls );
2
]]></Example>

<P/>

The two tables can be distinguished by their element orders
&nbsp;one contains the element order <M>54</M> and the other does not&nbsp;
or by their <M>4</M>th power maps
&nbsp;the classes of element order <M>171</M> in one table are not fixed
by the <M>4</M>th power map,
the corresponding classes in the other table are fixed.

<P/>

<Example><![CDATA[
gap> Set( OrdersClassRepresentatives( tbls[1] ) );
[ 1, 2, 3, 4, 6, 7, 9, 12, 18, 19, 21, 27, 36, 54, 57, 63, 171 ]
gap> Set( OrdersClassRepresentatives( tbls[2] ) );
[ 1, 2, 3, 4, 6, 7, 9, 12, 18, 19, 21, 27, 36, 57, 63, 171 ]
gap> pos171:= Positions( OrdersClassRepresentatives( tbls[1] ), 171 );;
gap> pow4:= PowerMap( tbls[1], 4 );;
gap> ForAny( [ 1 .. Length( pos171 ) ],
>            i -> pos171[i] = pow4[ pos171[i] ] );
false
gap> pos171:= Positions( OrdersClassRepresentatives( tbls[2] ), 171 );;
gap> PowerMap( tbls[2], 4 ){ pos171 } = pos171;
true
]]></Example>

<P/>

Thus we can use the group <M>N</M> to decide which table is correct.
For that, we construct a permutation representation of <M>N</M>.

<P/>

<Example><![CDATA[
gap> gu:= GU(3,8);;
gap> orbs:= OrbitsDomain( gu, Elements( GF(64)^3 ) );;
gap> List( orbs, Length );
[ 1, 32319, 32832, 32832, 32832, 32832, 32832, 32832, 32832 ]
gap> orb:= SortedList( First( orbs, x -> Length( x ) = 32319 ) );;
gap> actgu:= Action( gu, orb, OnRight );;
gap> Size( actgu ) = Size( gu );
true
gap> cen:= Centre( actgu );;
gap> Size( cen );
9
gap> u:= ClosureGroup( DerivedSubgroup( actgu ), cen );;
gap> aut:= v -> List( v, x -> x^4 );;
gap> pi:= PermList( List( orb, v -> PositionSorted( orb, aut( v ) ) ) );;
gap> outer:= First( GeneratorsOfGroup( actgu ), x -> not x in u );;
gap> g:= ClosureGroup( u, pi * outer );;
]]></Example>

<P/>

Before we perform computations with the group,
we reduce the degree of the representation by a factor of <M>7</M>.

<P/>

<Example><![CDATA[
gap> g:= Group( SmallGeneratingSet( g ) );;
gap> allbl:= AllBlocks( g );;
gap> List( allbl, Length );
[ 3, 21, 63, 9, 7 ]
gap> orb:= Orbit( g, First( allbl, x -> Length( x ) = 7 ), OnSets );;
gap> act:= Action( g, orb, OnSets );;
gap> Size( act ) = Size( g );
true
gap> NrMovedPoints( act );
4617
]]></Example>

<P/>

Now we test whether an element of order <M>171</M> in <M>N</M>
is conjugate in <M>N</M> to its fourth power.

<P/>

<Example><![CDATA[
gap> repeat x:= PseudoRandom( act ); until Order( x ) = 171;
gap> IsConjugate( act, x, x^4 );
true
]]></Example>

<P/>

This means that the second of the candidate tables constructed above
is the right one.
The character table with the identifier <C>"9.U3(8).3_3"</C> in the
character table library is equivalent to this table.

<P/>

<Example><![CDATA[
gap> lib:= CharacterTable( "9.U3(8).3_3" );;
gap> IsRecord( TransformingPermutationsCharacterTables( tbls[2], lib ) );
true
]]></Example>

<P/>

&GAP;'s currently available methods for the automatic computation
of character tables would require too much space
when called with this permutation group.
Using interactive methods, one can compute the character table with &GAP;.
The table obtained this way is equivalent to the library character table
with the identifier <C>"9.U3(8).3_3"</C>.

<P/>

I do not know how to disprove the other candidate with
character-theoretic arguments.
Thus this table provides an example of a pseudo character table,
see Section <Ref Subsect="subsect:pseudo"/>.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:pseudo">
<Heading>Pseudo Character Tables of the Type <M>M.G.A</M> (May 2004)</Heading>

With the construction method for character tables of groups of the type
<M>M.G.A</M>, one can construct tables that have many properties of character
tables but that are not character tables of groups,
cf.&nbsp;<Cite Key="Gag86"/>.
For example,
the group <M>3.A_6.2_3</M> has a <E>central</E> subgroup of order <M>3</M>,
so it is not of the type <M>M.G.A</M> with fixed-point free action on the
faithful characters of <M>M.G</M>.

<P/>

However, if we apply the <Q><M>M.G.A</M> construction</Q> to the groups
<M>M.G = 3.A_6</M>, <M>G = A_6</M>, and <M>G.A = A_6.2_3</M>
then we get a (in this case unique) result.

<P/>

<Example><![CDATA[
gap> tblMG := CharacterTable( "3.A6" );;
gap> tblG  := CharacterTable( "A6" );;
gap> tblGA := CharacterTable( "A6.2_3" );;
gap> elms:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );  
[ [ [ 1 ], [ 2, 3 ], [ 4 ], [ 5, 6 ], [ 7, 8 ], [ 9 ], [ 10, 11 ], 
      [ 12, 15 ], [ 13, 17 ], [ 14, 16 ] ] ]
gap> poss:= PossibleCharacterTablesOfTypeMGA(                  
>                 tblMG, tblG, tblGA, elms[1], "pseudo" );    
[ rec( 
      MGfusMGA := [ 1, 2, 2, 3, 4, 4, 5, 5, 6, 7, 7, 8, 9, 10, 8, 10, 
          9 ], table := CharacterTable( "pseudo" ) ) ]
]]></Example>

<P/>

Such a table automatically satisfies the orthogonality relations,
<!-- For two rows in the factor group <M>G.A</M>,
     this follows form the first orthogonality relation for <M>G.A</M>;
     for two rows not from <M>G.A</M>,
     this follows from the first orthogonality relation in <M>M.G</M>;
     and for one row from <M>G.A</M> and the other not from <M>G.A</M>,
     it follows from the first orthogonality relation for <M>G</M>. -->
and the tensor product of two <Q>irreducible characters</Q> of which at least
one is a row from <M>G.A</M> decomposes into a sum of the
<Q>irreducible characters</Q>,
where the coefficients are nonnegative integers.
<!-- For two rows in the factor group <M>G.A</M>,
     this follows form this property for <M>G.A</M>;
     and for one row from <M>G.A</M> and the other not from <M>G.A</M>,
     it follows from this property for <M>M.G</M>. -->

<P/>

In this example, any tensor product decomposes with nonnegative integral
coefficients,
<M>n</M>-th symmetrizations of <Q>irreducible characters</Q> decompose,
for <M>n \leq 5</M>,
and the <Q>class multiplication coefficients</Q> are nonnegative integers.

<P/>

<Example><![CDATA[
gap> pseudo:= poss[1].table;
CharacterTable( "pseudo" )
gap> Display( pseudo );
pseudo

      2  4   3  4  3  .  3   2  .   .   .  2  3  3
      3  3   3  1  1  2  1   1  1   1   1  .  .  .
      5  1   1  .  .  .  .   .  1   1   1  .  .  .

        1a  3a 2a 6a 3b 4a 12a 5a 15a 15b 4b 8a 8b
     2P 1a  3a 1a 3a 3b 2a  6a 5a 15a 15b 2a 4a 4a
     3P 1a  1a 2a 2a 1a 4a  4a 5a  5a  5a 4b 8a 8b
     5P 1a  3a 2a 6a 3b 4a 12a 1a  3a  3a 4b 8b 8a

X.1      1   1  1  1  1  1   1  1   1   1  1  1  1
X.2      1   1  1  1  1  1   1  1   1   1 -1 -1 -1
X.3     10  10  2  2  1 -2  -2  .   .   .  .  .  .
X.4     16  16  .  . -2  .   .  1   1   1  .  .  .
X.5      9   9  1  1  .  1   1 -1  -1  -1  1 -1 -1
X.6      9   9  1  1  .  1   1 -1  -1  -1 -1  1  1
X.7     10  10 -2 -2  1  .   .  .   .   .  .  B -B
X.8     10  10 -2 -2  1  .   .  .   .   .  . -B  B
X.9      6  -3 -2  1  .  2  -1  1   A  /A  .  .  .
X.10     6  -3 -2  1  .  2  -1  1  /A   A  .  .  .
X.11    12  -6  4 -2  .  .   .  2  -1  -1  .  .  .
X.12    18  -9  2 -1  .  2  -1 -2   1   1  .  .  .
X.13    30 -15 -2  1  . -2   1  .   .   .  .  .  .

A = -E(15)-E(15)^2-E(15)^4-E(15)^8
  = (-1-Sqrt(-15))/2 = -1-b15
B = E(8)+E(8)^3
  = Sqrt(-2) = i2
gap> IsInternallyConsistent( pseudo );
true
gap> irr:= Irr( pseudo );;
gap> test:= Concatenation( List( [ 2 .. 5 ],
>               n -> Symmetrizations( pseudo, irr, n ) ) );;
gap> Append( test, Set( Tensored( irr, irr ) ) );
gap> fail in Decomposition( irr, test, "nonnegative" );
false
gap> if ForAny( Tuples( [ 1 .. NrConjugacyClasses( pseudo ) ], 3 ),        
>      t -> not ClassMultiplicationCoefficient( pseudo, t[1], t[2], t[3] )   
>               in NonnegativeIntegers ) then                           
>      Error( "contradiction" );
> fi;
]]></Example>

<P/>

I do not know a character-theoretic argument for showing that this table is
<E>not</E> the character table of a group,
but we can use the following group-theoretic argument.
Suppose that the group <M>G</M>, say, has the above character table.
Then <M>G</M> has a unique composition series with factors of the orders
<M>3</M>, <M>360</M>, and <M>2</M>, respectively.
Let <M>N</M> denote the normal subgroup of order <M>3</M> in <M>G</M>.
The factor group <M>F = G/N</M> is an automorphic extension of <M>A_6</M>,
and according to&nbsp;<Cite Key="CCN85" Where="p. 4"/>
it is isomorphic with <M>M_{10} = A_6.2_3</M>
and has Sylow <M>3</M> normalizers of the structure <M>3^2 : Q_8</M>.
Since the Sylow <M>3</M> subgroup of <M>G</M> is a self-centralizing
nonabelian group of order <M>3^3</M> and of exponent <M>3</M>,
the Sylow <M>3</M> normalizers in <M>G</M> have the structure
<M>3^{{1+2}}_+ : Q_8</M>,
but the <M>Q_8</M> type subgroups of Aut<M>( 3^{{1+2}}_+ )</M> act trivially
on the centre of <M>3^{{1+2}}_+</M>,
contrary to the situation in the above table.

<P/>

In general, this construction need not produce tables for which all
symmetrizations of irreducible characters decompose properly.
For example, applying
<Ref Func="PossibleCharacterTablesOfTypeMGA" BookName="ctbllib"/>
to the case <M>M.G = 3.L_3(4)</M> and <M>G.A = L_3(4).2_1</M>
does not yield a table because
the function suppresses tables that do not admit <M>p</M>-th power maps,
for prime divisors <M>p</M> of the order of <M>M.G.A</M>,
and in this case no compatible <M>2</M>-power map exists.

<P/>

<Example><![CDATA[
gap> tblMG := CharacterTable( "3.L3(4)" );;
gap> tblG  := CharacterTable( "L3(4)" );;
gap> tblGA := CharacterTable( "L3(4).2_1" );;
gap> elms:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );
[ [ [ 1 ], [ 2, 3 ], [ 4 ], [ 5, 6 ], [ 7 ], [ 8 ], [ 9, 10 ], 
      [ 11 ], [ 12, 13 ], [ 14 ], [ 15, 16 ], [ 17, 20 ], [ 18, 22 ], 
      [ 19, 21 ], [ 23, 26 ], [ 24, 28 ], [ 25, 27 ] ] ]
gap> PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, elms[1], "?" );
[  ]
]]></Example>

<P/>

Also, it may happen that already
<Ref Func="PossibleActionsForTypeMGA" BookName="ctbllib"/>
returns an empty list.
Examples are <M>M.G = 3_1.U_4(3)</M>, <M>G.A = U_4(3).2_2</M> and
<M>M.G = 3_2.U_4(3)</M>, <M>G.A = U_4(3).2_3</M>.

<P/>

<Example><![CDATA[
gap> tblG  := CharacterTable( "U4(3)" );;
gap> tblMG := CharacterTable( "3_1.U4(3)" );;
gap> tblGA := CharacterTable( "U4(3).2_2" );;
gap> PossibleActionsForTypeMGA( tblMG, tblG, tblGA );
[  ]
gap> tblMG:= CharacterTable( "3_2.U4(3)" );;
gap> tblGA:= CharacterTable( "U4(3).2_3" );;
gap> PossibleActionsForTypeMGA( tblMG, tblG, tblGA );
[  ]
]]></Example>

<P/>

Also the sections <Ref Subsect="subsect:4_2.L_3(4).2_3"/> and
<Ref Subsect="subsect:9.U_3(8).3_3"/> provide examples of
pseudo character tables.
If one does not use the arguments about Brauer tables
then the latter section presents in fact several pseudo character tables.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %<Subsection Label="sect:The Character Tables of Maximal Subgroups of <M>12.M_{22">
<Heading>The Character Tables of Maximal Subgroups of <M>12.M_{22</Heading>.2</M>} -->
<!-- % -->
<!-- %Idea: -->
<!-- % -->
<!-- %Regard 12.M22.2 as M.G.A with M of order 6, G = 2.M22. -->
<!-- %Yes, there is an ambiguity due to isoclinism (see Section ...), -->
<!-- %but we assume that the table of 12.M22.2 is known. -->
<!-- % -->
<!-- %Now construct the tables of the maxes of 12.M22.2, -->
<!-- %which also have the structure 6.U.2 where U is a maximal subgroup of 2.M22. -->
<!-- %So we need the tables of all maxes of 2.M22.2 and of 12.M22, -->
<!-- %decide the isoclinism via the known table of 12.M22.2. -->
<!-- % -->
<!-- %This way we get at the same time the tables of the maxes of 3.M22.2 -->
<!-- %(not surprising, for that we would have needed only the maxes of M22.2 ...), -->
<!-- %of 4.M22.2, and of 6.M22.2. -->
<!-- % -->
<!-- %First step: -->
<!-- % -->
<!-- %Compute the tables of the maxes of 2.M22.2. -->
<!-- % -->
<!-- %1. <M>2.M_{22}</M> clear -->
<!-- % -->
<!-- %2. <M>2.L_3(4).2_2</M> easy -->
<!-- % -->
<!-- %for the others, use atlasrep, perm. rep. of <M>2.M_{22}.2</M>, -->
<!-- %and scripts for maxes of <M>M_{22}.2</M> -->
<!-- % -->
<!-- %(Here is one example where the script yields a group that does not contain -->
<!-- %the centre, so we have to form the closure.) -->
<!-- % -->
<!-- %3. preimage of <M>2^4:S_6</M> is already in the library, name is <C>2\^5:S6</C>, -->
<!-- %   a subgroup of <M>S_6(2)</M>; add just the fusion ... -->
<!-- % -->
<!-- %4. this is the only case where we seem to be forced to add a new full table; -->
<!-- %   the structure is <M>2^5.(2 \times S_5)</M> -->
<!-- % -->
<!-- %5. <M>2 \times 2^3:L_3(2) \times 2</M> -->
<!-- % -->
<!-- %6. preimage of <M>A_6.2^2</M> is <M>(2 \times A_6).2^2</M>, an isoclinic table of -->
<!-- %   <C>A6.D8</C>, a subgroup of <M>2.M_{12}</M>. -->
<!-- % -->
<!-- %7. <M>2 \times L_2(11):2</M> (clear from looking at lifting of involutions of -->
<!-- %   <M>M_{22}.2</M>?) -->
<!-- % -->
<!-- 
<Example><![CDATA[
gap> tblMG:= CharacterTable( "12.M22" );;
gap> tblG:= CharacterTable( "6.M22" );;
gap> tblGA:= CharacterTable( "6.M22.2" );;
gap> SetInfoLevel( InfoCharacterTable, 1 );
gap> elms:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );
#I  31 automorphism(s) of order 2
#I  16 automorphism(s) mapping 2 compatibly
#I  8 automorphism(s) mapping 36 compatibly
#I  4 automorphism(s) mapping 48 compatibly
#I  2 automorphism(s) mapping 54 compatibly
#I  2 automorphism(s) acting semiregularly
[ (2,12)(3,11)(4,10)(5,9)(6,8)(14,18)(15,17)(20,22)(24,28)(25,27)(30,31)(33,
    43)(34,42)(35,41)(36,40)(37,39)(45,49)(46,48)(51,61)(52,60)(53,59)(54,
    58)(55,57)(63,73)(64,72)(65,71)(66,70)(67,69)(74,77)(75,76)(78,85)(79,
    84)(80,83)(81,82)(86,98)(87,109)(88,108)(89,107)(90,106)(91,105)(92,
    104)(93,103)(94,102)(95,101)(96,100)(97,99), 
  (2,12)(3,11)(4,10)(5,9)(6,8)(14,18)(15,17)(20,22)(24,28)(25,27)(30,31)(33,
    43)(34,42)(35,41)(36,40)(37,39)(45,49)(46,48)(51,61)(52,60)(53,59)(54,
    58)(55,57)(63,73)(64,72)(65,71)(66,70)(67,69)(74,83)(75,82)(76,81)(77,
    80)(78,79)(84,85)(86,98)(87,109)(88,108)(89,107)(90,106)(91,105)(92,
    104)(93,103)(94,102)(95,101)(96,100)(97,99) ]
gap> elms[1]/elms[2];
(74,80)(75,81)(76,82)(77,83)(78,84)(79,85)

Aha!
not unique!!
(really different result tables?)
(the first does not admit a 2nd power map,
the second currently admits two different ones,
for different element orders -- something such as isoclinism??)

and if we try the step by a 3?

gap> tblMG:= CharacterTable( "12.M22" );;
gap> tblG:= CharacterTable( "4.M22" );;
gap> tblGA:= CharacterTable( "4.M22.2" );;
gap> elms:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );
[ (2,12)(3,11)(4,10)(5,9)(6,8)(14,18)(15,17)(20,22)(24,28)(25,27)(30,31)(33,
    43)(34,42)(35,41)(36,40)(37,39)(45,49)(46,48)(51,61)(52,60)(53,59)(54,
    58)(55,57)(63,73)(64,72)(65,71)(66,70)(67,69)(74,83)(75,82)(76,81)(77,
    80)(78,79)(84,85)(86,98)(87,109)(88,108)(89,107)(90,106)(91,105)(92,
    104)(93,103)(94,102)(95,101)(96,100)(97,99) ]
]]></Example>
 -->
<!-- %and now the tables of the maxes!! -->
<!-- % -->
<!-- % -->
<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- %<Subsection Label="sect:TODO: More <M>M.G.A</M> Examples ...">
<Heading>TODO: More <M>M.G.A</M> Examples ...</Heading> -->
<!-- % -->
<!-- %Mention the question of computing fusions in the examples! -->
<!-- % -->
<!-- %Add an example that a wrong fusion choice leads to corrupt tables. -->
<!-- % -->
<!-- %Example ThM5: <M>(3 \times G_2(3)).2</M> (cf. &nbsp;/construct/ThM5) -->
<!-- % -->
<!-- %Mention possible problems in the bicyclic case: -->
<!-- %<M>3_2.U_4(3) \rightarrow 3_2.U_4(3).2_3'</M> is ambiguous, -->
<!-- %but the MGA situation determines the fusion. -->

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Extra-ordinary p-Modular Tables of the Type M.G.A">
<Heading>Some Extra-ordinary <M>p</M>-Modular Tables of the Type <M>M.G.A</M>
(September 2005)</Heading>

For a group <M>M.G.A</M> in the sense of
Section&nbsp;<Ref Subsect="subsect:theorMGA"/>
such that <E>not</E> all ordinary irreducible characters <M>\chi</M> have
the property that <M>M</M> is contained in the kernel of <M>\chi</M> or
<M>\chi</M> is induced from <M>M.G</M>,
it may happen that there are primes <M>p</M> such that all irreducible
<M>p</M>-modular characters have this property.
This happens if and only if the preimages in <M>M.G.A</M> of each
<M>p</M>-regular
conjugacy class in <M>G.A \setminus G</M> form one conjugacy class.

<P/>

The following function can be used to decide whether this situation applies
to a character table in the &GAP; Character Table Library;
here we assume that for the library table of a group with the structure
<M>M.G.A</M>, the class fusions from <M>M.G</M> and to <M>G.A</M> are stored.

<P/>

<Ignore Remark="gapfilecomments">
</Ignore>
<Example><![CDATA[
gap> FindExtraordinaryCase:= function( tblMGA )
>    local result, der, nsg, tblMGAclasses, orders, tblMG,
>          tblMGfustblMGA, tblMGclasses, pos, M, Mimg, tblMGAfustblGA, tblGA,
>          outer, inv, filt, other, primes, p;
>    result:= [];
>    der:= ClassPositionsOfDerivedSubgroup( tblMGA );
>    nsg:= ClassPositionsOfNormalSubgroups( tblMGA );
>    tblMGAclasses:= SizesConjugacyClasses( tblMGA );
>    orders:= OrdersClassRepresentatives( tblMGA );
>    if Length( der ) < NrConjugacyClasses( tblMGA ) then
>      # Look for tables of normal subgroups of the form $M.G$.
>      for tblMG in Filtered( List( NamesOfFusionSources( tblMGA ),
>                                   CharacterTable ), x -> x <> fail ) do
>        tblMGfustblMGA:= GetFusionMap( tblMG, tblMGA );
>        tblMGclasses:= SizesConjugacyClasses( tblMG );
>        pos:= Position( nsg, Set( tblMGfustblMGA ) );
>        if pos <> fail and
>           Size( tblMG ) = Sum( tblMGAclasses{ nsg[ pos ] } ) then
>          # Look for normal subgroups of the form $M$.
>          for M in Difference( ClassPositionsOfNormalSubgroups( tblMG ),
>                       [ [ 1 ], [ 1 .. NrConjugacyClasses( tblMG ) ] ] ) do
>            Mimg:= Set( tblMGfustblMGA{ M } );
>            if Sum( tblMGAclasses{ Mimg } ) = Sum( tblMGclasses{ M } ) then
>              tblMGAfustblGA:= First( ComputedClassFusions( tblMGA ),
>                  r -> ClassPositionsOfKernel( r.map ) = Mimg );
>              if tblMGAfustblGA <> fail then
>                tblGA:= CharacterTable( tblMGAfustblGA.name );
>                tblMGAfustblGA:= tblMGAfustblGA.map;
>                outer:= Difference( [ 1 .. NrConjugacyClasses( tblGA ) ],
>                    CompositionMaps( tblMGAfustblGA, tblMGfustblMGA ) );
>                inv:= InverseMap( tblMGAfustblGA ){ outer };
>                filt:= Flat( Filtered( inv, IsList ) );
>                if not IsEmpty( filt ) then
>                  other:= Filtered( inv, IsInt );
>                  primes:= Filtered( PrimeDivisors( Size( tblMGA ) ),
>                     p -> ForAll( orders{ filt }, x -> x mod p = 0 )
>                          and ForAny( orders{ other }, x -> x mod p <> 0 ) );
>                  for p in primes do
>                    Add( result, [ Identifier( tblMG ),
>                                   Identifier( tblMGA ),
>                                   Identifier( tblGA ), p ] );
>                  od;
>                fi;
>              fi;
>            fi;
>          od;
>        fi;
>      od;
>    fi;
>    return result;
> end;;
]]></Example>

<P/>

Let us list the tables which are found by this function.

<P/>

<Example><![CDATA[
gap> cases:= [];;
gap> for name in AllCharacterTableNames( IsDuplicateTable, false ) do
>      Append( cases, FindExtraordinaryCase( CharacterTable( name ) ) );
>    od;
gap> for i in Set( cases ) do
>      Print( i, "\n" ); 
>    od;
[ "2.A6", "2.A6.2_1", "A6.2_1", 3 ]
[ "2.Fi22", "2.Fi22.2", "Fi22.2", 3 ]
[ "2.L2(25)", "2.L2(25).2_2", "L2(25).2_2", 5 ]
[ "2.L2(49)", "2.L2(49).2_2", "L2(49).2_2", 7 ]
[ "2.L2(81)", "2.L2(81).2_1", "L2(81).2_1", 3 ]
[ "2.L2(81)", "2.L2(81).4_1", "L2(81).4_1", 3 ]
[ "2.L2(81).2_1", "2.L2(81).4_1", "L2(81).4_1", 3 ]
[ "2.L4(3)", "2.L4(3).2_2", "L4(3).2_2", 3 ]
[ "2.L4(3)", "2.L4(3).2_3", "L4(3).2_3", 3 ]
[ "2.S3", "2.D12", "S3x2", 3 ]
[ "2.U4(3).2_1", "2.U4(3).(2^2)_{12*2*}", "U4(3).(2^2)_{122}", 3 ]
[ "2.U4(3).2_1", "2.U4(3).(2^2)_{122}", "U4(3).(2^2)_{122}", 3 ]
[ "2.U4(3).2_1", "2.U4(3).(2^2)_{13*3*}", "U4(3).(2^2)_{133}", 3 ]
[ "2.U4(3).2_1", "2.U4(3).(2^2)_{133}", "U4(3).(2^2)_{133}", 3 ]
[ "3.U3(8)", "3.U3(8).3_1", "U3(8).3_1", 2 ]
[ "3.U3(8)", "3.U3(8).6", "U3(8).6", 2 ]
[ "3.U3(8)", "3.U3(8).6", "U3(8).6", 3 ]
[ "3.U3(8).2", "3.U3(8).6", "U3(8).6", 2 ]
[ "3^2:8", "2.A8N3", "s3wrs2", 3 ]
[ "5^(1+2):8:4", "2.HS.2N5", "HS.2N5", 5 ]
[ "6.A6", "6.A6.2_1", "3.A6.2_1", 3 ]
[ "6.A6", "6.A6.2_1", "A6.2_1", 3 ]
[ "6.Fi22", "6.Fi22.2", "3.Fi22.2", 3 ]
[ "6.Fi22", "6.Fi22.2", "Fi22.2", 3 ]
[ "Isoclinic(2.U4(3).2_1)", "2.U4(3).(2^2)_{1*2*2}", 
  "U4(3).(2^2)_{122}", 3 ]
[ "Isoclinic(2.U4(3).2_1)", "2.U4(3).(2^2)_{1*3*3}", 
  "U4(3).(2^2)_{133}", 3 ]
[ "bd10", "2.D20", "D20", 5 ]
]]></Example>

<P/>

The smallest example in this list is <M>2.A_6.2_1</M>,
the double cover of the symmetric group on six points.
The <M>3</M>-modular table of this group looks as follows.

<P/>

<Example><![CDATA[
gap> Display( CharacterTable( "2.A6.2_1" ) mod 3 );
2.A6.2_1mod3

     2  5   5  4  3  1   1  4  4  3
     3  2   2  .  .  .   .  1  1  .
     5  1   1  .  .  1   1  .  .  .

       1a  2a 4a 8a 5a 10a 2b 4b 8b
    2P 1a  1a 2a 4a 5a  5a 1a 2a 4a
    3P 1a  2a 4a 8a 5a 10a 2b 4b 8b
    5P 1a  2a 4a 8a 1a  2a 2b 4b 8b

X.1     1   1  1  1  1   1  1  1  1
X.2     1   1  1  1  1   1 -1 -1 -1
X.3     6   6 -2  2  1   1  .  .  .
X.4     4   4  . -2 -1  -1  2 -2  .
X.5     4   4  . -2 -1  -1 -2  2  .
X.6     9   9  1  1 -1  -1  3  3 -1
X.7     9   9  1  1 -1  -1 -3 -3  1
X.8     4  -4  .  . -1   1  .  .  .
X.9    12 -12  .  .  2  -2  .  .  .
]]></Example>

<P/>

We see that the two faithful irreducible characters vanish on the three
classes outside <M>2.A_6</M>.

<P/>

For the groups in the above list,
the function
<Ref Func="BrauerTableOfTypeMGA" BookName="ctbllib"/>
can be used to construct
the <M>p</M>-modular tables of <M>M.G.A</M> from the tables of <M>M.G</M>
and <M>G.A</M>,
for the given special primes <M>p</M>.
The computations can be performed as follows.

<P/>

<Example><![CDATA[
gap> for input in cases do
>      p:= input[4];
>      modtblMG:=  CharacterTable( input[1] ) mod p;
>      ordtblMGA:= CharacterTable( input[2] );
>      modtblGA:=  CharacterTable( input[3] ) mod p;
>      name:= Concatenation( Identifier( ordtblMGA ), " mod ", String(p) );
>      if ForAll( [ modtblMG, modtblGA ], IsCharacterTable ) then
>        poss:= BrauerTableOfTypeMGA( modtblMG, modtblGA, ordtblMGA );
>        modlib:= ordtblMGA mod p;
>        if IsCharacterTable( modlib ) then
>          trans:= TransformingPermutationsCharacterTables( poss.table,
>                      modlib );
>          if not IsRecord( trans ) then
>            Print( "#E  computed table and library table for ", name,
>                   " differ\n" );
>          fi;
>        else
>          Print( "#I  no library table for ", name, "\n" );
>        fi;
>      else
>        Print( "#I  not all input tables for ", name, " available\n" );
>      fi;
>    od;
#I  not all input tables for 2.L2(49).2_2 mod 7 available
#I  not all input tables for 2.L2(81).2_1 mod 3 available
#I  not all input tables for 2.L2(81).4_1 mod 3 available
#I  not all input tables for 2.L2(81).4_1 mod 3 available
]]></Example>
 
The examples <M>2.A_6.2_1</M>, <M>2.L_2(25).2_2</M>, and <M>2.L_2(49).2_2</M>
belong to the infinite series of semiliniear groups
<M>\Sigma</M>L<M>(2,p^2)</M>, for odd primes <M>p</M>.
All groups in this series have the property that all faithful irreducible
characters vanish on the <M>p</M>-regular classes outside SL<M>(2,p^2)</M>.
(Cf.&nbsp;Section&nbsp;<Ref Subsect="subsect:isoclinicATLAS"/>
for another property of the groups in this series.)

</Subsection>
</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:GS3">
<Heading>Examples for the Type <M>G.S_3</M></Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="sect:Small Examples">
<Heading>Small Examples</Heading>

The symmetric group <M>S_4</M> on four points has the form <M>G.S_3</M>
where <M>G</M> is the Klein four group <M>V_4</M>,
<M>G.2</M> is the dihedral group <M>D_8</M> of order <M>8</M>,
and <M>G.3</M> is the alternating group <M>A_4</M>.
The trivial character of <M>A_4</M> extends twofold to <M>S_4</M>, in the same way
as the trivial character of <M>V_4</M> extends to the dihedral group.
The nontrivial linear characters of <M>A_4</M> induce irreducibly to <M>S_4</M>.
The irreducible degree three character of <M>A_4</M> is induced from any of the
three nontrivial linear characters of <M>V_4</M>,
it extends to <M>S_4</M> in the same way as the unique constituent of the
restriction to <M>V_4</M> that is invariant in the chosen <M>D_8</M> extends to <M>D_8</M>.

<P/>

<Example><![CDATA[
gap> c2:= CharacterTable( "Cyclic", 2 );;
gap> t:= c2 * c2;;
gap> tC:= CharacterTable( "Dihedral", 8 );;
gap> tK:= CharacterTable( "Alternating", 4 );;
gap> tfustC:= PossibleClassFusions( t, tC );
[ [ 1, 3, 4, 4 ], [ 1, 3, 5, 5 ], [ 1, 4, 3, 4 ], [ 1, 4, 4, 3 ], 
  [ 1, 5, 3, 5 ], [ 1, 5, 5, 3 ] ]
gap> StoreFusion( t, tfustC[1], tC );
gap> tfustK:= PossibleClassFusions( t, tK );
[ [ 1, 2, 2, 2 ] ]
gap> StoreFusion( t, tfustK[1], tK );
gap> elms:= PossibleActionsForTypeGS3( t, tC, tK );
[ (3,4) ]
gap> new:= CharacterTableOfTypeGS3( t, tC, tK, elms[1], "S4" );
rec( table := CharacterTable( "S4" ), 
  tblCfustblKC := [ 1, 4, 2, 2, 5 ], tblKfustblKC := [ 1, 2, 3, 3 ] )
gap> Display( new.table );
S4

     2  3  3  .  2  2
     3  1  .  1  .  .

       1a 2a 3a 4a 2b
    2P 1a 1a 3a 2a 1a
    3P 1a 2a 1a 4a 2b

X.1     1  1  1  1  1
X.2     1  1  1 -1 -1
X.3     3 -1  .  1 -1
X.4     3 -1  . -1  1
X.5     2  2 -1  .  .
]]></Example>

<P/>

The case <M>e > 1</M> occurs in the following example.
We choose <M>G</M> the cyclic group of order two,
<M>G.C</M> the cyclic group of order six,
<M>G.K</M> the quaternion group of order eight,
and construct the character table of <M>G.F = SL_2(3)</M>,
with <M>F \cong A_4</M>.

<P/>

We get three extensions of the trivial character of <M>G.K</M> to <M>G.F</M>,
a degree three character induced from the nontrivial linear characters
of <M>G.K</M>,
and three extensions of the irreducible degree <M>2</M> character of <M>G.K</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "Cyclic", 2 );;
gap> tC:= CharacterTable( "Cyclic", 6 );;
gap> tK:= CharacterTable( "Quaternionic", 8 );;
gap> tfustC:= PossibleClassFusions( t, tC );
[ [ 1, 4 ] ]
gap> StoreFusion( t, tfustC[1], tC );
gap> tfustK:= PossibleClassFusions( t, tK );
[ [ 1, 3 ] ]
gap> StoreFusion( t, tfustK[1], tK );
gap> elms:= PossibleActionsForTypeGS3( t, tC, tK );
[ (2,5,4) ]
gap> new:= CharacterTableOfTypeGS3( t, tC, tK, elms[1], "SL(2,3)" );
rec( table := CharacterTable( "SL(2,3)" ), 
  tblCfustblKC := [ 1, 4, 5, 3, 6, 7 ], 
  tblKfustblKC := [ 1, 2, 3, 2, 2 ] )
gap> Display( new.table );
SL(2,3)

     2  3  2  3  1   1   1  1
     3  1  .  1  1   1   1  1

       1a 4a 2a 6a  3a  3b 6b
    2P 1a 2a 1a 3a  3b  3a 3b
    3P 1a 4a 2a 2a  1a  1a 2a

X.1     1  1  1  1   1   1  1
X.2     1  1  1  A  /A   A /A
X.3     1  1  1 /A   A  /A  A
X.4     3 -1  3  .   .   .  .
X.5     2  . -2 /A  -A -/A  A
X.6     2  . -2  1  -1  -1  1
X.7     2  . -2  A -/A  -A /A

A = E(3)
  = (-1+Sqrt(-3))/2 = b3
]]></Example>

<!-- % small Brauer table? -->

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:xplGS3">
<Heading>&ATLAS; Tables of the Type <M>G.S_3</M></Heading>

We demonstrate the construction of all those ordinary and modular character
tables in the &GAP; Character Table Library that are of the type <M>G.S_3</M>
where <M>G</M> is a simple group or a central extension of a simple group whose
character table is contained in the &ATLAS;.
Here is the list of
<Ref Func="Identifier" BookName="ref"/>
values needed for accessing the input
tables and the known library tables corresponding to the output.

<P/>

<Example><![CDATA[
gap> listGS3:= [
> [ "U3(5)",      "U3(5).2",      "U3(5).3",      "U3(5).S3"        ],
> [ "3.U3(5)",    "3.U3(5).2",    "3.U3(5).3",    "3.U3(5).S3"      ],
> [ "L3(4)",      "L3(4).2_2",    "L3(4).3",      "L3(4).3.2_2"     ],
> [ "L3(4)",      "L3(4).2_3",    "L3(4).3",      "L3(4).3.2_3"     ],
> [ "3.L3(4)",    "3.L3(4).2_2",  "3.L3(4).3",    "3.L3(4).3.2_2"   ],
> [ "3.L3(4)",    "3.L3(4).2_3",  "3.L3(4).3",    "3.L3(4).3.2_3"   ],
> [ "2^2.L3(4)",  "2^2.L3(4).2_2","2^2.L3(4).3",  "2^2.L3(4).3.2_2" ],
> [ "2^2.L3(4)",  "2^2.L3(4).2_3","2^2.L3(4).3",  "2^2.L3(4).3.2_3" ],
> [ "U6(2)",      "U6(2).2",      "U6(2).3",      "U6(2).3.2"       ],
> [ "3.U6(2)",    "3.U6(2).2",    "3.U6(2).3",    "3.U6(2).3.2"     ],
> [ "2^2.U6(2)",  "2^2.U6(2).2",  "2^2.U6(2).3",  "2^2.U6(2).3.2"   ],
> [ "O8+(2)",     "O8+(2).2",     "O8+(2).3",     "O8+(2).3.2"      ],
> [ "2^2.O8+(2)", "2^2.O8+(2).2", "2^2.O8+(2).3", "2^2.O8+(2).3.2"  ],
> [ "L3(7)",      "L3(7).2",      "L3(7).3",      "L3(7).S3"        ],
> [ "3.L3(7)",    "3.L3(7).2",    "3.L3(7).3",    "3.L3(7).S3"      ],
> [ "U3(8)",      "U3(8).2",      "U3(8).3_2",    "U3(8).S3"        ],
> [ "3.U3(8)",    "3.U3(8).2",    "3.U3(8).3_2",  "3.U3(8).S3"      ],
> [ "U3(11)",     "U3(11).2",     "U3(11).3",     "U3(11).S3"       ],
> [ "3.U3(11)",   "3.U3(11).2",   "3.U3(11).3",   "3.U3(11).S3"     ],
> [ "O8+(3)",     "O8+(3).2_2",   "O8+(3).3",     "O8+(3).S3"       ],
> [ "2E6(2)",     "2E6(2).2",     "2E6(2).3",     "2E6(2).S3"       ],
> [ "2^2.2E6(2)", "2^2.2E6(2).2", "2^2.2E6(2).3", "2^2.2E6(2).S3"   ],
> ];;
]]></Example>

<P/>

(For <M>G</M> one of <M>L_3(4)</M>, <M>U_6(2)</M>, <M>O_8^+(2)</M>,
and <M>{}^2E_6(2)</M>,
the tables of <M>2^2.G</M>, <M>2^2.G.2</M>, and <M>2^2.G.3</M>
can be constructed
with the methods described in Section&nbsp;<Ref Subsect="subsect:theorV4G"/>
and Section&nbsp;<Ref Subsect="subsect:theorMGA"/>, respectively.)

<P/>

Analogously, the automorphism groups of <M>L_3(4)</M>, <M>U_3(8)</M>,
and <M>O_8^+(3)</M>
have factor groups isomorphic with <M>S_3</M>;
in these cases,
we choose <M>G = L_3(4).2_1</M>, <M>G = U_3(8).3_1</M>,
and <M>G = O_8^+(3).2^2_{111}</M>, respectively.

<P/>

<Example><![CDATA[
gap> Append( listGS3, [
> [ "L3(4).2_1",          "L3(4).2^2",     "L3(4).6",     "L3(4).D12"     ],
> [ "2^2.L3(4).2_1",      "2^2.L3(4).2^2", "2^2.L3(4).6", "2^2.L3(4).D12" ],
> [ "U3(8).3_1",          "U3(8).6",       "U3(8).3^2",   "U3(8).(S3x3)"  ],
> [ "O8+(3).(2^2)_{111}", "O8+(3).D8",     "O8+(3).A4",   "O8+(3).S4"     ],
> ] );
]]></Example>

<P/>

In all these cases, the required table automorphism of <M>G.3</M> is uniquely
determined.
We first compute the ordinary character table of <M>G.S_3</M> and then
the <M>p</M>-modular tables,
for all prime divisors <M>p</M> of the order of <M>G</M> such that
the &GAP; Character Table Library contains the necessary <M>p</M>-modular
input tables.

<P/>

In each case, we compare the computed character tables with the ones in
the &GAP; Character Table Library.
Note that in order to avoid conflicts of the class fusions that arise in
the construction with the class fusions that are already stored on the
library tables, we choose identifiers for the result tables that are
different from the identifiers of the library tables.

<P/>

<Ignore Remark="gapfilecomments">
</Ignore>
<Example><![CDATA[
gap> ProcessGS3Example:= function( t, tC, tK, identifier, pi )
>    local tF, lib, trans, p, tmodp, tCmodp, tKmodp, modtF;
> 
>    tF:= CharacterTableOfTypeGS3( t, tC, tK, pi,
>             Concatenation( identifier, "new" ) );
>    lib:= CharacterTable( identifier );
>    if lib <> fail then
>      trans:= TransformingPermutationsCharacterTables( tF.table, lib );
>      if not IsRecord( trans ) then
>        Print( "#E  computed table and library table for `", identifier,
>               "' differ\n" );
>      fi;
>    else
>      Print( "#I  no library table for `", identifier, "'\n" );
>    fi;
>    StoreFusion( tC, tF.tblCfustblKC, tF.table );
>    StoreFusion( tK, tF.tblKfustblKC, tF.table );
>    for p in PrimeDivisors( Size( t ) ) do
>      tmodp := t  mod p;
>      tCmodp:= tC mod p;
>      tKmodp:= tK mod p;
>      if IsCharacterTable( tmodp ) and
>         IsCharacterTable( tCmodp ) and
>         IsCharacterTable( tKmodp ) then
>        modtF:= CharacterTableOfTypeGS3( tmodp, tCmodp, tKmodp,
>                    tF.table,
>                    Concatenation(  identifier, "mod", String( p ) ) );
>        if   Length( Irr( modtF.table ) ) <>
>             Length( Irr( modtF.table )[1] ) then
>          Print( "#E  nonsquare result table for `",
>                 identifier, " mod ", p, "'\n" );
>        elif lib <> fail and IsCharacterTable( lib mod p ) then
>          trans:= TransformingPermutationsCharacterTables( modtF.table,
>                                                           lib mod p );
>          if not IsRecord( trans ) then
>            Print( "#E  computed table and library table for `",
>                   identifier, " mod ", p, "' differ\n" );
>          fi;
>        else
>          Print( "#I  no library table for `", identifier, " mod ",
>                 p, "'\n" );
>        fi;
>      else
>        Print( "#I  not all inputs available for `", identifier,
>               " mod ", p, "'\n" );
>      fi;
>    od;
> end;;
]]></Example>

<P/>

Now we call the function for the examples in the list.

<P/>

<Example><![CDATA[
gap> for input in listGS3 do
>      t := CharacterTable( input[1] );
>      tC:= CharacterTable( input[2] );
>      tK:= CharacterTable( input[3] );
>      identifier:= input[4];
>      elms:= PossibleActionsForTypeGS3( t, tC, tK );
>      if Length( elms ) = 1 then
>        ProcessGS3Example( t, tC, tK, identifier, elms[1] );
>      else
>        Print( "#I  ", Length( elms ), " actions possible for `",
>               identifier, "'\n" );
>      fi;
>    od;
#I  not all inputs available for `O8+(3).S3 mod 3'
#I  not all inputs available for `2E6(2).S3 mod 2'
#I  not all inputs available for `2E6(2).S3 mod 3'
#I  not all inputs available for `2E6(2).S3 mod 5'
#I  not all inputs available for `2E6(2).S3 mod 7'
#I  not all inputs available for `2E6(2).S3 mod 11'
#I  not all inputs available for `2E6(2).S3 mod 13'
#I  not all inputs available for `2E6(2).S3 mod 17'
#I  not all inputs available for `2E6(2).S3 mod 19'
#I  not all inputs available for `2^2.2E6(2).S3 mod 2'
#I  not all inputs available for `2^2.2E6(2).S3 mod 3'
#I  not all inputs available for `2^2.2E6(2).S3 mod 5'
#I  not all inputs available for `2^2.2E6(2).S3 mod 7'
#I  not all inputs available for `2^2.2E6(2).S3 mod 11'
#I  not all inputs available for `2^2.2E6(2).S3 mod 13'
#I  not all inputs available for `2^2.2E6(2).S3 mod 17'
#I  not all inputs available for `2^2.2E6(2).S3 mod 19'
#I  not all inputs available for `U3(8).(S3x3) mod 2'
#I  not all inputs available for `U3(8).(S3x3) mod 19'
#I  not all inputs available for `O8+(3).S4 mod 3'
]]></Example>

<P/>

Also the ordinary character table of the automorphic extension
of the simple &ATLAS; group <M>O_8^+(3)</M> by <M>A_4</M> can be constructed
with the same approach.
Here we get four possible permutations, which lead to essentially the
same character table.

<P/>

<Example><![CDATA[
gap> input:= [ "O8+(3)", "O8+(3).3", "O8+(3).(2^2)_{111}", "O8+(3).A4" ];;
gap> t := CharacterTable( input[1] );;
gap> tC:= CharacterTable( input[2] );;
gap> tK:= CharacterTable( input[3] );;
gap> identifier:= input[4];;
gap> elms:= PossibleActionsForTypeGS3( t, tC, tK );;
gap> Length( elms );
4
gap> differ:= MovedPoints( Group( List( elms, x -> x / elms[1] ) ) );;
gap> List( elms, x -> RestrictedPerm( x, differ ) );
[ (118,216,169)(119,217,170)(120,218,167)(121,219,168), 
  (118,216,170)(119,217,169)(120,219,168)(121,218,167), 
  (118,217,169)(119,216,170)(120,218,168)(121,219,167), 
  (118,217,170)(119,216,169)(120,219,167)(121,218,168) ]
gap> poss:= List( elms, pi -> CharacterTableOfTypeGS3( t, tC, tK, pi,
>             Concatenation( identifier, "new" ) ) );;
gap> lib:= CharacterTable( identifier );;
gap> ForAll( poss, r -> IsRecord(
>        TransformingPermutationsCharacterTables( r.table, lib ) ) );
true
]]></Example>

<P/>

Also the construction of the <M>p</M>-modular tables of <M>O_8^+(3).A_4</M>
works.

<P/>

<Example><![CDATA[
gap> ProcessGS3Example( t, tC, tK, identifier, elms[1] );
#I  not all inputs available for `O8+(3).A4 mod 3'
]]></Example>

<!-- Remark:

cross-reference to the 2.G.2 situations mentioned in this file!

     In the tables of O8+(2).S3 and O8+(3).S3, the outer involution swaps
     only 3-singular classes.
     Thus the 3-modular tables have the property that all Brauer characters
     of the subgroup of index 2 extend.
     (We do not have the table of O8+(3).2_2 mod 3 yet.)
Thus we do not know how they extend ...

     GAP function for turning this into an example:

     gap> fun:= function( tblG3, tblGS3 )
     > local fus, ord;
     > fus:= GetFusionMap( tblG3, tblGS3 );
     > ord:= OrdersClassRepresentatives( tblG3 );
     > if ForAll( Filtered( InverseMap( fus ), IsList ),
     >            x -> ord[ x[1] ] mod 3 = 0 ) then
     >   Print( "found ", tblG3, "\n" );
     > fi;
     > end;;
     gap> for l in listGS3 do
     >      fun( CharacterTable( l[3] ), CharacterTable( l[4] ) );
     >    od;
     found CharacterTable( "O8+(2).3" )
     found CharacterTable( "O8+(3).3" )
-->

</Subsection>
</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:xplGV4">
<Heading>Examples for the Type <M>G.2^2</M></Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="sect:The Character Table of A_6.2^2">
<Heading>The Character Table of <M>A_6.2^2</M></Heading>

As the first example,
we consider the automorphism group Aut<M>( A_6 ) \cong A_6.2^2</M> of the
alternating group <M>A_6</M> on six points.

<P/>

In this case, the triple of actions on the subgroups <M>A_6.2_i</M> is uniquely
determined by the condition on the number of conjugacy classes
in Section&nbsp;<Ref Subsect="subsect:theorGV4"/>.

<P/>

<Example><![CDATA[
gap> tblG:= CharacterTable( "A6" );;
gap> tblsG2:= List( [ "A6.2_1", "A6.2_2", "A6.2_3" ], CharacterTable );;
gap> List( tblsG2, NrConjugacyClasses );
[ 11, 11, 8 ]
gap> possact:= List( tblsG2, x -> Filtered( Elements( 
>        AutomorphismsOfTable( x ) ), y -> Order( y ) <= 2 ) );
[ [ (), (3,4)(7,8)(10,11) ], 
  [ (), (8,9), (5,6)(10,11), (5,6)(8,9)(10,11) ], [ (), (7,8) ] ]
]]></Example>

<P/>

Note that <M>n_1 = n_2</M> implies <M>f_1 = f_2</M>,
and <M>n_1 - n_3 = 3</M> implies <M>f_1 - f_3 = 2</M>,
so we get <M>f_1 = 3</M> and <M>f_3 = 1</M>,
and <M>A_6.2^2</M> has
<M>2 \cdot 11 - 3 \cdot 3 = 2 \cdot 8 - 3 \cdot 1 = 13</M> classes.

<P/>

(The compatibility on the classes inside <M>A_6</M> yields only
that the classes <M>3</M> and <M>4</M> of <M>A_6.2_1 \cong S_6</M>
must be fused in <M>A_6.2^2</M>,
as well as the classes <M>5</M> and <M>6</M> of
<M>A_6.2_2 \cong</M> PGL<M>(2,9)</M>.)

<P/>

<Example><![CDATA[
gap> List( tblsG2, x -> GetFusionMap( tblG, x ) );
[ [ 1, 2, 3, 4, 5, 6, 6 ], [ 1, 2, 3, 3, 4, 5, 6 ], 
  [ 1, 2, 3, 3, 4, 5, 5 ] ]
]]></Example>

<P/>

These arguments are used by the &GAP; function
<Ref Func="PossibleActionsForTypeGV4" BookName="ctbllib"/>,
which returns the list of all possible triples of permutations such that
the <M>i</M>-th permutation describes the action of <M>A_6.2^2</M>
on the classes of <M>A_6.2_i</M>.

<P/>

<Example><![CDATA[
gap> acts:= PossibleActionsForTypeGV4( tblG, tblsG2 );    
[ [ (3,4)(7,8)(10,11), (5,6)(8,9)(10,11), (7,8) ] ]
]]></Example>

<P/>

For the given actions, the &GAP; function
<Ref Func="PossibleCharacterTablesOfTypeGV4" BookName="ctbllib"/>
then computes the possibilities for the character table of <M>A_6.2^2</M>;
in this case, the result is unique.

<P/>

<Example><![CDATA[
gap> poss:= PossibleCharacterTablesOfTypeGV4( tblG, tblsG2, acts[1],
>               "A6.2^2" );
[ rec( 
      G2fusGV4 := [ [ 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8 ], 
          [ 1, 2, 3, 4, 5, 5, 9, 10, 10, 11, 11 ], 
          [ 1, 2, 3, 4, 5, 12, 13, 13 ] ], 
      table := CharacterTable( "A6.2^2" ) ) ]
gap> IsRecord( TransformingPermutationsCharacterTables( poss[1].table,
>                  CharacterTable( "A6.2^2" ) ) );
true
]]></Example>

<P/>

Finally, possible <M>p</M>-modular tables can be computed from
the <M>p</M>-modular input tables and the ordinary table of <M>A_6.2^2</M>;
here we show this for <M>p = 3</M>.

<P/>

<Example><![CDATA[
gap> PossibleCharacterTablesOfTypeGV4( tblG mod 3,
>        List( tblsG2, t -> t mod 3 ), poss[1].table );
[ rec( 
      G2fusGV4 := 
        [ [ 1, 2, 3, 4, 5, 5, 6 ], [ 1, 2, 3, 4, 4, 7, 8, 8, 9, 9 ], 
          [ 1, 2, 3, 4, 10, 11, 11 ] ], 
      table := BrauerTable( "A6.2^2", 3 ) ) ]
]]></Example>

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:xplGV43.A6.V4">
<Heading>&ATLAS; Tables of the Type <M>G.2^2</M> &ndash; Easy Cases</Heading>

We demonstrate the construction of all those ordinary and modular character
tables in the &GAP; Character Table Library that are of the type <M>G.2^2</M>
where <M>G</M> is a simple group or a central extension of a simple group whose
character table is contained in the &ATLAS;.
Here is the list of
<Ref Func="Identifier" BookName="ref"/>
values needed for accessing the input
tables and the result tables.

<P/>

(The construction of the character table of <M>O_8^+(3).2^2_{111}</M>
is more involved and will be described in
Section&nbsp;<Ref Subsect="subsect:O_8^+(3).2^2_111"/>.
The construction of the character tables of groups of the type
<M>2.L_3(4).2^2</M> and <M>6.L_3(4).2^2</M> is described
in the sections&nbsp;<Ref Subsect="subsect:2L34V4"/>
and&nbsp;<Ref Subsect="subsect:6L34V4"/>, respectively.
The construction of the character tables of groups of the type
<M>2.U_4(3).2^2</M> is described in Section&nbsp;<Ref Subsect="subsect:2U43V4"/>.)

<P/>

<Example><![CDATA[
gap> listGV4:= [
> [ "A6",      "A6.2_1",      "A6.2_2",      "A6.2_3",      "A6.2^2"      ],
> [ "3.A6",    "3.A6.2_1",    "3.A6.2_2",    "3.A6.2_3",    "3.A6.2^2"    ],
> [ "L2(25)",  "L2(25).2_1",  "L2(25).2_2",  "L2(25).2_3",  "L2(25).2^2"  ],
> [ "L3(4)",   "L3(4).2_1",   "L3(4).2_2",   "L3(4).2_3",   "L3(4).2^2"   ],
> [ "2^2.L3(4)", "2^2.L3(4).2_1", "2^2.L3(4).2_2", "2^2.L3(4).2_3",
>                                                         "2^2.L3(4).2^2" ],
> [ "3.L3(4)", "3.L3(4).2_1", "3.L3(4).2_2", "3.L3(4).2_3", "3.L3(4).2^2" ],
> [ "U4(3)",   "U4(3).2_1",   "U4(3).2_2",   "U4(3).2_2'",
>                                                     "U4(3).(2^2)_{122}" ],
> [ "U4(3)",   "U4(3).2_1",   "U4(3).2_3",   "U4(3).2_3'",
>                                                     "U4(3).(2^2)_{133}" ],
> [ "3_1.U4(3)", "3_1.U4(3).2_1", "3_1.U4(3).2_2", "3_1.U4(3).2_2'",
>                                                 "3_1.U4(3).(2^2)_{122}" ],
> [ "3_2.U4(3)", "3_2.U4(3).2_1", "3_2.U4(3).2_3", "3_2.U4(3).2_3'",
>                                                 "3_2.U4(3).(2^2)_{133}" ],
> [ "L2(49)",  "L2(49).2_1",  "L2(49).2_2",  "L2(49).2_3",  "L2(49).2^2"  ],
> [ "L2(81)",  "L2(81).2_1",  "L2(81).2_2",  "L2(81).2_3",  "L2(81).2^2"  ],
> [ "L3(9)",   "L3(9).2_1",   "L3(9).2_2",   "L3(9).2_3",   "L3(9).2^2"   ],
> [ "O8+(3)",  "O8+(3).2_1",  "O8+(3).2_2",  "O8+(3).2_2'",
>                                                    "O8+(3).(2^2)_{122}" ],
> [ "O8-(3)",  "O8-(3).2_1",  "O8-(3).2_2",  "O8-(3).2_3",  "O8-(3).2^2"  ],
> ];;
]]></Example>

<P/>

Analogously,
the automorphism groups <M>L_3(4).D_{12}</M> of <M>L_3(4)</M>
and <M>U_4(3).D_8</M> of <M>U_4(3)</M>,
and the subgroup <M>O_8^+(3).D_8</M> of the automorphism group <M>O_8^+(3).S_4</M>
have factor groups that are isomorphic with <M>2^2</M>;
in these cases,
we choose <M>G = L_3(4).3</M>, <M>G = U_4(3).2_1</M>, and <M>G = O_8^+(3).2_1</M>,
respectively.

<P/>

Also the group <M>2^2.L_3(4).D_{12}</M> has a factor group isomorphic with <M>2^2</M>.
Note that the character tables of <M>L_3(4).D_{12}</M> and <M>2^2.L_3(4).D_{12}</M>
have been constructed already in Section&nbsp;<Ref Subsect="subsect:xplGS3"/>.

<P/>

The automorphism groups of <M>L_4(4)</M> and <M>U_4(5)</M> have the structure
<M>L_4(4).2^2</M> and <M>U_4(5).2^2</M>, respectively;
their tables are contained in the &GAP; Character Table Library
but not in the &ATLAS;.

<P/>

<Example><![CDATA[
gap> Append( listGV4, [
> [ "L3(4).3", "L3(4).6",     "L3(4).3.2_2", "L3(4).3.2_3", "L3(4).D12"   ],
> [ "2^2.L3(4).3", "2^2.L3(4).6", "2^2.L3(4).3.2_2", "2^2.L3(4).3.2_3",
>                                                         "2^2.L3(4).D12" ],
> [ "U4(3).2_1", "U4(3).4", "U4(3).(2^2)_{122}", "U4(3).(2^2)_{133}",
>                                                              "U4(3).D8" ],
> [ "O8+(3).2_1", "O8+(3).(2^2)_{111}", "O8+(3).(2^2)_{122}", "O8+(3).4",
>                                                             "O8+(3).D8" ],
> [ "L4(4)",   "L4(4).2_1",   "L4(4).2_2",   "L4(4).2_3",   "L4(4).2^2"   ],
> [ "U4(5)",   "U4(5).2_1",   "U4(5).2_2",   "U4(5).2_3",   "U4(5).2^2"   ],
> ] );
]]></Example>

<P/>

Now we proceed in two steps, the computation of the possible ordinary
character tables from the ordinary tables of the relevant subgroups,
and then the computation of the Brauer tables from the Brauer tables of the
relevant subgroups and from the ordinary table of the group.

<P/>

The following function first computes the possible triples of actions on the
subgroups <M>G.2_i</M>, using the function
<Ref Func="PossibleActionsForTypeGV4" BookName="ctbllib"/>.
Then the union of the candidate tables for these actions is computed,
this list is returned in the end.
and representatives of classes of permutation equivalent candidates are
inspected further with consistency checks.
If there is a unique solution up to permutation equivalence,
this table is compared with the one that is contained in the
&GAP; Character Table Library.

<P/>

<Ignore Remark="gapfilecomments">
</Ignore>
<Example><![CDATA[
gap> ConstructOrdinaryGV4Table:= function( tblG, tblsG2, name, lib )
>      local acts, nam, poss, reps, i, trans;
> 
>      # Compute the possible actions for the ordinary tables.
>      acts:= PossibleActionsForTypeGV4( tblG, tblsG2 );
>      # Compute the possible ordinary tables for the given actions.
>      nam:= Concatenation( "new", name );
>      poss:= Concatenation( List( acts, triple -> 
>          PossibleCharacterTablesOfTypeGV4( tblG, tblsG2, triple, nam ) ) );
>      # Test the possibilities for permutation equivalence.
>      reps:= RepresentativesCharacterTables( poss );
>      if 1 < Length( reps ) then
>        Print( "#I  ", name, ": ", Length( reps ),
>               " equivalence classes\n" );
>      elif Length( reps ) = 0 then
>        Print( "#E  ", name, ": no solution\n" );
>      else
>        # Compare the computed table with the library table.
>        if not IsCharacterTable( lib ) then
>          Print( "#I  no library table for ", name, "\n" );
>          PrintToLib( name, poss[1].table );
>          for i in [ 1 .. 3 ] do
>            Print( LibraryFusion( tblsG2[i],
>                       rec( name:= name, map:= poss[1].G2fusGV4[i] ) ) );
>          od;
>        else
>          trans:= TransformingPermutationsCharacterTables( poss[1].table,
>                      lib );
>          if not IsRecord( trans ) then
>            Print( "#E  computed table and library table for ", name,
>                   " differ\n" );
>          fi;
>          # Compare the computed fusions with the stored ones.
>          if List( poss[1].G2fusGV4, x -> OnTuples( x, trans.columns ) )
>                 <> List( tblsG2, x -> GetFusionMap( x, lib ) ) then
>            Print( "#E  computed and stored fusions for ", name,
>                   " differ\n" );
>          fi;
>        fi;
>      fi;
>      return poss;
>    end;;
]]></Example>

<P/>

The following function computes, for all those prime divisors <M>p</M> of the
group order in question such that the <M>p</M>-modular Brauer tables of the
subgroups <M>G.2_i</M> are available, the possible <M>p</M>-modular Brauer tables.
If the solution is unique up to permutation equivalence,
it is compared with the table that is contained in the
&GAP; Character Table Library.

<P/>

It may happen (even in the case that the ordinary character table is
unique up to permutation equivalence) that some candidates for the
ordinary character table are excluded due to information provided by
some <M>p</M>-modular table.
In this case, a message is printed, and the ordinary character table
from the &GAP; Character Table Library is checked again under the
additional restrictions.

<P/>

<Ignore Remark="gapfilecomments">
</Ignore>
<Example><![CDATA[
gap> ConstructModularGV4Tables:= function( tblG, tblsG2, ordposs,
>                                          ordlibtblGV4 )
>      local name, modposs, primes, checkordinary, i, record, p, tmodp,
>            t2modp, poss, modlib, trans, reps;
> 
>      if not IsCharacterTable( ordlibtblGV4 ) then
>        Print( "#I  no ordinary library table ...\n" );
>        return [];
>      fi;
>      name:= Identifier( ordlibtblGV4 );
>      modposs:= List( ordposs, x -> [] );
>      primes:= ShallowCopy( PrimeDivisors( Size( tblG ) ) );
>      ordposs:= ShallowCopy( ordposs );
>      checkordinary:= false;
>      for i in [ 1 .. Length( ordposs ) ] do
>        record:= ordposs[i];
>        for p in primes do
>          tmodp := tblG  mod p;
>          t2modp:= List( tblsG2, t2 -> t2 mod p );
>          if IsCharacterTable( tmodp ) and
>             ForAll( t2modp, IsCharacterTable ) then
>            poss:= PossibleCharacterTablesOfTypeGV4( tmodp, t2modp,
>                       record.table, record.G2fusGV4 );
>            poss:= RepresentativesCharacterTables( poss );
>            if   Length( poss ) = 0 then
>              Print( "#I  excluded cand. ", i, " (out of ",
>                     Length( ordposs ), ") for ", name, " by ", p,
>                     "-mod. table\n" );
>              Unbind( ordposs[i] );
>              Unbind( modposs[i] );
>              checkordinary:= true;
>              break;
>            elif Length( poss ) = 1 then
>              # Compare the computed table with the library table.
>              modlib:= ordlibtblGV4 mod p;
>              if IsCharacterTable( modlib ) then
>                trans:= TransformingPermutationsCharacterTables(
>                            poss[1].table, modlib );
>                if not IsRecord( trans ) then
>                  Print( "#E  computed table and library table for ",
>                         name, " mod ", p, " differ\n" );
>                fi;
>              else
>                Print( "#I  no library table for ",
>                       name, " mod ", p, "\n" );
>                PrintToLib( name, poss[1].table );
>              fi;
>            else
>              Print( "#I  ", name, " mod ", p, ": ", Length( poss ),
>                     " equivalence classes\n" );
>            fi;
>            Add( modposs[i], poss );
>          elif i = 1 then
>            Print( "#I  not all input tables for ", name, " mod ", p,
>                   " available\n" );
>            primes:= Difference( primes, [ p ] );
>          fi;
>        od;
>      od;
>      if checkordinary then
>        # Test whether the ordinary table is admissible.
>        ordposs:= Compacted( ordposs );
>        modposs:= Compacted( modposs );
>        reps:= RepresentativesCharacterTables( ordposs );
>        if 1 < Length( reps ) then
>          Print( "#I  ", name, ": ", Length( reps ),
>                 " equivalence classes (ord. table)\n" );
>        elif Length( reps ) = 0 then
>          Print( "#E  ", name, ": no solution (ord. table)\n" );
>        else
>          # Compare the computed table with the library table.
>          trans:= TransformingPermutationsCharacterTables(
>                      ordposs[1].table, ordlibtblGV4 );
>          if not IsRecord( trans ) then
>            Print( "#E  computed table and library table for ", name,
>                   " differ\n" );
>          fi;
>          # Compare the computed fusions with the stored ones.
>          if List( ordposs[1].G2fusGV4, x -> OnTuples( x, trans.columns ) )
>               <> List( tblsG2, x -> GetFusionMap( x, ordlibtblGV4 ) ) then
>            Print( "#E  computed and stored fusions for ", name,
>                   " differ\n" );
>          fi;
>        fi;
>      fi;
>      return rec( ordinary:= ordposs, modular:= modposs );
>    end;;
]]></Example>

<P/>

Finally, here is the loop over the list of tables.

<P/>

<Example><![CDATA[
gap> for input in listGV4 do
>      tblG   := CharacterTable( input[1] );
>      tblsG2 := List( input{ [ 2 .. 4 ] }, CharacterTable );
>      lib    := CharacterTable( input[5] );
>      poss   := ConstructOrdinaryGV4Table( tblG, tblsG2, input[5], lib );
>      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
>    od;
#I  excluded cand. 2 (out of 2) for L3(4).2^2 by 3-mod. table
#I  excluded cand. 2 (out of 8) for 2^2.L3(4).2^2 by 7-mod. table
#I  excluded cand. 3 (out of 8) for 2^2.L3(4).2^2 by 5-mod. table
#I  excluded cand. 4 (out of 8) for 2^2.L3(4).2^2 by 5-mod. table
#I  excluded cand. 5 (out of 8) for 2^2.L3(4).2^2 by 5-mod. table
#I  excluded cand. 6 (out of 8) for 2^2.L3(4).2^2 by 5-mod. table
#I  excluded cand. 7 (out of 8) for 2^2.L3(4).2^2 by 7-mod. table
#I  excluded cand. 2 (out of 2) for 3.L3(4).2^2 by 3-mod. table
#I  not all input tables for L2(49).2^2 mod 7 available
#I  not all input tables for L2(81).2^2 mod 3 available
#I  excluded cand. 2 (out of 2) for L3(9).2^2 by 7-mod. table
#I  not all input tables for O8+(3).(2^2)_{122} mod 3 available
#I  not all input tables for O8-(3).2^2 mod 3 available
#I  not all input tables for O8-(3).2^2 mod 5 available
#I  not all input tables for O8-(3).2^2 mod 7 available
#I  not all input tables for O8-(3).2^2 mod 13 available
#I  not all input tables for O8-(3).2^2 mod 41 available
#I  excluded cand. 2 (out of 2) for L3(4).D12 by 3-mod. table
#I  excluded cand. 2 (out of 2) for 2^2.L3(4).D12 by 7-mod. table
#I  not all input tables for O8+(3).D8 mod 3 available
#I  not all input tables for L4(4).2^2 mod 3 available
#I  not all input tables for L4(4).2^2 mod 5 available
#I  not all input tables for L4(4).2^2 mod 7 available
#I  not all input tables for L4(4).2^2 mod 17 available
#I  not all input tables for U4(5).2^2 mod 2 available
#I  not all input tables for U4(5).2^2 mod 3 available
#I  not all input tables for U4(5).2^2 mod 5 available
#I  not all input tables for U4(5).2^2 mod 7 available
#I  not all input tables for U4(5).2^2 mod 13 available
]]></Example>

<P/>

The groups <M>3.A_6.2^2</M>, <M>3.L_3(4).2^2</M>, and <M>3_2.U_4(3).(2^2)_{133}</M>
have also the structure <M>M.G.A</M>,
with <M>M.G</M> equal to <M>3.A_6.2_3</M>, <M>3.L_3(4).2_1</M>, and <M>3_2.U_4(3).2_3</M>,
respectively,
and <M>G.A</M> equal to <M>A_6.2^2</M>, <M>L_3(4).2^2</M>, and <M>U_4(3).(2^2)_{133}</M>,
respectively (see Section&nbsp;<Ref Subsect="subsect:ATLASMGA"/>).

<P/>

Similarly, the group <M>L_3(4).D_{12}</M> has also the structure <M>G.S_3</M>,
with <M>G = L_3(4).2_1</M>, <M>G.2 = L_3(4).2^2</M>, and <M>G.3 = L_3(4).6</M>,
respectively (see Section&nbsp;<Ref Subsect="subsect:xplGS3"/>).

<!-- %T  What about <M>U_3(8).3^2</M>? -->

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:The Character Table of S_4(9).2^2">
<Heading>The Character Table of <M>S_4(9).2^2</M> (September 2011)</Heading>

The available functions yield two possibilities for the ordinary character
table of <M>S_4(9).2^2</M>.

<P/>

<Example><![CDATA[
gap> tblG:= CharacterTable( "S4(9)" );;
gap> tblsG2:= List( [ "S4(9).2_1", "S4(9).2_2", "S4(9).2_3" ],
>                   CharacterTable );;
gap> lib:= CharacterTable( "S4(9).2^2" );;
gap> poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, "newS4(9).2^2", lib );;
#I  newS4(9).2^2: 2 equivalence classes
gap> poss:= RepresentativesCharacterTables( poss );;
]]></Example>

<P/>

The two candidates differ w.&nbsp;r.&nbsp;t. the action of <M>S_4(9).2^2</M> on the classes
of element order <M>80</M> in <M>S_4(9).2_2</M>.
In the two possible tables, each element of order <M>80</M> is conjugate to its
third power or to its <M>13</M>-th power, respectively.

<P/>

<Example><![CDATA[
gap> order80:= PositionsProperty( OrdersClassRepresentatives( tblsG2[2] ),
>                  x -> x = 80 );
[ 98, 99, 100, 101, 102, 103, 104, 105 ]
gap> List( poss, r -> r.G2fusGV4[2]{ order80 } );
[ [ 77, 77, 78, 79, 80, 78, 79, 80 ], 
  [ 77, 78, 79, 79, 77, 80, 80, 78 ] ]
gap> PowerMap( tblsG2[2], 3 ){ order80 };
[ 99, 98, 103, 104, 105, 100, 101, 102 ]
gap> PowerMap( tblsG2[2], 13 ){ order80 };
[ 102, 105, 101, 100, 98, 104, 103, 99 ]
]]></Example>

<P/>

We claim that the first candidate is the correct one.
For that,
first note that <M>S_4(9).2_2</M> is the extension of the simple group
by a diagonal automorphism.
(An easy way to see this is that for any subgroup of <M>S_4(9)</M>
isomorphic with <M>S_2(81) \cong L_2(81)</M>, the extension by a diagonal
automorphism contains elements of order <M>80</M>
&ndash;this group is isomorphic with PGL<M>(2,81)</M>&ndash;
and only <M>S_4(9).2_2</M> contains elements of order <M>80</M>.)

<P/>

<Example><![CDATA[
gap> List( tblsG2, x -> 80 in OrdersClassRepresentatives( x ) );
[ false, true, false ]
]]></Example>

<P/>

Now the field automorphism of <M>S_4(9).2_2</M>
maps each element <M>x</M> of order <M>80</M>
in <M>S_4(9).2_2</M> to a conjugate of <M>x^3</M>.

<P/>

<Example><![CDATA[
gap> tbl:= poss[1].table;;
gap> IsRecord( TransformingPermutationsCharacterTables( tbl, lib ) );
true
]]></Example>

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:2L34V4">
<Heading>The Character Tables of Groups of the Type <M>2.L_3(4).2^2</M>
(June 2010)</Heading>

The outer automorphism group of the group <M>L_3(4)</M> is a dihedral group
of order <M>12</M>; its Sylow <M>2</M>-subgroups are Klein four groups,
so there is a unique almost simple group <M>H</M> of the type <M>L_3(4).2^2</M>,
up to isomorphism.
In this section, we construct the character tables of the double covers
of this group with the approach from
Section&nbsp;<Ref Subsect="subsect:theorGV4"/>.

<P/>

The group <M>H</M> has three subgroups of index two,
of the types <M>L_3(4).2_1</M>, <M>L_3(4).2_2</M>, and <M>L_3(4).2_3</M>,
respectively.
So any double cover of <M>H</M> contains one subgroup of each of the types
<M>2.L_3(4).2_1</M>, <M>2.L_3(4).2_2</M>, and <M>2.L_3(4).2_3</M>,
and there are two isoclinic variants of each of these group to consider,
see Section&nbsp;<Ref Subsect="subsect:isoclinicATLAS"/>.
So we start with eight different inputs for the construction of the
character tables of double covers.

<P/>

<Example><![CDATA[
gap> names:= List( [ 1 .. 3 ],
>                  i -> Concatenation( "2.L3(4).2_", String( i ) ) );;
gap> tbls:= List( names, CharacterTable );
[ CharacterTable( "2.L3(4).2_1" ), CharacterTable( "2.L3(4).2_2" ), 
  CharacterTable( "2.L3(4).2_3" ) ]
gap> isos:= List( names, nam -> CharacterTable( Concatenation( nam, "*" ) ) );
[ CharacterTable( "Isoclinic(2.L3(4).2_1)" ), 
  CharacterTable( "Isoclinic(2.L3(4).2_2)" ), 
  CharacterTable( "Isoclinic(2.L3(4).2_3)" ) ]
gap> inputs:= [
> [ tbls[1], tbls[2], tbls[3], "2.L3(4).(2^2)_{123}" ],
> [ tbls[1], isos[2], tbls[3], "2.L3(4).(2^2)_{12*3}" ],
> [ tbls[1], tbls[2], isos[3], "2.L3(4).(2^2)_{123*}" ],
> [ tbls[1], isos[2], isos[3], "2.L3(4).(2^2)_{12*3*}" ],
> [ isos[1], tbls[2], tbls[3], "2.L3(4).(2^2)_{1*23}" ],
> [ isos[1], isos[2], tbls[3], "2.L3(4).(2^2)_{1*2*3}" ],
> [ isos[1], tbls[2], isos[3], "2.L3(4).(2^2)_{1*23*}" ],
> [ isos[1], isos[2], isos[3], "2.L3(4).(2^2)_{1*2*3*}" ] ];;
gap> tblG:= CharacterTable( "2.L3(4)" );;
gap> result:= [];;
gap> for input in inputs do
>      tblsG2:= input{ [ 1 .. 3 ] };
>      lib:= CharacterTable( input[4] );
>      poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );
>      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
>      Append( result, RepresentativesCharacterTables( poss ) );
>    od;
#I  excluded cand. 2 (out of 8) for 2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 2.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 2.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 
5-mod. table
gap> result:= List( result, x -> x.table );
[ CharacterTable( "new2.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{12*3*}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{1*23}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{1*2*3}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{1*23*}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{1*2*3*}" ) ]
]]></Example>

<P/>

We get exactly one character table for each input.
For each of these tables, there are three possibilities to form an
isoclinic table, corresponding to the three subgroups of index two.
It turns out that the eight solutions form two orbits under forming
some isoclinic table.
Tables in different orbits are essentially different,
already their numbers of conjugacy classes differ.

<P/>

<Example><![CDATA[
gap> List( result, NrConjugacyClasses );
[ 39, 33, 33, 39, 33, 39, 39, 33 ]
gap> t:= result[1];;
gap> nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
>            x -> Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
gap> iso:= List( nsg, x -> CharacterTableIsoclinic( t, x ) );;
gap> List( iso, x -> PositionProperty( result, y ->
>            TransformingPermutationsCharacterTables( x, y ) <> fail ) );
[ 4, 7, 6 ]
gap> t:= result[2];;
gap> nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
>            x -> Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
gap> iso:= List( nsg, x -> CharacterTableIsoclinic( t, x ) );;
gap> List( iso, x -> PositionProperty( result, y ->
>            TransformingPermutationsCharacterTables( x, y ) <> fail ) );
[ 3, 8, 5 ]
]]></Example>

<P/>

Up to now, it is not clear that the character tables we have constructed
are really the character tables of some groups.
The existence of groups for the first orbit of character tables
can be established as follows.

<P/>

The group <M>U_6(2).2</M> contains a maximal subgroup <M>M</M> of the type <M>L_3(4).2^2</M>,
see&nbsp;<Cite Key="CCN85" Where="p. 115"/>.
Its derived subgroup <M>M'</M> of the type <M>L_3(4)</M> lies inside <M>U_6(2)</M>,
and we claim that the preimage of <M>M'</M> under the natural epimorphism from
<M>2.U_6(2)</M> to <M>U_6(2)</M> is a double cover of <M>L_3(4)</M>.
Unfortunately, <M>L_3(4)</M> admits class fusions into <M>2.U_6(2)</M>,
so this criterion cannot be used.

<P/>

<Example><![CDATA[
gap> l34:= CharacterTable( "L3(4)" );;
gap> u:= CharacterTable( "U6(2)" );;
gap> 2u:= CharacterTable( "2.U6(2)" );;
gap> cand:= PossibleClassFusions( l34, 2u );
[ [ 1, 5, 12, 16, 22, 22, 23, 23, 41, 41 ], 
  [ 1, 5, 12, 22, 16, 22, 23, 23, 41, 41 ], 
  [ 1, 5, 12, 22, 22, 16, 23, 23, 41, 41 ] ]
gap> OrdersClassRepresentatives( l34 );
[ 1, 2, 3, 4, 4, 4, 5, 5, 7, 7 ]
]]></Example>

<P/>

Consider the three classes of elements of order four in <M>L_3(4)</M>.
Under the possible fusions into <M>2.U_6(2)</M>,
they are mapped to the classes <M>16</M> and <M>22</M>,
which are preimages of the classes <M>10</M> and <M>14</M>
(<C>4C</C> and <C>4G</C>) of <M>U_6(2)</M>.
Note that the maximal subgroups of type <M>L_3(4).2</M> in <M>U_6(2)</M>
extend to <M>L_3(4).6</M> type subgroups in <M>U_6(2).3</M>,
and the three classes <C>4C</C>, <C>4D</C>, <C>4E</C> form one orbit
under the action of an outer automorphism of order three of <M>U_6(2)</M>.

<P/>

<Example><![CDATA[
gap> GetFusionMap( 2u, u ){ [ 16, 22 ] };
[ 10, 14 ]
gap> ClassNames( u, "ATLAS" ){ [ 10, 14 ] };
[ "4C", "4G" ]
gap> GetFusionMap( u, CharacterTable( "U6(2).3" ) );
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 11, 12, 13, 14, 15, 16, 17, 
  18, 19, 20, 21, 22, 23, 24, 24, 24, 25, 26, 27, 28, 29, 30, 31, 32, 
  33, 34, 35, 36, 36, 36, 37, 38, 39, 40 ]
]]></Example>

<P/>

This means that any <M>L_3(4)</M> type subgroup of <M>U_6(2)</M> that extends
to an <M>L_3(4).6</M> type subgroup in <M>U_6(2).3</M> either contains
elements from all three classes <C>4C</C>, <C>4D</C>, <C>4E</C> of
<M>U_6(2)</M>, or contains no element from these classes.
Thus we know that any double cover of <M>U_6(2).2</M> contains a double cover
of <M>L_3(4).2^2</M>.
Only the first of our result tables admits a class fusion into the table
of <M>2.U_6(2).2</M>.

<P/>

<Example><![CDATA[
gap> 2u2:= CharacterTable( "2.U6(2).2" );;
gap> fus:= List( result, x -> PossibleClassFusions( x, 2u2 ) );;
gap> List( fus, Length );
[ 4, 0, 0, 0, 0, 0, 0, 0 ]
]]></Example>

<P/>

As a consequence, the fourth result table is established
as that of a maximal subgroup of the group isoclinic to <M>2.U_6(2).2</M>.

<P/>

<Example><![CDATA[
gap> 2u2iso:= CharacterTableIsoclinic( 2u2 );;
gap> fus:= List( result, x -> PossibleClassFusions( x, 2u2iso ) );;
gap> List( fus, Length );
[ 0, 0, 0, 4, 0, 0, 0, 0 ]
]]></Example>

<P/>

Similarly, the group <M>HS.2</M> contains a maximal subgroup <M>M</M> of the
type <M>L_3(4).2^2</M>, see&nbsp;<Cite Key="CCN85" Where="p. 80"/>.
Its derived subgroup <M>M'</M> of the type <M>L_3(4)</M> lies inside <M>HS</M>,
and the preimage of <M>M'</M> under the natural epimorphism from
<M>2.HS</M> to <M>HS</M> is a double cover of <M>L_3(4)</M>,
because <M>L_3(4)</M> does not admit a class fusion into <M>2.HS.2</M>.

<P/>

<Example><![CDATA[
gap> h2:= CharacterTable( "HS.2" );;
gap> 2h2:= CharacterTable( "2.HS.2" );;
gap> PossibleClassFusions( l34, 2h2 );
[  ]
]]></Example>

<P/>

Only the fifth of our result tables admits a class fusion into <M>2.HS.2</M>,
which means that <M>2.L_3(4).(2^2)_{1{\ast}23}</M> is a subgroup of
<M>2.HS.2</M>,
and the eighth result table
&ndash;<M>2.L_3(4).(2^2)_{1{\ast}2{\ast}3{\ast}}</M>&ndash;
admits a class fusion into the isoclinic variant of <M>2.HS.2</M>
This shows the existence of groups for the tables from the second orbit.

<P/>

<Example><![CDATA[
gap> fus:= List( result, x -> PossibleClassFusions( x, 2h2 ) );;
gap> List( fus, Length );
[ 0, 0, 0, 0, 4, 0, 0, 0 ]
gap> 2h2iso:= CharacterTableIsoclinic( 2h2 );;
gap> fus:= List( result, x -> PossibleClassFusions( x, 2h2iso ) );;
gap> List( fus, Length );
[ 0, 0, 0, 0, 0, 0, 0, 4 ]
]]></Example>

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:6L34V4">
<Heading>The Character Tables of Groups of the Type <M>6.L_3(4).2^2</M>
(October 2011)</Heading>

We have two approaches for constructing the character tables of these groups.

<P/>

First, we may regard them as normal products of the three normal subgroups
of index two, each of them having the structure <M>6.L_3(4).2</M>,
and use the approach from Section&nbsp;<Ref Subsect="subsect:theorGV4"/>,
as we did in Section&nbsp;<Ref Subsect="subsect:2L34V4"/> for the groups of the structure
<M>2.L_3(4).2^2</M>.

<P/>

Second, we may use the approach from Section&nbsp;<Ref Subsect="subsect:theorMGA"/>.
Note that the factor group <M>L_3(4).2^2</M> contains each of the three groups
<M>L_3(4).2_i</M> as a subgroup, for <M>1 \leq i \leq 3</M>,
and the groups of the type <M>6.L_3(4).2_1</M> have a centre of order six,
whereas the centres of the <M>6.L_3(4).2_2</M> and <M>6.L_3(4).2_3</M> type groups
have order two.
For that, the character tables of the subgroups <M>6.L_3(4).2_1</M> and
<M>6.L_3(4).2_1^{\ast}</M> are needed,
as well as the character tables of the eight possible factor groups
<M>2.L_3(4).2^2</M>; the latter tables are known from Section&nbsp;<Ref Subsect="subsect:2L34V4"/>.

<P/>

We show both approaches.
(The second approach is better suited for storing the character tables
in the Character Table Library, since the irreducible characters need not
be stored, and since the Brauer tables of the groups can be derived from
the Brauer tables of the compound tables.)

<P/>

<Example><![CDATA[
gap> tbls:= List( [ "1", "2", "3" ],
>      i -> CharacterTable( Concatenation( "6.L3(4).2_", i ) ) );
[ CharacterTable( "6.L3(4).2_1" ), CharacterTable( "6.L3(4).2_2" ), 
  CharacterTable( "6.L3(4).2_3" ) ]
gap> isos:= List( [ "1", "2", "3" ],
>      i -> CharacterTable( Concatenation( "6.L3(4).2_", i, "*" ) ) );
[ CharacterTable( "Isoclinic(6.L3(4).2_1)" ), 
  CharacterTable( "Isoclinic(6.L3(4).2_2)" ), 
  CharacterTable( "Isoclinic(6.L3(4).2_3)" ) ]
gap> inputs:= [
> [ tbls[1], tbls[2], tbls[3], "6.L3(4).(2^2)_{123}" ],
> [ tbls[1], isos[2], tbls[3], "6.L3(4).(2^2)_{12*3}" ],
> [ tbls[1], tbls[2], isos[3], "6.L3(4).(2^2)_{123*}" ],
> [ tbls[1], isos[2], isos[3], "6.L3(4).(2^2)_{12*3*}" ],
> [ isos[1], tbls[2], tbls[3], "6.L3(4).(2^2)_{1*23}" ],
> [ isos[1], isos[2], tbls[3], "6.L3(4).(2^2)_{1*2*3}" ],
> [ isos[1], tbls[2], isos[3], "6.L3(4).(2^2)_{1*23*}" ],
> [ isos[1], isos[2], isos[3], "6.L3(4).(2^2)_{1*2*3*}" ] ];;
gap> tblG:= CharacterTable( "6.L3(4)" );;
gap> result:= [];;
gap> for input in inputs do
>      tblsG2:= input{ [ 1 .. 3 ] };
>      lib:= CharacterTable( input[4] );
>      poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );
>      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
>      Append( result, RepresentativesCharacterTables( poss ) );
>    od;
#I  excluded cand. 2 (out of 8) for 6.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 6.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 6.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 6.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 6.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 6.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 
5-mod. table
gap> result:= List( result, x -> x.table );
[ CharacterTable( "new6.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{12*3*}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*23}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*2*3}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*23*}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*2*3*}" ) ]
]]></Example>

<P/>

As in Section&nbsp;<Ref Subsect="subsect:2L34V4"/>,
we get exactly one character table for each input,
and the eight solutions lie in two orbits under isoclinism.

<P/>

<Example><![CDATA[
gap> List( result, NrConjugacyClasses );
[ 59, 53, 53, 59, 53, 59, 59, 53 ]
gap> t:= result[1];;
gap> nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
>            x -> Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
gap> iso:= List( nsg, x -> CharacterTableIsoclinic( t, x ) );;
gap> List( iso, x -> PositionProperty( result, y ->
>            TransformingPermutationsCharacterTables( x, y ) <> fail ) );
[ 7, 6, 4 ]
gap> t:= result[2];;
gap> nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
>            x -> Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
gap> iso:= List( nsg, x -> CharacterTableIsoclinic( t, x ) );;
gap> List( iso, x -> PositionProperty( result, y ->
>            TransformingPermutationsCharacterTables( x, y ) <> fail ) );
[ 8, 5, 3 ]
]]></Example>

<P/>

Up to now, it is not clear that the character tables we have constructed
are really the character tables of some groups.
The existence of groups for the first orbit of character tables
can be established as follows.

<P/>

We have shown in Section&nbsp;<Ref Subsect="subsect:2L34V4"/>
that the maximal subgroups <M>M</M> of the type <M>L_3(4).2^2</M>
in <M>U_6(2).2</M> lift to double covers <M>2.L_3(4).2^2</M>
in <M>2.U_6(2).2</M>.
The preimages of these groups under the natural epimorphism
from <M>6.U_6(2).2</M> have the structure <M>6.L_3(4).2^2</M>,
where the derived subgroup is the six-fold cover of <M>L_3(4)</M>;
this follows from the fact that <M>6.U_6(2)</M> does not admit
a class fusion from the double cover <M>2.L_3(4)</M>.

<P/>

<Example><![CDATA[
gap> 2l34:= CharacterTable( "2.L3(4)" );;
gap> 6u:= CharacterTable( "6.U6(2)" );;
gap> cand:= PossibleClassFusions( 2l34, 6u );
[  ]
]]></Example>

<P/>

This establishes the first and the fourth result as character tables
of subgroups of <M>6.U_6(2)</M> and its isoclinic variant, respectively.

<P/>

<Example><![CDATA[
gap> 6u2:= CharacterTable( "6.U6(2).2" );;
gap> fus:= List( result, x -> PossibleClassFusions( x, 6u2 ) );;
gap> List( fus, Length );
[ 8, 0, 0, 0, 0, 0, 0, 0 ]
gap> 6u2iso:= CharacterTableIsoclinic( 6u2 );;
gap> fus:= List( result, x -> PossibleClassFusions( x, 6u2iso ) );;
gap> List( fus, Length );
[ 0, 0, 0, 8, 0, 0, 0, 0 ]
]]></Example>

<P/>

Similarly, the group <M>G_2(4).2</M> contains a maximal subgroup <M>M</M>
of the type <M>3.L_3(4).2^2</M>, see&nbsp;<Cite Key="CCN85" Where="p. 97"/>.
Its derived subgroup <M>M'</M> of the type <M>3.L_3(4)</M> lies inside
<M>G_2(4)</M>,
and the preimage of <M>M'</M> under the natural epimorphism from
<M>2.G_2(4)</M> to <M>G_2(4)</M> is a double cover of <M>3.L_3(4)</M>,
because <M>3.L_3(4)</M> does not admit a class fusion into <M>2.G_2(4).2</M>.

<P/>

<Example><![CDATA[
gap> 3l34:= CharacterTable( "3.L3(4)" );;
gap> g2:= CharacterTable( "G2(4).2" );;
gap> 2g2:= CharacterTable( "2.G2(4).2" );;
gap> PossibleClassFusions( 3l34, 2g2 );
[  ]
]]></Example>

<P/>

Only the third and eighth of our result tables admit a class fusion into
<M>2.G_2(4).2</M> and its isoclinic variant, respectively.
This shows the existence of groups for the tables from the second orbit.

<P/>

<Example><![CDATA[
gap> fus:= List( result, x -> PossibleClassFusions( x, 2g2 ) );;
gap> List( fus, Length );
[ 0, 0, 16, 0, 0, 0, 0, 0 ]
gap> 2g2iso:= CharacterTableIsoclinic( 2g2 );;
gap> fus:= List( result, x -> PossibleClassFusions( x, 2g2iso ) );;
gap> List( fus, Length );
[ 0, 0, 0, 0, 0, 0, 0, 16 ]
]]></Example>

<P/>

Now we try the second approach and compare the results.

<P/>

<Example><![CDATA[
gap> names:= [ "L3(4).(2^2)_{123}", "L3(4).(2^2)_{12*3}",
>              "L3(4).(2^2)_{123*}", "L3(4).(2^2)_{12*3*}" ];;
gap> inputs1:= List( names, nam -> [ "6.L3(4).2_1", "2.L3(4).2_1",
>        Concatenation( "2.", nam ), Concatenation( "6.", nam ) ] );;
gap> names:= List( names, nam -> ReplacedString( nam, "1", "1*" ) );;
gap> inputs2:= List( names, nam -> [ "6.L3(4).2_1*", "2.L3(4).2_1*",
>        Concatenation( "2.", nam ), Concatenation( "6.", nam ) ] );;
gap> inputs:= Concatenation( inputs1, inputs2 );
[ [ "6.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{123}", 
      "6.L3(4).(2^2)_{123}" ], 
  [ "6.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{12*3}", 
      "6.L3(4).(2^2)_{12*3}" ], 
  [ "6.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{123*}", 
      "6.L3(4).(2^2)_{123*}" ], 
  [ "6.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{12*3*}", 
      "6.L3(4).(2^2)_{12*3*}" ], 
  [ "6.L3(4).2_1*", "2.L3(4).2_1*", "2.L3(4).(2^2)_{1*23}", 
      "6.L3(4).(2^2)_{1*23}" ], 
  [ "6.L3(4).2_1*", "2.L3(4).2_1*", "2.L3(4).(2^2)_{1*2*3}", 
      "6.L3(4).(2^2)_{1*2*3}" ], 
  [ "6.L3(4).2_1*", "2.L3(4).2_1*", "2.L3(4).(2^2)_{1*23*}", 
      "6.L3(4).(2^2)_{1*23*}" ], 
  [ "6.L3(4).2_1*", "2.L3(4).2_1*", "2.L3(4).(2^2)_{1*2*3*}", 
      "6.L3(4).(2^2)_{1*2*3*}" ] ]
gap> result2:= [];;
gap> for  input in inputs do
>      tblMG := CharacterTable( input[1] );
>      tblG  := CharacterTable( input[2] );
>      tblGA := CharacterTable( input[3] );
>      name  := Concatenation( "new", input[4] );
>      lib   := CharacterTable( input[4] );
>      poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );
>      Append( result2, poss );
>    od;
gap> result2:= List( result2, x -> x.table );
[ CharacterTable( "new6.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{12*3*}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*23}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*2*3}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*23*}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*2*3*}" ) ]
gap> trans:= List( [ 1 .. 8 ], i ->
>        TransformingPermutationsCharacterTables( result[i],
>            result2[i] ) );;
gap> ForAll( trans, IsRecord );
true
]]></Example>

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:2U43V4">
<Heading>The Character Tables of Groups of the Type <M>2.U_4(3).2^2</M>
(February 2012)</Heading>

The outer automorphism group of the group <M>U_4(3)</M> is a dihedral group
of order <M>8</M>.
There are two almost simple groups of the type <M>U_4(3).2^2</M>,
up to isomorphism,
denoted as <M>U_4(3).(2^2)_{122}</M> and <M>U_4(3).(2^2)_{133}</M>,
respectively.
Note that <M>U_4(3).2_1</M> is the extension by the central involution of the
outer automorphism group of <M>U_4(3)</M>,
the other two subgroups of index two in <M>U_4(3).(2^2)_{122}</M> are
<M>U_4(3).2_2</M> and <M>U_4(3).2^{\prime}_2</M>, respectively,
and the other two subgroups of index two in <M>U_4(3).(2^2)_{133}</M> are
<M>U_4(3).2_3</M> and <M>U_4(3).2^{\prime}_3</M>, respectively.

<P/>

Since Aut<M>( U_4(3) )</M> possesses a double cover
(see&nbsp;<Cite Key="CCN85" Where="p. 52"/>),
double covers of <M>U_4(3).(2^2)_{122}</M> and <M>U_4(3).(2^2)_{133}</M> exist.

<P/>

First we deal with the double covers of <M>U_4(3).(2^2)_{122}</M>.
Any such group contains one subgroup of the type <M>2.U_4(3).2_1</M> and two
subgroups of the type <M>2.U_4(3).2_2</M>,
and there are two isoclinic variants of each of these group to consider,
see Section&nbsp;<Ref Subsect="subsect:isoclinicATLAS"/>.
Thus we start with six different inputs for the construction of the
character tables of double covers.

<P/>

<Example><![CDATA[
gap> tbls:= List( [ "1", "2", "2'" ], i ->
>      CharacterTable( Concatenation( "2.U4(3).2_", i ) ) );;
gap> isos:= List( [ "1", "2", "2'" ], i ->
>      CharacterTable( Concatenation( "Isoclinic(2.U4(3).2_", i, ")" ) ) );;
gap> inputs:= [
> [ tbls[1], tbls[2], tbls[3], "2.U4(3).(2^2)_{122}" ],
> [ isos[1], tbls[2], tbls[3], "2.U4(3).(2^2)_{1*22}" ],
> [ tbls[1], isos[2], tbls[3], "2.U4(3).(2^2)_{12*2}" ],
> [ isos[1], isos[2], tbls[3], "2.U4(3).(2^2)_{1*2*2}" ],
> [ tbls[1], isos[2], isos[3], "2.U4(3).(2^2)_{12*2*}" ],
> [ isos[1], isos[2], isos[3], "2.U4(3).(2^2)_{1*2*2*}" ] ];;
gap> tblG:= CharacterTable( "2.U4(3)" );;
gap> result:= [];;
gap> for input in inputs do
>      tblsG2:= input{ [ 1 .. 3 ] };
>      lib:= CharacterTable( input[4] );
>      poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );
>      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
>      Append( result, RepresentativesCharacterTables( poss ) );
>    od;
gap> result:= List( result, x -> x.table );
[ CharacterTable( "new2.U4(3).(2^2)_{122}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{1*22}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{12*2}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{1*2*2}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{12*2*}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{1*2*2*}" ) ]
]]></Example>

<P/>

We get exactly one character table for each input.
For each of these tables, there are three possibilities to form an
isoclinic table, corresponding to the three subgroups of index two.
It turns out that the six solutions form two orbits under forming
some isoclinic table.
Tables in different orbits are essentially different,
already their numbers of conjugacy classes differ.

<P/>

<Example><![CDATA[
gap> List( result, NrConjugacyClasses );
[ 87, 102, 102, 87, 87, 102 ]
gap> t:= result[1];;
gap> nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
>            x -> Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
gap> iso:= List( nsg, x -> CharacterTableIsoclinic( t, x ) );;
gap> List( iso, x -> PositionProperty( result, y ->
>            TransformingPermutationsCharacterTables( x, y ) <> fail ) );
[ 4, 4, 5 ]
gap> t:= result[2];;
gap> nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
>            x -> Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
gap> iso:= List( nsg, x -> CharacterTableIsoclinic( t, x ) );;
gap> List( iso, x -> PositionProperty( result, y ->
>            TransformingPermutationsCharacterTables( x, y ) <> fail ) );
[ 3, 3, 6 ]
]]></Example>

<P/>

Up to now, it is not clear that the character tables we have constructed
are really the character tables of some groups.
The existence of groups for the first orbit of character tables
can be established as follows.

<P/>

The group <M>O_8^+(3)</M> contains maximal subgroups of the type
<M>2.U_4(3).2^2</M>, see&nbsp;<Cite Key="CCN85" Where="p. 140"/>.
Only the first of our result tables admits a class fusion into the table
of <M>O_8^+(3)</M>.

<P/>

<Example><![CDATA[
gap> u:= CharacterTable( "O8+(3)" );;
gap> fus:= List( result, x -> PossibleClassFusions( x, u ) );;
gap> List( fus, Length );
[ 24, 0, 0, 0, 0, 0 ]
]]></Example>

<P/>

A table in the second orbit belongs to a maximal subgroup of <M>O_7(3).2</M>,
see&nbsp;<Cite Key="CCN85" Where="p. 109"/>.

<P/>

<Example><![CDATA[
gap> u:= CharacterTable( "O7(3).2" );;
gap> fus:= List( result, x -> PossibleClassFusions( x, u ) );;
gap> List( fus, Length );
[ 0, 16, 0, 0, 0, 0 ]
]]></Example>

<P/>

Note that this subgroup of <M>O_7(3).2 \cong SO(7,3)</M>
is the orthogonal group GO<M>_6^-(3)</M>.

<!-- % more groups for these tables: -->
<!-- %  -->
<!-- % gap> u:= CharacterTable( "2.U6(2).2" );; -->
<!-- % gap> fus:= List( result, x -> PossibleClassFusions( x, u ) );; -->
<!-- % gap> List( fus, Length ); -->
<!-- % [ 0, 0, 0, 0, 0, 0 ] -->
<!-- % gap> u:= CharacterTable( "2^2.U6(2).2" );; -->
<!-- % gap> fus:= List( result, x -> PossibleClassFusions( x, u ) );; -->
<!-- % gap> List( fus, Length ); -->
<!-- % [ 8, 4, 2, 4, 0, 0 ] -->
<!-- %  -->
<!-- % Thus the subgroup U4(3).2_2 of U6(2) that extends to U6(2).2 -->
<!-- % does not lift as required in 2.U6(2).2; -->
<!-- % but putting the whole 2^2 under it yields what we need. -->
<!-- %  -->
<!-- % gap> u:= CharacterTable( "2.Fi22.2" );;                        -->
<!-- % gap> fus:= List( result, x -> PossibleClassFusions( x, u ) );; -->
<!-- % gap> List( fus, Length ); -->
<!-- % [ 8, 4, 2, 4, 0, 0 ] -->
<!-- % gap> NamesOfFusionSources( u ); -->
<!-- % [ "2.Fi22", "6.Fi22.2", "(S3x2.U4(3).2_2).2" ] -->
<!-- % gap> u:= CharacterTable( last[3] ); -->
<!-- % CharacterTable( "(S3x2.U4(3).2_2).2" ) -->
<!-- % gap> fus:= List( result, x -> PossibleClassFusions( x, u ) );; -->
<!-- % gap> List( fus, Length ); -->
<!-- % [ 8, 4, 2, 4, 0, 0 ] -->
<!-- %  -->
<!-- % Note that u has no normal S3 type subgroup, so we do not get a -->
<!-- % factor in the list result! -->
<!-- % -->
<!-- % In B, we have a maximal subgroup "(3^2:D8xU4(3).2^2).2", -->
<!-- % which is constructed from "U4(3).(2^2)_{122}" and "U4(3).D8"; -->
<!-- % what happens in 2.B? -->

<P/>

Now we deal with the double covers of <M>U_4(3).(2^2)_{133}</M>.
The constructions of the character tables are completely analogous
to those in the case of <M>U_4(3).(2^2)_{122}</M>.

<P/>

<Example><![CDATA[
gap> tbls:= List( [ "1", "3", "3'" ],
>      i -> CharacterTable( Concatenation( "2.U4(3).2_", i ) ) );;
gap> isos:= List( [ "1", "3", "3'" ], i ->
>      CharacterTable( Concatenation( "Isoclinic(2.U4(3).2_", i, ")" ) ) );;
gap> inputs:= [
> [ tbls[1], tbls[2], tbls[3], "2.U4(3).(2^2)_{133}" ],
> [ isos[1], tbls[2], tbls[3], "2.U4(3).(2^2)_{1*33}" ],
> [ tbls[1], isos[2], tbls[3], "2.U4(3).(2^2)_{13*3}" ],
> [ isos[1], isos[2], tbls[3], "2.U4(3).(2^2)_{1*3*3}" ],
> [ tbls[1], isos[2], isos[3], "2.U4(3).(2^2)_{13*3*}" ],
> [ isos[1], isos[2], isos[3], "2.U4(3).(2^2)_{1*3*3*}" ] ];;
gap> tblG:= CharacterTable( "2.U4(3)" );;
gap> result:= [];;
gap> for input in inputs do
>      tblsG2:= input{ [ 1 .. 3 ] };
>      lib:= CharacterTable( input[4] );
>      poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );
>      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
>      Append( result, RepresentativesCharacterTables( poss ) );
>    od;
#I  excluded cand. 2 (out of 4) for 2.U4(3).(2^2)_{1*33} by 
3-mod. table
#I  excluded cand. 3 (out of 4) for 2.U4(3).(2^2)_{1*33} by 
3-mod. table
#I  excluded cand. 2 (out of 4) for 2.U4(3).(2^2)_{13*3} by 
3-mod. table
#I  excluded cand. 3 (out of 4) for 2.U4(3).(2^2)_{13*3} by 
3-mod. table
#I  excluded cand. 2 (out of 4) for 2.U4(3).(2^2)_{1*3*3*} by 
3-mod. table
#I  excluded cand. 3 (out of 4) for 2.U4(3).(2^2)_{1*3*3*} by 
3-mod. table
gap> result:= List( result, x -> x.table );
[ CharacterTable( "new2.U4(3).(2^2)_{133}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{1*33}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{13*3}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{1*3*3}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{13*3*}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{1*3*3*}" ) ]
gap> List( result, NrConjugacyClasses );
[ 69, 72, 72, 69, 69, 72 ]
gap> t:= result[1];;
gap> nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
>            x -> Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
gap> iso:= List( nsg, x -> CharacterTableIsoclinic( t, x ) );;
gap> List( iso, x -> PositionProperty( result, y ->
>            TransformingPermutationsCharacterTables( x, y ) <> fail ) );
[ 4, 4, 5 ]
gap> t:= result[2];;
gap> nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
>            x -> Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
gap> iso:= List( nsg, x -> CharacterTableIsoclinic( t, x ) );;
gap> List( iso, x -> PositionProperty( result, y ->
>            TransformingPermutationsCharacterTables( x, y ) <> fail ) );
[ 3, 3, 6 ]
]]></Example>

<!-- %T TODO: -->
<!-- %T establish groups for these tables: -->
<!-- %T - 2.Suz.2 contains 6_2.U4(3).(2^2)_{133} or some starred version of it; -->
<!-- %T - what about 2.Co1, since Co1 contains 3^2.U4(3).D8; -->

<P/>

<!-- %T add: -->
<!-- %T [ "2.U4(3).2_1", "2.U4(3).4", "2.U4(3).(2^2)_{122}", "2.U4(3).(2^2)_{133}", -->
<!-- %T                                                            "2.U4(3).D8" ], -->
<!-- %T -> two equiv. classes, distinguished by third power map, -->
<!-- %T    only one table admits one! -->
<!-- %T    Note: Recomputing the power maps is not sufficient, -->
<!-- %T    so add a test that decomposes ALL 3rd symmetrizations -->
<!-- %T    not just the minus characters!! -->

<!-- %T other MGA example: "2^2.U4(3).(2^2)_{122}" -->

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:41L34V4">
<Heading>The Character Tables of Groups of the Type <M>4_1.L_3(4).2^2</M>
(October 2011)</Heading>

The situation with <M>4_1.L_3(4).2^2</M> is analogous to that with
<M>6.L_3(4).2^2</M>,
see Section&nbsp;<Ref Subsect="subsect:6L34V4"/>.

<P/>

<Example><![CDATA[
gap> tbls:= List( [ "1", "2", "3" ],
>      i -> CharacterTable( Concatenation( "4_1.L3(4).2_", i ) ) );
[ CharacterTable( "4_1.L3(4).2_1" ), CharacterTable( "4_1.L3(4).2_2" )
    , CharacterTable( "4_1.L3(4).2_3" ) ]
gap> isos:= List( [ "1", "2", "3" ],
>      i -> CharacterTable( Concatenation( "4_1.L3(4).2_", i, "*" ) ) );
[ CharacterTable( "Isoclinic(4_1.L3(4).2_1)" ), 
  CharacterTable( "Isoclinic(4_1.L3(4).2_2)" ), 
  CharacterTable( "4_1.L3(4).2_3*" ) ]
]]></Example>

<P/>

Note that the group <M>4_1.L_3(4).2_3</M> has a centre of order four,
so one cannot construct the isoclinic variant by calling
the one argument version of
<Ref Func="CharacterTableIsoclinic" BookName="ref"/>.

<P/>

<Example><![CDATA[
gap> List( tbls, ClassPositionsOfCentre );
[ [ 1, 3 ], [ 1, 3 ], [ 1, 2, 3, 4 ] ]
gap> IsRecord( TransformingPermutationsCharacterTables( tbls[3],
>        CharacterTableIsoclinic( tbls[3] ) ) );
true
]]></Example>

<P/>

Again, we get eight different character tables,
in two orbits.

<P/>

<Example><![CDATA[
gap> inputs:= [
> [ tbls[1], tbls[2], tbls[3], "4_1.L3(4).(2^2)_{123}" ],
> [ isos[1], tbls[2], tbls[3], "4_1.L3(4).(2^2)_{1*23}" ],
> [ tbls[1], isos[2], tbls[3], "4_1.L3(4).(2^2)_{12*3}" ],
> [ isos[1], isos[2], tbls[3], "4_1.L3(4).(2^2)_{1*2*3}" ],
> [ tbls[1], tbls[2], isos[3], "4_1.L3(4).(2^2)_{123*}" ],
> [ isos[1], tbls[2], isos[3], "4_1.L3(4).(2^2)_{1*23*}" ],
> [ tbls[1], isos[2], isos[3], "4_1.L3(4).(2^2)_{12*3*}" ],
> [ isos[1], isos[2], isos[3], "4_1.L3(4).(2^2)_{1*2*3*}" ] ];;
gap> tblG:= CharacterTable( "4_1.L3(4)" );;
gap> result:= [];;
gap> for input in inputs do
>      tblsG2:= input{ [ 1 .. 3 ] };
>      lib:= CharacterTable( input[4] );
>      poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );
>      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
>      Append( result, RepresentativesCharacterTables( poss ) );
>    od;
#I  excluded cand. 2 (out of 8) for 4_1.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_1.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_1.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_1.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_1.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_1.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 
5-mod. table
gap> result:= List( result, x -> x.table );
[ CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{1*23}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{1*2*3}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{1*23*}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{12*3*}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{1*2*3*}" ) ]
gap> List( result, NrConjugacyClasses );
[ 48, 48, 48, 48, 42, 42, 42, 42 ]
gap> t:= result[1];;
gap> nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
>            x -> Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
gap> iso:= List( nsg, x -> CharacterTableIsoclinic( t, x ) );;
gap> List( iso, x -> PositionProperty( result, y ->
>            TransformingPermutationsCharacterTables( x, y ) <> fail ) );
[ 3, 2, 4 ]
gap> t:= result[5];;
gap> nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
>            x -> Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
gap> iso:= List( nsg, x -> CharacterTableIsoclinic( t, x ) );;
gap> List( iso, x -> PositionProperty( result, y ->
>            TransformingPermutationsCharacterTables( x, y ) <> fail ) );
[ 7, 6, 8 ]
]]></Example>

<P/>

Note that only two out of the eight tables of the type <M>2.L_3(4).2^2</M>
occur as factors of the eight tables.

<P/>

<Example><![CDATA[
gap> facts:= [ CharacterTable( "2.L3(4).(2^2)_{123}" ), 
>              CharacterTable( "2.L3(4).(2^2)_{123*}" ) ];;
gap> factresults:= List( result, t -> t / ClassPositionsOfCentre( t ) );;
gap> List( factresults, t -> PositionProperty( facts, f ->
>            IsRecord( TransformingPermutationsCharacterTables( t, f ) ) ) );
[ 1, 1, 1, 1, 2, 2, 2, 2 ]
]]></Example>

<P/>

This is not surprising;
note that for <M>1 \leq i \leq 2</M>,
the two isoclinic variants of <M>4_1.L_3(4).2_i</M> have isomorphic
factor groups of the type <M>2.L_3(4).2_i</M>.
(For <M>i = 3</M>, this is not the case.)

<P/>

<Example><![CDATA[
gap> test:= [ CharacterTable( "4_1.L3(4).2_1" ),
>             CharacterTable( "4_1.L3(4).2_1*" ) ];;
gap> List( test, ClassPositionsOfCentre );
[ [ 1, 3 ], [ 1, 3 ] ]
gap> fact:= List( test, t -> t / ClassPositionsOfCentre( t ) );;
gap> IsRecord( TransformingPermutationsCharacterTables( fact[1], fact[2] ) );
true
gap> test:= [ CharacterTable( "4_1.L3(4).2_2" ),
>             CharacterTable( "4_1.L3(4).2_2*" ) ];;
gap> List( test, ClassPositionsOfCentre );
[ [ 1, 3 ], [ 1, 3 ] ]
gap> fact:= List( test, t -> t / ClassPositionsOfCentre( t ) );;
gap> IsRecord( TransformingPermutationsCharacterTables( fact[1], fact[2] ) );
true
]]></Example>

<P/>

Now we try the second approach and compare the results.
By the abovementioned asymmetry,
it is clear that the tables are not uniquely determined by the input data.

<P/>

<Example><![CDATA[
gap> names:= [ "L3(4).(2^2)_{123}", "L3(4).(2^2)_{1*23}",
>              "L3(4).(2^2)_{12*3}", "L3(4).(2^2)_{1*2*3}" ];;
gap> inputs1:= List( names, nam -> [ "4_1.L3(4).2_3", "2.L3(4).2_3",
>      Concatenation( "2.", nam ), Concatenation( "4_1.", nam ) ] );;
gap> names:= List( names, nam -> ReplacedString( nam, "3}", "3*}" ) );;
gap> inputs2:= List( names, nam -> [ "4_1.L3(4).2_3*", "2.L3(4).2_3*",
>      Concatenation( "2.", nam ), Concatenation( "4_1.", nam ) ] );;
gap> inputs:= Concatenation( inputs1, inputs2 );
[ [ "4_1.L3(4).2_3", "2.L3(4).2_3", "2.L3(4).(2^2)_{123}", 
      "4_1.L3(4).(2^2)_{123}" ], 
  [ "4_1.L3(4).2_3", "2.L3(4).2_3", "2.L3(4).(2^2)_{1*23}", 
      "4_1.L3(4).(2^2)_{1*23}" ], 
  [ "4_1.L3(4).2_3", "2.L3(4).2_3", "2.L3(4).(2^2)_{12*3}", 
      "4_1.L3(4).(2^2)_{12*3}" ], 
  [ "4_1.L3(4).2_3", "2.L3(4).2_3", "2.L3(4).(2^2)_{1*2*3}", 
      "4_1.L3(4).(2^2)_{1*2*3}" ], 
  [ "4_1.L3(4).2_3*", "2.L3(4).2_3*", "2.L3(4).(2^2)_{123*}", 
      "4_1.L3(4).(2^2)_{123*}" ], 
  [ "4_1.L3(4).2_3*", "2.L3(4).2_3*", "2.L3(4).(2^2)_{1*23*}", 
      "4_1.L3(4).(2^2)_{1*23*}" ], 
  [ "4_1.L3(4).2_3*", "2.L3(4).2_3*", "2.L3(4).(2^2)_{12*3*}", 
      "4_1.L3(4).(2^2)_{12*3*}" ], 
  [ "4_1.L3(4).2_3*", "2.L3(4).2_3*", "2.L3(4).(2^2)_{1*2*3*}", 
      "4_1.L3(4).(2^2)_{1*2*3*}" ] ]
gap> result2:= [];;
gap> for  input in inputs do
>      tblMG := CharacterTable( input[1] );
>      tblG  := CharacterTable( input[2] );
>      tblGA := CharacterTable( input[3] );
>      name  := Concatenation( "new", input[4] );
>      lib   := CharacterTable( input[4] );
>      poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );
>      Append( result2, poss );
>    od;
#E  4 possibilities for new4_1.L3(4).(2^2)_{123}
#E  no solution for new4_1.L3(4).(2^2)_{1*23}
#E  no solution for new4_1.L3(4).(2^2)_{12*3}
#E  no solution for new4_1.L3(4).(2^2)_{1*2*3}
#E  4 possibilities for new4_1.L3(4).(2^2)_{123*}
#E  no solution for new4_1.L3(4).(2^2)_{1*23*}
#E  no solution for new4_1.L3(4).(2^2)_{12*3*}
#E  no solution for new4_1.L3(4).(2^2)_{1*2*3*}
gap> Length( result2 );
8
gap> result2:= List( result2, x -> x.table );
[ CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ) ]
gap> List( result, t1 -> PositionsProperty( result2, t2 -> IsRecord(
>      TransformingPermutationsCharacterTables( t1, t2 ) ) ) );
[ [ 1 ], [ 4 ], [ 3 ], [ 2 ], [ 7 ], [ 6 ], [ 5 ], [ 8 ] ]
]]></Example>

<P/>

At the moment, I do not know interesting groups that contain one of the
<M>4_1.L_3(4).2^2</M> type groups and whose character tables are available.

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:42L34V4">
<Heading>The Character Tables of Groups of the Type <M>4_2.L_3(4).2^2</M>
(October 2011)</Heading>

The situation with <M>4_2.L_3(4).2^2</M> is analogous to that with <M>6.L_3(4).2^2</M>,
see Section&nbsp;<Ref Subsect="subsect:6L34V4"/>.

<P/>

<Example><![CDATA[
gap> tbls:= List( [ "1", "2", "3" ],
>      i -> CharacterTable( Concatenation( "4_2.L3(4).2_", i ) ) );
[ CharacterTable( "4_2.L3(4).2_1" ), CharacterTable( "4_2.L3(4).2_2" )
    , CharacterTable( "4_2.L3(4).2_3" ) ]
gap> isos:= List( [ "1", "2", "3" ], 
>      i -> CharacterTable( Concatenation( "4_2.L3(4).2_", i, "*" ) ) );
[ CharacterTable( "Isoclinic(4_2.L3(4).2_1)" ), 
  CharacterTable( "4_2.L3(4).2_2*" ), 
  CharacterTable( "Isoclinic(4_2.L3(4).2_3)" ) ]
]]></Example>

<P/>

Note that the group <M>4_1.L_3(4).2_2</M> has a centre of order four,
so one cannot construct the isoclinic variant not by calling
the one argument version of
<Ref Func="CharacterTableIsoclinic" BookName="ref"/>.

<P/>

<Example><![CDATA[
gap> List( tbls, ClassPositionsOfCentre );
[ [ 1, 3 ], [ 1, 2, 3, 4 ], [ 1, 3 ] ]
gap> IsRecord( TransformingPermutationsCharacterTables( tbls[2],
>        CharacterTableIsoclinic( tbls[2] ) ) );
true
]]></Example>

<P/>

Again, we get eight different character tables,
in two orbits.

<P/>

<Example><![CDATA[
gap> inputs:= [
> [ tbls[1], tbls[2], tbls[3], "4_2.L3(4).(2^2)_{123}" ],
> [ isos[1], tbls[2], tbls[3], "4_2.L3(4).(2^2)_{1*23}" ],
> [ tbls[1], isos[2], tbls[3], "4_2.L3(4).(2^2)_{12*3}" ],
> [ tbls[1], tbls[2], isos[3], "4_2.L3(4).(2^2)_{123*}" ],
> [ isos[1], isos[2], tbls[3], "4_2.L3(4).(2^2)_{1*2*3}" ],
> [ isos[1], tbls[2], isos[3], "4_2.L3(4).(2^2)_{1*23*}" ],
> [ tbls[1], isos[2], isos[3], "4_2.L3(4).(2^2)_{12*3*}" ],
> [ isos[1], isos[2], isos[3], "4_2.L3(4).(2^2)_{1*2*3*}" ] ];;
gap> tblG:= CharacterTable( "4_2.L3(4)" );;
gap> result:= [];;
gap> for input in inputs do
>      tblsG2:= input{ [ 1 .. 3 ] };
>      lib:= CharacterTable( input[4] );
>      poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );
>      ConstructModularGV4Tables( tblG, tblsG2, poss, lib );
>      Append( result, RepresentativesCharacterTables( poss ) );
>    od;
#I  excluded cand. 2 (out of 8) for 4_2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_2.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_2.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 
5-mod. table
gap> result:= List( result, x -> x.table );
[ CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{1*23}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{1*2*3}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{1*23*}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{12*3*}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{1*2*3*}" ) ]
gap> List( result, NrConjugacyClasses );
[ 50, 50, 44, 50, 44, 50, 44, 44 ]
gap> t:= result[1];;
gap> nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
>            x -> Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
gap> iso:= List( nsg, x -> CharacterTableIsoclinic( t, x ) );;
gap> List( iso, x -> PositionProperty( result, y ->
>            TransformingPermutationsCharacterTables( x, y ) <> fail ) );
[ 4, 2, 6 ]
gap> t:= result[3];;
gap> nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),
>            x -> Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;
gap> iso:= List( nsg, x -> CharacterTableIsoclinic( t, x ) );;
gap> List( iso, x -> PositionProperty( result, y ->
>            TransformingPermutationsCharacterTables( x, y ) <> fail ) );
[ 7, 5, 8 ]
]]></Example>

<P/>

Note that only two out of the eight tables of the type <M>2.L_3(4).2^2</M>
occur as factors of the eight tables.

<P/>

<Example><![CDATA[
gap> facts:= [ CharacterTable( "2.L3(4).(2^2)_{123}" ),
>              CharacterTable( "2.L3(4).(2^2)_{12*3}" ) ];;
gap> factresults:= List( result, t -> t / ClassPositionsOfCentre( t ) );;
gap> List( factresults, t -> PositionProperty( facts, f ->
>            IsRecord( TransformingPermutationsCharacterTables( t, f ) ) ) );
[ 1, 1, 2, 1, 2, 1, 2, 2 ]
]]></Example>

<P/>

This is not surprising;
note that for <M>i \in \{ 1, 3 \}</M>,
the two isoclinic variants of <M>4_1.L_3(4).2_i</M> have isomorphic
factor groups of the type <M>2.L_3(4).2_i</M>.
(For <M>i = 2</M>, this is not the case.)

<P/>

<Example><![CDATA[
gap> test:= [ CharacterTable( "4_2.L3(4).2_1" ),
>             CharacterTable( "4_2.L3(4).2_1*" ) ];;
gap> List( test, ClassPositionsOfCentre );
[ [ 1, 3 ], [ 1, 3 ] ]
gap> fact:= List( test, t -> t / ClassPositionsOfCentre( t ) );;
gap> IsRecord( TransformingPermutationsCharacterTables( fact[1], fact[2] ) );
true
gap> test:= [ CharacterTable( "4_2.L3(4).2_3" ),
>             CharacterTable( "4_2.L3(4).2_3*" ) ];;
gap> List( test, ClassPositionsOfCentre );
[ [ 1, 3 ], [ 1, 3 ] ]
gap> fact:= List( test, t -> t / ClassPositionsOfCentre( t ) );;
gap> IsRecord( TransformingPermutationsCharacterTables( fact[1], fact[2] ) );
true
]]></Example>

<P/>

Now we try the second approach and compare the results.
By the abovementioned asymmetry,
it is clear that the tables are not uniquely determined by the input data.

<P/>

<Example><![CDATA[
gap> names:= [ "L3(4).(2^2)_{123}", "L3(4).(2^2)_{1*23}",
>              "L3(4).(2^2)_{123*}", "L3(4).(2^2)_{1*23*}" ];;
gap> inputs1:= List( names, nam -> [ "4_2.L3(4).2_2", "2.L3(4).2_2",
>      Concatenation( "2.", nam ), Concatenation( "4_2.", nam ) ] );;
gap> names:= List( names, nam -> ReplacedString( nam, "23", "2*3" ) );;
gap> inputs2:= List( names, nam -> [ "4_2.L3(4).2_2*", "2.L3(4).2_2*",
>      Concatenation( "2.", nam ), Concatenation( "4_2.", nam ) ] );;
gap> inputs:= Concatenation( inputs1, inputs2 );
[ [ "4_2.L3(4).2_2", "2.L3(4).2_2", "2.L3(4).(2^2)_{123}", 
      "4_2.L3(4).(2^2)_{123}" ], 
  [ "4_2.L3(4).2_2", "2.L3(4).2_2", "2.L3(4).(2^2)_{1*23}", 
      "4_2.L3(4).(2^2)_{1*23}" ], 
  [ "4_2.L3(4).2_2", "2.L3(4).2_2", "2.L3(4).(2^2)_{123*}", 
      "4_2.L3(4).(2^2)_{123*}" ], 
  [ "4_2.L3(4).2_2", "2.L3(4).2_2", "2.L3(4).(2^2)_{1*23*}", 
      "4_2.L3(4).(2^2)_{1*23*}" ], 
  [ "4_2.L3(4).2_2*", "2.L3(4).2_2*", "2.L3(4).(2^2)_{12*3}", 
      "4_2.L3(4).(2^2)_{12*3}" ], 
  [ "4_2.L3(4).2_2*", "2.L3(4).2_2*", "2.L3(4).(2^2)_{1*2*3}", 
      "4_2.L3(4).(2^2)_{1*2*3}" ], 
  [ "4_2.L3(4).2_2*", "2.L3(4).2_2*", "2.L3(4).(2^2)_{12*3*}", 
      "4_2.L3(4).(2^2)_{12*3*}" ], 
  [ "4_2.L3(4).2_2*", "2.L3(4).2_2*", "2.L3(4).(2^2)_{1*2*3*}", 
      "4_2.L3(4).(2^2)_{1*2*3*}" ] ]
gap> result2:= [];;
gap> for  input in inputs do
>      tblMG := CharacterTable( input[1] );
>      tblG  := CharacterTable( input[2] );
>      tblGA := CharacterTable( input[3] );
>      name  := Concatenation( "new", input[4] );
>      lib   := CharacterTable( input[4] );
>      poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );
>      Append( result2, poss );
>    od;
#E  4 possibilities for new4_2.L3(4).(2^2)_{123}
#E  no solution for new4_2.L3(4).(2^2)_{1*23}
#E  no solution for new4_2.L3(4).(2^2)_{123*}
#E  no solution for new4_2.L3(4).(2^2)_{1*23*}
#E  4 possibilities for new4_2.L3(4).(2^2)_{12*3}
#E  no solution for new4_2.L3(4).(2^2)_{1*2*3}
#E  no solution for new4_2.L3(4).(2^2)_{12*3*}
#E  no solution for new4_2.L3(4).(2^2)_{1*2*3*}
gap> Length( result2 );
8
gap> result2:= List( result2, x -> x.table );
[ CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ) ]
gap> List( result, t1 -> PositionsProperty( result2, t2 -> IsRecord(
>      TransformingPermutationsCharacterTables( t1, t2 ) ) ) );
[ [ 1 ], [ 4 ], [ 7 ], [ 3 ], [ 6 ], [ 2 ], [ 5 ], [ 8 ] ]
]]></Example>

<P/>

The group <M>ON.2</M> contains a maximal subgroup <M>M</M> of the type
<M>4_2.L_3(4).2^2</M>, see&nbsp;<Cite Key="CCN85" Where="p. 132"/>.
Only the third result table admits a class fusion into <M>ON.2</M>.
This shows the existence of groups for the tables from the second orbit.

<P/>

<Example><![CDATA[
gap> on2:= CharacterTable( "ON.2" );;
gap> fus:= List( result, x -> PossibleClassFusions( x, on2 ) );;
gap> List( fus, Length );
[ 0, 0, 16, 0, 0, 0, 0, 0 ]
]]></Example>

<!-- % -> yields also an example for 12_2.L3(4).2^2 -> 3.ON.2 -->

<!-- % The group <M>U_4(3).(2^2)_{133}</M> contains a maximal subgroup <M>M</M> of the type -->
<!-- % <M>L_3(4).2^2</M>, see&nbsp;<Cite Key="CCN85" Where="p. 52"/>. -->
<!-- % Its derived subgroup <M>M'</M> of the type <M>L_3(4)</M> lies inside <M>U_4(3)</M>, -->
<!-- % and we claim that the preimage of <M>M'</M> under the natural epimorphism from -->
<!-- % <M>4.U_4(3)</M> to <M>U_4(3)</M> is a four-fold cover of <M>L_3(4)</M>, of the type -->
<!-- % <M>4_2.L_3(4)</M>. -->
<!-- % This follows from the fact that <M>L_3(4)</M> and its double cover do not admit -->
<!-- % a class fusion into <M>4.U_4(3)</M>, as well as the group of the type -->
<!-- % 4_2.L_3(4)$. -->
<!-- 
<Example><![CDATA[
gap> List( [ "L3(4)", "2.L3(4)", "4_1.L3(4)", "4_2.L3(4)" ], nam ->
>          Length( PossibleClassFusions( CharacterTable( nam ), 4u ) ) );
[ 0, 0, 0, 4 ]
]]></Example>
  -->
<!-- % This means that <M>4.U_4(3).(2^2)_{133}</M> contains a subgroup of the type -->
<!-- % <M>4_2.L3(4).2^2</M>. -->
<!-- % -->
<!-- % -> this requires the table of the supergroup; but which name is appropriate? -->
<!-- % -> and add also the example for 2.L3(4).2^2 -> 2.U_4(3).(2^2)_{133}! -->

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Aut(L_2(81))">
<Heading>The Character Table of Aut<M>(L_2(81))</M></Heading>

The group Aut<M>(L_2(81)) \cong L_2(81).(2 \times 4)</M> has the structure
<M>G.2^2</M> where <M>G = L_2(81).2_1</M>.
Here we get two triples of possible actions on the tables of the groups
<M>G.2_i</M>, and one possible character table for each triple.

<P/>

<Example><![CDATA[
gap> input:= [ "L2(81).2_1", "L2(81).4_1", "L2(81).4_2", "L2(81).2^2",
>                                                        "L2(81).(2x4)" ];;
gap> tblG   := CharacterTable( input[1] );;
gap> tblsG2 := List( input{ [ 2 .. 4 ] }, CharacterTable );;
gap> name   := Concatenation( "new", input[5] );;
gap> lib    := CharacterTable( input[5] );;
gap> poss   := ConstructOrdinaryGV4Table( tblG, tblsG2, name, lib );;
#I  newL2(81).(2x4): 2 equivalence classes
gap> reps:= RepresentativesCharacterTables( poss );;
gap> Length( reps );
2
]]></Example>

<P/>

Due to the different underlying actions, the power maps of the two candidate
tables differ.

<P/>

<Example><![CDATA[
gap> ord:= OrdersClassRepresentatives( reps[1].table );;
gap> ord = OrdersClassRepresentatives( reps[2].table ); 
true
gap> pos:= Position( ord, 80 );
33
gap> PowerMap( reps[1].table, 3 )[ pos ];
34
gap> PowerMap( reps[2].table, 3 )[ pos ];
33
]]></Example>

<P/>

Aut<M>(L_2(81))</M> can be generated by PGL<M>(2,81) = L_2(81).2_2</M>
and the Frobenius automorphism of order four that is defined on GL<M>(2,81)</M>
as the map that cubes the matrix entries.
The elements of order <M>80</M> in Aut<M>(L_2(81))</M> are conjugates of diagonal
matrices modulo scalar matrices,
which are mapped to their third powers by the Frobenius homomorphism.
So the third power map of Aut<M>(L_2(81))</M> fixes the classes of elements of
order <M>80</M>.
In other words, the second of the two tables is the right one.

<P/>

<Example><![CDATA[
gap> trans:= TransformingPermutationsCharacterTables( reps[2].table, lib );;
gap> IsRecord( trans );
true
gap> List( reps[2].G2fusGV4, x -> OnTuples( x, trans.columns ) )
>  = List( tblsG2, x -> GetFusionMap( x, lib ) );
true
gap> ConstructModularGV4Tables( tblG, tblsG2, poss, lib );;
#I  not all input tables for L2(81).(2x4) mod 3 available
#I  not all input tables for L2(81).(2x4) mod 41 available
]]></Example>

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:O_8^+(3).2^2_111">
<Heading>The Character Table of <M>O_8^+(3).2^2_{111}</M></Heading>

The construction of the character table of the group <M>O_8^+(3).2^2_{111}</M>
is not as straightforward as the constructions shown
in Section&nbsp;<Ref Subsect="subsect:xplGV43.A6.V4"/>.
Here we get <M>26</M> triples of actions on the tables of the three subgroups
<M>G.2_i</M> of index two,
but only one of them leads to candidates for the desired character table.
Specifically, we get <M>64</M> such candidates, in two equivalence classes
w.r.t.&nbsp;permutation equivalence.

<!-- This computation needs about one and a half hour of CPU time
     for getting the candidates,
     and about two hours for the equivalence tests. -->

<!-- % As an alternative to the check of the 26 actions, one could use the group -->
<!-- % for showing that the elements of the orders 40 and 28 have centralizers -->
<!-- % of the orders 80 and 56, respectively. -->
<!-- % However, this part is not very time consuming. -->

<P/>

<Example><![CDATA[
gap> input:= [ "O8+(3)", "O8+(3).2_1",  "O8+(3).2_1'", "O8+(3).2_1''",
>                                                  "O8+(3).(2^2)_{111}" ];;
gap> tblG   := CharacterTable( input[1] );;
gap> tblsG2 := List( input{ [ 2 .. 4 ] }, CharacterTable );;
gap> name   := Concatenation( "new", input[5] );;
gap> lib    := CharacterTable( input[5] );;
gap> poss   := ConstructOrdinaryGV4Table( tblG, tblsG2, name, lib );;
#I  newO8+(3).(2^2)_{111}: 2 equivalence classes
gap> Length( poss );
64
gap> reps:= RepresentativesCharacterTables( poss );;
gap> Length( reps );
2
]]></Example>

<P/>

The two candidate tables differ only in four irreducible characters
involving irrationalities on the classes of element order <M>28</M>.
All three subgroups <M>G.2_i</M> contain elements of order <M>28</M>
that do not lie in the simple group <M>G</M>;
these classes are roots of the same (unique) class of element order <M>7</M>.
The centralizer <M>C</M> of an order <M>7</M> element in <M>G.2^2</M>
has order <M>112 = 2^4 \cdot 7</M>,
the intersection of <M>C</M> with <M>G</M> has the structure
<M>2^2 \times 7</M> since <M>G</M> contains three classes
of cyclic subgroups of the order <M>14</M>,
and each of the intersections of <M>C</M> with one of the subgroups
<M>G.2_i</M> has the structure <M>2 \times 4 \times 7</M>,
so the structure of <M>C</M> is <M>4^2 \times 7 \cong 4 \times 28</M>.

<P/>

<Example><![CDATA[
gap> t:= reps[1].table;;
gap> ord7:= Filtered( [ 1 .. NrConjugacyClasses( t ) ],                        
>               i -> OrdersClassRepresentatives( t )[i] = 7 );
[ 37 ]
gap> SizesCentralizers( t ){ ord7 };
[ 112 ]
gap> ord28:= Filtered( [ 1 .. NrConjugacyClasses( t ) ],
>               i -> OrdersClassRepresentatives( t )[i] = 28 );
[ 112, 113, 114, 115, 161, 162, 163, 164, 210, 211, 212, 213 ]
gap> List( reps[1].G2fusGV4, x -> Intersection( ord28, x ) );
[ [ 112, 113, 114, 115 ], [ 161, 162, 163, 164 ], 
  [ 210, 211, 212, 213 ] ]
gap> sub:= CharacterTable( "Cyclic", 28 ) * CharacterTable( "Cyclic", 4 );;
gap> List( reps, x -> Length( PossibleClassFusions( sub, x.table ) ) );
[ 0, 96 ]
]]></Example>

<P/>

It turns out that only one of the two candidate tables admits a class fusion
from the character table of <M>C</M>,
thus we have determined the ordinary character table
of <M>O_8^+(3).2^2_{111}</M>.
It coincides with the table from the library.

<P/>

<Example><![CDATA[
gap> trans:= TransformingPermutationsCharacterTables( reps[2].table, lib );;
gap> IsRecord( trans );
true
gap> List( reps[2].G2fusGV4, x -> OnTuples( x, trans.columns ) )
>  = List( tblsG2, x -> GetFusionMap( x, lib ) );
true
]]></Example>

<P/>

(If we do not believe the statement about the structure of <M>C</M>
then we can check all <M>14</M> groups of order <M>112</M>
that contain a central subgroup of order <M>7</M>.
A unique such group admits a class fusion into at least one of the two
candidate tables.)

<P/>

The wrong candidate for the ordinary table cannot be excluded
via conditions that are forced by the construction of the
<M>p</M>-modular tables of <M>O_8^+(3).2^2_{111}</M>.
Thus we restrict the ordinary tables used for this construction
to those candidates that are equivalent to the correct table.

<P/>

<Example><![CDATA[
gap> poss:= Filtered( poss,
>      r -> TransformingPermutationsCharacterTables( r.table, lib )
>           <> fail );;
gap> ConstructModularGV4Tables( tblG, tblsG2, poss, lib );;
#I  not all input tables for O8+(3).(2^2)_{111} mod 3 available
]]></Example>

<P/>

So also the <M>p</M>-modular tables of <M>O_8^+(3).2^2_{111}</M>
can be computed this way,
provided that the <M>p</M>-modular tables of the index <M>2</M> subgroups
are available.

</Subsection>
</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:xplV4G">
<Heading>Examples for the Type <M>2^2.G</M></Heading>

We compute the character table of a group of the type <M>2^2.G</M> from the
character tables of the three factor groups of the type <M>2.G</M>,
using the function
<Ref Func="PossibleCharacterTablesOfTypeV4G" BookName="ctbllib"/>,
see Section&nbsp;<Ref Subsect="subsect:theorV4G"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:2^2.Sz(8)">
<Heading>The Character Table of <M>2^2.Sz(8)</M></Heading>

The three central involutions in <M>2^2.Sz(8)</M> are permuted cyclicly
by an outer automorphism <M>\alpha</M> of order three.
In order to apply
<Ref Func="PossibleCharacterTablesOfTypeV4G" BookName="ctbllib"/>,
we need the character table of the group <M>2.Sz(8)</M> and the action
on the classes of <M>Sz(8)</M> that is induced by <M>\alpha</M>.

<P/>

The ordinary character table of <M>G = Sz(8)</M> admits exactly five
table automorphisms of order dividing <M>3</M>.
Each of these possibilities leads to exactly one possible character table
of <M>2^2.G</M>, and the five tables are permutation equivalent.
From this point of view, we need not know which of the table automorphisms
are induced by outer <E>group</E> automorphisms of <M>G</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "Sz(8)" );;
gap> 2t:= CharacterTable( "2.Sz(8)" );;
gap> aut:= AutomorphismsOfTable( t );;
gap> elms:= Set( Filtered( aut, x -> Order( x ) in [ 1, 3 ] ),           
>                SmallestGeneratorPerm );
[ (), (9,10,11), (6,7,8), (6,7,8)(9,10,11), (6,7,8)(9,11,10) ]
gap> poss:= List( elms,                                         
>       pi -> PossibleCharacterTablesOfTypeV4G( t, 2t, pi, "2^2.Sz(8)" ) );
[ [ CharacterTable( "2^2.Sz(8)" ) ], [ CharacterTable( "2^2.Sz(8)" ) ]
    , [ CharacterTable( "2^2.Sz(8)" ) ], 
  [ CharacterTable( "2^2.Sz(8)" ) ], 
  [ CharacterTable( "2^2.Sz(8)" ) ] ]
gap> reps:= RepresentativesCharacterTables( Concatenation( poss ) );
[ CharacterTable( "2^2.Sz(8)" ) ]
]]></Example>

<P/>

The tables coincide with the one that is stored in the &GAP; library.

<P/>

<Example><![CDATA[
gap> IsRecord( TransformingPermutationsCharacterTables( reps[1],
>        CharacterTable( "2^2.Sz(8)" ) ) );
true
]]></Example>

<P/>

The computation of the <M>p</M>-modular character table of <M>2^2.G</M>
from the <M>p</M>-modular character table of <M>2.G</M>
and the three factor fusions from <M>2^2.G</M> to <M>2.G</M>
is straightforward,
as is stated in Section&nbsp;<Ref Subsect="subsect:theorV4G"/>.
The three fusions are stored on the tables returned by
<Ref Func="PossibleCharacterTablesOfTypeV4G" BookName="ctbllib"/>.

<P/>

<Example><![CDATA[
gap> GetFusionMap( poss[1][1], 2t, "1" );
[ 1, 1, 2, 2, 3, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 
  12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19 ]
gap> GetFusionMap( poss[1][1], 2t, "2" );
[ 1, 2, 1, 2, 3, 4, 5, 6, 7, 6, 7, 8, 9, 8, 9, 10, 11, 10, 11, 12, 
  13, 12, 13, 14, 15, 14, 15, 16, 17, 16, 17, 18, 19, 18, 19 ]
gap> GetFusionMap( poss[1][1], 2t, "3" );
[ 1, 2, 2, 1, 3, 4, 5, 6, 7, 7, 6, 8, 9, 9, 8, 10, 11, 11, 10, 12, 
  13, 13, 12, 14, 15, 15, 14, 16, 17, 17, 16, 18, 19, 19, 18 ]
]]></Example>

<P/>

The &GAP; library function
<Ref Func="BrauerTableOfTypeV4G" BookName="ctbllib"/>
can be used
to derive Brauer tables of <M>2^2.G</M>.
We have to compute the <M>p</M>-modular tables
for prime divisors <M>p</M> of <M>|G|</M>,
that is, for <M>p \in \{ 2, 5, 7, 13 \}</M>.

<P/>

<Example><![CDATA[
gap> PrimeDivisors( Size( t ) );
[ 2, 5, 7, 13 ]
]]></Example>

<P/>

Clearly <M>p = 2</M> is uninteresting from this point of view
because the <M>2</M>-modular table of <M>2^2.G</M>
can be identified with the <M>2</M>-modular table of <M>G</M>.

<P/>

For each of the five ordinary tables (corresponding to the five possible
table automorphisms of <M>G</M>) constructed above,
we get one candidate of a <M>5</M>-modular table.
However, these tables are <E>not</E> all equivalent.
There are two equivalence classes, and one of the two possibilities is
inconsistent in the sense that not all tensor products of irreducibles
decompose into irreducibles.

<P/>

<Example><![CDATA[
gap> cand:= List( poss, l -> BrauerTableOfTypeV4G( l[1], 2t mod 5,
>      ConstructionInfoCharacterTable( l[1] )[3] ) );
[ BrauerTable( "2^2.Sz(8)", 5 ), BrauerTable( "2^2.Sz(8)", 5 ), 
  BrauerTable( "2^2.Sz(8)", 5 ), BrauerTable( "2^2.Sz(8)", 5 ), 
  BrauerTable( "2^2.Sz(8)", 5 ) ]
gap> Length( RepresentativesCharacterTables( cand ) );
2
gap> List( cand, CTblLib.Test.TensorDecomposition );
[ false, true, false, true, true ]
gap> Length( RepresentativesCharacterTables( cand{ [ 2, 4, 5 ] } ) );
1
gap> IsRecord( TransformingPermutationsCharacterTables( cand[2],
>        CharacterTable( "2^2.Sz(8)" ) mod 5 ) );
true
]]></Example>

<P/>

This implies that only those table automorphisms of <M>G</M> can be induced by
an outer group automorphism that move the classes of element order <M>13</M>.

<P/>

The <M>7</M>-modular table of <M>2^2.G</M> is uniquely determined,
independent of the choice of the table automorphism of <M>G</M>.

<P/>

<Example><![CDATA[
gap> cand:= List( poss, l -> BrauerTableOfTypeV4G( l[1], 2t mod 7,
>      ConstructionInfoCharacterTable( l[1] )[3] ) );
[ BrauerTable( "2^2.Sz(8)", 7 ), BrauerTable( "2^2.Sz(8)", 7 ), 
  BrauerTable( "2^2.Sz(8)", 7 ), BrauerTable( "2^2.Sz(8)", 7 ), 
  BrauerTable( "2^2.Sz(8)", 7 ) ]
gap> Length( RepresentativesCharacterTables( cand ) );
1
gap> IsRecord( TransformingPermutationsCharacterTables( cand[1],      
>        CharacterTable( "2^2.Sz(8)" ) mod 7 ) );
true
]]></Example>

<P/>

We get two candidates for the <M>13</M>-modular table of <M>2^2.G</M>,
also if we consider only the three admissible table automorphisms.

<P/>

<Example><![CDATA[
gap> elms:= elms{ [ 2, 4, 5 ] };
[ (9,10,11), (6,7,8)(9,10,11), (6,7,8)(9,11,10) ]
gap> poss:= poss{ [ 2, 4, 5 ] };;                                     
gap> cand:= List( poss, l -> BrauerTableOfTypeV4G( l[1], 2t mod 13,
>      ConstructionInfoCharacterTable( l[1] )[3] ) );
[ BrauerTable( "2^2.Sz(8)", 13 ), BrauerTable( "2^2.Sz(8)", 13 ), 
  BrauerTable( "2^2.Sz(8)", 13 ) ]
gap> Length( RepresentativesCharacterTables( cand ) );
2
gap> List( cand, CTblLib.Test.TensorDecomposition );                      
[ true, true, true ]
]]></Example>

<P/>

The action of the outer automorphism of order three of <M>G</M>
can be read off from the <M>2</M>-modular table of <M>G</M>.
Note that the ordinary and the <M>5</M>-modular character table of <M>G</M>
possess two independent table automorphisms of order three,
whereas the group of table automorphisms of the <M>2</M>-modular table
has order three.
(The reason is that the irrational values on the classes of the
element orders <M>7</M> and <M>13</M> appear in the same
irreducible <M>2</M>-modular Brauer characters.)

<P/>

<Example><![CDATA[
gap> mod2:= CharacterTable( "Sz(8)" ) mod 2;
BrauerTable( "Sz(8)", 2 )
gap> AutomorphismsOfTable( mod2 );
Group([ (3,4,5)(6,7,8) ])
gap> OrdersClassRepresentatives( mod2 );
[ 1, 5, 7, 7, 7, 13, 13, 13 ]
]]></Example>

<P/>

This means that the first candidate is ruled out;
this determines the <M>13</M>-modular character table of <M>2^2.G</M>.

<P/>

<Example><![CDATA[
gap> Length( RepresentativesCharacterTables( cand{ [ 2, 3 ] } ) );
1
gap> IsRecord( TransformingPermutationsCharacterTables( cand[2],
>        CharacterTable( "2^2.Sz(8)" ) mod 13 ) );
true
]]></Example>

<!-- % {}From the class fusion into the automorphism group <M>G.3</M> of <M>G</M> -->
<!-- % it is clear that exactly the classes of orders <M>7</M> and <M>13</M> are not fixed, -->
<!-- % but it is not clear whether the group automorphism (or its inverse) -->
<!-- % acts as <M>(</M><C>7A</C>, <C>7B</C>, <C>7C</C></M>)(<M><C>13A</C>, <C>13B</C>, <C>13C</C><M>)</M> -->
<!-- % or <M>(</M><C>7A</C>, <C>7B</C>, <C>7C</C><M>)(</M><C>13A</C>, <C>13C</C>, <C>13B</C><M>)</M>. -->
<!-- %  -->
<!-- % If we want to determine which of these two permutations describes the -->
<!-- % action of an outer automorphism of <M>G</M> on the classes of <M>G</M> -->
<!-- % then we can use explicit computations with the group. -->
<!-- % The lifting order rows in the &ATLAS; tell us that the former permutation -->
<!-- % must be taken, which corresponds to the Galois automorphism <M>{\ast 2}</M>; -->
<!-- % we want to check this. -->
<!-- % For that, we work with a representation of <M>G.3</M> taken from the -->
<!-- % &ATLAS; of Group Representations&nbsp;<Cite Key="AGRv3"/>, -->
<!-- % via the &GAP; interface&nbsp;<Cite Key="AtlasRep"/>. -->
<!-- % So we first load this package and fetch a representation. -->
<!-- 
<Example><![CDATA[
gap> LoadPackage( "atlasrep", false );
true
gap> g3:= Group( OneAtlasGeneratingSet( "Sz(8).3" ).generators );;
]]></Example>
  -->
<!-- % We show that the elements in <M>G.3 \setminus G</M> act on the classes of the -->
<!-- % element orders <M>7</M> and <M>13</M> in <M>G</M> like the Galois automorphism that -->
<!-- % squares the elements (or like the inverse of this automorphism). -->
<!--
<Example><![CDATA[
gap> g3:= Image( IsomorphismPermGroup( g3 ) );;
gap> g:= DerivedSubgroup( g3 );;
gap> repeat outer:= Random( g3 ); until not outer in g;
gap> outer:= outer^( Order( outer ) / 3 );;
gap> repeat ord7:= Random( g ); until Order( ord7 ) = 7;
gap> repeat ord13:= Random( g ); until Order( ord13 ) = 7;
gap> ( IsConjugate( g, ord7^outer, ord7^2 ) and
>      IsConjugate( g, ord13^outer, ord13^2 ) ) or
>    ( IsConjugate( g, ord7^outer, ord7^4 ) and
>      IsConjugate( g, ord13^outer, ord13^4 ) );
true
]]></Example>
 -->
<!-- % This means that the induced permutation is indeed <M>(6,7,8)(9,10,11)</M>. -->

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:V4GATLAS">
<Heading>&ATLAS; Tables of the Type <M>2^2.G</M> (September 2005)</Heading>

Besides <M>2^2.Sz(8)</M>
(cf.&nbsp;Section&nbsp;<Ref Subsect="subsect:2^2.Sz(8)"/>),
<M>2^2.O_8^+(3)</M> (cf.&nbsp;Section&nbsp;<Ref Subsect="subsect:MultO8p3"/>),
and certain central extensions of <M>L_3(4)</M>
(cf.&nbsp;Section&nbsp;<Ref Subsect="subsect:MultL34"/>),
the following examples of central extensions of nearly simple &ATLAS; groups
<M>G</M> by a Klein four group occur.

<P/>

<Example><![CDATA[
gap> listV4G:= [
>      [ "2^2.L3(4)",         "2.L3(4)",     "L3(4)"       ],
>      [ "2^2.L3(4).2_1",     "2.L3(4).2_1", "L3(4).2_1"   ],
>      [ "(2^2x3).L3(4)",     "6.L3(4)",     "3.L3(4)"     ],
>      [ "(2^2x3).L3(4).2_1", "6.L3(4).2_1", "3.L3(4).2_1" ],
>      [ "2^2.O8+(2)",        "2.O8+(2)",    "O8+(2)"      ],
>      [ "2^2.U6(2)",         "2.U6(2)",     "U6(2)"       ],
>      [ "(2^2x3).U6(2)",     "6.U6(2)",     "3.U6(2)"     ],
>      [ "2^2.2E6(2)",        "2.2E6(2)",    "2E6(2)"      ],
>      [ "(2^2x3).2E6(2)",    "6.2E6(2)",    "3.2E6(2)"    ],
> ];;
]]></Example>

<P/>

(For the tables of <M>(2^2 \times 3).G</M>, with <M>G</M> one of <M>L_3(4)</M>, <M>U_6(2)</M>,
or <M>{}^2E_6(2)</M>,
we could alternatively use the tables of <M>2^2.G</M> and <M>3.G</M>,
and the construction described in Chapter <Ref Chap="chap:CCE"/>.)
<!-- &nbsp;<Cite Key="CCE"/>.) -->

<P/>

The function for computing the candidates for the ordinary character tables
is similar to the one from Section&nbsp;<Ref Subsect="subsect:xplGV43.A6.V4"/>.

<P/>

<Ignore Remark="gapfilecomments">
</Ignore>
<Example><![CDATA[
gap> ConstructOrdinaryV4GTable:= function( tblG, tbl2G, name, lib )
>      local ord3, nam, poss, reps, trans;
> 
>      # Compute the possible actions for the ordinary tables.
>      ord3:= Set( Filtered( AutomorphismsOfTable( tblG ),
>                            x -> Order( x ) = 3 ),
>                  SmallestGeneratorPerm );
>      if 1 < Length( ord3 ) then
>        Print( "#I  ", name,
>               ": the action of the automorphism is not unique" );
>      fi;
>      # Compute the possible ordinary tables for the given actions.
>      nam:= Concatenation( "new", name );
>      poss:= Concatenation( List( ord3, pi ->
>             PossibleCharacterTablesOfTypeV4G( tblG, tbl2G, pi, nam ) ) );
>      # Test the possibilities for permutation equivalence.
>      reps:= RepresentativesCharacterTables( poss );
>      if 1 < Length( reps ) then
>        Print( "#I  ", name, ": ", Length( reps ),
>               " equivalence classes\n" );
>      elif Length( reps ) = 0 then
>        Print( "#E  ", name, ": no solution\n" );
>      else
>        # Compare the computed table with the library table.
>        if not IsCharacterTable( lib ) then
>          Print( "#I  no library table for ", name, "\n" );
>          PrintToLib( name, poss[1].table );
>        else
>          trans:= TransformingPermutationsCharacterTables( reps[1], lib );
>          if not IsRecord( trans ) then
>            Print( "#E  computed table and library table for ", name,
>                   " differ\n" );
>          fi;
>        fi;
>      fi;
>      return poss;
>    end;;
]]></Example>

<P/>

Concerning the Brauer tables, the same ambiguity problem may occur as in
Section&nbsp;<Ref Subsect="subsect:xplGV43.A6.V4"/>:
Some candidates for the ordinary table may be excluded due to information
provided by some <M>p</M>-modular table,
see Section&nbsp;<Ref Subsect="subsect:2^2.Sz(8)"/> for an easy example.
Our strategy is analogous to the one used in Section&nbsp;<Ref Subsect="subsect:xplGV43.A6.V4"/>.

<P/>

<Ignore Remark="gapfilecomments">
</Ignore>
<Example><![CDATA[
gap> ConstructModularV4GTables:= function( tblG, tbl2G, ordposs,
>                                          ordlibtblV4G )
>      local name, modposs, primes, checkordinary, i, p, tmodp, 2tmodp, aut,
>            poss, modlib, trans, reps;
> 
>      if not IsCharacterTable( ordlibtblV4G ) then
>        Print( "#I  no ordinary library table ...\n" );
>        return [];
>      fi;
>      name:= Identifier( ordlibtblV4G );
>      modposs:= [];
>      primes:= ShallowCopy( PrimeDivisors( Size( tblG ) ) );
>      ordposs:= ShallowCopy( ordposs );
>      checkordinary:= false;
>      for i in [ 1 .. Length( ordposs ) ] do
>        modposs[i]:= [];
>        for p in primes do
>          tmodp := tblG  mod p;
>          2tmodp:= tbl2G mod p;
>          if IsCharacterTable( tmodp ) and IsCharacterTable( 2tmodp ) then
>            aut:= ConstructionInfoCharacterTable( ordposs[i] )[3];
>            poss:= BrauerTableOfTypeV4G( ordposs[i], 2tmodp, aut );
>            if CTblLib.Test.TensorDecomposition( poss, false ) = false then
>              Print( "#I  excluded cand. ", i, " (out of ",
>                     Length( ordposs ), ") for ", name, " by ", p,
>                     "-mod. table\n" );
>              Unbind( ordposs[i] );
>              Unbind( modposs[i] );
>              checkordinary:= true;
>              break;
>            fi;
>            Add( modposs[i], poss );
>          else
>            Print( "#I  not all input tables for ", name, " mod ", p,
>                   " available\n" );
>            primes:= Difference( primes, [ p ] );
>          fi;
>        od;
>        if IsBound( modposs[i] ) then
>          # Compare the computed Brauer tables with the library tables.
>          for poss in modposs[i] do
>            p:= UnderlyingCharacteristic( poss );
>            modlib:= ordlibtblV4G mod p;
>            if IsCharacterTable( modlib ) then
>              trans:= TransformingPermutationsCharacterTables(
>                          poss, modlib );
>              if not IsRecord( trans ) then
>                Print( "#E  computed table and library table for ",
>                       name, " mod ", p, " differ\n" );
>              fi;
>            else
>              Print( "#I  no library table for ",
>                     name, " mod ", p, "\n" );
>              PrintToLib( name, poss );
>            fi;
>          od;
>        fi;
>      od;
>      if checkordinary then
>        # Test whether the ordinary table is admissible.
>        ordposs:= Compacted( ordposs );
>        modposs:= Compacted( modposs );
>        reps:= RepresentativesCharacterTables( ordposs );
>        if 1 < Length( reps ) then
>          Print( "#I  ", name, ": ", Length( reps ),
>                 " equivalence classes (ord. table)\n" );
>        elif Length( reps ) = 0 then
>          Print( "#E  ", name, ": no solution (ord. table)\n" );
>        else
>          # Compare the computed table with the library table.
>          trans:= TransformingPermutationsCharacterTables( reps[1],
>                      ordlibtblV4G );
>          if not IsRecord( trans ) then
>            Print( "#E  computed table and library table for ", name,
>                   " differ\n" );
>          fi;
>        fi;
>      fi;
>      # Test the uniqueness of the Brauer tables.
>      for poss in TransposedMat( modposs ) do
>        reps:= RepresentativesCharacterTables( poss );
>        if Length( reps ) <> 1 then
>          Print( "#I  ", name, ": ", Length( reps ), " candidates for the ",
>                 UnderlyingCharacteristic( reps[1] ), "-modular table\n" );
>        fi;
>      od;
>      return rec( ordinary:= ordposs, modular:= modposs );
>    end;;
]]></Example>

<P/>

In our examples,
the action of the outer automorphism of order three on the classes of <M>G</M>
turns out to be uniquely determined by the table automorphisms
of the character table of <M>G</M>.

<P/>

<Example><![CDATA[
gap> for input in listV4G do
>      tblG  := CharacterTable( input[3] );
>      tbl2G := CharacterTable( input[2] );
>      lib   := CharacterTable( input[1] );
>      poss  := ConstructOrdinaryV4GTable( tblG, tbl2G, input[1], lib );
>      ConstructModularV4GTables( tblG, tbl2G, poss, lib );
>    od;
#I  excluded cand. 1 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
#I  excluded cand. 2 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
#I  excluded cand. 7 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
#I  excluded cand. 10 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
#I  excluded cand. 15 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
#I  excluded cand. 16 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
#I  excluded cand. 1 (out of 16) for (2^2x3).L3(4).2_1 by 7-mod. table
#I  excluded cand. 2 (out of 16) for (2^2x3).L3(4).2_1 by 7-mod. table
#I  excluded cand. 7 (out of 16) for (2^2x3).L3(4).2_1 by 7-mod. table
#I  excluded cand. 10 (out of 16) for (2^2x3).L3(4).2_1 by 
7-mod. table
#I  excluded cand. 15 (out of 16) for (2^2x3).L3(4).2_1 by 
7-mod. table
#I  excluded cand. 16 (out of 16) for (2^2x3).L3(4).2_1 by 
7-mod. table
#I  not all input tables for 2^2.2E6(2) mod 2 available
#I  not all input tables for 2^2.2E6(2) mod 3 available
#I  not all input tables for 2^2.2E6(2) mod 5 available
#I  not all input tables for 2^2.2E6(2) mod 7 available
#I  not all input tables for (2^2x3).2E6(2) mod 2 available
#I  not all input tables for (2^2x3).2E6(2) mod 3 available
#I  not all input tables for (2^2x3).2E6(2) mod 5 available
#I  not all input tables for (2^2x3).2E6(2) mod 7 available
#I  not all input tables for (2^2x3).2E6(2) mod 11 available
#I  not all input tables for (2^2x3).2E6(2) mod 13 available
#I  not all input tables for (2^2x3).2E6(2) mod 17 available
#I  not all input tables for (2^2x3).2E6(2) mod 19 available
]]></Example>

<!-- %T add more consistency checks to the construction functions? -->
<!-- %T (There are cases, such as <M>2^2.L_3(4).2^2</M>, where the 7-modular table fails -->
<!-- %T but the 5-modular table is also inconsistent, which can be seen from the -->
<!-- %T embedding into bigger groups, such as <M>2^2.L_3(4).D_{12}</M>. -->
<!-- %T How to detect the inconsistency already in the table itself?) -->

<!-- %T still requires 5977734 msec! (without (2^2x3).2E6(2)) -->
<!-- %T A lot of time is spent in TableAutomorphisms calls. -->

<!-- %T other examples: -->
<!-- %T 2.U6(2)M3 -->
<!-- %T 6.U6(2)M3 -->

<!-- %T and maxes of the above groups! -->

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:MultO8p3">
<Heading>The Character Table of <M>2^2.O_8^+(3)</M> (March 2009)</Heading>

When one tries to construct the character table of the central extensions of
<M>G = O_8^+(3)</M> by a Klein four group,
in the same way as in Section&nbsp;<Ref Subsect="subsect:V4GATLAS"/>,
one notices that the order three automorphism that relates the three central
extensions of <M>G</M> by an involution is <E>not</E> uniquely determined.

<P/>

<Example><![CDATA[
gap> entry:= [ "2^2.O8+(3)", "2.O8+(3)", "O8+(3)" ];;
gap> tblG:= CharacterTable( entry[3] );;
gap> aut:= AutomorphismsOfTable( tblG );;
gap> ord3:= Set( Filtered( aut, x -> Order( x ) = 3 ),
>                SmallestGeneratorPerm );;
gap> Length( ord3 );
4
]]></Example>

<P/>

However, the table candidates one gets from the four possible automorphisms
turn out to be all equivalent,
hence the character table of <M>2^2.O_8^+(3)</M> can be constructed as follows.

<P/>

<Example><![CDATA[
gap> poss:= [];;
gap> tbl2G:= CharacterTable( entry[2] );
CharacterTable( "2.O8+(3)" )
gap> for pi in ord3 do
>   Append( poss,
>           PossibleCharacterTablesOfTypeV4G( tblG, tbl2G, pi, entry[1] ) );
> od;
gap> Length( poss );
32
gap> poss:= RepresentativesCharacterTables( poss );;
gap> Length( poss );
1
]]></Example>

<P/>

The computed table coincides with the library table.

<P/>

<Example><![CDATA[
gap> lib:= CharacterTable( entry[1] );;
gap> if TransformingPermutationsCharacterTables( poss[1], lib ) = fail then
>      Print( "#E  differences for ", entry[1], "\n" );
>    fi;
]]></Example>

<!-- % Can I perhaps conclude from the symmetries of 2.O8+(3) -->
<!-- % that the four actions are all equivalent? -->

<!-- % The whole computation required 9450 sec. -->

<!-- % There are no Brauer tables yet ... -->

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:MultL34">
<Heading>The Character Table of the Schur Cover of <M>L_3(4)</M>
(September 2005)</Heading>

The Schur cover of <M>G = L_3(4)</M> has the structure
<M>(4^2 \times 3).L_3(4)</M>.
Following&nbsp;<Cite Key="CCN85" Where="p. 23"/>,
we regard the multiplier of <M>G</M> as

<Display Mode="M">
   M =
   \langle a, b, c, d \mid [a,b] = [a,c] = [a,d] = [b,c] = [b,d] = [c,d]
                                 = a^4 = b^4 = c^4 = d^3 = abc \rangle ,
</Display>

and we will consider the automorphism <M>\alpha</M> of <M>M.G</M>
that acts as <M>(a,b,c)(d)</M> on <M>M</M>.

<P/>

The subgroup lattice of the subgroup
<M>\langle a, b, c \rangle = \langle a, b \rangle \cong 4^2</M> of <M>M</M>
looks as follows.
(The subgroup in the centre of the picture is the Klein four group
<M>\langle a^2, b^2, c^2 \rangle = \langle a^2, b^2 \rangle</M>.)

<P/>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons19.png" alt="Schur cover of L3(4)"/>
</center>
]]></Alt>

<Alt Only='Text'>
<Verb>
                  K
                 ╱│╲
                ╱ │ ╲
         ┌──── .  .  .─────┐
         │    ╱ ╲╱│╲╱ ╲    │
         │   ╱  ╱╲│╱╲  ╲   │
         .  .  .  .  .  .  .
         │   ╲  ╲╱│╲╱  ╱   │
         │    ╲ ╱╲│╱╲ ╱    │
         └──── .  .  .─────┘
                ╲ │ ╱
                 ╲│╱
                  1
</Verb>
</Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons19 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(70,45)(-35,-20)
\put(  0, 20){\circle*{1}}\put( 0,23){\makebox(0,0){$\langle a, b, c \rangle$}}
\put(-10, 10){\circle*{1}}\put(-15,11.5){\makebox(0,0){$\langle a, b^2 \rangle$}}
\put(  0, 10){\circle*{1}}\put( -4,11.5){\makebox(0,0){$\langle b, c^2 \rangle$}}
\put( 10, 10){\circle*{1}}\put( 15,11.5){\makebox(0,0){$\langle c, a^2 \rangle$}}
\put(  0,  0){\circle*{1}}
\put(-30,  0){\circle*{1}}\put(-33, 0){\makebox(0,0){$\langle a \rangle$}}
\put(-20,  0){\circle*{1}}\put(-24, 0){\makebox(0,0){$\langle a b^2 \rangle$}}
\put(-10,  0){\circle*{1}}\put(-13, 0){\makebox(0,0){$\langle b \rangle$}}
\put( 10,  0){\circle*{1}}\put( 14, 0){\makebox(0,0){$\langle b c^2 \rangle$}}
\put( 20,  0){\circle*{1}}\put( 23, 0){\makebox(0,0){$\langle c \rangle$}}
\put( 30,  0){\circle*{1}}\put( 34, 0){\makebox(0,0){$\langle c a^2 \rangle$}}
\put(-10,-10){\circle*{1}}\put(-13,-12){\makebox(0,0){$\langle a^2 \rangle$}}
\put(  0,-10){\circle*{1}}\put( -3,-12){\makebox(0,0){$\langle b^2 \rangle$}}
\put( 10,-10){\circle*{1}}\put( 13,-12){\makebox(0,0){$\langle c^2 \rangle$}}
\put(  0,-20){\circle*{1}}
\put(-30,0){\line(2, 1){20}}
\put(-30,0){\line(2,-1){20}}
\put(-20,0){\line(1, 1){10}}
\put(-20,0){\line(1,-1){10}}
\put(-10,0){\line(1, 1){10}}
\put(-10,0){\line(1,-1){10}}
\put(-10,10){\line(1, 1){10}}
\put(-10,-10){\line(1,-1){10}}
\put(  0,-20){\line(0,1){40}}
\put(-10, 10){\line(1,-1){20}}
\put(-10,-10){\line(1,1){20}}
\put(30,0){\line(-2, 1){20}}
\put(30,0){\line(-2,-1){20}}
\put(20,0){\line(-1, 1){10}}
\put(20,0){\line(-1,-1){10}}
\put(10,0){\line(-1, 1){10}}
\put(10,0){\line(-1,-1){10}}
\put(10,10){\line(-1, 1){10}}
\put(10,-10){\line(-1,-1){10}}
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

(The symmetry w.r.t.&nbsp;<M>\alpha</M> would be reflected better
in a three dimensional model,
with <M>\langle a, b \rangle</M>, <M>\langle a^2, b^2 \rangle</M>, and the
trivial subgroup on a vertical symmetry axis,
and with the remaining subgroups on three circles such that <M>\alpha</M>
induces a rotation.)

<P/>

<Alt Not='Text'>
The following is a 3D variant of the picture,
which shows the symmetry of order three of the group <M>4 \times 4</M>.
</Alt>

<Alt Only='HTML'><![CDATA[
<center>
<img src="ctblcons20.png" alt="Schur cover of L3(4), emphasizing a symmetry of order three "/>
</center>
]]></Alt>

<Alt Only='LaTeX'>
<!-- BP ctblcons20 -->
<![CDATA[
\begin{center}
\setlength{\unitlength}{3pt}
\begin{picture}(60,50)(-30,-25)
\put(  0, 25){\circle*{2}}
\put( 14, 10){\circle*{2}}
\put(  1, 17){\circle*{2}}
\put(-15, 11){\circle*{2}}
\put(  0,  0){\circle*{2}}
\put( 12, -7){\circle*{2}}
\put( 29, -1){\circle*{2}}
\put(-12,  7){\circle*{2}}
\put( 17,  6){\circle*{2}}
\put(-29,  1){\circle*{2}}
\put(-17, -6){\circle*{2}}
\put( 14,-15){\circle*{2}}
\put(  1, -8){\circle*{2}}
\put(-15,-14){\circle*{2}}
\put(  0,-25){\circle*{2}}
\drawline(0,25)( 14,10)
\drawline(0,25)(  1,17)
\drawline(0,25)(-15,11)
\drawline( 14,10)(0,0)
\drawline( 14,10)(29,-1)
\drawline( 14,10)(12,-7)
\drawline( 1,17)(0,0)
\drawline( 1,17)(16,6)
\drawline( 1,17)(-12,7)
\drawline(-15,11)(0,0)
\drawline(-15,11)(-29,1)
\drawline(-15,11)(-17,-6)
\drawline( 14,-15)(0,0)
\drawline( 14,-15)(29,-1)
\drawline( 14,-15)(12,-7)
\drawline(  1, -8)(0,0)
\drawline(  1, -8)(16,6)
\drawline(  1, -8)(-12,7)
\drawline(-15,-14)(0,0)
\drawline(-15,-14)(-29,1)
\drawline(-15,-14)(-17,-6)
\drawline( 14,-15)(0,-25)
\drawline(  1, -8)(0,-25)
\drawline(-15,-14)(0,-25)
\end{picture}
\end{center}
]]>
<!-- EP -->
</Alt>

<P/>

We have
<M>(M / \langle a \rangle).G \cong (M / \langle b \rangle).G
                           \cong (M / \langle c \rangle).G \cong 12_2.G</M>
and
<M>(M / \langle a b^2 \rangle).G \cong (M / \langle b c^2 \rangle).G
                               \cong (M / \langle c a^2 \rangle).G
                               \cong 12_1.G</M>.
This is because the action of <M>G.2_2</M> fixes <M>a</M>,
and swaps <M>b</M> and <M>c</M>;
so <M>b</M> is inverted modulo <M>\langle a \rangle</M> but fixed modulo
<M>\langle a b^2 \rangle</M>,
and the normal subgroup of order four in <M>4_2.G.2_2</M> is central
but that in <M>4_1.G.2_2</M> is not central.

<P/>

The constructions of the character tables of <M>4^2.G</M>
and <M>(4^2 \times 3).G</M> are essentially the same.
We start with the table of <M>4^2.G</M>.
It can be regarded as a central extension <M>H = V.2^2.G</M> of
<M>2^2.G</M> by a Klein four group <M>V</M>.
The three subgroups of order two in <M>V</M> are cyclicly permuted
by the automorphism of <M>M / \langle d \rangle</M> induced by <M>\alpha</M>,
so the three factors by these subgroups are isomorphic groups <M>F</M>, say,
with the structure <M>(2 \times 4).G</M>.

<P/>

The group <M>F</M> itself is a central extension of <M>2.G</M>
by a Klein four group,
but in this case the three factor groups by the order two subgroups of the
Klein four group are nonisomorphic groups, of the types
<M>4_1.G</M>, <M>4_2.G</M>, and <M>2^2.G</M>, respectively.
The &GAP; function
<Ref Func="PossibleCharacterTablesOfTypeV4G" BookName="ctbllib"/>
can be used
to construct the character table of <M>F</M> from the three factors.
Note that in this case, no information about table automorphisms is
required.

<P/>

<Example><![CDATA[
gap> tblG:= CharacterTable( "2.L3(4)" );;
gap> tbls2G:= List( [ "4_1.L3(4)", "4_2.L3(4)", "2^2.L3(4)"],
>                   CharacterTable );;
gap> poss:= PossibleCharacterTablesOfTypeV4G( tblG, tbls2G, "(2x4).L3(4)" );;
gap> Length( poss );
2
gap> reps:= RepresentativesCharacterTables( poss );
[ CharacterTable( "(2x4).L3(4)" ) ]
gap> lib:= CharacterTable( "(2x4).L3(4)" );;
gap> IsRecord( TransformingPermutationsCharacterTables( reps[1], lib ) );
true
]]></Example>

<P/>

In the second step, we construct the table of <M>4^2.G</M> from that of
<M>(2 \times 4).G</M> and the table automorphism of <M>2^2.G</M>
that is induced by <M>\alpha</M>;
it turns out that the group of table automorphisms of <M>2^2.G</M> contains
a unique subgroup of order three.

<P/>

<Example><![CDATA[
gap> tblG:= tbls2G[3];
CharacterTable( "2^2.L3(4)" )
gap> tbl2G:= lib;       
CharacterTable( "(2x4).L3(4)" )
gap> aut:= AutomorphismsOfTable( tblG );;
gap> ord3:= Set( Filtered( aut, x -> Order( x ) = 3 ),
>                SmallestGeneratorPerm );
[ (2,3,4)(6,7,8)(10,11,12)(13,15,17)(14,16,18)(20,21,22)(24,25,26)(28,
    29,30)(32,33,34) ]
gap> pi:= ord3[1];;
gap> poss:= PossibleCharacterTablesOfTypeV4G( tblG, tbl2G, pi, "4^2.L3(4)" );;
gap> Length( poss );
4
gap> reps:= RepresentativesCharacterTables( poss );        
[ CharacterTable( "4^2.L3(4)" ) ]
gap> lib:= CharacterTable( "4^2.L3(4)" );;
gap> IsRecord( TransformingPermutationsCharacterTables( reps[1], lib ) );
true
]]></Example>

<P/>

With the same approach,
we compute the table of <M>(2 \times 12).G = 2^2.6.G</M>
from the tables of the three nonisomorphic factor groups <M>12_1.G</M>,
<M>12_2.G</M>, and <M>(2^2 \times 3).G</M>,
and we compute the table of <M>(4^2 \times 3).G = 2^2.(2^2 \times 3).G</M>
from the three tables of the factor groups <M>(2 \times 12).G</M>
and the action induced by <M>\alpha</M>.

<P/>

<Example><![CDATA[
gap> tblG:= CharacterTable( "6.L3(4)" );;
gap> tbls2G:= List( [ "12_1.L3(4)", "12_2.L3(4)", "(2^2x3).L3(4)"],            
>                   CharacterTable );;
gap> poss:= PossibleCharacterTablesOfTypeV4G( tblG, tbls2G, "(2x12).L3(4)" );;
gap> Length( poss );
2
gap> reps:= RepresentativesCharacterTables( poss );
[ CharacterTable( "(2x12).L3(4)" ) ]
gap> lib:= CharacterTable( "(2x12).L3(4)" );;
gap> IsRecord( TransformingPermutationsCharacterTables( reps[1], lib ) );
true
gap> tblG:= CharacterTable( "(2^2x3).L3(4)" ); 
CharacterTable( "(2^2x3).L3(4)" )
gap> tbl2G:= CharacterTable( "(2x12).L3(4)" );
CharacterTable( "(2x12).L3(4)" )
gap> aut:= AutomorphismsOfTable( tblG );;
gap> ord3:= Set( Filtered( aut, x -> Order( x ) = 3 ),
>                SmallestGeneratorPerm );
[ (2,7,8)(3,4,10)(6,11,12)(14,19,20)(15,16,22)(18,23,24)(26,27,28)(29,
    35,41)(30,37,43)(31,39,45)(32,36,42)(33,38,44)(34,40,46)(48,53,
    54)(49,50,56)(52,57,58)(60,65,66)(61,62,68)(64,69,70)(72,77,
    78)(73,74,80)(76,81,82)(84,89,90)(85,86,92)(88,93,94) ]
gap> pi:= ord3[1];;
gap> poss:= PossibleCharacterTablesOfTypeV4G( tblG, tbl2G, pi,
>                                             "(4^2x3).L3(4)" );;
gap> Length( poss );
4
gap> reps:= RepresentativesCharacterTables( poss );
[ CharacterTable( "(4^2x3).L3(4)" ) ]
gap> lib:= CharacterTable( "(4^2x3).L3(4)" );;
gap> IsRecord( TransformingPermutationsCharacterTables( reps[1], lib ) );
true
]]></Example>

</Subsection>
</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:xplpsing">
<Heading>Examples of Extensions by <M>p</M>-singular Automorphisms</Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Some p-Modular Tables of Groups of the Type M.G.A">
<Heading>Some <M>p</M>-Modular Tables of Groups of the Type <M>M.G.A</M></Heading>

We show an alternative construction of <M>p</M>-modular tables
of certain groups that have been met in
Section&nbsp;<Ref Subsect="subsect:ATLASMGA"/>.
Each entry in the &GAP; list <C>listMGA</C> contains the
<Ref Func="Identifier" BookName="ref"/>
values of character tables of groups of the types
<M>M.G</M>, <M>G</M>, <M>G.A</M>, and <M>M.G.A</M>.
For each entry with <M>|A| = p</M>, a prime integer,
we fetch the <M>p</M>-modular table of <M>G</M>
and the ordinary table of <M>G.A</M>, compute the action of <M>G.A</M>
on the <M>p</M>-regular classes of <M>G</M>,
and then compute the <M>p</M>-modular table of <M>G.A</M>.
Analogously, we compute the <M>p</M>-modular table of <M>M.G.A</M> from
the <M>p</M>-modular
table of <M>M.G</M> and the ordinary table of <M>M.G.A</M>.

<P/>

<Example><![CDATA[
gap> for input in listMGA do
>      ordtblMG  := CharacterTable( input[1] );
>      ordtblG   := CharacterTable( input[2] );
>      ordtblGA  := CharacterTable( input[3] );
>      ordtblMGA := CharacterTable( input[4] );
>      p:= Size( ordtblGA ) / Size( ordtblG );
>      if IsPrimeInt( p ) then
>        modtblG:= ordtblG mod p;
>        if modtblG <> fail then
>          modtblGA := CharacterTableRegular( ordtblGA, p );
>          SetIrr( modtblGA, IBrOfExtensionBySingularAutomorphism( modtblG,
>                                ordtblGA ) );
>          modlibtblGA:= ordtblGA mod p;
>          if modlibtblGA = fail then
>            Print( "#E  ", p, "-modular table of '", Identifier( ordtblGA ),
>                   "' is missing\n" );
>          elif TransformingPermutationsCharacterTables( modtblGA,
>                   modlibtblGA ) = fail then
>            Print( "#E  computed table and library table for ", input[3],
>                   " mod ", p, " differ\n" );
>          fi;
>        fi;
>        modtblMG:= ordtblMG mod p;
>        if modtblMG <> fail then
>          modtblMGA := CharacterTableRegular( ordtblMGA, p );
>          SetIrr( modtblMGA, IBrOfExtensionBySingularAutomorphism( modtblMG,
>                                 ordtblMGA ) );
>          modlibtblMGA:= ordtblMGA mod p;
>          if modlibtblMGA = fail then
>            Print( "#E  ", p, "-modular table of '", Identifier( ordtblMGA ),
>                   "' is missing\n" );
>          elif TransformingPermutationsCharacterTables( modtblMGA,
>                   modlibtblMGA ) = fail then
>            Print( "#E  computed table and library table for ", input[4],
>                   " mod ", p, " differ\n" );
>          fi;
>        fi;
>      fi;
>    od;
]]></Example>

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Some p-Modular Tables of Groups of the Type G.S_3">
<Heading>Some <M>p</M>-Modular Tables of Groups of the Type <M>G.S_3</M></Heading>

We show an alternative construction of <M>2</M>- and <M>3</M>-modular tables
of certain groups that have been met in Section&nbsp;<Ref Subsect="subsect:xplGS3"/>.
Each entry in the &GAP; list <C>listGS3</C> contains the
<Ref Func="Identifier" BookName="ref"/>
values of
character tables of groups of the types <M>G</M>, <M>G.2</M>, <M>G.3</M>, and <M>G.S_3</M>.
For each entry, we fetch the <M>2</M>-modular table of <M>G</M> and the ordinary table
of <M>G.2</M>, compute the action of <M>G.2</M> on the <M>2</M>-regular classes of <M>G</M>,
and then compute the <M>2</M>-modular table of <M>G.2</M>.
Analogously, we compute the <M>3</M>-modular table of <M>G.3</M> from the <M>3</M>-modular
table of <M>G</M> and the ordinary table of <M>G.3</M>,
and we compute the <M>2</M>-modular table of <M>G.S_3</M> from the <M>2</M>-modular table
of <M>G.3</M> and the ordinary table of <M>G.S_3</M>.

<P/>

<Example><![CDATA[
gap> for input in listGS3 do
>      modtblG:= CharacterTable( input[1] ) mod 2;
>      if modtblG <> fail then
>        ordtblG2 := CharacterTable( input[2] );
>        modtblG2 := CharacterTableRegular( ordtblG2, 2 );
>        SetIrr( modtblG2, IBrOfExtensionBySingularAutomorphism( modtblG,
>                              ordtblG2 ) );
>        modlibtblG2:= ordtblG2 mod 2;
>        if modlibtblG2 = fail then
>          Print( "#E  2-modular table of '", Identifier( ordtblG2 ),
>                 "' is missing\n" );
>        elif TransformingPermutationsCharacterTables( modtblG2,
>                 modlibtblG2 ) = fail then
>          Print( "#E  computed table and library table for ", input[2],
>                 " mod 2 differ\n" );
>        fi;
>      fi;
>      modtblG:= CharacterTable( input[1] ) mod 3;
>      if modtblG <> fail then
>        ordtblG3 := CharacterTable( input[3] );
>        modtblG3 := CharacterTableRegular( ordtblG3, 3 );
>        SetIrr( modtblG3, IBrOfExtensionBySingularAutomorphism( modtblG,
>                              ordtblG3 ) );
>        modlibtblG3:= ordtblG3 mod 3;
>        if modlibtblG3 = fail then
>          Print( "#E  3-modular table of '", Identifier( ordtblG3 ),
>                 "' is missing\n" );
>        elif TransformingPermutationsCharacterTables( modtblG3,
>                 modlibtblG3 ) = fail then
>          Print( "#E  computed table and library table for ", input[3],
>                 " mod 3 differ\n" );
>        fi;
>      fi;
>      modtblG3:= CharacterTable( input[3] ) mod 2;
>      if modtblG3 <> fail then
>        ordtblGS3 := CharacterTable( input[4] );
>        modtblGS3 := CharacterTableRegular( ordtblGS3, 2 );
>        SetIrr( modtblGS3, IBrOfExtensionBySingularAutomorphism( modtblG3,
>                               ordtblGS3 ) );
>        modlibtblGS3:= ordtblGS3 mod 2;
>        if modlibtblGS3 = fail then
>          Print( "#E  2-modular table of '", Identifier( ordtblGS3 ),
>                 "' is missing\n" );
>        elif TransformingPermutationsCharacterTables( modtblGS3,
>                 modlibtblGS3 ) = fail then
>          Print( "#E  computed table and library table for ", input[4],
>                 " mod 2 differ\n" );
>        fi;
>      fi;
>    od;
]]></Example>

<!-- %T (Note that the <M>2</M>-modular tables of <M>2^2.O_8^+(2).3.2</M>, -->
<!-- % <M>2^2.U_6(2).3.2</M>, and <M>2^2.{}^2E_6(2).3.2</M> are available automatically -->
<!-- % as soon as the factor fusions onto the tables of the factor groups -->
<!-- % modulo the normal Klein four group are stored.) -->

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:2-Modular Tables of Groups of the Type G.2^2">
<Heading><M>2</M>-Modular Tables of Groups of the Type <M>G.2^2</M></Heading>

We show an alternative construction of <M>2</M>-modular tables
of certain groups that have been met in Section&nbsp;<Ref Subsect="subsect:xplGV43.A6.V4"/>.
Each entry in the &GAP; list <C>listGV4</C> contains the
<Ref Func="Identifier" BookName="ref"/>
values of
character tables of groups of the types <M>G</M>, <M>G.2_1</M>, <M>G.2_2</M>, <M>G.2_3</M>,
and <M>G.2^2</M>.
For each entry, we fetch the <M>2</M>-modular table of <M>G</M> and the ordinary tables
of the groups <M>G.2_i</M>, and compute the <M>2</M>-modular tables of <M>G.2_i</M>;
Then we compute from this modular table and the ordinary table of <M>G.2^2</M>
the <M>2</M>-modular table of <M>G.2^2</M>.

<P/>

<Example><![CDATA[
gap> for input in listGV4 do
>      modtblG:= CharacterTable( input[1] ) mod 2;
>      if modtblG <> fail then
>        ordtblsG2:= List( input{ [ 2 .. 4 ] }, CharacterTable );
>        ordtblGV4:= CharacterTable( input[5] );
>        for tblG2 in ordtblsG2 do
>          modtblG2:= CharacterTableRegular( tblG2, 2 );
>          SetIrr( modtblG2, IBrOfExtensionBySingularAutomorphism( modtblG,
>                                tblG2 ) );
>          modlibtblG2:= tblG2 mod 2;
>          if modlibtblG2 = fail then
>            Print( "#E  2-modular table of '", Identifier( tblG2 ),
>                   "' is missing\n" );
>          elif TransformingPermutationsCharacterTables( modtblG2,
>                   modlibtblG2 ) = fail then
>            Print( "#E  computed table and library table for ",
>                   Identifier( tblG2 ), " mod 2 differ\n" );
>          fi;
>          modtblGV4:= CharacterTableRegular( ordtblGV4, 2 );
>          SetIrr( modtblGV4, IBrOfExtensionBySingularAutomorphism( modtblG2,
>                                ordtblGV4 ) );
>          modlibtblGV4:= ordtblGV4 mod 2;
>          if modlibtblGV4 = fail then
>            Print( "#E  2-modular table of '", Identifier( ordtblGV4 ),
>                   "' is missing\n" );
>          elif TransformingPermutationsCharacterTables( modtblGV4,
>                 ordtblGV4 mod 2 ) = fail then
>            Print( "#E  computed table and library table for ", input[5],
>                   " mod 2 differ\n" );
>          fi;
>        od;
>      fi;
>    od;
]]></Example>


</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:The 3-Modular Table of U38.32">
<Heading>The <M>3</M>-Modular Table of <M>U_3(8).3^2</M></Heading>

The only example of an &ATLAS; group of the structure <M>G.3^3</M>
is <M>U_3(8).3^2</M>.
Its <M>3</M>-modular character table can be constructed from the known
<M>3</M>-modular character table of any of its index <M>3</M> subgroups,
plus the action of <M>U_3(8).3^2</M> on the classes of this subgroup.

<P/>

<Example><![CDATA[
gap> ordtblG3:= CharacterTable( "U3(8).3^2" );;
gap> modlibtblG3:= ordtblG3 mod 3;
BrauerTable( "U3(8).3^2", 3 )
gap> for nam in [ "U3(8).3_1", "U3(8).3_2", "U3(8).3_3" ] do
>      modtblG:= CharacterTable( nam ) mod 3;
>      if modtblG = fail then
>        Error( "no 3-modular table of ", nam );
>      fi;
>      modtblG3:= CharacterTableRegular( ordtblG3, 3 );
>      SetIrr( modtblG3, IBrOfExtensionBySingularAutomorphism( modtblG,
>                            ordtblG3 ) );
>      if TransformingPermutationsCharacterTables( modtblG3,
>             modlibtblG3 ) = fail then
>        Print( "#E  computed table and library table for ",
>               Identifier( ordtblG3 ), " mod 3 differ\n" );
>      fi;
>    od;
]]></Example>

<P/>

As expected, we get the same <M>3</M>-modular table for any choice of
the index <M>3</M> subgroup.

<P/>

Note that all <M>3</M>-modular Brauer characters of <M>U_3(8).3^2</M>
lift to characteristic zero.

<P/>

<Example><![CDATA[
gap> rest:= RestrictedClassFunctions( Irr( ordtblG3 ), modlibtblG3 );;
gap> IsSubset( rest, Irr( modlibtblG3 ) );
true
]]></Example>

</Subsection>
</Section>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Gsubdir">
<Heading>Examples of Subdirect Products of Index Two</Heading>

Typical examples of this construction are those maximal subgroups of
alternating groups <M>A_n</M> that extend in the corresponding symmetric groups
<M>S_n</M> to direct products of the structures <M>S_m \times S_{n-m}</M>,
for <M>2 &lt; m &lt; n/2</M>.
Also certain subgroups of these maximal subgroups that have this structure
can be interesting, see Section&nbsp;<Ref Subsect="subsect:A12N7"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:dihedralsubdir">
<Heading>Certain Dihedral Groups as Subdirect Products of Index Two</Heading>

Also dihedral groups of order <M>2 n</M> with <M>n</M> divisible by at least two
different primes have the required structure:
Let <M>n = n_1 n_2</M> with coprime <M>n_1</M>, <M>n_2</M>,
and let the normal subgroups <M>H_1</M>, <M>H_2</M> be cyclic subgroups of order <M>n_1</M>
and <M>n_2</M>, respectively, inside the cyclic subgroup of index two.
Then the factors <M>G/N_1</M>, <M>G/N_2</M> are themselves dihedral groups.

<P/>

So an example (with <M>n_1 = 3</M> and <M>n_2 = 5</M>) is the construction of
the dihedral group <M>D_{30}</M> as a subdirect product of index two
in the direct product <M>D_6 \times D_{10}</M>.

<P/>

<Example><![CDATA[
gap> tblh1:= CharacterTable( "C3" );;
gap> tblg1:= CharacterTable( "S3" );;
gap> StoreFusion( tblh1, PossibleClassFusions( tblh1, tblg1 )[1], tblg1 );
gap> tblh2:= CharacterTable( "C5" );;
gap> tblg2:= CharacterTable( "D10" );;
gap> StoreFusion( tblh2, PossibleClassFusions( tblh2, tblg2 )[1], tblg2 );
gap> subdir:= CharacterTableOfIndexTwoSubdirectProduct( tblh1, tblg1,
>                 tblh2, tblg2, "D30" );;
gap> IsRecord( TransformingPermutationsCharacterTables( subdir.table,
>                  CharacterTable( "Dihedral", 30 ) ) );
true
]]></Example>

</Subsection>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:The Character Table of (D10xHN).2">
<Heading>The Character Table of <M>(D_{10} \times HN).2 &lt; M</M> (June 2008)</Heading>

<!-- % somebody from Argentina had asked for this table -->

The sporadic simple Monster group contains maximal subgroups with the
structure <M>(D_{10} \times HN).2</M> (see&nbsp;<Cite Key="CCN85" Where="p. 234"/>),
the factor group modulo <M>D_{10}</M> is the automorphism group <M>HN.2</M> of <M>HN</M>,
and the factor group modulo <M>HN</M> is the Frobenius group <M>5:4</M> of order <M>20</M>.

<P/>

<Example><![CDATA[
gap> tblh1:= CharacterTable( "D10" );;
gap> tblg1:= CharacterTable( "5:4" );;
gap> tblh2:= CharacterTable( "HN" );;
gap> tblg2:= CharacterTable( "HN.2" );;
gap> subdir:= CharacterTableOfIndexTwoSubdirectProduct( tblh1, tblg1,
>                 tblh2, tblg2, "(D10xHN).2" );;
gap> IsRecord( TransformingPermutationsCharacterTables( subdir.table,
>                  CharacterTable( "(D10xHN).2" ) ) );
true
gap> m:= CharacterTable( "M" );;
gap> fus:= PossibleClassFusions( subdir.table, m );;
gap> Length( fus );
16
gap> Length( RepresentativesFusions( subdir.table, fus, m ) );
1
]]></Example>

<P/>

An alternative construction is the one described in Section&nbsp;<Ref Subsect="subsect:theorMGA"/>,
as <M>(D_{10} \times HN).2 = M.G.A</M> with <M>G = 2 \times HN</M>,
<M>M.G = D_{10} \times HN</M>, and <M>G.A</M> the subdirect product of <M>HN.2</M> and
a cyclic group of order four
(which can be constructed as the isoclinic variant of <M>2 \times HN.2</M>,
see Section&nbsp;<Ref Subsect="subsect:isoclinism"/>).

<P/>

Here is this construction:

<P/>

<Example><![CDATA[
gap> c2:= CharacterTable( "C2" );;
gap> hn:= CharacterTable( "HN" );;
gap> g:= c2 * hn;;
gap> d10:= CharacterTable( "D10" );;
gap> mg:= d10 * hn;;
gap> nsg:= ClassPositionsOfNormalSubgroups( mg );
[ [ 1 ], [ 1, 55 .. 109 ], [ 1, 55 .. 163 ], [ 1 .. 54 ], 
  [ 1 .. 162 ], [ 1 .. 216 ] ]
gap> SizesConjugacyClasses( mg ){ nsg[2] };
[ 1, 2, 2 ]
gap> g:= mg / nsg[2];
CharacterTable( "D10xHN/[ 1, 55, 109 ]" )
gap> help:= c2 * CharacterTable( "HN.2" );
CharacterTable( "C2xHN.2" )
gap> ga:= CharacterTableIsoclinic( help ); 
CharacterTable( "Isoclinic(C2xHN.2)" )
gap> gfusga:= PossibleClassFusions( g, ga ); 
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 15, 16, 17, 
      18, 19, 20, 21, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 
      32, 32, 33, 33, 34, 35, 36, 37, 37, 38, 39, 40, 40, 41, 42, 42, 
      43, 43, 44, 44, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 89, 
      90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 101, 102, 
      103, 103, 104, 105, 106, 107, 108, 109, 110, 110, 111, 111, 
      112, 113, 114, 115, 115, 116, 117, 118, 118, 119, 120, 120, 
      121, 121, 122, 122 ], 
  [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 15, 16, 17, 
      18, 19, 20, 21, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 
      32, 32, 33, 33, 35, 34, 36, 37, 37, 38, 39, 40, 40, 41, 42, 42, 
      43, 43, 44, 44, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 89, 
      90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 101, 102, 
      103, 103, 104, 105, 106, 107, 108, 109, 110, 110, 111, 111, 
      113, 112, 114, 115, 115, 116, 117, 118, 118, 119, 120, 120, 
      121, 121, 122, 122 ] ]
gap> StoreFusion( g, gfusga[1], ga );
gap> acts:= PossibleActionsForTypeMGA( mg, g, ga );;
gap> Length( acts );
1
gap> poss:= PossibleCharacterTablesOfTypeMGA( mg, g, ga, acts[1],       
>               "(D10xHN).2" );;
gap> Length( poss );
1
gap> IsRecord( TransformingPermutationsCharacterTables( poss[1].table,
>                  CharacterTable( "(D10xHN).2" ) ) );
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Counterexample">
<Heading>A Counterexample (August 2015)</Heading>

A group <M>G</M> is called <E>real</E> if each of its elements is conjugate
in <M>G</M> to its inverse.
Equivalently,
a group is real if and only if all its character values are real.
One might ask whether the Sylow <M>2</M>-subgroup of a real group
is itself real.
Counterexamples can be found by a search through &GAP;'s library of
small groups.
Using the facts we have collected about index two subdirect products in
Section <Ref Subsect="subsect:theorsubdir"/>,
we can demonstrate such a counterexample without using &GAP;.

<P/>

Let <M>H_1 = A_4</M>, <M>G_1 = S_4</M>, <M>H_2 = C_4</M>,
and <M>G_2</M> a nonabelian group of order <M>8</M>,
and consider the unique index two subgroup <M>G</M> of <M>G_1 \times G_2</M>
that is different from <M>H_1 \times G_2</M> and <M>G_1 \times H_2</M>.

<P/>

Each irreducible character of <M>G</M> either extends to <M>G_1 \times G_2</M>
or it is induced from an irreducible character of <M>H_1 \times H_2</M>.
In the former case, the character is integer valued.
Irrational values in the latter case arise as follows.

<P/>

Let <M>\chi</M> be an irreducible character of <M>H_1 \times H_2</M>;
then it is the product of irreducible characters
<M>\chi_1</M> and <M>\chi_2</M> of <M>H_1</M> and <M>H_2</M>,
respectively.
If <M>\chi</M> has irrational values then <M>\chi_1</M> takes
primitive third roots of unity <M>\omega, \omega^2</M>
on elements of order three in <M>H_1</M>,
or <M>\chi_2</M> takes
primitive fourth roots of unity <M>\pm i</M>
on elements of order four in <M>H_2</M>,
or both.
In the first two cases, inducing <M>\chi</M> to <M>G</M> yields
an integer valued character, because each pair of Galois conjugate classes
fuses in <M>G</M> on which <M>\chi</M> takes irrational values.
In the last case, <M>\chi</M> takes primitive <M>12</M>-th roots of unity
<M>\pm i \omega</M> and <M>\pm i \omega^2</M> on elements of order <M>12</M>;
since <M>G</M> fuses the classes with the character values
<M>i \omega</M> and <M>-i \omega^2</M>, we get the character value
<M>i \omega -i \omega^2 = -\sqrt{{3}}</M> in the induced character
<M>\chi^G</M>.
This means that this character is real valued.
Hence <M>G</M> is real.

<P/>

Now we consider a Sylow <M>2</M>-subgroup of <M>G</M>.
It has also the structure of a subdirect product, as follows.
Let <M>H_1 = V_4</M>, <M>G_1 = D_8</M>, and <M>H_2</M> and <M>G_2</M>
as above,
and consider the unique index two subgroup <M>G</M> of <M>G_1 \times G_2</M>
that is different from <M>H_1 \times G_2</M> and <M>G_1 \times H_2</M>.

<P/>

As above,
irrational values in an irreducible character of <M>G</M> arise only if
this character is induced from a character <M>\chi</M>, say,
that is the product of irreducible characters
<M>\chi_1</M> and <M>\chi_2</M> of <M>H_1</M> and <M>H_2</M>,
respectively.
In this case, <M>\chi_2</M> takes primitive fourth roots of unity <M>\pm i</M>
on elements of order four in <M>H_2</M>.
Moreover, <M>\chi_1</M> takes different values <M>\pm 1</M> on the
two classes of <M>H_1</M> that are fused in <M>G</M> if the induced character
has irrational values, and these values are <M>\pm 2i</M>.
Hence the group <M>G</M> is <E>not</E> real.

<P/>

(In fact the above two groups of order <M>96</M> are the smallest real
groups with non-real Sylow <M>2</M>-subgroup,
and there are no other such groups of this order.)

</Subsection>
</Section>
</Chapter>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

