<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (CTblLibXpls) - Chapter 11: GAP Computations Concerning Probabilistic Generation of Finite
Simple Groups</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap11"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap10.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap11_mj.html">[MathJax on]</a></p>
<p><a id="X7BE9906583D0FCEC" name="X7BE9906583D0FCEC"></a></p>
<div class="ChapSects"><a href="chap11.html#X7BE9906583D0FCEC">11 <span class="Heading"><strong class="pkg">GAP</strong> Computations Concerning Probabilistic Generation of Finite
Simple Groups</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11.html#X8389AD927B74BA4A">11.1 <span class="Heading">Overview</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11.html#X7B4649CF7B7CFAA1">11.2 <span class="Heading">Prerequisites</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7B6AEBDF7B857E2E">11.2-1 <span class="Heading">Theoretical Background</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X79D7312484E78274">11.2-2 <span class="Heading">Computational Criteria</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11.html#X7B56BE5384BAD54E">11.3 <span class="Heading"><strong class="pkg">GAP</strong> Functions for the Computations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X806328747D1D4ECC">11.3-1 <span class="Heading">General Utilities</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7A221012861440E2">11.3-2 <span class="Heading">Character-Theoretic Computations</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X83DACCF07EF62FAE">11.3-3 <span class="Heading">Computations with Groups</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11.html#X7A221012861440E2">11.4 <span class="Heading">Character-Theoretic Computations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X86CE51E180A3D4ED">11.4-1 <span class="Heading">Sporadic Simple Groups</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X84E9D10F80A74A53">11.4-2 <span class="Heading">Automorphism Groups of Sporadic Simple Groups</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X80DA58F187CDCF5F">11.4-3 <span class="Heading">Other Simple Groups – Easy Cases</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7B1E26D586337487">11.4-4 <span class="Heading">Automorphism Groups of other Simple Groups – Easy Cases</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X78B856907ED13545">11.4-5 <span class="Heading"><span class="SimpleMath">O_8^-(3)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X84AB334886DCA746">11.4-6 <span class="Heading"><span class="SimpleMath">O_10^+(2)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X84E3E4837BB93977">11.4-7 <span class="Heading"><span class="SimpleMath">O_10^-(2)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X8307367E7C7C3BCE">11.4-8 <span class="Heading"><span class="SimpleMath">O_12^+(2)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X834FE1B58119A5FF">11.4-9 <span class="Heading"><span class="SimpleMath">O_12^-(2)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7C5980A385C088FA">11.4-10 <span class="Heading"><span class="SimpleMath">S_6(4)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X829EDF7F7C0BCB8E">11.4-11 <span class="Heading"><span class="SimpleMath">∗</span> <span class="SimpleMath">S_6(5)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X85162B297E4B67EB">11.4-12 <span class="Heading"><span class="SimpleMath">S_8(3)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X8495C2BF7B6EFFEF">11.4-13 <span class="Heading"><span class="SimpleMath">U_4(4)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7A3BB5AA83A2BDF3">11.4-14 <span class="Heading"><span class="SimpleMath">U_6(2)</span></span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11.html#X8237B8617D6F6027">11.5 <span class="Heading">Computations using Groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X815320787B601000">11.5-1 <span class="Heading"><span class="SimpleMath">A_2m+1</span>, <span class="SimpleMath">2 ≤ m ≤ 11</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7B5321337B28100B">11.5-2 <span class="Heading"><span class="SimpleMath">A_5</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X82C3B4287B0C7BEE">11.5-3 <span class="Heading"><span class="SimpleMath">A_6</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X85B3C7217B105D4D">11.5-4 <span class="Heading"><span class="SimpleMath">A_7</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X84EA645A82E2BAFB">11.5-5 <span class="Heading"><span class="SimpleMath">L_d(q)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X855460BE787188B9">11.5-6 <span class="Heading"><span class="SimpleMath">∗</span> <span class="SimpleMath">L_d(q)</span> with prime <span class="SimpleMath">d</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7EA88CEF81962F3F">11.5-7 <span class="Heading">Automorphic Extensions of <span class="SimpleMath">L_d(q)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7C8806DB8588BB51">11.5-8 <span class="Heading"><span class="SimpleMath">L_3(2)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7B7061917ED3714D">11.5-9 <span class="Heading"><span class="SimpleMath">M_11</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X82E0F48A7FF82BB3">11.5-10 <span class="Heading"><span class="SimpleMath">M_12</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7FF2E8F27FBEB65C">11.5-11 <span class="Heading"><span class="SimpleMath">O_7(3)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7F80F2527C424AA4">11.5-12 <span class="Heading"><span class="SimpleMath">O_8^+(2)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X78F0815B86253A1F">11.5-13 <span class="Heading"><span class="SimpleMath">O_8^+(3)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X85BACC4A83F73392">11.5-14 <span class="Heading"><span class="SimpleMath">O^+_8(4)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X86EC26F78609618E">11.5-15 <span class="Heading"><span class="SimpleMath">∗</span> <span class="SimpleMath">O_9(3)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X8393978A8773997E">11.5-16 <span class="Heading"><span class="SimpleMath">O_10^-(3)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7BBBEEEF834F1002">11.5-17 <span class="Heading"><span class="SimpleMath">O_14^-(2)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X8477457780B69BC7">11.5-18 <span class="Heading"><span class="SimpleMath">O_12^+(3)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X854D85F287767342">11.5-19 <span class="Heading"><span class="SimpleMath">∗</span> <span class="SimpleMath">S_4(8)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X82CFBAF07D3487A0">11.5-20 <span class="Heading"><span class="SimpleMath">S_6(2)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X826658207D9D6570">11.5-21 <span class="Heading"><span class="SimpleMath">S_8(2)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X82A6496887F80843">11.5-22 <span class="Heading"><span class="SimpleMath">∗</span> <span class="SimpleMath">S_10(2)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7A03F8EC839AF0B5">11.5-23 <span class="Heading"><span class="SimpleMath">U_4(2)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7D738BE5804CF22E">11.5-24 <span class="Heading"><span class="SimpleMath">U_4(3)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7D4BC6A38074BF68">11.5-25 <span class="Heading"><span class="SimpleMath">U_6(3)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7A92577A830B5F23">11.5-26 <span class="Heading"><span class="SimpleMath">U_8(2)</span></span></a>
</span>
</div></div>
</div>

<h3>11 <span class="Heading"><strong class="pkg">GAP</strong> Computations Concerning Probabilistic Generation of Finite
Simple Groups</span></h3>

<p>Date: March 28th, 2012</p>

<p>This is a collection of examples showing how the <strong class="pkg">GAP</strong> system <a href="chapBib.html#biBGAP">[GAP21]</a> can be used to compute information about the probabilistic generation of finite almost simple groups. It includes all examples that were needed for the computational results in <a href="chapBib.html#biBBGK">[BGK08]</a>.</p>

<p>The purpose of this writeup is twofold. On the one hand, the computations are documented this way. On the other hand, the <strong class="pkg">GAP</strong> code shown for the examples can be used as test input for automatic checking of the data and the functions used.</p>

<p>A first version of this document, which was based on <strong class="pkg">GAP</strong> 4.4.10, had been accessible in the web since April 2006 and is available in the arXiv (no. 0710.3267) since October 2007. The differences between that document and the current version are as follows.</p>


<ul>
<li><p>The format of the <strong class="pkg">GAP</strong> output was adjusted to the changed behaviour of <strong class="pkg">GAP</strong> until version 4.10. This affects mainly the way how <strong class="pkg">GAP</strong> records are printed.</p>

</li>
<li><p>Several computations are now easier because more character tables of almost simple groups and maximal subgroups of such groups are available in the <strong class="pkg">GAP</strong> Character Table Library. (The more involved computations from the original version have been kept in the file.)</p>

</li>
<li><p>The computation of all conjugacy classes of a subgroup of <span class="SimpleMath">PΩ^+(12,3)</span> has been replaced by the computation of the conjugacy classes of elements of prime order in this subgroup.</p>

</li>
<li><p>The irreducible element chosen in the simple group <span class="SimpleMath">PΩ^-(10,3)</span> has order <span class="SimpleMath">61</span> not <span class="SimpleMath">122</span>.</p>

</li>
</ul>
<p><a id="X8389AD927B74BA4A" name="X8389AD927B74BA4A"></a></p>

<h4>11.1 <span class="Heading">Overview</span></h4>

<p>The main purpose of this note is to document the <strong class="pkg">GAP</strong> computations that were carried out in order to obtain the computational results in <a href="chapBib.html#biBBGK">[BGK08]</a>. Table I lists the simple groups among these examples. The first column gives the group names, the second and third columns contain a plus sign <span class="SimpleMath">+</span> or a minus sign <span class="SimpleMath">-</span>, depending on whether the quantities <span class="SimpleMath">σ(G,s)</span> and <span class="SimpleMath">P(G,s)</span>, respectively, are less than <span class="SimpleMath">1/3</span>. The fourth column lists the orders of elements <span class="SimpleMath">s</span> which either prove the <span class="SimpleMath">+</span> signs or cover most of the cases for proving these signs. The fifth column lists the sections in this note where the example is treated. The rows of the table are ordered alphabetically w.r.t. the group names.</p>

<p>In order to keep this note self-contained, we first describe the theory needed, in Section <a href="chap11.html#X7B4649CF7B7CFAA1"><span class="RefLink">11.2</span></a>. The translation of the relevant formulae into <strong class="pkg">GAP</strong> functions can be found in Section <a href="chap11.html#X7B56BE5384BAD54E"><span class="RefLink">11.3</span></a>. Then Section <a href="chap11.html#X7A221012861440E2"><span class="RefLink">11.4</span></a> describes the computations that only require (ordinary) character tables in the <strong class="pkg">GAP</strong> Character Table Library <a href="chapBib.html#biBCTblLib">[Bre22]</a>. Computations using also the groups are shown in Section <a href="chap11.html#X8237B8617D6F6027"><span class="RefLink">11.5</span></a>. In each of the last two sections, the examples are ordered alphabetically w.r.t. the names of the simple groups.</p>

<div class="pcenter"><table class="GAPDocTable">
<caption class="GAPDocTable"><b>Table: </b>Table I: Computations needed in <a href="chapBib.html#biBBGK">[BGK08]</a></caption>
<tr>
<td class="tdleft"><span class="SimpleMath">G</span></td>
<td class="tdcenter"><span class="SimpleMath">σ &lt; frac13</span></td>
<td class="tdcenter"><span class="SimpleMath">P &lt; frac13</span></td>
<td class="tdright"><span class="SimpleMath">|s|</span></td>
<td class="tdright">see</td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">A_5</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdright"><span class="SimpleMath">5</span></td>
<td class="tdright"><a href="chap11.html#X7B5321337B28100B"><span class="RefLink">11.5-2</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">A_6</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdright"><span class="SimpleMath">4</span></td>
<td class="tdright"><a href="chap11.html#X82C3B4287B0C7BEE"><span class="RefLink">11.5-3</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">A_7</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdright"><span class="SimpleMath">7</span></td>
<td class="tdright"><a href="chap11.html#X85B3C7217B105D4D"><span class="RefLink">11.5-4</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">A_8</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">15</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, <a href="chap11.html#X84EA645A82E2BAFB"><span class="RefLink">11.5-5</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">A_9</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">9</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, <a href="chap11.html#X815320787B601000"><span class="RefLink">11.5-1</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">A_11</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">11</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, <a href="chap11.html#X815320787B601000"><span class="RefLink">11.5-1</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">A_13</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">13</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, <a href="chap11.html#X815320787B601000"><span class="RefLink">11.5-1</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">A_15</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">15</span></td>
<td class="tdright"><a href="chap11.html#X815320787B601000"><span class="RefLink">11.5-1</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">A_17</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">17</span></td>
<td class="tdright"><a href="chap11.html#X815320787B601000"><span class="RefLink">11.5-1</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">A_19</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">19</span></td>
<td class="tdright"><a href="chap11.html#X815320787B601000"><span class="RefLink">11.5-1</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">A_21</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">21</span></td>
<td class="tdright"><a href="chap11.html#X815320787B601000"><span class="RefLink">11.5-1</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">A_23</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">23</span></td>
<td class="tdright"><a href="chap11.html#X815320787B601000"><span class="RefLink">11.5-1</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">L_3(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">7</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, <a href="chap11.html#X7B1E26D586337487"><span class="RefLink">11.4-4</span></a>,</td>
</tr>
<tr>
<td class="tdleft"> </td>
<td class="tdcenter"> </td>
<td class="tdcenter"> </td>
<td class="tdright"> </td>
<td class="tdright"><a href="chap11.html#X84EA645A82E2BAFB"><span class="RefLink">11.5-5</span></a>, <a href="chap11.html#X7C8806DB8588BB51"><span class="RefLink">11.5-8</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">L_3(3)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">13</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, <a href="chap11.html#X7B1E26D586337487"><span class="RefLink">11.4-4</span></a>,</td>
</tr>
<tr>
<td class="tdleft"> </td>
<td class="tdcenter"> </td>
<td class="tdcenter"> </td>
<td class="tdright"> </td>
<td class="tdright"><a href="chap11.html#X84EA645A82E2BAFB"><span class="RefLink">11.5-5</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">L_3(4)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">7</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, <a href="chap11.html#X7B1E26D586337487"><span class="RefLink">11.4-4</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">L_4(3)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">20</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, <a href="chap11.html#X84EA645A82E2BAFB"><span class="RefLink">11.5-5</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">L_4(4)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">85</span></td>
<td class="tdright"><a href="chap11.html#X84EA645A82E2BAFB"><span class="RefLink">11.5-5</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">L_6(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">63</span></td>
<td class="tdright"><a href="chap11.html#X84EA645A82E2BAFB"><span class="RefLink">11.5-5</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">L_6(3)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">182</span></td>
<td class="tdright"><a href="chap11.html#X84EA645A82E2BAFB"><span class="RefLink">11.5-5</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">L_6(4)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">455</span></td>
<td class="tdright"><a href="chap11.html#X84EA645A82E2BAFB"><span class="RefLink">11.5-5</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">L_6(5)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">1953</span></td>
<td class="tdright"><a href="chap11.html#X84EA645A82E2BAFB"><span class="RefLink">11.5-5</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">L_8(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">255</span></td>
<td class="tdright"><a href="chap11.html#X84EA645A82E2BAFB"><span class="RefLink">11.5-5</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">L_10(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">1023</span></td>
<td class="tdright"><a href="chap11.html#X84EA645A82E2BAFB"><span class="RefLink">11.5-5</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">M_11</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdright"><span class="SimpleMath">11</span></td>
<td class="tdright"><a href="chap11.html#X7B7061917ED3714D"><span class="RefLink">11.5-9</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">M_12</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdright"><span class="SimpleMath">10</span></td>
<td class="tdright"><a href="chap11.html#X84E9D10F80A74A53"><span class="RefLink">11.4-2</span></a>, <a href="chap11.html#X82E0F48A7FF82BB3"><span class="RefLink">11.5-10</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">O^+_8(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdright"><span class="SimpleMath">15</span></td>
<td class="tdright"><a href="chap11.html#X7F80F2527C424AA4"><span class="RefLink">11.5-12</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">O^+_8(3)</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdright"><span class="SimpleMath">20</span></td>
<td class="tdright"><a href="chap11.html#X78F0815B86253A1F"><span class="RefLink">11.5-13</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">O^+_8(4)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">65</span></td>
<td class="tdright"><a href="chap11.html#X85BACC4A83F73392"><span class="RefLink">11.5-14</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">O^+_10(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">45</span></td>
<td class="tdright"><a href="chap11.html#X84AB334886DCA746"><span class="RefLink">11.4-6</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">O^+_12(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">85</span></td>
<td class="tdright"><a href="chap11.html#X8307367E7C7C3BCE"><span class="RefLink">11.4-8</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">O^+_12(3)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">205</span></td>
<td class="tdright"><a href="chap11.html#X8477457780B69BC7"><span class="RefLink">11.5-18</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">O^-_8(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">17</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">O^-_8(3)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">41</span></td>
<td class="tdright"><a href="chap11.html#X78B856907ED13545"><span class="RefLink">11.4-5</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">O^-_10(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">33</span></td>
<td class="tdright"><a href="chap11.html#X84E3E4837BB93977"><span class="RefLink">11.4-7</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">O^-_10(3)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">122</span></td>
<td class="tdright"><a href="chap11.html#X8393978A8773997E"><span class="RefLink">11.5-16</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">O^-_12(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">65</span></td>
<td class="tdright"><a href="chap11.html#X834FE1B58119A5FF"><span class="RefLink">11.4-9</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">O^-_14(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">129</span></td>
<td class="tdright"><a href="chap11.html#X7BBBEEEF834F1002"><span class="RefLink">11.5-17</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">O_7(3)</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdright"><span class="SimpleMath">14</span></td>
<td class="tdright"><a href="chap11.html#X7FF2E8F27FBEB65C"><span class="RefLink">11.5-11</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">S_4(4)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">17</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, <a href="chap11.html#X7B1E26D586337487"><span class="RefLink">11.4-4</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">S_6(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdright"><span class="SimpleMath">9</span></td>
<td class="tdright"><a href="chap11.html#X82CFBAF07D3487A0"><span class="RefLink">11.5-20</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">S_6(3)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">14</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, <a href="chap11.html#X7B1E26D586337487"><span class="RefLink">11.4-4</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">S_6(4)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">65</span></td>
<td class="tdright"><a href="chap11.html#X7C5980A385C088FA"><span class="RefLink">11.4-10</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">S_8(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdright"><span class="SimpleMath">17</span></td>
<td class="tdright"><a href="chap11.html#X826658207D9D6570"><span class="RefLink">11.5-21</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">S_8(3)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">41</span></td>
<td class="tdright"><a href="chap11.html#X85162B297E4B67EB"><span class="RefLink">11.4-12</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">U_3(3)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">6</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, <a href="chap11.html#X7B1E26D586337487"><span class="RefLink">11.4-4</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">U_3(5)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">10</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, <a href="chap11.html#X7B1E26D586337487"><span class="RefLink">11.4-4</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">U_4(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdright"><span class="SimpleMath">9</span></td>
<td class="tdright"><a href="chap11.html#X7A03F8EC839AF0B5"><span class="RefLink">11.5-23</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">U_4(3)</span></td>
<td class="tdcenter"><span class="SimpleMath">-</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdright"><span class="SimpleMath">7</span></td>
<td class="tdright"><a href="chap11.html#X7D738BE5804CF22E"><span class="RefLink">11.5-24</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">U_4(4)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">65</span></td>
<td class="tdright"><a href="chap11.html#X8495C2BF7B6EFFEF"><span class="RefLink">11.4-13</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">U_5(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">11</span></td>
<td class="tdright"><a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">U_6(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">11</span></td>
<td class="tdright"><a href="chap11.html#X7A3BB5AA83A2BDF3"><span class="RefLink">11.4-14</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">U_6(3)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">122</span></td>
<td class="tdright"><a href="chap11.html#X7D4BC6A38074BF68"><span class="RefLink">11.5-25</span></a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">U_8(2)</span></td>
<td class="tdcenter"><span class="SimpleMath">+</span></td>
<td class="tdcenter"> </td>
<td class="tdright"><span class="SimpleMath">129</span></td>
<td class="tdright"><a href="chap11.html#X7A92577A830B5F23"><span class="RefLink">11.5-26</span></a></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>Contrary to <a href="chapBib.html#biBBGK">[BGK08]</a>, <strong class="pkg">Atlas</strong> notation is used throughout this note, because the identifiers used for character tables in the <strong class="pkg">GAP</strong> Character Table Library follow mainly the <strong class="pkg">Atlas</strong> <a href="chapBib.html#biBCCN85">[CCN+85]</a>. For example, we write <span class="SimpleMath">L_d(q)</span> for <span class="SimpleMath">PSL(d,q)</span>, <span class="SimpleMath">S_d(q)</span> for <span class="SimpleMath">PSp(d,q)</span>, <span class="SimpleMath">U_d(q)</span> for <span class="SimpleMath">PSU(d,q)</span>, and <span class="SimpleMath">O^+_2d(q)</span>, <span class="SimpleMath">O^-_2d(q)</span>, <span class="SimpleMath">O_2d+1(q)</span> for <span class="SimpleMath">PΩ^+(2d,q)</span>, <span class="SimpleMath">PΩ^-(2d,q)</span>, <span class="SimpleMath">PΩ(2d+1,q)</span>, respectively.</p>

<p>Furthermore, in the case of classical groups, the character tables of the (almost) <em>simple</em> groups are considered not the tables of the matrix groups (which are in fact often not available in the <strong class="pkg">GAP</strong> Character Table Library). Consequently, also element orders and the description of maximal subgroups refer to the (almost) simple groups not to the matrix groups.</p>

<p>This note contains also several examples that are not needed for the proofs in <a href="chapBib.html#biBBGK">[BGK08]</a>. Besides several small simple groups <span class="SimpleMath">G</span> whose character table is contained in the <strong class="pkg">GAP</strong> Character Table Library and for which enough information is available for computing <span class="SimpleMath">σ(G)</span>, in Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, a few such examples appear in individual sections. In the table of contents, the section headers of the latter kind of examples are marked with an asterisk <span class="SimpleMath">(∗)</span>.</p>

<p>The examples use the <strong class="pkg">GAP</strong> Character Table Library, the <strong class="pkg">GAP</strong> Library of Tables of Marks, and the <strong class="pkg">GAP</strong> interface <a href="chapBib.html#biBAtlasRep">[WPN+19]</a> to the <strong class="pkg">Atlas</strong> of Group Representations <a href="chapBib.html#biBAGRv3">[WWT+]</a>, so we first load these three packages in the required versions. The <strong class="pkg">GAP</strong> output was adjusted to the versions shown below; in older versions, features necessary for the computations may be missing, and it may happen that with newer versions, the behaviour is different.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CompareVersionNumbers( GAPInfo.Version, "4.5.0" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "ctbllib", "1.2", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "tomlib", "1.2", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "atlasrep", "1.5", false );</span>
true
</pre></div>

<p>Some of the computations in Section <a href="chap11.html#X8237B8617D6F6027"><span class="RefLink">11.5</span></a> require about <span class="SimpleMath">800</span> MB of space (on <span class="SimpleMath">32</span> bit machines). Therefore we check whether <strong class="pkg">GAP</strong> was started with sufficient maximal memory; the command line option for this is <code class="code">-o 800m</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">max:= GAPInfo.CommandLineOptions.o;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">if not ( ( IsSubset( max, "m" ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              Int( Filtered( max, IsDigitChar ) ) &gt;= 800 ) or</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            ( IsSubset( max, "g" ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              Int( Filtered( max, IsDigitChar ) ) &gt;= 1 ) ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Print( "the maximal allowed memory might be too small\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   fi;</span>
</pre></div>

<p>Several computations involve calls to the <strong class="pkg">GAP</strong> function <code class="func">Random</code> (<a href="../../../doc/ref/chap30.html#X7FF906E57D6936F8"><span class="RefLink">Reference: Random</span></a>). In order to make the results of individual examples reproducible, independent of the rest of the computations, we reset the relevant random number generators whenever this is appropriate. For that, we store the initial states in the variable <code class="code">staterandom</code>, and provide a function for resetting the random number generators. (The <code class="func">Random</code> (<a href="../../../doc/ref/chap30.html#X7FF906E57D6936F8"><span class="RefLink">Reference: Random</span></a>) calls in the <strong class="pkg">GAP</strong> library use the two random number generators <code class="func">GlobalRandomSource</code> (<a href="../../../doc/ref/chap14.html#X7F772E2686B35865"><span class="RefLink">Reference: GlobalRandomSource</span></a>) and <code class="func">GlobalMersenneTwister</code> (<a href="../../../doc/ref/chap14.html#X7F772E2686B35865"><span class="RefLink">Reference: GlobalMersenneTwister</span></a>).)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">staterandom:= [ State( GlobalRandomSource ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   State( GlobalMersenneTwister ) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators:= function()</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Reset( GlobalRandomSource, staterandom[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Reset( GlobalMersenneTwister, staterandom[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p><a id="X7B4649CF7B7CFAA1" name="X7B4649CF7B7CFAA1"></a></p>

<h4>11.2 <span class="Heading">Prerequisites</span></h4>

<p><a id="X7B6AEBDF7B857E2E" name="X7B6AEBDF7B857E2E"></a></p>

<h5>11.2-1 <span class="Heading">Theoretical Background</span></h5>

<p>Let <span class="SimpleMath">G</span> be a finite group, <span class="SimpleMath">S</span> the socle of <span class="SimpleMath">G</span>, and denote by <span class="SimpleMath">G^×</span> the set of nonidentity elements in <span class="SimpleMath">G</span>. For <span class="SimpleMath">s, g ∈ G^×</span>, let <span class="SimpleMath">P( g, s ):= |{ h ∈ G; S ⊈ ⟨ s^h, g ⟩ }| / |G|</span>, the proportion of elements in the class <span class="SimpleMath">s^G</span> which fail to generate at least <span class="SimpleMath">S</span> with <span class="SimpleMath">g</span>; we set <span class="SimpleMath">P( G, s ):= max{ P( g, s ); g ∈ G^× }</span>. We are interested in finding a class <span class="SimpleMath">s^G</span> of elements in <span class="SimpleMath">S</span> such that <span class="SimpleMath">P( G, s ) &lt; 1/3</span> holds.</p>

<p>First consider <span class="SimpleMath">g ∈ S</span>, and let <span class="SimpleMath">𝕄(S,s)</span> denote the set of those maximal subgroups of <span class="SimpleMath">S</span> that contain <span class="SimpleMath">s</span>. We have</p>

<p class="pcenter">|{ h ∈ S; S ⊈ ⟨ s^h, g ⟩ }| = |{ h ∈ S; ⟨ s, h g h^-1 ⟩ ≠ S }| ≤ ∑_M ∈ 𝕄(S,s) |{ h ∈ S; h g h^-1 ∈ M }|</p>

<p>Since <span class="SimpleMath">h g h^-1 ∈ M</span> holds if and only if the coset <span class="SimpleMath">M h</span> is fixed by <span class="SimpleMath">g</span> under the permutation action of <span class="SimpleMath">S</span> on the right cosets of <span class="SimpleMath">M</span> in <span class="SimpleMath">S</span>, we get that <span class="SimpleMath">|{ h ∈ S; h g h^-1 ∈ M }| = |C_S(g)| ⋅ |g^S ∩ M| = |M| ⋅ 1_M^S(g)</span>, where <span class="SimpleMath">1_M^S</span> is the permutation character of this action, of degree <span class="SimpleMath">|S|/|M|</span>. Thus</p>

<p class="pcenter">|{ h ∈ S; ⟨ s, h g h^-1 ⟩ ≠ S }| / |S| ≤ ∑_M ∈ 𝕄(S,s) 1_M^S(g) / 1_M^S(1) .</p>

<p>We abbreviate the right hand side of this inequality by <span class="SimpleMath">σ( g, s )</span>, set <span class="SimpleMath">σ( S, s ):= max{ σ( g, s ); g ∈ S^× }</span>, and choose a transversal <span class="SimpleMath">T</span> of <span class="SimpleMath">S</span> in <span class="SimpleMath">G</span>. Then <span class="SimpleMath">P( g, s ) ≤ |T|^-1 ⋅ ∑_t ∈ T σ( g^t, s )</span> and thus <span class="SimpleMath">P( G, s ) ≤ σ( S, s )</span> holds.</p>

<p>If <span class="SimpleMath">S = G</span> and if <span class="SimpleMath">𝕄(G,s)</span> consists of a single maximal subgroup <span class="SimpleMath">M</span> of <span class="SimpleMath">G</span> then equality holds, i.e., <span class="SimpleMath">P( g, s ) = σ( g, s ) = 1_M^S(g) / 1_M^S(1)</span>.</p>

<p>The quantity <span class="SimpleMath">1_M^S(g) / 1_M^S(1) = |g^S ∩ M| / |g^S|</span> is the proportion of fixed points of <span class="SimpleMath">g</span> in the permutation action of <span class="SimpleMath">S</span> on the right cosets of its subgroup <span class="SimpleMath">M</span>. This is called the <em>fixed point ratio</em> of <span class="SimpleMath">g</span> w. r. t. <span class="SimpleMath">S/M</span>, and is denoted as <span class="SimpleMath">μ(g,S/M)</span>.</p>

<p>For a subgroup <span class="SimpleMath">M</span> of <span class="SimpleMath">S</span>, the number <span class="SimpleMath">n</span> of <span class="SimpleMath">S</span>-conjugates of <span class="SimpleMath">M</span> containing <span class="SimpleMath">s</span> is equal to <span class="SimpleMath">|M^S| ⋅ |s^S ∩ M| / |s^S|</span>. To see this, consider the set <span class="SimpleMath">{ (s^h, M^k); h, k ∈ S, s^h ∈ M^k }</span>, the cardinality of which can be counted either as <span class="SimpleMath">|M^S| ⋅ |s^S ∩ M|</span> or as <span class="SimpleMath">|s^S| ⋅ n</span>. So we get <span class="SimpleMath">n = |M| ⋅ 1_M^S(s) / |N_S(M)|</span>.</p>

<p>If <span class="SimpleMath">S</span> is a finite <em>nonabelian simple</em> group then each maximal subgroup in <span class="SimpleMath">S</span> is self-normalizing, and we have <span class="SimpleMath">n = 1_M^S(s)</span> if <span class="SimpleMath">M</span> is maximal. So we can replace the summation over <span class="SimpleMath">𝕄(S,s)</span> by one over a set <span class="SimpleMath">𝕄/~(S,s)</span> of representatives of conjugacy classes of maximal subgroups of <span class="SimpleMath">S</span>, and get that</p>

<p class="pcenter">σ( g, s ) = ∑_M ∈ 𝕄/~(S,s) frac1_M^S(s) ⋅ 1_M^S(g)1_M^S(1).</p>

<p>Furthermore, we have <span class="SimpleMath">|𝕄(S,s)| = ∑_M ∈ 𝕄/~(S,s) 1_M^S(s)</span>.</p>

<p>In the following, we will often deal with the quantities <span class="SimpleMath">σ(S):= min{ σ( S, s ); s ∈ S^× }</span> and <span class="SimpleMath">𝕊/~(S):= ⌈ 1 / σ(S) - 1 ⌉</span>. These values can be computed easily from the primitive permutation characters of <span class="SimpleMath">S</span>.</p>

<p>Analogously, we set <span class="SimpleMath">P(S):= min { P( S, s ); s ∈ S^× }</span> and <span class="SimpleMath">P(S):= ⌈ 1 / P(S) - 1 ⌉</span>. Clearly we have <span class="SimpleMath">P(S) ≤ σ(S)</span> and <span class="SimpleMath">P(S) ≥ 𝕊/~(S)</span>.</p>

<p>One interpretation of <span class="SimpleMath">P(S)</span> is that if this value is at least <span class="SimpleMath">k</span> then it follows that for any <span class="SimpleMath">g_1, g_2, ..., g_k ∈ S^×</span>, there is some <span class="SimpleMath">s ∈ S</span> such that <span class="SimpleMath">S = ⟨ g_i, s ⟩</span>, for <span class="SimpleMath">1 ≤ i ≤ k</span>. In this case, <span class="SimpleMath">S</span> is said to have <em>spread</em> at least <span class="SimpleMath">k</span>. (Note that the lower bound <span class="SimpleMath">𝕊/~(S)</span> for <span class="SimpleMath">P(S)</span> can be computed from the list of primitive permutation characters of <span class="SimpleMath">S</span>.)</p>

<p>Moreover, <span class="SimpleMath">P(S) ≥ k</span> implies that the element <span class="SimpleMath">s</span> can be chosen uniformly from a fixed conjugacy class of <span class="SimpleMath">S</span>. This is called <em>uniform spread</em> at least <span class="SimpleMath">k</span> in <a href="chapBib.html#biBBGK">[BGK08]</a>.</p>

<p>It is proved in <a href="chapBib.html#biBGK">[GK00]</a> that all finite simple groups have uniform spread at least <span class="SimpleMath">1</span>, that is, for any element <span class="SimpleMath">x ∈ S^×</span>, there is an element <span class="SimpleMath">y</span> in a prescribed class of <span class="SimpleMath">S</span> such that <span class="SimpleMath">G = ⟨ x, y ⟩</span> holds. In <a href="chapBib.html#biBBGK">[BGK08, Corollary 1.3]</a>, it is shown that all finite simple groups have uniform spread at least <span class="SimpleMath">2</span>, and the finite simple groups with (uniform) spread exactly <span class="SimpleMath">2</span> are listed.</p>

<p>Concerning the spread, it should be mentioned that the methods used here and in <a href="chapBib.html#biBBGK">[BGK08]</a> are nonconstructive in the sense that they cannot be used for finding an element <span class="SimpleMath">s</span> that generates <span class="SimpleMath">G</span> together with each of the <span class="SimpleMath">k</span> prescribed elements <span class="SimpleMath">g_1, g_2, ..., g_k</span>.</p>

<p>Now consider <span class="SimpleMath">g ∈ G ∖ S</span>. Since <span class="SimpleMath">P( g^k, s ) ≥ P( g, s )</span> for any positive integer <span class="SimpleMath">k</span>, we can assume that <span class="SimpleMath">g</span> has prime order <span class="SimpleMath">p</span>, say. We set <span class="SimpleMath">H = ⟨ S, g ⟩ ≤ G</span>, with <span class="SimpleMath">[H:S] = p</span>, choose a transversal <span class="SimpleMath">T</span> of <span class="SimpleMath">H</span> in <span class="SimpleMath">G</span>, let <span class="SimpleMath">𝕄^'(H,s):= 𝕄(H,s) ∖ { S }</span>, and let <span class="SimpleMath">𝕄/~^'(H,s)</span> denote a set of representatives of <span class="SimpleMath">H</span>-conjugacy classes of these groups. As above,</p>

<div class="pcenter"><table class="GAPDocTablenoborder">
<tr>
<td class="tdright"><span class="SimpleMath">|{ h ∈ H; S ⊈ ⟨ s^h, g ⟩ }| / |H|</span></td>
<td class="tdcenter"><span class="SimpleMath">=</span></td>
<td class="tdleft"><span class="SimpleMath">|{ h ∈ H; ⟨ s^h, g ⟩ ≠ H }| / |H|</span></td>
</tr>
<tr>
<td class="tdright"> </td>
<td class="tdcenter"><span class="SimpleMath">≤</span></td>
<td class="tdleft"><span class="SimpleMath">∑_M ∈ 𝕄^'(H,s) |{ h ∈ H; h g h^-1 ∈ M }| / |H|</span></td>
</tr>
<tr>
<td class="tdright"> </td>
<td class="tdcenter"><span class="SimpleMath">=</span></td>
<td class="tdleft"><span class="SimpleMath">∑_M ∈ 𝕄^'(H,s) 1_M^H(g) / 1_M^H(1)</span></td>
</tr>
<tr>
<td class="tdright"> </td>
<td class="tdcenter"><span class="SimpleMath">=</span></td>
<td class="tdleft"><span class="SimpleMath">∑_M ∈ 𝕄/~^'(H,s) 1_M^H(g) ⋅ 1_M^H(s) / 1_M^H(1)</span></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>(Note that no summand for <span class="SimpleMath">M = S</span> occurs, so each group in <span class="SimpleMath">𝕄/~^'(H,s)</span> is self-normalizing.) We abbreviate the right hand side by <span class="SimpleMath">σ(H,g,s)</span>, and set <span class="SimpleMath">σ^'( H, s ) = max{ σ(H,g,s); g ∈ H ∖ S, |g| = [H:S] }</span>. Then we get <span class="SimpleMath">P( g, s ) ≤ |T|^-1 ⋅ ∑_t ∈ T σ(H^t,g^t,s)</span> and thus</p>

<p class="pcenter">P( G, s ) ≤ max{ P( S, s ), max{ σ^'( H, s ); S ≤ H ≤ G, [H:S] prime } } .</p>

<p>For convenience, we set <span class="SimpleMath">P^'(G,s) = max{ P(g,s); g ∈ G ∖ S }</span>.</p>

<p><a id="X79D7312484E78274" name="X79D7312484E78274"></a></p>

<h5>11.2-2 <span class="Heading">Computational Criteria</span></h5>

<p>The following criteria will be used when we have to show the existence or nonexistence of <span class="SimpleMath">x_1, x_2, ..., x_k</span>, and <span class="SimpleMath">s ∈ G</span> with the property <span class="SimpleMath">⟨ x_i, s ⟩ = G</span> for <span class="SimpleMath">1 ≤ i ≤ k</span>. Note that manipulating lists of integers (representing fixed or moved points) is much more efficient than testing whether certain permutations generate a given group.</p>

<p>Lemma:</p>

<p>Let <span class="SimpleMath">G</span> be a finite group, <span class="SimpleMath">s ∈ G^×</span>, and <span class="SimpleMath">X = ⋃_M ∈ 𝕄(G,s) G/M</span>. For <span class="SimpleMath">x_1, x_2, ..., x_k ∈ G</span>, the conjugate <span class="SimpleMath">s^'</span> of <span class="SimpleMath">s</span> satisfies <span class="SimpleMath">⟨ x_i, s^' ⟩ = G</span> for <span class="SimpleMath">1 ≤ i ≤ k</span> if and only if <span class="SimpleMath">Fix_X(s^') ∩ ⋃_i=1^k Fix_X(x_i) = ∅</span> holds.</p>

<p><em>Proof.</em> If <span class="SimpleMath">s^g ∈ U ≤ G</span> for some <span class="SimpleMath">g ∈ G</span> then <span class="SimpleMath">Fix_X(U) = ∅</span> if and only if <span class="SimpleMath">U = G</span> holds; note that <span class="SimpleMath">Fix_X(G) = ∅</span>, and <span class="SimpleMath">Fix_X(U) = ∅</span> implies that <span class="SimpleMath">U ⊈ h^-1 M h</span> holds for all <span class="SimpleMath">h ∈ G</span> and <span class="SimpleMath">M ∈ 𝕄(G,s)</span>, thus <span class="SimpleMath">U = G</span>. Applied to <span class="SimpleMath">U = ⟨ x_i, s^' ⟩</span>, we get <span class="SimpleMath">⟨ x_i, s^' ⟩ = G</span> if and only if <span class="SimpleMath">Fix_X(s^') ∩ Fix_X(x_i) = Fix_X(U) = ∅</span>.</p>

<p>Corollary 1:</p>

<p>If <span class="SimpleMath">𝕄(G,s) = { M }</span> in the situation of the above Lemma then there is a conjugate <span class="SimpleMath">s^'</span> of <span class="SimpleMath">s</span> that satisfies <span class="SimpleMath">⟨ x_i, s^' ⟩ = G</span> for <span class="SimpleMath">1 ≤ i ≤ k</span> if and only if <span class="SimpleMath">⋃_i=1^k Fix_X(x_i) ≠ X</span>.</p>

<p>Corollary 2:</p>

<p>Let <span class="SimpleMath">G</span> be a finite simple group and let <span class="SimpleMath">X</span> be a <span class="SimpleMath">G</span>-set such that each <span class="SimpleMath">g ∈ G</span> fixes at least one point in <span class="SimpleMath">X</span> but that <span class="SimpleMath">Fix_X(G) = ∅</span> holds. If <span class="SimpleMath">x_1, x_2, ... x_k</span> are elements in <span class="SimpleMath">G</span> such that <span class="SimpleMath">⋃_i=1^k Fix_X(x_i) = X</span> holds then for each <span class="SimpleMath">s ∈ G</span> there is at least one <span class="SimpleMath">i</span> with <span class="SimpleMath">⟨ x_i, s ⟩ ≠ G</span>.</p>

<p><a id="X7B56BE5384BAD54E" name="X7B56BE5384BAD54E"></a></p>

<h4>11.3 <span class="Heading"><strong class="pkg">GAP</strong> Functions for the Computations</span></h4>

<p>After the introduction of general utilities in Section <a href="chap11.html#X806328747D1D4ECC"><span class="RefLink">11.3-1</span></a>, we distinguish two different tasks. Section <a href="chap11.html#X7A221012861440E2"><span class="RefLink">11.3-2</span></a> introduces functions that will be used in the following to compute <span class="SimpleMath">σ(g,s)</span> with character-theoretic methods. Functions for computing <span class="SimpleMath">P(g,s)</span> or an upper bound for this value will be introduced in Section <a href="chap11.html#X83DACCF07EF62FAE"><span class="RefLink">11.3-3</span></a>.</p>

<p>The <strong class="pkg">GAP</strong> functions shown in this section are collected in the file <code class="file">tst/probgen.g</code> that is distributed with the <strong class="pkg">GAP</strong> Character Table Library, see <span class="URL"><a href="http://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib">http://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib</a></span>.</p>

<p>The functions have been designed for the examples in the later sections, they could be generalized and optimized for other examples. It is not our aim to provide a package for this functionality.</p>

<p><a id="X806328747D1D4ECC" name="X806328747D1D4ECC"></a></p>

<h5>11.3-1 <span class="Heading">General Utilities</span></h5>

<p>Let <code class="code">list</code> be a dense list and <code class="code">prop</code> be a unary function that returns <code class="keyw">true</code> or <code class="keyw">false</code> when applied to the entries of <code class="code">list</code>. <code class="code">PositionsProperty</code> returns the set of positions in <code class="code">list</code> for which <code class="keyw">true</code> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">if not IsBound( PositionsProperty ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     PositionsProperty:= function( list, prop )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       return Filtered( [ 1 .. Length( list ) ], i -&gt; prop( list[i] ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     end;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   fi;</span>
</pre></div>

<p>The following two functions implement loops over ordered triples (and quadruples, respectively) in a Cartesian product. A prescribed function <code class="code">prop</code> is subsequently applied to the triples (quadruples), and if the result of this call is <code class="keyw">true</code> then this triple (quadruple) is returned immediately; if none of the calls to <code class="code">prop</code> yields <code class="keyw">true</code> then <code class="keyw">fail</code> is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "TripleWithProperty", function( threelists, prop )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local i, j, k, test;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for i in threelists[1] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      for j in threelists[2] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        for k in threelists[3] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          test:= [ i, j, k ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          if prop( test ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              return test;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "QuadrupleWithProperty", function( fourlists, prop )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local i, j, k, l, test;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for i in fourlists[1] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      for j in fourlists[2] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        for k in fourlists[3] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          for l in fourlists[4] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            test:= [ i, j, k, l ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            if prop( test ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              return test;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>Of course one could do better by considering <em>un</em>ordered <span class="SimpleMath">n</span>-tuples when several of the argument lists are equal, and in practice, backtrack searches would often allow one to prune parts of the search tree in early stages. However, the above loops are not time critical in the examples presented here, so the possible improvements are not worth the effort for our purposes.</p>

<p>The function <code class="code">PrintFormattedArray</code> prints the matrix <code class="code">array</code> in a columnwise formatted way. (The only diference to the <strong class="pkg">GAP</strong> library function <code class="func">PrintArray</code> (<a href="../../../doc/ref/chap24.html#X7DEBC9967DFDFC18"><span class="RefLink">Reference: PrintArray</span></a>) is that <code class="code">PrintFormattedArray</code> chooses each column width according to the entries only in this column not w.r.t. the whole matrix.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "PrintFormattedArray", function( array )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     local colwidths, n, row;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     array:= List( array, row -&gt; List( row, String ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     colwidths:= List( TransposedMat( array ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       col -&gt; Maximum( List( col, Length ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     n:= Length( array[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     for row in List( array, row -&gt; List( [ 1 .. n ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  i -&gt; String( row[i], colwidths[i] ) ) ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "  ", JoinStringsWithSeparator( row, " " ), "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>Finally, <code class="code">CleanWorkspace</code> is a utility for reducing the space needed. This is achieved by unbinding those user variables that are not write protected and are not mentioned in the list <code class="code">NeededVariables</code> of variable names that are bound now, and by flushing the caches of tables of marks and character tables.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "NeededVariables", NamesUserGVars() );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "CleanWorkspace", function()</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      local name, record;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      for name in Difference( NamesUserGVars(), NeededVariables ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if not IsReadOnlyGlobal( name ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         UnbindGlobal( name );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     for record in [ LIBTOMKNOWN, LIBTABLE ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       for name in RecNames( record.LOADSTATUS ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Unbind( record.LOADSTATUS.( name ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Unbind( record.( name ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>The function <code class="code">PossiblePermutationCharacters</code> takes two ordinary character tables <code class="code">sub</code> and <code class="code">tbl</code>, computes the possible class fusions from <code class="code">sub</code> to <code class="code">tbl</code>, then induces the trivial character of <code class="code">sub</code> to <code class="code">tbl</code>, w.r.t. these fusions, and returns the set of these class functions. (So if <code class="code">sub</code> and <code class="code">tbl</code> are the character tables of groups <span class="SimpleMath">H</span> and <span class="SimpleMath">G</span>, respectively, where <span class="SimpleMath">H</span> is a subgroup of <span class="SimpleMath">G</span>, then the result contains the permutation character <span class="SimpleMath">1_H^G</span>.)</p>

<p>Note that the columns of the character tables in the <strong class="pkg">GAP</strong> Character Table Library are not explicitly associated with particular conjugacy classes of the corresponding groups, so from the character tables, we can compute only <em>possible</em> class fusions, i.e., maps between the columns of two tables that satisfy certain necessary conditions, see the section about the function <code class="code">PossibleClassFusions</code> in the <strong class="pkg">GAP</strong> Reference Manual for details. There is no problem if the permutation character is uniquely determined by the character tables, in all other cases we give ad hoc arguments for resolving the ambiguities.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">if not IsBound( PossiblePermutationCharacters ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     BindGlobal( "PossiblePermutationCharacters", function( sub, tbl )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       local fus, triv;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fus:= PossibleClassFusions( sub, tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if fus = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         return fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       triv:= [ TrivialCharacter( sub ) ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       return Set(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           List( fus, map -&gt; Induced( sub, tbl, triv, map )[1] ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     end );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   fi;</span>
</pre></div>

<p><a id="X7A221012861440E2" name="X7A221012861440E2"></a></p>

<h5>11.3-2 <span class="Heading">Character-Theoretic Computations</span></h5>

<p>We want to use the <strong class="pkg">GAP</strong> libraries of character tables and of tables of marks, and proceed in three steps.</p>

<p>First we extract the primitive permutation characters from the library information if this is available; for that, we write the function <code class="code">PrimitivePermutationCharacters</code>. Then the result can be used as the input for the function <code class="code">ApproxP</code>, which computes the values <span class="SimpleMath">σ( g, s )</span>. Finally, the functions <code class="code">ProbGenInfoSimple</code> and <code class="code">ProbGenInfoAlmostSimple</code> compute <span class="SimpleMath">𝕊/~( G )</span>.</p>

<p>For a group <span class="SimpleMath">G</span> whose character table <span class="SimpleMath">T</span> is contained in the <strong class="pkg">GAP</strong> character table library, the complete set of primitive permutation characters can be easily computed if the character tables of all maximal subgroups and their class fusions into <span class="SimpleMath">T</span> are known (in this case, we check whether the attribute <code class="func">Maxes</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap3.html#X8150E63F7DBDF252"><span class="RefLink">CTblLib: Maxes</span></a>) of <span class="SimpleMath">T</span> is bound) or if the table of marks of <span class="SimpleMath">G</span> and the class fusion from <span class="SimpleMath">T</span> into this table of marks are known (in this case, we check whether the attribute <code class="func">FusionToTom</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap3.html#X7B1AAED68753B1BE"><span class="RefLink">CTblLib: FusionToTom</span></a>) of <span class="SimpleMath">T</span> is bound). If the attribute <code class="func">UnderlyingGroup</code> (<a href="../../../doc/ref/chap70.html#X81E41D3880FA6C4C"><span class="RefLink">Reference: UnderlyingGroup for tables of marks</span></a>) of <span class="SimpleMath">T</span> is bound then this group can be used to compute the primitive permutation characters. The latter happens if <span class="SimpleMath">T</span> was computed from the group object in <strong class="pkg">GAP</strong>; for tables in the <strong class="pkg">GAP</strong> character table library, this is not the case by default.</p>

<p>The <strong class="pkg">GAP</strong> function <code class="code">PrimitivePermutationCharacters</code> tries to compute the primitive permutation characters of a group using this information; it returns the required list of characters if this can be computed this way, otherwise <code class="keyw">fail</code> is returned. (For convenience, we use the <strong class="pkg">GAP</strong> mechanism of <em>attributes</em> in order to store the permutation characters in the character table object once they have been computed.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeclareAttribute( "PrimitivePermutationCharacters", IsCharacterTable );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallOtherMethod( PrimitivePermutationCharacters,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ IsCharacterTable ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    function( tbl )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local maxes, tom, G;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if HasMaxes( tbl ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      maxes:= List( Maxes( tbl ), CharacterTable );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if ForAll( maxes, s -&gt; GetFusionMap( s, tbl ) &lt;&gt; fail ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return List( maxes, subtbl -&gt; TrivialCharacter( subtbl )^tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif HasFusionToTom( tbl ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      tom:= TableOfMarks( tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      maxes:= MaximalSubgroupsTom( tom );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return PermCharsTom( tbl, tom ){ maxes[1] };</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif HasUnderlyingGroup( tbl ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      G:= UnderlyingGroup( tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return List( MaximalSubgroupClassReps( G ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   M -&gt; TrivialCharacter( M )^tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>The function <code class="code">ApproxP</code> takes a list <code class="code">primitives</code> of primitive permutation characters of a group <span class="SimpleMath">G</span>, say, and the position <code class="code">spos</code> of the class <span class="SimpleMath">s^G</span> in the character table of <span class="SimpleMath">G</span>.</p>

<p>Assume that the elements in <code class="code">primitives</code> have the form <span class="SimpleMath">1_M^G</span>, for suitable maximal subgroups <span class="SimpleMath">M</span> of <span class="SimpleMath">G</span>, and let <span class="SimpleMath">𝕄/~</span> be the set of these groups <span class="SimpleMath">M</span>. <code class="code">ApproxP</code> returns the class function <span class="SimpleMath">ψ</span> of <span class="SimpleMath">G</span> that is defined by <span class="SimpleMath">ψ(1) = 0</span> and</p>

<p class="pcenter">ψ(g) = ∑_M ∈ 𝕄/~ frac1_M^G(s) ⋅ 1_M^G(g)1_M^G(1)</p>

<p>otherwise.</p>

<p>If <code class="code">primitives</code> contains all those primitive permutation characters <span class="SimpleMath">1_M^G</span> of <span class="SimpleMath">G</span> (with multiplicity according to the number of conjugacy classes of these maximal subgroups) that do not vanish at <span class="SimpleMath">s</span>, and if all these <span class="SimpleMath">M</span> are self-normalizing in <span class="SimpleMath">G</span> –this holds for example if <span class="SimpleMath">G</span> is a finite simple group– then <span class="SimpleMath">ψ(g) = σ( g, s )</span> holds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "ApproxP", function( primitives, spos )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local sum;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    sum:= ShallowCopy( Sum( List( primitives,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                  pi -&gt; pi[ spos ] * pi / pi[1] ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    sum[1]:= 0;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return sum;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>Note that for computations with permutation characters, it would make the functions more complicated (and not more efficient) if we would consider only elements <span class="SimpleMath">g</span> of prime order, and only one representative of Galois conjugate classes.</p>

<p>The next functions needed in this context compute <span class="SimpleMath">σ(S)</span> and <span class="SimpleMath">𝕊/~( S )</span>, for a simple group <span class="SimpleMath">S</span>, and <span class="SimpleMath">σ^'(G,s)</span> for an almost simple group <span class="SimpleMath">G</span> with socle <span class="SimpleMath">S</span>, respectively.</p>

<p><code class="code">ProbGenInfoSimple</code> takes the character table <code class="code">tbl</code> of <span class="SimpleMath">S</span> as its argument. If the full list of primitive permutation characters of <span class="SimpleMath">S</span> cannot be computed with <code class="code">PrimitivePermutationCharacters</code> then the function returns <code class="keyw">fail</code>. Otherwise <code class="code">ProbGenInfoSimple</code> returns a list containing the identifier of the table, the value <span class="SimpleMath">σ(S)</span>, the integer <span class="SimpleMath">𝕊/~( S )</span>, a list of <strong class="pkg">Atlas</strong> names of representatives of Galois families of those classes of elements <span class="SimpleMath">s</span> for which <span class="SimpleMath">σ(S) = σ( S, s )</span> holds, and the list of the corresponding cardinalities <span class="SimpleMath">|𝕄(S,s)|</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "ProbGenInfoSimple", function( tbl )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local prim, max, min, bound, s;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    prim:= PrimitivePermutationCharacters( tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if prim = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    max:= List( [ 1 .. NrConjugacyClasses( tbl ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                i -&gt; Maximum( ApproxP( prim, i ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    min:= Minimum( max );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    bound:= Inverse( min );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if IsInt( bound ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      bound:= bound - 1;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      bound:= Int( bound );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    s:= PositionsProperty( max, x -&gt; x = min );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    s:= List( Set( s, i -&gt; ClassOrbit( tbl, i ) ), i -&gt; i[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return [ Identifier( tbl ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             min,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             bound,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             AtlasClassNames( tbl ){ s },</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Sum( List( prim, pi -&gt; pi{ s } ) ) ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p><code class="code">ProbGenInfoAlmostSimple</code> takes the character tables <code class="code">tblS</code> and <code class="code">tblG</code> of <span class="SimpleMath">S</span> and <span class="SimpleMath">G</span>, and a list <code class="code">sposS</code> of class positions (w.r.t. <code class="code">tblS</code>) as its arguments. It is assumed that <span class="SimpleMath">S</span> is simple and has prime index in <span class="SimpleMath">G</span>. If <code class="code">PrimitivePermutationCharacters</code> can compute the full list of primitive permutation characters of <span class="SimpleMath">G</span> then the function returns a list containing the identifier of <code class="code">tblG</code>, the maximum <span class="SimpleMath">m</span> of <span class="SimpleMath">σ^'( G, s )</span>, for <span class="SimpleMath">s</span> in the classes described by <code class="code">sposS</code>, a list of <strong class="pkg">Atlas</strong> names (in <span class="SimpleMath">G</span>) of the classes of elements <span class="SimpleMath">s</span> for which this maximum is attained, and the list of the corresponding cardinalities <span class="SimpleMath">|𝕄^'(G,s)|</span>. When <code class="code">PrimitivePermutationCharacters</code> returns <code class="keyw">fail</code>, also <code class="code">ProbGenInfoAlmostSimple</code> returns <code class="keyw">fail</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "ProbGenInfoAlmostSimple", function( tblS, tblG, sposS )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local p, fus, inv, prim, sposG, outer, approx, l, max, min,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          s, cards, i, names;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    p:= Size( tblG ) / Size( tblS );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if not IsPrimeInt( p )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       or Length( ClassPositionsOfNormalSubgroups( tblG ) ) &lt;&gt; 3 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fus:= GetFusionMap( tblS, tblG );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if fus = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    inv:= InverseMap( fus );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    prim:= PrimitivePermutationCharacters( tblG );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if prim = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    sposG:= Set( fus{ sposS } );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    outer:= Difference( PositionsProperty(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                OrdersClassRepresentatives( tblG ), IsPrimeInt ), fus );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    approx:= List( sposG, i -&gt; ApproxP( prim, i ){ outer } );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if IsEmpty( outer ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      max:= List( approx, x -&gt; 0 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      max:= List( approx, Maximum );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    min:= Minimum( max);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    s:= sposG{ PositionsProperty( max, x -&gt; x = min ) };</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    cards:= List( prim, pi -&gt; pi{ s } );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for i in [ 1 .. Length( prim ) ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      # Omit the character that is induced from the simple group.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if ForAll( prim[i], x -&gt; x = 0 or x = prim[i][1] ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        cards[i]:= 0;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    names:= AtlasClassNames( tblG ){ s };</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Perform( names, ConvertToStringRep );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return [ Identifier( tblG ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             min,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             names,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Sum( cards ) ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>The next function computes <span class="SimpleMath">σ(G,s)</span> from the character table <code class="code">tbl</code> of a simple or almost simple group <span class="SimpleMath">G</span>, the name <code class="code">sname</code> of the class of <span class="SimpleMath">s</span> in this table, the list <code class="code">maxes</code> of the character tables of all subgroups <span class="SimpleMath">M</span> with <span class="SimpleMath">M ∈ 𝕄(G,s)</span>, and the list <code class="code">numpermchars</code> of the numbers of possible permutation characters induced from <code class="code">maxes</code>. If the string <code class="code">"outer"</code> is given as an optional argument then <span class="SimpleMath">G</span> is assumed to be an automorphic extension of a simple group <span class="SimpleMath">S</span>, with <span class="SimpleMath">[G:S]</span> a prime, and <span class="SimpleMath">σ^'(G,s)</span> is returned. In both situations, the result is <code class="keyw">fail</code> if the numbers of possible permutation characters induced from <code class="code">maxes</code> do not coincide with the numbers prescribed in <code class="code">numpermchars</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "SigmaFromMaxes", function( arg )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local t, sname, maxes, numpermchars, prim, spos, outer;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    t:= arg[1];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    sname:= arg[2];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    maxes:= arg[3];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    numpermchars:= arg[4];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    prim:= List( maxes, s -&gt; PossiblePermutationCharacters( s, t ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    spos:= Position( AtlasClassNames( t ), sname );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if ForAny( [ 1 .. Length( maxes ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               i -&gt; Length( prim[i] ) &lt;&gt; numpermchars[i] ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif Length( arg ) = 5 and arg[5] = "outer" then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      outer:= Difference(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          PositionsProperty( OrdersClassRepresentatives( t ), IsPrimeInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          ClassPositionsOfDerivedSubgroup( t ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return Maximum( ApproxP( Concatenation( prim ), spos ){ outer } );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return Maximum( ApproxP( Concatenation( prim ), spos ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>The following function allows us to extract information about <span class="SimpleMath">𝕄(G,s)</span> from the character table <code class="code">tbl</code> of <span class="SimpleMath">G</span> and a list <code class="code">snames</code> of class positions of <span class="SimpleMath">s</span>. If <code class="code">Maxes( tbl )</code> is stored then the names of the character tables of the subgroups in <span class="SimpleMath">𝕄(G,s)</span> and the number of conjugates are printed, otherwise <code class="keyw">fail</code> is printed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "DisplayProbGenMaxesInfo", function( tbl, snames )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local mx, prim, i, spos, nonz, indent, j;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if not HasMaxes( tbl ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      Print( Identifier( tbl ), ": fail\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    mx:= List( Maxes( tbl ), CharacterTable );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    prim:= List( mx, s -&gt; TrivialCharacter( s )^tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Assert( 1, SortedList( prim ) =</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               SortedList( PrimitivePermutationCharacters( tbl ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for i in [ 1 .. Length( prim ) ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      # Deal with the case that the subgroup is normal.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if ForAll( prim[i], x -&gt; x = 0 or x = prim[i][1] ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        prim[i]:= prim[i] / prim[i][1];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    spos:= List( snames,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 nam -&gt; Position( AtlasClassNames( tbl ), nam ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    nonz:= List( spos, x -&gt; PositionsProperty( prim, pi -&gt; pi[x] &lt;&gt; 0 ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for i in [ 1 .. Length( spos ) ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      Print( Identifier( tbl ), ", ", snames[i], ": " );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      indent:= ListWithIdenticalEntries(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          Length( Identifier( tbl ) ) + Length( snames[i] ) + 4, ' ' );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if not IsEmpty( nonz[i] ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        Print( Identifier( mx[ nonz[i][1] ] ), "  (",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               prim[ nonz[i][1] ][ spos[i] ], ")\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        for j in [ 2 .. Length( nonz[i] ) ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          Print( indent, Identifier( mx[ nonz[i][j] ] ), "  (",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               prim[ nonz[i][j] ][ spos[i] ], ")\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        Print( "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p><a id="X83DACCF07EF62FAE" name="X83DACCF07EF62FAE"></a></p>

<h5>11.3-3 <span class="Heading">Computations with Groups</span></h5>

<p>Here, the task is to compute <span class="SimpleMath">P(g,s)</span> or <span class="SimpleMath">P(G,s)</span> using explicit computations with <span class="SimpleMath">G</span>, where the character-theoretic bounds are not sufficient.</p>

<p>We start with small utilities that make the examples shorter.</p>

<p>For a finite solvable group <code class="code">G</code>, the function <code class="code">PcConjugacyClassReps</code> returns a list of representatives of the conjugacy classes of <code class="code">G</code>, which are computed using a polycyclic presentation for <code class="code">G</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "PcConjugacyClassReps", function( G )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     local iso;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     iso:= IsomorphismPcGroup( G );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     return List( ConjugacyClasses( Image( iso ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              c -&gt; PreImagesRepresentative( iso, Representative( c ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>For a finite group <code class="code">G</code>, a list <code class="code">primes</code> of prime integers, and a normal subgroup <code class="code">N</code> of <code class="code">G</code>, the function <code class="code">ClassesOfPrimeOrder</code> returns a list of those conjugacy classes of <code class="code">G</code> that are not contained in <code class="code">N</code> and whose elements' orders occur in <code class="code">primes</code>.</p>

<p>For each prime <span class="SimpleMath">p</span> in <code class="code">primes</code>, first class representatives of order <span class="SimpleMath">p</span> in a Sylow <span class="SimpleMath">p</span> subgroup of <code class="code">G</code> are computed, then the representatives in <code class="code">N</code> are discarded, and then representatives w. r. t. conjugacy in <code class="code">G</code> are computed.</p>

<p>(Note that this approach may be inappropriate for example if a large elementary abelian Sylow <span class="SimpleMath">p</span> subgroup occurs, and if the conjugacy tests in <code class="code">G</code> are expensive, see Section <a href="chap11.html#X85BACC4A83F73392"><span class="RefLink">11.5-14</span></a>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "ClassesOfPrimeOrder", function( G, primes, N )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     local ccl, p, syl, Greps, reps, r, cr;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ccl:= [];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     for p in primes do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       syl:= SylowSubgroup( G, p );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Greps:= [];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       reps:= Filtered( PcConjugacyClassReps( syl ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  r -&gt; Order( r ) = p and not r in N );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       for r in reps do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         cr:= ConjugacyClass( G, r );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if ForAll( Greps, c -&gt; c &lt;&gt; cr ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Add( Greps, cr );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Append( ccl, Greps );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     return ccl;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>The function <code class="code">IsGeneratorsOfTransPermGroup</code> takes a <em>transitive</em> permutation group <code class="code">G</code> and a list <code class="code">list</code> of elements in <code class="code">G</code>, and returns <code class="keyw">true</code> if the elements in <code class="code">list</code> generate <code class="code">G</code>, and <code class="keyw">false</code> otherwise. The main point is that the return value <code class="keyw">true</code> requires the group generated by <code class="code">list</code> to be transitive, and the check for transitivity is much cheaper than the test whether this group is equal to <code class="code">G</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">if not IsBound( IsGeneratorsOfTransPermGroup) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     BindGlobal( "IsGeneratorsOfTransPermGroup", function( G, list )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       local S;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if not IsTransitive( G ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Error( "&lt;G&gt; must be transitive on its moved points" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       S:= SubgroupNC( G, list );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       return IsTransitive( S, MovedPoints( G ) ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              Size( S ) = Size( G );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     end );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   fi;</span>
</pre></div>

<p><code class="code">RatioOfNongenerationTransPermGroup</code> takes a <em>transitive</em> permutation group <code class="code">G</code> and two elements <code class="code">g</code> and <code class="code">s</code> of <code class="code">G</code>, and returns the proportion <span class="SimpleMath">P(g,s)</span>. (The function tests the (non)generation only for representatives of <span class="SimpleMath">C_G(g)</span>-<span class="SimpleMath">C_G(s)</span>-double cosets. Note that for <span class="SimpleMath">c_1 ∈ C_G(g)</span>, <span class="SimpleMath">c_2 ∈ C_G(s)</span>, and a representative <span class="SimpleMath">r ∈ G</span>, we have <span class="SimpleMath">⟨ g^c_1 r c_2, s ⟩ = ⟨ g^r, s ⟩^c_2</span>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "RatioOfNongenerationTransPermGroup", function( G, g, s )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local nongen, pair;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if not IsTransitive( G ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      Error( "&lt;G&gt; must be transitive on its moved points" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    nongen:= 0;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for pair in DoubleCosetRepsAndSizes( G, Centralizer( G, g ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    Centralizer( G, s ) ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if not IsGeneratorsOfTransPermGroup( G, [ s, g^pair[1] ] ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        nongen:= nongen + pair[2];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return nongen / Size( G );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>Let <span class="SimpleMath">G</span> be a group, and let <code class="code">groups</code> be a list <span class="SimpleMath">[ G_1, G_2, ..., G_n ]</span> of permutation groups such that <span class="SimpleMath">G_i</span> describes the action of <span class="SimpleMath">G</span> on a set <span class="SimpleMath">Ω_i</span>, say. Moreover, we require that for <span class="SimpleMath">1 ≤ i, j ≤ n</span>, mapping the <code class="code">GeneratorsOfGroup</code> list of <span class="SimpleMath">G_i</span> to that of <span class="SimpleMath">G_j</span> defines an isomorphism. <code class="code">DiagonalProductOfPermGroups</code> takes <code class="code">groups</code> as its argument, and returns the action of <span class="SimpleMath">G</span> on the disjoint union of <span class="SimpleMath">Ω_1, Ω_2, ..., Ω_n</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "DiagonalProductOfPermGroups", function( groups )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local prodgens, deg, i, gens, D, pi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    prodgens:= GeneratorsOfGroup( groups[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    deg:= NrMovedPoints( prodgens );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for i in [ 2 .. Length( groups ) ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      gens:= GeneratorsOfGroup( groups[i] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      D:= MovedPoints( gens );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      pi:= MappingPermListList( D, [ deg+1 .. deg+Length( D ) ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      deg:= deg + Length( D );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      prodgens:= List( [ 1 .. Length( prodgens ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       i -&gt; prodgens[i] * gens[i]^pi );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return Group( prodgens );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>The following two functions are used to reduce checks of generation to class representatives of maximal order. Note that if <span class="SimpleMath">⟨ s, g ⟩</span> is a proper subgroup of <span class="SimpleMath">G</span> then also <span class="SimpleMath">⟨ s^k, g ⟩</span> is a proper subgroup of <span class="SimpleMath">G</span>, so we need not check powers <span class="SimpleMath">s^k</span> different from <span class="SimpleMath">s</span> in this situation.</p>

<p>For an ordinary character table <code class="code">tbl</code>, the function <code class="code">RepresentativesMaximallyCyclicSubgroups</code> returns a list of class positions, containing one class of generators for each class of maximally cyclic subgroups.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "RepresentativesMaximallyCyclicSubgroups", function( tbl )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local n, result, orders, p, pmap, i, j;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Initialize.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    n:= NrConjugacyClasses( tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    result:= BlistList( [ 1 .. n ], [ 1 .. n ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Omit powers of smaller order.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    orders:= OrdersClassRepresentatives( tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for p in PrimeDivisors( Size( tbl ) ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      pmap:= PowerMap( tbl, p );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      for i in [ 1 .. n ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        if orders[ pmap[i] ] &lt; orders[i] then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          result[ pmap[i] ]:= false;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Omit Galois conjugates.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for i in [ 1 .. n ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if result[i] then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        for j in ClassOrbit( tbl, i ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          if i &lt;&gt; j then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            result[j]:= false;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Return the result.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return ListBlist( [ 1 .. n ], result );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>Let <code class="code">G</code> be a finite group, <code class="code">tbl</code> be the ordinary character table of <code class="code">G</code>, and <code class="code">cols</code> be a list of class positions in <code class="code">tbl</code>, for example the list returned by <code class="code">RepresentativesMaximallyCyclicSubgroups</code>. The function <code class="code">ClassesPerhapsCorrespondingToTableColumns</code> returns the sublist of those conjugacy classes of <code class="code">G</code> for which the corresponding column in <code class="code">tbl</code> can be contained in <code class="code">cols</code>, according to element order and class size.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "ClassesPerhapsCorrespondingToTableColumns",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( G, tbl, cols )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local orders, classes, invariants;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    orders:= OrdersClassRepresentatives( tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    classes:= SizesConjugacyClasses( tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    invariants:= List( cols, i -&gt; [ orders[i], classes[i] ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return Filtered( ConjugacyClasses( G ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        c -&gt; [ Order( Representative( c ) ), Size(c) ] in invariants );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>The next function computes, for a finite group <span class="SimpleMath">G</span> and subgroups <span class="SimpleMath">M_1, M_2, ..., M_n</span> of <span class="SimpleMath">G</span>, an upper bound for <span class="SimpleMath">max { ∑_i=1^n μ(g,G/M_i); g ∈ G ∖ Z(G) }</span>. So if the <span class="SimpleMath">M_i</span> are the groups in <span class="SimpleMath">𝕄(G,s)</span>, for some <span class="SimpleMath">s ∈ G^×</span>, then we get an upper bound for <span class="SimpleMath">σ(G,s)</span>.</p>

<p>The idea is that for <span class="SimpleMath">M ≤ G</span> and <span class="SimpleMath">g ∈ G</span> of order <span class="SimpleMath">p</span>, we have</p>

<p class="pcenter">μ(g,G/M) = |g^G ∩ M| / |g^G| ≤ ∑_h ∈ C |h^M| / |g^G| = ∑_h ∈ C |h^M| ⋅ |C_G(g)| / |G| ,</p>

<p>where <span class="SimpleMath">C</span> is a set of class representatives <span class="SimpleMath">h ∈ M</span> of all those classes that satisfy <span class="SimpleMath">|h| = p</span> and <span class="SimpleMath">|C_G(h)| = |C_G(g)|</span>, and in the case that <span class="SimpleMath">G</span> is a permutation group additionally that <span class="SimpleMath">h</span> and <span class="SimpleMath">g</span> move the same number of points. (Note that it is enough to consider elements of <em>prime</em> order.)</p>

<p>For computing the maximum of the rightmost term in this inequality, for <span class="SimpleMath">g ∈ G ∖ Z(G)</span>, we need not determine the <span class="SimpleMath">G</span>-conjugacy of class representatives in <span class="SimpleMath">M</span>. Of course we pay the price that the result may be larger than the leftmost term. However, if the maximal sum is in fact taken only over a single class representative, we are sure that equality holds. Thus we return a list of length two, containing the maximum of the right hand side of the above inequality and a Boolean value indicating whether this is equal to <span class="SimpleMath">max { μ(g,G/M); g ∈ G ∖ Z(G) }</span> or just an upper bound.</p>

<p>The arguments for <code class="code">UpperBoundFixedPointRatios</code> are the group <code class="code">G</code>, a list <code class="code">maxesclasses</code> such that the <span class="SimpleMath">i</span>-th entry is a list of conjugacy classes of <span class="SimpleMath">M_i</span>, which covers all classes of prime element order in <span class="SimpleMath">M_i</span>, and either <code class="keyw">true</code> or <code class="keyw">false</code>, where <code class="keyw">true</code> means that the <em>exact</em> value of <span class="SimpleMath">σ(G,s)</span> is computed, not just an upper bound; this can be much more expensive because of the conjugacy tests in <span class="SimpleMath">G</span> that may be necessary. (We try to reduce the number of conjugacy tests in this case, the second half of the code is not completely straightforward. The special treatment of conjugacy checks for elements with the same sets of fixed points is essential in the computation of <span class="SimpleMath">σ^'(G,s)</span> for <span class="SimpleMath">G = PGL(6,4)</span>; the critical input line is <code class="code">ApproxPForOuterClassesInGL( 6, 4 )</code>, see Section <a href="chap11.html#X7EA88CEF81962F3F"><span class="RefLink">11.5-7</span></a>. Currently the standard <strong class="pkg">GAP</strong> conjugacy test for an element of order three and its inverse in <span class="SimpleMath">G ∖ G^'</span> requires hours of CPU time, whereas the check for existence of a conjugating element in the stabilizer of the common set of fixed points of the two elements is almost free of charge.)</p>

<p><code class="code">UpperBoundFixedPointRatios</code> can be used to compute <span class="SimpleMath">σ^'(G,s)</span> in the case that <span class="SimpleMath">G</span> is an automorphic extension of a simple group <span class="SimpleMath">S</span>, with <span class="SimpleMath">[G:S] = p</span> a prime; if <span class="SimpleMath">𝕄^'(G,s) = { M_1, M_2, ..., M_n }</span> then the <span class="SimpleMath">i</span>-th entry of <code class="code">maxesclasses</code> must contain only the classes of element order <span class="SimpleMath">p</span> in <span class="SimpleMath">M_i ∖ (M_i ∩ S)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "UpperBoundFixedPointRatios",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( G, maxesclasses, truetest )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local myIsConjugate, invs, info, c, r, o, inv, pos, sums, max, maxpos,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          maxlen, reps, split, i, found, j;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    myIsConjugate:= function( G, x, y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      local movx, movy;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      movx:= MovedPoints( x );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      movy:= MovedPoints( y );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if movx = movy then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        G:= Stabilizer( G, movx, OnSets );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return IsConjugate( G, x, y );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    end;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    invs:= [];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    info:= [];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # First distribute the classes according to invariants.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for c in Concatenation( maxesclasses ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      r:= Representative( c );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      o:= Order( r );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      # Take only prime order representatives.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if IsPrimeInt( o ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        inv:= [ o, Size( Centralizer( G, r ) ) ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        # Omit classes that are central in `G'.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        if inv[2] &lt;&gt; Size( G ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          if IsPerm( r ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            Add( inv, NrMovedPoints( r ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          pos:= First( [ 1 .. Length( invs ) ], i -&gt; inv = invs[i] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          if pos = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            # This class is not `G'-conjugate to any of the previous ones.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            Add( invs, inv );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            Add( info, [ [ r, Size( c ) * inv[2] ] ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            # This class may be conjugate to an earlier one.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            Add( info[ pos ], [ r, Size( c ) * inv[2] ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if info = [] then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return [ 0, true ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    repeat</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      # Compute the contributions of the classes with the same invariants.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      sums:= List( info, x -&gt; Sum( List( x, y -&gt; y[2] ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      max:= Maximum( sums );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      maxpos:= Filtered( [ 1 .. Length( info ) ], i -&gt; sums[i] = max );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      maxlen:= List( maxpos, i -&gt; Length( info[i] ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      # Split the sets with the same invariants if necessary</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      # and if we want to compute the exact value.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if truetest and not 1 in maxlen then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        # Make one conjugacy test.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        pos:= Position( maxlen, Minimum( maxlen ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        reps:= info[ maxpos[ pos ] ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        if myIsConjugate( G, reps[1][1], reps[2][1] ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          # Fuse the two classes.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          reps[1][2]:= reps[1][2] + reps[2][2];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          reps[2]:= reps[ Length( reps ) ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          Unbind( reps[ Length( reps ) ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          # Split the list. This may require additional conjugacy tests.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          Unbind( info[ maxpos[ pos ] ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          split:= [ reps[1], reps[2] ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          for i in [ 3 .. Length( reps ) ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            found:= false;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            for j in split do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              if myIsConjugate( G, reps[i][1], j[1] ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                j[2]:= reps[i][2] + j[2];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                found:= true;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                break;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            if not found then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              Add( split, reps[i] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          info:= Compacted( Concatenation( info,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                           List( split, x -&gt; [ x ] ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    until 1 in maxlen or not truetest;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return [ max / Size( G ), 1 in maxlen ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>Suppose that <span class="SimpleMath">C_1, C_2, C_3</span> are conjugacy classes in <span class="SimpleMath">G</span>, and that we have to prove, for each <span class="SimpleMath">(x_1, x_2, x_3) ∈ C_1 × C_2 × C_3</span>, the existence of an element <span class="SimpleMath">s</span> in a prescribed class <span class="SimpleMath">C</span> of <span class="SimpleMath">G</span> such that <span class="SimpleMath">⟨ x_1, s ⟩ = ⟨ x_2, s ⟩ = ⟨ x_2, s ⟩ = G</span> holds.</p>

<p>We have to check only representatives under the conjugation action of <span class="SimpleMath">G</span> on <span class="SimpleMath">C_1 × C_2 × C_3</span>. For each representative, we try a prescribed number of random elements in <span class="SimpleMath">C</span>. If this is successful then we are done. The following two functions implement this idea.</p>

<p>For a group <span class="SimpleMath">G</span> and a list <span class="SimpleMath">[ g_1, g_2, ..., g_n ]</span> of elements in <span class="SimpleMath">G</span>, <code class="code">OrbitRepresentativesProductOfClasses</code> returns a list <span class="SimpleMath">R(G, g_1, g_2, ..., g_n)</span> of representatives of <span class="SimpleMath">G</span>-orbits on the Cartesian product <span class="SimpleMath">g_1^G × g_2^G × ⋯ × g_n^G</span>.</p>

<p>The idea behind this function is to choose <span class="SimpleMath">R(G, g_1) = { ( g_1 ) }</span> in the case <span class="SimpleMath">n = 1</span>, and, for <span class="SimpleMath">n &gt; 1</span>,</p>

<p class="pcenter">R(G, g_1, g_2, ..., g_n) = { (h_1, h_2, ..., h_n) ∣ (h_1, h_2, ..., h_n-1) ∈ R(G, g_1, g_2, ..., g_n-1), h_n = g_n^d, for d ∈ D } ,</p>

<p>where <span class="SimpleMath">D</span> is a set of representatives of double cosets <span class="SimpleMath">C_G(g_n) ∖ G / ∩_i=1^n-1 C_G(h_i)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "OrbitRepresentativesProductOfClasses",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( G, classreps )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local cents, n, orbreps;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    cents:= List( classreps, x -&gt; Centralizer( G, x ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    n:= Length( classreps );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    orbreps:= function( reps, intersect, pos )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if pos &gt; n then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return [ reps ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return Concatenation( List(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          DoubleCosetRepsAndSizes( G, cents[ pos ], intersect ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            r -&gt; orbreps( Concatenation( reps, [ classreps[ pos ]^r[1] ] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 Intersection( intersect, cents[ pos ]^r[1] ), pos+1 ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    end;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return orbreps( [ classreps[1] ], cents[1], 2 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>The function <code class="code">RandomCheckUniformSpread</code> takes a transitive permutation group <span class="SimpleMath">G</span>, a list of class representatives <span class="SimpleMath">g_i ∈ G</span>, an element <span class="SimpleMath">s ∈ G</span>, and a positive integer <span class="SimpleMath">N</span>. The return value is <code class="keyw">true</code> if for each representative of <span class="SimpleMath">G</span>-orbits on the product of the classes <span class="SimpleMath">g_i^G</span>, a good conjugate of <span class="SimpleMath">s</span> is found in at most <span class="SimpleMath">N</span> random tests.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "RandomCheckUniformSpread", function( G, classreps, s, try )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local elms, found, i, conj;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if not IsTransitive( G, MovedPoints( G ) ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      Error( "&lt;G&gt; must be transitive on its moved points" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Compute orbit representatives of G on the direct product,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # and try to find a good conjugate of s for each representative.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for elms in OrbitRepresentativesProductOfClasses( G, classreps ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      found:= false;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      for i in [ 1 .. try ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        conj:= s^Random( G );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        if ForAll( elms,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              x -&gt; IsGeneratorsOfTransPermGroup( G, [ x, conj ] ) ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          found:= true;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          break;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      if not found then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        return elms;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return true;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>Of course this approach is not suitable for <em>dis</em>proving the existence of <span class="SimpleMath">s</span>, but it is much cheaper than an exhaustive search in the class <span class="SimpleMath">C</span>. (Typically, <span class="SimpleMath">|C|</span> is large whereas the <span class="SimpleMath">|C_i|</span> are small.)</p>

<p>The following function can be used to verify that a given <span class="SimpleMath">n</span>-tuple <span class="SimpleMath">(x_1, x_2, ..., x_n)</span> of elements in a group <span class="SimpleMath">G</span> has the property that for all elements <span class="SimpleMath">g ∈ G</span>, at least one <span class="SimpleMath">x_i</span> satisfies <span class="SimpleMath">⟨ x_i, g ⟩</span>. The arguments are a transitive permutation group <span class="SimpleMath">G</span>, a list of class representatives in <span class="SimpleMath">G</span>, and the <span class="SimpleMath">n</span>-tuple in question. The return value is a conjugate <span class="SimpleMath">g</span> of the given representatives that has the property if such an element exists, and <code class="keyw">fail</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "CommonGeneratorWithGivenElements",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( G, classreps, tuple )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local inter, rep, repcen, pair;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if not IsTransitive( G, MovedPoints( G ) ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      Error( "&lt;G&gt; must be transitive on its moved points" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    inter:= Intersection( List( tuple, x -&gt; Centralizer( G, x ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for rep in classreps do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      repcen:= Centralizer( G, rep );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      for pair in DoubleCosetRepsAndSizes( G, repcen, inter ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        if ForAll( tuple,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; IsGeneratorsOfTransPermGroup( G, [ x, rep^pair[1] ] ) ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          return rep;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p><a id="X7A221012861440E2" name="X7A221012861440E2"></a></p>

<h4>11.4 <span class="Heading">Character-Theoretic Computations</span></h4>

<p>In this section, we apply the functions introduced in Section <a href="chap11.html#X7A221012861440E2"><span class="RefLink">11.3-2</span></a> to the character tables of simple groups that are available in the <strong class="pkg">GAP</strong> Character Table Library.</p>

<p>Our first examples are the sporadic simple groups, in Section <a href="chap11.html#X86CE51E180A3D4ED"><span class="RefLink">11.4-1</span></a>, then their automorphism groups are considered in Section <a href="chap11.html#X84E9D10F80A74A53"><span class="RefLink">11.4-2</span></a>.</p>

<p>Then we consider those other simple groups for which <strong class="pkg">GAP</strong> provides enough information for automatically computing an upper bound on <span class="SimpleMath">σ(G,s)</span> –see Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>– and their automorphic extensions –see Section <a href="chap11.html#X7B1E26D586337487"><span class="RefLink">11.4-4</span></a>.</p>

<p>After that, individual groups are considered.</p>

<p><a id="X86CE51E180A3D4ED" name="X86CE51E180A3D4ED"></a></p>

<h5>11.4-1 <span class="Heading">Sporadic Simple Groups</span></h5>

<p>The <strong class="pkg">GAP</strong> Character Table Library contains the tables of maximal subgroups of all sporadic simple groups except <span class="SimpleMath">B</span> and <span class="SimpleMath">M</span>, so all primitive permutation characters can be computed via the function <code class="code">PrimitivePermutationCharacters</code> for <span class="SimpleMath">24</span> of the <span class="SimpleMath">26</span> sporadic simple groups.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sporinfo:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spornames:= AllCharacterTableNames( IsSporadicSimple, true,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                       IsDuplicateTable, false );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for tbl in List( spornames, CharacterTable ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     info:= ProbGenInfoSimple( tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if info &lt;&gt; fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Add( sporinfo, info );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
</pre></div>

<p>We show the result as a formatted table.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintFormattedArray( sporinfo );</span>
   Co1    421/1545600         3671        [ "35A" ]    [ 4 ]
   Co2          1/270          269        [ "23A" ]    [ 1 ]
   Co3        64/6325           98        [ "21A" ]    [ 4 ]
   F3+ 1/269631216855 269631216854        [ "29A" ]    [ 1 ]
  Fi22         43/585           13        [ "16A" ]    [ 7 ]
  Fi23   2651/2416635          911        [ "23A" ]    [ 2 ]
    HN        4/34375         8593        [ "19A" ]    [ 1 ]
    HS        64/1155           18        [ "15A" ]    [ 2 ]
    He          3/595          198        [ "14C" ]    [ 3 ]
    J1           1/77           76        [ "19A" ]    [ 1 ]
    J2           5/28            5        [ "10C" ]    [ 3 ]
    J3          2/153           76        [ "19A" ]    [ 2 ]
    J4   1/1647124116   1647124115        [ "29A" ]    [ 1 ]
    Ly     1/35049375     35049374        [ "37A" ]    [ 1 ]
   M11            1/3            2        [ "11A" ]    [ 1 ]
   M12            1/3            2        [ "10A" ]    [ 3 ]
   M22           1/21           20        [ "11A" ]    [ 1 ]
   M23         1/8064         8063        [ "23A" ]    [ 1 ]
   M24       108/1265           11        [ "21A" ]    [ 2 ]
   McL      317/22275           70 [ "15A", "30A" ] [ 3, 3 ]
    ON       10/30723         3072        [ "31A" ]    [ 2 ]
    Ru         1/2880         2879        [ "29A" ]    [ 1 ]
   Suz       141/5720           40        [ "14A" ]    [ 3 ]
    Th       2/267995       133997 [ "27A", "27B" ] [ 2, 2 ]
</pre></div>

<p>We see that in all these cases, <span class="SimpleMath">σ(G) &lt; 1/2</span> and thus <span class="SimpleMath">P( G ) ≥ 2</span>, and all sporadic simple groups <span class="SimpleMath">G</span> except <span class="SimpleMath">G = M_11</span> and <span class="SimpleMath">G = M_12</span> satisfy <span class="SimpleMath">σ(G) &lt; 1/3</span>. See <a href="chap11.html#X7B7061917ED3714D"><span class="RefLink">11.5-9</span></a> and <a href="chap11.html#X82E0F48A7FF82BB3"><span class="RefLink">11.5-10</span></a> for a proof that also these two groups have uniform spread at least three.</p>

<p>The structures and multiplicities of the maximal subgroups containing <span class="SimpleMath">s</span> are as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for entry in sporinfo do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     DisplayProbGenMaxesInfo( CharacterTable( entry[1] ), entry[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">od;</span>
Co1, 35A: (A5xJ2):2  (1)
          (A6xU3(3)):2  (2)
          (A7xL2(7)):2  (1)
Co2, 23A: M23  (1)
Co3, 21A: U3(5).3.2  (2)
          L3(4).D12  (1)
          s3xpsl(2,8).3  (1)
F3+, 29A: 29:14  (1)
Fi22, 16A: 2^10:m22  (1)
           (2x2^(1+8)):U4(2):2  (1)
           2F4(2)'  (4)
           2^(5+8):(S3xA6)  (1)
Fi23, 23A: 2..11.m23  (1)
           L2(23)  (1)
HN, 19A: U3(8).3_1  (1)
HS, 15A: A8.2  (1)
         5:4xa5  (1)
He, 14C: 2^1+6.psl(3,2)  (1)
         7^2:2psl(2,7)  (1)
         7^(1+2):(S3x3)  (1)
J1, 19A: 19:6  (1)
J2, 10C: 2^1+4b:a5  (1)
         a5xd10  (1)
         5^2:D12  (1)
J3, 19A: L2(19)  (1)
         J3M3  (1)
J4, 29A: frob  (1)
Ly, 37A: 37:18  (1)
M11, 11A: L2(11)  (1)
M12, 10A: A6.2^2  (1)
          M12M4  (1)
          2xS5  (1)
M22, 11A: L2(11)  (1)
M23, 23A: 23:11  (1)
M24, 21A: L3(4).3.2_2  (1)
          2^6:(psl(3,2)xs3)  (1)
McL, 15A: 3^(1+4):2S5  (1)
          2.A8  (1)
          5^(1+2):3:8  (1)
McL, 30A: 3^(1+4):2S5  (1)
          2.A8  (1)
          5^(1+2):3:8  (1)
ON, 31A: L2(31)  (1)
         ONM8  (1)
Ru, 29A: L2(29)  (1)
Suz, 14A: J2.2  (2)
          (a4xpsl(3,4)):2  (1)
Th, 27A: ThN3B  (1)
         ThM7  (1)
Th, 27B: ThN3B  (1)
         ThM7  (1)
</pre></div>

<p>For the remaining two sporadic simple groups, <span class="SimpleMath">B</span> and <span class="SimpleMath">M</span>, we choose suitable elements <span class="SimpleMath">s</span>. If <span class="SimpleMath">G = B</span> and <span class="SimpleMath">s ∈ G</span> is of order <span class="SimpleMath">47</span> then, by <a href="chapBib.html#biBWil99">[Wil99]</a>, <span class="SimpleMath">𝕄(G,s) = { 47:23 }</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "B" ), "47A",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ CharacterTable( "47:23" ) ], [ 1 ] );</span>
1/174702778623598780219392000000
</pre></div>

<p>If <span class="SimpleMath">G = M</span> and <span class="SimpleMath">s ∈ G</span> is of order <span class="SimpleMath">59</span> then, by <a href="chapBib.html#biBHW04">[HW04]</a>, <span class="SimpleMath">𝕄(G,s) = { L_2(59) }</span>. In this case, the permutation character is not uniquely determined by the character tables, but all possibilities lead to the same value for <span class="SimpleMath">σ(G)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "M" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= CharacterTable( "L2(59)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters( s, t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( pi );</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 59 );</span>
152
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set( pi, x -&gt; Maximum( ApproxP( [ x ], spos ) ) );</span>
[ 1/3385007637938037777290625 ]
</pre></div>

<p>Essentially the same approach is taken in <a href="chapBib.html#biBGM01">[GM01]</a>. However, there <span class="SimpleMath">s</span> is restricted to classes of prime order. Thus the results in the above table are better for <span class="SimpleMath">J_2</span>, <span class="SimpleMath">HS</span>, <span class="SimpleMath">M_24</span>, <span class="SimpleMath">McL</span>, <span class="SimpleMath">He</span>, <span class="SimpleMath">Suz</span>, <span class="SimpleMath">Co_3</span>, <span class="SimpleMath">Fi_22</span>, <span class="SimpleMath">Ly</span>, <span class="SimpleMath">Th</span>, <span class="SimpleMath">Co_1</span>, and <span class="SimpleMath">J_4</span>. Besides that, the value <span class="SimpleMath">10999</span> claimed in <a href="chapBib.html#biBGM01">[GM01]</a> for <span class="SimpleMath">𝕊/~( HN )</span> is not correct.</p>

<p><a id="X84E9D10F80A74A53" name="X84E9D10F80A74A53"></a></p>

<h5>11.4-2 <span class="Heading">Automorphism Groups of Sporadic Simple Groups</span></h5>

<p>Next we consider the automorphism groups of the sporadic simple groups. There are exactly <span class="SimpleMath">12</span> cases where nontrivial outer automorphisms exist, and then the simple group <span class="SimpleMath">S</span> has index <span class="SimpleMath">2</span> in its automorphism group <span class="SimpleMath">G</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sporautnames:= AllCharacterTableNames( IsSporadicSimple, true,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                      IsDuplicateTable, false,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                      OfThose, AutomorphismGroup );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sporautnames:= Difference( sporautnames, spornames );</span>
[ "F3+.2", "Fi22.2", "HN.2", "HS.2", "He.2", "J2.2", "J3.2", "M12.2", 
  "M22.2", "McL.2", "ON.2", "Suz.2" ]
</pre></div>

<p>First we compute the values <span class="SimpleMath">σ^'(G,s)</span>, for the same <span class="SimpleMath">s ∈ S</span> that were chosen for the simple group <span class="SimpleMath">S</span> in Section <a href="chap11.html#X86CE51E180A3D4ED"><span class="RefLink">11.4-1</span></a>.</p>

<p>For six of the groups <span class="SimpleMath">G</span> in question, the character tables of all maximal subgroups are available in the <strong class="pkg">GAP</strong> Character Table Library. In these cases, the values <span class="SimpleMath">σ^'( G, s )</span> can be computed using <code class="code">ProbGenInfoAlmostSimple</code>.</p>

<p><em>(The above statement can meanwhile be replaced by the statement that the character tables of all maximal subgroups are available for all twelve groups. We show the table results for all these groups but keep the individual computations from the original computations.)</em></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sporautinfo:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fails:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for name in sporautnames do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tbl:= CharacterTable( name{ [ 1 .. Position( name, '.' ) - 1 ] } );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblG:= CharacterTable( name );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     info:= ProbGenInfoSimple( tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     info:= ProbGenInfoAlmostSimple( tbl, tblG,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         List( info[4], x -&gt; Position( AtlasClassNames( tbl ), x ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if info = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Add( fails, name );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Add( sporautinfo, info );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintFormattedArray( sporautinfo );</span>
   F3+.2         0         [ "29AB" ]    [ 1 ]
  Fi22.2  251/3861         [ "16AB" ]    [ 7 ]
    HN.2    1/6875         [ "19AB" ]    [ 1 ]
    HS.2    36/275          [ "15A" ]    [ 2 ]
    He.2   37/9520         [ "14CD" ]    [ 3 ]
    J2.2      1/15         [ "10CD" ]    [ 3 ]
    J3.2    1/1080         [ "19AB" ]    [ 1 ]
   M12.2      4/99          [ "10A" ]    [ 1 ]
   M22.2      1/21         [ "11AB" ]    [ 1 ]
   McL.2      1/63 [ "15AB", "30AB" ] [ 3, 3 ]
    ON.2   1/84672         [ "31AB" ]    [ 1 ]
   Suz.2 661/46332          [ "14A" ]    [ 3 ]
</pre></div>

<p>Note that for <span class="SimpleMath">S = McL</span>, the bound <span class="SimpleMath">σ^'(G,s)</span> for <span class="SimpleMath">G = S.2</span> (in the second column) is worse than the bound for the simple group <span class="SimpleMath">S</span>.</p>

<p>The structures and multiplicities of the maximal subgroups containing <span class="SimpleMath">s</span> are as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for entry in sporautinfo do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     DisplayProbGenMaxesInfo( CharacterTable( entry[1] ), entry[3] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">od;</span>
F3+.2, 29AB: F3+  (1)
             frob  (1)
Fi22.2, 16AB: Fi22  (1)
              Fi22.2M4  (1)
              (2x2^(1+8)):(U4(2):2x2)  (1)
              2F4(2)'.2  (4)
              2^(5+8):(S3xS6)  (1)
HN.2, 19AB: HN  (1)
            U3(8).6  (1)
HS.2, 15A: HS  (1)
           S8x2  (1)
           5:4xS5  (1)
He.2, 14CD: He  (1)
            2^(1+6)_+.L3(2).2  (1)
            7^2:2.L2(7).2  (1)
            7^(1+2):(S3x6)  (1)
J2.2, 10CD: J2  (1)
            2^(1+4).S5  (1)
            (A5xD10).2  (1)
            5^2:(4xS3)  (1)
J3.2, 19AB: J3  (1)
            19:18  (1)
M12.2, 10A: M12  (1)
            (2^2xA5):2  (1)
M22.2, 11AB: M22  (1)
             L2(11).2  (1)
McL.2, 15AB: McL  (1)
             3^(1+4):4S5  (1)
             Isoclinic(2.A8.2)  (1)
             5^(1+2):(24:2)  (1)
McL.2, 30AB: McL  (1)
             3^(1+4):4S5  (1)
             Isoclinic(2.A8.2)  (1)
             5^(1+2):(24:2)  (1)
ON.2, 31AB: ON  (1)
            31:30  (1)
Suz.2, 14A: Suz  (1)
            J2.2x2  (2)
            (A4xL3(4):2_3):2  (1)
</pre></div>

<p>Note that the maximal subgroups <span class="SimpleMath">L_2(19)</span> of <span class="SimpleMath">J_3</span> do not extend to <span class="SimpleMath">J_3.2</span> and that a class of maximal subgroups of the type <span class="SimpleMath">19:18</span> appears in <span class="SimpleMath">J_3.2</span> whose intersection with <span class="SimpleMath">J_3</span> is not maximal in <span class="SimpleMath">J_3</span>. Similarly, the maximal subgroups <span class="SimpleMath">A_6.2^2</span> of <span class="SimpleMath">M_12</span> do not extend to <span class="SimpleMath">M_12.2</span>.</p>

<p>For the other six groups, we use individual computations.</p>

<p>In the case <span class="SimpleMath">S = Fi_24^'</span>, the unique maximal subgroup <span class="SimpleMath">29:14</span> that contains an element <span class="SimpleMath">s</span> of order <span class="SimpleMath">29</span> extends to a group of the type <span class="SimpleMath">29:28</span> in <span class="SimpleMath">Fi_24</span>, which is a nonsplit extension of <span class="SimpleMath">29:14</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "Fi24'.2" ), "29AB",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ CharacterTable( "29:28" ) ], [ 1 ], "outer" );</span>
0
</pre></div>

<p>In the case <span class="SimpleMath">S = Fi_22</span>, there are four classes of maximal subgroups that contain <span class="SimpleMath">s</span> of order <span class="SimpleMath">16</span>. They extend to <span class="SimpleMath">G = Fi_22.2</span>, and none of the <em>novelties</em> in <span class="SimpleMath">G</span> (i. e., subgroups of <span class="SimpleMath">G</span> that are maximal in <span class="SimpleMath">G</span> but whose intersections with <span class="SimpleMath">S</span> are not maximal in <span class="SimpleMath">S</span>) contains <span class="SimpleMath">s</span>, cf. <a href="chapBib.html#biBCCN85">[CCN+85, p. 163]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">16 in OrdersClassRepresentatives( CharacterTable( "U4(2).2" ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">16 in OrdersClassRepresentatives( CharacterTable( "G2(3).2" ) );</span>
false
</pre></div>

<p>The character tables of three of the four extensions are available in the <strong class="pkg">GAP</strong> Character Table Library. The permutation character on the cosets of the fourth extension can be obtained as the extension of the permutation character of <span class="SimpleMath">S</span> on the cosets of its maximal subgroup of the type <span class="SimpleMath">2^5+8:(S_3 × A_6)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "Fi22.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= List( [ "Fi22.2M4", "(2x2^(1+8)):(U4(2):2x2)", "2F4(2)" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       n -&gt; PossiblePermutationCharacters( CharacterTable( n ), t2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "Fi22" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            CharacterTable( "2^(5+8):(S3xA6)" ), t );</span>
[ Character( CharacterTable( "Fi22" ),
  [ 3648645, 56133, 10629, 2245, 567, 729, 405, 81, 549, 165, 133, 
      37, 69, 20, 27, 81, 9, 39, 81, 19, 1, 13, 33, 13, 1, 0, 13, 13, 
      5, 1, 0, 0, 0, 8, 4, 0, 0, 9, 3, 15, 3, 1, 1, 1, 1, 3, 3, 1, 0, 
      0, 0, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">torso:= CompositionMaps( pi[1], InverseMap( GetFusionMap( t, t2 ) ) );</span>
[ 3648645, 56133, 10629, 2245, 567, 729, 405, 81, 549, 165, 133, 37, 
  69, 20, 27, 81, 9, 39, 81, 19, 1, 13, 33, 13, 1, 0, 13, 13, 5, 1, 
  0, 0, 0, 8, 4, 0, 9, 3, 15, 3, 1, 1, 1, 3, 3, 1, 0, 0, 2, 1, 0, 0, 
  0, 0, 0, 0, 1, 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= PermChars( t2, rec( torso:= torso ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Add( prim, ext );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= Concatenation( prim );;  Length( prim );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t2 ), 16 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( prim, x -&gt; x[ spos ] );</span>
[ 1, 1, 4, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sigma:= ApproxP( prim, spos );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( sigma{ Difference( PositionsProperty(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       OrdersClassRepresentatives( t2 ), IsPrimeInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       ClassPositionsOfDerivedSubgroup( t2 ) ) } );</span>
251/3861
</pre></div>

<p>In the case <span class="SimpleMath">S = HN</span>, the unique maximal subgroup <span class="SimpleMath">U_3(8).3</span> that contains the fixed element <span class="SimpleMath">s</span> of order <span class="SimpleMath">19</span> extends to a group of the type <span class="SimpleMath">U_3(8).6</span> in <span class="SimpleMath">HN.2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "HN.2" ), "19AB",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ CharacterTable( "U3(8).6" ) ], [ 1 ], "outer" );</span>
1/6875
</pre></div>

<p>In the case <span class="SimpleMath">S = HS</span>, there are two classes of maximal subgroups that contain <span class="SimpleMath">s</span> of order <span class="SimpleMath">15</span>. They extend to <span class="SimpleMath">G = HS.2</span>, and none of the novelties in <span class="SimpleMath">G</span> contains <span class="SimpleMath">s</span> (cf. <a href="chapBib.html#biBCCN85">[CCN+85, p. 80]</a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "HS.2" ), "15A",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ CharacterTable( "S8x2" ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "5:4" ) * CharacterTable( "A5.2" ) ], [ 1, 1 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     "outer" );</span>
36/275
</pre></div>

<p>In the case <span class="SimpleMath">S = He</span>, there are three classes of maximal subgroups that contain <span class="SimpleMath">s</span> in the class <code class="code">14C</code>. They extend to <span class="SimpleMath">G = He.2</span>, and none of the novelties in <span class="SimpleMath">G</span> contains <span class="SimpleMath">s</span> (cf. <a href="chapBib.html#biBCCN85">[CCN+85, p. 104]</a>). We compute the extensions of the corresponding primitive permutation characters of <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "He" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "He.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= PrimitivePermutationCharacters( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( AtlasClassNames( t ), "14C" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= Filtered( prim, x -&gt; x[ spos ] &lt;&gt; 0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map:= InverseMap( GetFusionMap( t, t2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">torso:= List( prim, pi -&gt; CompositionMaps( pi, map ) );</span>
[ [ 187425, 945, 449, 0, 21, 21, 25, 25, 0, 0, 5, 0, 0, 7, 1, 0, 0, 
      1, 0, 1, 0, 0, 0, 0, 0, 0 ], 
  [ 244800, 0, 64, 0, 84, 0, 0, 16, 0, 0, 4, 24, 45, 3, 4, 0, 0, 0, 
      0, 1, 0, 0, 0, 0, 0, 0 ], 
  [ 652800, 0, 512, 120, 72, 0, 0, 0, 0, 0, 8, 8, 22, 1, 0, 0, 0, 0, 
      0, 1, 0, 0, 1, 1, 2, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= List( torso, x -&gt; PermChars( t2, rec( torso:= x ) ) );</span>
[ [ Character( CharacterTable( "He.2" ),
      [ 187425, 945, 449, 0, 21, 21, 25, 25, 0, 0, 5, 0, 0, 7, 1, 0, 
          0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 315, 15, 0, 0, 3, 7, 7, 3, 0, 
          0, 0, 1, 1, 0, 1, 1, 0, 0, 0 ] ) ], 
  [ Character( CharacterTable( "He.2" ),
      [ 244800, 0, 64, 0, 84, 0, 0, 16, 0, 0, 4, 24, 45, 3, 4, 0, 0, 
          0, 0, 1, 0, 0, 0, 0, 0, 0, 360, 0, 0, 0, 6, 0, 0, 0, 0, 0, 
          3, 2, 2, 0, 0, 0, 0, 0, 0 ] ) ], 
  [ Character( CharacterTable( "He.2" ),
      [ 652800, 0, 512, 120, 72, 0, 0, 0, 0, 0, 8, 8, 22, 1, 0, 0, 0, 
          0, 0, 1, 0, 0, 1, 1, 2, 0, 480, 0, 120, 0, 12, 0, 0, 0, 0, 
          0, 4, 0, 0, 0, 0, 0, 0, 1, 1 ] ) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( AtlasClassNames( t2 ), "14CD" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sigma:= ApproxP( Concatenation( ext ), spos );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( sigma{ Difference( PositionsProperty(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       OrdersClassRepresentatives( t2 ), IsPrimeInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       ClassPositionsOfDerivedSubgroup( t2 ) ) } );</span>
37/9520
</pre></div>

<p>In the case <span class="SimpleMath">S = O'N</span>, the two classes of maximal subgroups of the type <span class="SimpleMath">L_2(31)</span> do not extend to <span class="SimpleMath">G = O'N.2</span>, and a class of novelties of the structure <span class="SimpleMath">31:30</span> appears (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 132]</a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "ON.2" ), "31AB",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ CharacterTable( "P:Q", [ 31, 30 ] ) ], [ 1 ], "outer" );</span>
1/84672
</pre></div>

<p>Now we consider also <span class="SimpleMath">σ(G,hats)</span>, for suitable <span class="SimpleMath">hats ∈ G ∖ S</span>; this yields lower bounds for the spread of the nonsimple groups <span class="SimpleMath">G</span>. (These results are shown in the last two columns of <a href="chapBib.html#biBBGK">[BGK08, Table 9]</a>.)</p>

<p>As above, we use the known character tables of the maximal subgroups in order to compute the optimal choice for <span class="SimpleMath">hats ∈ G ∖ S</span>. (We may use the function <code class="code">ProbGenInfoSimple</code> although the groups are not simple; all we need is that the relevant maximal subgroups are self-normalizing.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sporautinfo2:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for name in List( sporautinfo, x -&gt; x[1] ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Add( sporautinfo2, ProbGenInfoSimple( CharacterTable( name ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintFormattedArray( sporautinfo2 );</span>
   F3+.2    19/5684  299        [ "42E" ]   [ 10 ]
  Fi22.2 1165/20592   17        [ "24G" ]    [ 3 ]
    HN.2     1/1425 1424        [ "24B" ]    [ 4 ]
    HS.2     21/550   26        [ "20C" ]    [ 4 ]
    He.2    33/4165  126        [ "24A" ]    [ 2 ]
    J2.2       1/15   14        [ "14A" ]    [ 1 ]
    J3.2   77/10260  133        [ "34A" ]    [ 1 ]
   M12.2    113/495    4        [ "12B" ]    [ 3 ]
   M22.2       8/33    4        [ "10A" ]    [ 4 ]
   McL.2      1/135  134        [ "22A" ]    [ 1 ]
    ON.2  61/109368 1792 [ "22A", "38A" ] [ 1, 1 ]
   Suz.2      1/351  350        [ "28A" ]    [ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for entry in sporautinfo2 do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     DisplayProbGenMaxesInfo( CharacterTable( entry[1] ), entry[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">od;</span>
F3+.2, 42E: 2^12.M24  (2)
            2^2.U6(2):S3x2  (1)
            2^(3+12).(L3(2)xS6)  (2)
            (S3xS3xG2(3)):2  (1)
            S6xL2(8):3  (1)
            7:6xS7  (1)
            7^(1+2)_+:(6xS3).2  (2)
Fi22.2, 24G: Fi22.2M4  (1)
             2^(5+8):(S3xS6)  (1)
             3^5:(2xU4(2).2)  (1)
HN.2, 24B: 2^(1+8)_+.(A5xA5).2^2  (1)
           5^2.5.5^2.4S5  (2)
           HN.2M13  (1)
HS.2, 20C: (2xA6.2^2).2  (1)
           HS.2N5  (2)
           5:4xS5  (1)
He.2, 24A: 2^(1+6)_+.L3(2).2  (1)
           S4xL3(2).2  (1)
J2.2, 14A: L3(2).2x2  (1)
J3.2, 34A: L2(17)x2  (1)
M12.2, 12B: L2(11).2  (1)
            D8.(S4x2)  (1)
            3^(1+2):D8  (1)
M22.2, 10A: M22.2M4  (1)
            A6.2^2  (1)
            L2(11).2  (2)
McL.2, 22A: 2xM11  (1)
ON.2, 22A: J1x2  (1)
ON.2, 38A: J1x2  (1)
Suz.2, 28A: (A4xL3(4):2_3):2  (1)
</pre></div>

<p>In the other six cases, we do not have the complete lists of primitive permutation characters, so we choose a suitable element <span class="SimpleMath">hats</span> for each group. It is sufficient to prescribe <span class="SimpleMath">|hats|</span>, as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sporautchoices:= [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ "Fi22",  "Fi22.2",  42 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ "Fi24'", "Fi24'.2", 46 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ "He",    "He.2",    42 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ "HN",    "HN.2",    44 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ "HS",    "HS.2",    30 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ "ON",    "ON.2",    38 ], ];;</span>
</pre></div>

<p>First we list the maximal subgroups of the corresponding simple groups that contain the square of <span class="SimpleMath">hats</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for triple in sporautchoices do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tbl:= CharacterTable( triple[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tbl2:= CharacterTable( triple[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     spos2:= PowerMap( tbl2, 2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Position( OrdersClassRepresentatives( tbl2 ), triple[3] ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     spos:= Position( GetFusionMap( tbl, tbl2 ), spos2 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     DisplayProbGenMaxesInfo( tbl, AtlasClassNames( tbl ){ [ spos ] } );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
Fi22, 21A: O8+(2).3.2  (1)
           S3xU4(3).2_2  (1)
           A10.2  (1)
           A10.2  (1)
F3+, 23A: Fi23  (1)
          F3+M7  (1)
He, 21B: 3.A7.2  (1)
         7^(1+2):(S3x3)  (1)
         7:3xpsl(3,2)  (2)
HN, 22A: 2.HS.2  (1)
HS, 15A: A8.2  (1)
         5:4xa5  (1)
ON, 19B: L3(7).2  (1)
         ONM2  (1)
         J1  (1)
</pre></div>

<p>According to <a href="chapBib.html#biBCCN85">[CCN+85]</a>, exactly the following maximal subgroups of the simple group <span class="SimpleMath">S</span> in the above list do <em>not</em> extend to <span class="SimpleMath">Aut(S)</span>: The two <span class="SimpleMath">S_10</span> type subgroups of <span class="SimpleMath">Fi_22</span> and the two <span class="SimpleMath">L_3(7).2</span> type subgroups of <span class="SimpleMath">O'N</span>.</p>

<p>Furthermore, the following maximal subgroups of <span class="SimpleMath">Aut(S)</span> with the property that the intersection with <span class="SimpleMath">S</span> is not maximal in <span class="SimpleMath">S</span> have to be considered whether they contain <span class="SimpleMath">s^'</span>: <span class="SimpleMath">G_2(3).2</span> and <span class="SimpleMath">3^5:(2 × U_4(2).2)</span> in <span class="SimpleMath">Fi_22.2</span>. (Note that the order of the <span class="SimpleMath">7^1+2_+:(3 × D_16)</span> type subgroup in <span class="SimpleMath">O'N.2</span> is obviously not divisible by <span class="SimpleMath">19</span>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">42 in OrdersClassRepresentatives( CharacterTable( "G2(3).2" ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( CharacterTable( "U4(2)" ) ) mod 7 = 0;</span>
false
</pre></div>

<p>So we take the extensions of the above maximal subgroups, as described in <a href="chapBib.html#biBCCN85">[CCN+85]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "Fi22.2" ), "42A",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ CharacterTable( "O8+(2).3.2" ) * CharacterTable( "Cyclic", 2 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      CharacterTable( "S3" ) * CharacterTable( "U4(3).(2^2)_{122}" ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ 1, 1 ] );</span>
163/1170
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "Fi24'.2" ), "46A",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ CharacterTable( "Fi23" ) * CharacterTable( "Cyclic", 2 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "2^12.M24" ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ 1, 1 ] );</span>
566/5481
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "He.2" ), "42A",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ CharacterTable( "3.A7.2" ) * CharacterTable( "Cyclic", 2 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "7^(1+2):(S3x6)" ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "7:6" ) * CharacterTable( "L3(2)" ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ 1, 1, 1 ] );</span>
1/119
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "HN.2" ), "44A",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ CharacterTable( "4.HS.2" ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ 1 ] );</span>
997/192375
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "HS.2" ), "30A",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ CharacterTable( "S8" ) * CharacterTable( "C2" ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "5:4" ) * CharacterTable( "S5" ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ 1, 1 ] );</span>
36/275
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "ON.2" ), "38A",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ CharacterTable( "J1" ) * CharacterTable( "C2" ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ 1 ] );</span>
61/109368
</pre></div>

<p><a id="X80DA58F187CDCF5F" name="X80DA58F187CDCF5F"></a></p>

<h5>11.4-3 <span class="Heading">Other Simple Groups – Easy Cases</span></h5>

<p>We are interested in simple groups <span class="SimpleMath">G</span> for which <code class="code">ProbGenInfoSimple</code> does not guarantee <span class="SimpleMath">𝕊/~(G) ≥ 3</span>. So we examine the remaining tables of simple groups in the <strong class="pkg">GAP</strong> Character Table Library, and distinguish the following three cases: Either <code class="code">ProbGenInfoSimple</code> yields the lower bound at least three, or a smaller bound, or the computation of a lower bound fails because not enough information is available to compute the primitive permutation characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">names:= AllCharacterTableNames( IsSimple, true, IsAbelian, false,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                   IsDuplicateTable, false );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">names:= Difference( names, spornames );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fails:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lessthan3:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">atleast3:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for name in names do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tbl:= CharacterTable( name );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     info:= ProbGenInfoSimple( tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if info = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Add( fails, name );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     elif info[3] &lt; 3 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Add( lessthan3, info );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Add( atleast3, info );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
</pre></div>

<p>For the following simple groups, (currently) not enough information is available in the <strong class="pkg">GAP</strong> Character Table Library and in the <strong class="pkg">GAP</strong> Library of Tables of Marks, for computing a lower bound for <span class="SimpleMath">σ(G)</span>. Some of these groups will be dealt with in later sections, and for the other groups, the bounds derived with theoretical arguments in <a href="chapBib.html#biBBGK">[BGK08]</a> are sufficient, so we need no <strong class="pkg">GAP</strong> computations for them.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fails;</span>
[ "2E6(2)", "2F4(8)", "3D4(3)", "3D4(4)", "A14", "A15", "A16", "A17", 
  "A18", "A19", "E6(2)", "L4(4)", "L4(5)", "L4(9)", "L5(3)", "L8(2)", 
  "O10+(2)", "O10+(3)", "O10-(2)", "O10-(3)", "O12+(2)", "O12+(3)", 
  "O12-(2)", "O12-(3)", "O7(5)", "O8+(7)", "O8-(3)", "O9(3)", 
  "R(27)", "S10(2)", "S12(2)", "S4(7)", "S4(8)", "S4(9)", "S6(4)", 
  "S6(5)", "S8(3)", "U4(4)", "U4(5)", "U5(3)", "U5(4)", "U6(4)", 
  "U7(2)" ]
</pre></div>

<p>The following simple groups appear in <a href="chapBib.html#biBBGK">[BGK08, Table 1–6]</a>. More detailed computations can be found in the sections <a href="chap11.html#X7B5321337B28100B"><span class="RefLink">11.5-2</span></a>, <a href="chap11.html#X82C3B4287B0C7BEE"><span class="RefLink">11.5-3</span></a>, <a href="chap11.html#X85B3C7217B105D4D"><span class="RefLink">11.5-4</span></a>, <a href="chap11.html#X7F80F2527C424AA4"><span class="RefLink">11.5-12</span></a>, <a href="chap11.html#X78F0815B86253A1F"><span class="RefLink">11.5-13</span></a>, <a href="chap11.html#X82CFBAF07D3487A0"><span class="RefLink">11.5-20</span></a>, <a href="chap11.html#X7A03F8EC839AF0B5"><span class="RefLink">11.5-23</span></a>, <a href="chap11.html#X7D738BE5804CF22E"><span class="RefLink">11.5-24</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintFormattedArray( lessthan3 );</span>
      A5      1/3 2                [ "5A" ]       [ 1 ]
      A6      2/3 1                [ "5A" ]       [ 2 ]
      A7      2/5 2                [ "7A" ]       [ 2 ]
   O7(3)  199/351 1               [ "14A" ]       [ 3 ]
  O8+(2)  334/315 0 [ "15A", "15B", "15C" ] [ 7, 7, 7 ]
  O8+(3) 863/1820 2 [ "20A", "20B", "20C" ] [ 8, 8, 8 ]
   S6(2)      4/7 1                [ "9A" ]       [ 4 ]
   S8(2)     8/15 1               [ "17A" ]       [ 3 ]
   U4(2)    21/40 1               [ "12A" ]       [ 2 ]
   U4(3)   53/135 2                [ "7A" ]       [ 7 ]
</pre></div>

<p>For the following simple groups <span class="SimpleMath">G</span>, the inequality <span class="SimpleMath">σ(G) &lt; 1/3</span> follows from the loop above. The columns show the name of <span class="SimpleMath">G</span>, the values <span class="SimpleMath">σ(G)</span> and <span class="SimpleMath">𝕊/~(G)</span>, the class names of <span class="SimpleMath">s</span> for which these values are attained, and <span class="SimpleMath">|𝕄(G,s)|</span>.</p>

<p>(We increase the line length for this table. Even with this width, the entry for the group <span class="SimpleMath">L_7(2)</span> would not fit on one screen line, we show it separately below.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">oldsize:= SizeScreen();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen( [ 80 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintFormattedArray( Filtered( atleast3, l -&gt; l[1] &lt;&gt; "L7(2)" ) );</span>
  2F4(2)'  118/1755   14                           [ "16A" ]             [ 2 ]
   3D4(2)    1/5292 5291                           [ "13A" ]             [ 1 ]
      A10      3/10    3                           [ "21A" ]             [ 1 ]
      A11     2/105   52                           [ "11A" ]             [ 2 ]
      A12       2/9    4                           [ "35A" ]             [ 1 ]
      A13    4/1155  288                           [ "13A" ]             [ 5 ]
       A8      3/14    4                           [ "15A" ]             [ 1 ]
       A9      9/35    3                      [ "9A", "9B" ]          [ 4, 4 ]
    F4(2)     9/595   66                           [ "13A" ]             [ 5 ]
    G2(3)       1/7    6                           [ "13A" ]             [ 3 ]
    G2(4)      1/21   20                           [ "13A" ]             [ 2 ]
    G2(5)      1/31   30                     [ "7A", "21A" ]         [ 10, 1 ]
  L2(101)     1/101  100                    [ "51A", "17A" ]          [ 1, 1 ]
  L2(103)   53/5253   99             [ "52A", "26A", "13A" ]       [ 1, 1, 1 ]
  L2(107)   55/5671  103 [ "54A", "27A", "18A", "9A", "6A" ] [ 1, 1, 1, 1, 1 ]
  L2(109)     1/109  108                    [ "55A", "11A" ]          [ 1, 1 ]
   L2(11)      7/55    7                            [ "6A" ]             [ 1 ]
  L2(113)     1/113  112                    [ "57A", "19A" ]          [ 1, 1 ]
  L2(121)     1/121  120                           [ "61A" ]             [ 1 ]
  L2(125)     1/125  124        [ "63A", "21A", "9A", "7A" ]    [ 1, 1, 1, 1 ]
   L2(13)      1/13   12                            [ "7A" ]             [ 1 ]
   L2(16)      1/15   14                           [ "17A" ]             [ 1 ]
   L2(17)      1/17   16                            [ "9A" ]             [ 1 ]
   L2(19)    11/171   15                           [ "10A" ]             [ 1 ]
   L2(23)    13/253   19                     [ "6A", "12A" ]          [ 1, 1 ]
   L2(25)      1/25   24                           [ "13A" ]             [ 1 ]
   L2(27)     5/117   23                     [ "7A", "14A" ]          [ 1, 1 ]
   L2(29)      1/29   28                           [ "15A" ]             [ 1 ]
   L2(31)    17/465   27                     [ "8A", "16A" ]          [ 1, 1 ]
   L2(32)      1/31   30              [ "3A", "11A", "33A" ]       [ 1, 1, 1 ]
   L2(37)      1/37   36                           [ "19A" ]             [ 1 ]
   L2(41)      1/41   40                     [ "21A", "7A" ]          [ 1, 1 ]
   L2(43)    23/903   39                    [ "22A", "11A" ]          [ 1, 1 ]
   L2(47)   25/1081   43        [ "24A", "12A", "8A", "6A" ]    [ 1, 1, 1, 1 ]
   L2(49)      1/49   48                           [ "25A" ]             [ 1 ]
   L2(53)      1/53   52                     [ "27A", "9A" ]          [ 1, 1 ]
   L2(59)   31/1711   55       [ "30A", "15A", "10A", "6A" ]    [ 1, 1, 1, 1 ]
   L2(61)      1/61   60                           [ "31A" ]             [ 1 ]
   L2(64)      1/63   62                    [ "65A", "13A" ]          [ 1, 1 ]
   L2(67)   35/2211   63                    [ "34A", "17A" ]          [ 1, 1 ]
   L2(71)   37/2485   67 [ "36A", "18A", "12A", "9A", "6A" ] [ 1, 1, 1, 1, 1 ]
   L2(73)      1/73   72                           [ "37A" ]             [ 1 ]
   L2(79)   41/3081   75       [ "40A", "20A", "10A", "8A" ]    [ 1, 1, 1, 1 ]
    L2(8)       1/7    6                      [ "3A", "9A" ]          [ 1, 1 ]
   L2(81)      1/81   80                           [ "41A" ]             [ 1 ]
   L2(83)   43/3403   79 [ "42A", "21A", "14A", "7A", "6A" ] [ 1, 1, 1, 1, 1 ]
   L2(89)      1/89   88              [ "45A", "15A", "9A" ]       [ 1, 1, 1 ]
   L2(97)      1/97   96                     [ "49A", "7A" ]          [ 1, 1 ]
   L3(11)    1/6655 6654                   [ "19A", "133A" ]          [ 1, 1 ]
    L3(2)       1/4    3                            [ "7A" ]             [ 1 ]
    L3(3)      1/24   23                           [ "13A" ]             [ 1 ]
    L3(4)       1/5    4                            [ "7A" ]             [ 3 ]
    L3(5)     1/250  249                           [ "31A" ]             [ 1 ]
    L3(7)    1/1372 1371                           [ "19A" ]             [ 1 ]
    L3(8)    1/1792 1791                           [ "73A" ]             [ 1 ]
    L3(9)    1/2880 2879                           [ "91A" ]             [ 1 ]
    L4(3)   53/1053   19                           [ "20A" ]             [ 1 ]
    L5(2)    1/5376 5375                           [ "31A" ]             [ 1 ]
    L6(2) 365/55552  152                    [ "21A", "63A" ]          [ 2, 2 ]
   O8-(2)      1/63   62                           [ "17A" ]             [ 1 ]
    S4(4)      4/15    3                           [ "17A" ]             [ 2 ]
    S4(5)       1/5    4                           [ "13A" ]             [ 1 ]
    S6(3)     1/117  116                           [ "14A" ]             [ 2 ]
   Sz(32)    1/1271 1270                     [ "5A", "25A" ]          [ 1, 1 ]
    Sz(8)      1/91   90                            [ "5A" ]             [ 1 ]
   U3(11)    1/6655 6654                           [ "37A" ]             [ 1 ]
    U3(3)     16/63    3                     [ "6A", "12A" ]          [ 2, 2 ]
    U3(4)     1/160  159                           [ "13A" ]             [ 1 ]
    U3(5)    46/525   11                           [ "10A" ]             [ 2 ]
    U3(7)    1/1372 1371                           [ "43A" ]             [ 1 ]
    U3(8)    1/1792 1791                           [ "19A" ]             [ 1 ]
    U3(9)    1/3600 3599                           [ "73A" ]             [ 1 ]
    U5(2)      1/54   53                           [ "11A" ]             [ 1 ]
    U6(2)      5/21    4                           [ "11A" ]             [ 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen( oldsize );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">First( atleast3, l -&gt; l[1] = "L7(2)" );</span>
[ "L7(2)", 1/4388290560, 4388290559, [ "127A" ], [ 1 ] ]
</pre></div>

<p>It should be mentioned that <a href="chapBib.html#biBBW1">[BW75]</a> states the following lower bounds for the uniform spread of the groups <span class="SimpleMath">L_2(q)</span>.</p>

<div class="pcenter"><table class="GAPDocTable">
<tr>
<td class="tdleft"><span class="SimpleMath">q-2</span></td>
<td class="tdleft">if <span class="SimpleMath">4 ≤ q</span> is even,</td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">q-1</span></td>
<td class="tdleft">if <span class="SimpleMath">11 ≤ q ≡ 1 mod 4</span>,</td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">q-4</span></td>
<td class="tdleft">if <span class="SimpleMath">11 ≤ q ≡ -1 mod 4</span>.</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p>These bounds appear in the third column of the above table. Furthermore, <a href="chapBib.html#biBBW1">[BW75]</a> states that the (uniform) spread of alternating groups of even degree at least <span class="SimpleMath">8</span> is exactly <span class="SimpleMath">4</span>.</p>

<p>For the sake of completeness, Table II gives an overview of the sets <span class="SimpleMath">𝕄(G,s)</span> for those cases in the above list that are needed in <a href="chapBib.html#biBBGK">[BGK08]</a> but that do not require a further discussion here. The structure of the maximal subgroups and the order of <span class="SimpleMath">s</span> in the table refer to the matrix groups not to the simple groups. The number of the subgroups has been shown above, the structure follows from <a href="chapBib.html#biBCCN85">[CCN+85]</a>.</p>

<div class="pcenter"><table class="GAPDocTable">
<caption class="GAPDocTable"><b>Table: </b>Table II: Maximal subgroups/&gt;</caption>
<tr>
<td class="tdleft"><span class="SimpleMath">G</span></td>
<td class="tdleft"><span class="SimpleMath">𝕄(G,s)</span></td>
<td class="tdright"><span class="SimpleMath">|s|</span></td>
<td class="tdright">see <a href="chapBib.html#biBCCN85">[CCN+85]</a></td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">SL(3,4) = 3.L_3(4)</span></td>
<td class="tdleft"><span class="SimpleMath">3 × L_3(2), 3 × L_3(2), 3 × L_3(2)</span></td>
<td class="tdright"><span class="SimpleMath">21</span></td>
<td class="tdright">p. 23</td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">Ω^-(8,2) = O^-_8(2)</span></td>
<td class="tdleft"><span class="SimpleMath">Ω^-(4,4).2 = L_2(16).2</span></td>
<td class="tdright"><span class="SimpleMath">17</span></td>
<td class="tdright">p. 89</td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">Sp(4,4) = S_4(4)</span></td>
<td class="tdleft"><span class="SimpleMath">Ω^-(4,4).2 = L_2(16).2, Sp(2,16).2 = L_2(16).2</span></td>
<td class="tdright"><span class="SimpleMath">17</span></td>
<td class="tdright">p. 44</td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">Sp(6,3) = 2.S_6(3)</span></td>
<td class="tdleft"><span class="SimpleMath">(4 × U_3(3)).2, Sp(2,17).3 = 2.L_2(27).3</span></td>
<td class="tdright"><span class="SimpleMath">28</span></td>
<td class="tdright">p. 113</td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">SU(3,3) = U_3(3)</span></td>
<td class="tdleft"><span class="SimpleMath">3^1+2_+:8, GU(2,3) = 4.S_4</span></td>
<td class="tdright"><span class="SimpleMath">6</span></td>
<td class="tdright">p. 14</td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">SU(3,5) = 3.U_3(5)</span></td>
<td class="tdleft"><span class="SimpleMath">3 × 5^1+2_+:8, GU(2,5) = 3 × 2S_5</span></td>
<td class="tdright"><span class="SimpleMath">30</span></td>
<td class="tdright">p. 34</td>
</tr>
<tr>
<td class="tdleft"><span class="SimpleMath">SU(5,2) = U_5(2)</span></td>
<td class="tdleft"><span class="SimpleMath">L_2(11)</span></td>
<td class="tdright"><span class="SimpleMath">11</span></td>
<td class="tdright">p. 73</td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p><a id="X7B1E26D586337487" name="X7B1E26D586337487"></a></p>

<h5>11.4-4 <span class="Heading">Automorphism Groups of other Simple Groups – Easy Cases</span></h5>

<p>We deal with automorphic extensions of those simple groups that are listed in Table I and that have been treated successfully in Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>.</p>

<p>For the following groups, <code class="code">ProbGenInfoAlmostSimple</code> can be used because <strong class="pkg">GAP</strong> can compute their primitive permutation characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">list:= [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "A5", "A5.2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "A6", "A6.2_1" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "A6", "A6.2_2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "A6", "A6.2_3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "A7", "A7.2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "A8", "A8.2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "A9", "A9.2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "A11", "A11.2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "L3(2)", "L3(2).2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "L3(3)", "L3(3).2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "L3(4)", "L3(4).2_1" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "L3(4)", "L3(4).2_2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "L3(4)", "L3(4).2_3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "L3(4)", "L3(4).3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "S4(4)", "S4(4).2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "U3(3)", "U3(3).2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "U3(5)", "U3(5).2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "U3(5)", "U3(5).3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "U4(2)", "U4(2).2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "U4(3)", "U4(3).2_1" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ "U4(3)", "U4(3).2_3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">autinfo:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fails:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for pair in list do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tbl:= CharacterTable( pair[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblG:= CharacterTable( pair[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     info:= ProbGenInfoSimple( tbl );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     spos:= List( info[4], x -&gt; Position( AtlasClassNames( tbl ), x ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Add( autinfo, ProbGenInfoAlmostSimple( tbl, tblG, spos ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintFormattedArray( autinfo );</span>
       A5.2      0        [ "5AB" ]    [ 1 ]
     A6.2_1    2/3        [ "5AB" ]    [ 2 ]
     A6.2_2    1/6         [ "5A" ]    [ 1 ]
     A6.2_3      0        [ "5AB" ]    [ 1 ]
       A7.2   1/15        [ "7AB" ]    [ 1 ]
       A8.2  13/28       [ "15AB" ]    [ 1 ]
       A9.2    1/4        [ "9AB" ]    [ 1 ]
      A11.2  1/945       [ "11AB" ]    [ 1 ]
    L3(2).2    1/4        [ "7AB" ]    [ 1 ]
    L3(3).2   1/18       [ "13AB" ]    [ 1 ]
  L3(4).2_1   3/10        [ "7AB" ]    [ 3 ]
  L3(4).2_2  11/60         [ "7A" ]    [ 1 ]
  L3(4).2_3   1/12        [ "7AB" ]    [ 1 ]
    L3(4).3   1/64         [ "7A" ]    [ 1 ]
    S4(4).2      0       [ "17AB" ]    [ 2 ]
    U3(3).2    2/7 [ "6A", "12AB" ] [ 2, 2 ]
    U3(5).2   2/21        [ "10A" ]    [ 2 ]
    U3(5).3 46/525        [ "10A" ]    [ 2 ]
    U4(2).2  16/45       [ "12AB" ]    [ 2 ]
  U4(3).2_1 76/135         [ "7A" ]    [ 3 ]
  U4(3).2_3 31/162        [ "7AB" ]    [ 3 ]
</pre></div>

<p>We see that from this list, the two groups <span class="SimpleMath">A_6.2_1 = S_6</span> and <span class="SimpleMath">U_4(3).2_1</span> require further computations (see Sections <a href="chap11.html#X82C3B4287B0C7BEE"><span class="RefLink">11.5-3</span></a> and <a href="chap11.html#X7D738BE5804CF22E"><span class="RefLink">11.5-24</span></a>, respectively) because the bound in the second column is larger than <span class="SimpleMath">1/2</span>.</p>

<p>Also <span class="SimpleMath">U_4(2)</span> is not done by the above, because in <a href="chapBib.html#biBBGK">[BGK08, Table 4]</a>, an element <span class="SimpleMath">s</span> of order <span class="SimpleMath">9</span> is chosen for the simple group, see Section <a href="chap11.html#X7A03F8EC839AF0B5"><span class="RefLink">11.5-23</span></a>.</p>

<p>Finally, we deal with automorphic extensions of the groups <span class="SimpleMath">L_4(3)</span>, <span class="SimpleMath">O_8^-(2)</span>, <span class="SimpleMath">S_6(3)</span>, and <span class="SimpleMath">U_5(2)</span>.</p>

<p>For <span class="SimpleMath">S = L_4(3)</span> and <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">20</span>, we have <span class="SimpleMath">𝕄(S,s) = { (4 × A_6):2 }</span>, the subgroup has index <span class="SimpleMath">2106</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 69]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "L4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= PrimitivePermutationCharacters( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( AtlasClassNames( t ), "20A" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= Filtered( prim, x -&gt; x[ spos ] &lt;&gt; 0 );</span>
[ Character( CharacterTable( "L4(3)" ),
  [ 2106, 106, 42, 0, 27, 27, 0, 46, 6, 6, 1, 7, 7, 0, 3, 3, 0, 0, 0, 
      1, 1, 1, 0, 0, 0, 0, 0, 1, 1 ] ) ]
</pre></div>

<p>For the three automorphic extensions of the structure <span class="SimpleMath">G = S.2</span>, we compute the extensions of the permutation character, and the bounds <span class="SimpleMath">σ^'(G,s)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for name in [ "L4(3).2_1", "L4(3).2_2", "L4(3).2_3" ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     t2:= CharacterTable( name );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     map:= InverseMap( GetFusionMap( t, t2 ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     torso:= List( prim, pi -&gt; CompositionMaps( pi, map ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ext:= Concatenation( List( torso,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                             x -&gt; PermChars( t2, rec( torso:= x ) ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     sigma:= ApproxP( ext, Position( OrdersClassRepresentatives( t2 ), 20 ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     max:= Maximum( sigma{ Difference( PositionsProperty(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                          OrdersClassRepresentatives( t2 ), IsPrimeInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                          ClassPositionsOfDerivedSubgroup( t2 ) ) } );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Print( name, ":\n", ext, "\n", max, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">od;</span>
L4(3).2_1:
[ Character( CharacterTable( "L4(3).2_1" ), 
    [ 2106, 106, 42, 0, 27, 0, 46, 6, 6, 1, 7, 0, 3, 0, 0, 1, 1, 0, 
      0, 0, 0, 0, 1, 1, 0, 4, 0, 0, 6, 6, 6, 6, 2, 0, 0, 0, 0, 0, 0, 
      1, 1, 1, 1 ] ) ]
0
L4(3).2_2:
[ Character( CharacterTable( "L4(3).2_2" ), 
    [ 2106, 106, 42, 0, 27, 27, 0, 46, 6, 6, 1, 7, 7, 0, 3, 3, 0, 0, 
      0, 1, 1, 1, 0, 0, 0, 1, 306, 306, 42, 6, 10, 10, 0, 0, 15, 15, 
      3, 3, 3, 3, 0, 0, 1, 1, 0, 1, 1, 0, 0 ] ) ]
17/117
L4(3).2_3:
[ Character( CharacterTable( "L4(3).2_3" ), 
    [ 2106, 106, 42, 0, 27, 0, 46, 6, 6, 1, 7, 0, 3, 0, 0, 1, 1, 0, 
      0, 0, 1, 36, 0, 0, 6, 6, 2, 2, 2, 1, 1, 0, 0, 0 ] ) ]
2/117
</pre></div>

<p>For <span class="SimpleMath">S = O_8^-(2)</span> and <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">17</span>, we have <span class="SimpleMath">𝕄(S,s) = { L_2(16).2 }</span>, the subgroup extends to <span class="SimpleMath">L_2(16).4</span> in <span class="SimpleMath">S.2</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 89]</a>. This is a non-split extension, so <span class="SimpleMath">σ^'(S.2,s) = 0</span> holds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "O8-(2).2" ), "17AB",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ CharacterTable( "L2(16).4" ) ], [ 1 ], "outer" );</span>
0
</pre></div>

<p>For <span class="SimpleMath">S = S_6(3)</span> and <span class="SimpleMath">s ∈ S</span> irreducible of order <span class="SimpleMath">14</span>, we have <span class="SimpleMath">𝕄(S,s) = { (2 × U_3(3)).2, L_2(27).3 }</span>. In <span class="SimpleMath">G = S.2</span>, the subgroups extend to <span class="SimpleMath">(4 × U_3(3)).2</span> and <span class="SimpleMath">L_2(27).6</span>, respectively, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 113]</a>. In order to show that <span class="SimpleMath">σ^'(G,s) = 7/3240</span> holds, we compute the primitive permutation characters of <span class="SimpleMath">S</span> (cf. Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>) and the unique extensions to <span class="SimpleMath">G</span> of those which are nonzero on <span class="SimpleMath">s</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "S6(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "S6(3).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= PrimitivePermutationCharacters( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( AtlasClassNames( t ), "14A" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= Filtered( prim, x -&gt; x[ spos ] &lt;&gt; 0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map:= InverseMap( GetFusionMap( t, t2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">torso:= List( prim, pi -&gt; CompositionMaps( pi, map ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= List( torso, pi -&gt; PermChars( t2, rec( torso:= pi ) ) );</span>
[ [ Character( CharacterTable( "S6(3).2" ),
      [ 155520, 0, 288, 0, 0, 0, 216, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
          0, 0, 0, 0, 6, 1, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 
          0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 144, 288, 0, 0, 0, 
          6, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 
          0 ] ) ], 
  [ Character( CharacterTable( "S6(3).2" ),
      [ 189540, 1620, 568, 0, 486, 0, 0, 27, 540, 84, 24, 0, 0, 0, 0, 
          0, 54, 0, 0, 10, 0, 7, 1, 6, 6, 0, 0, 0, 0, 0, 0, 18, 0, 0, 
          0, 6, 12, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 234, 64, 
          30, 8, 0, 3, 90, 6, 0, 4, 10, 6, 0, 2, 1, 0, 0, 0, 0, 0, 0, 
          0, 1, 1, 0, 0 ] ) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( AtlasClassNames( t2 ), "14A" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sigma:= ApproxP( Concatenation( ext ), spos );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( sigma{ Difference(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ClassPositionsOfDerivedSubgroup( t2 ) ) } );</span>
7/3240
</pre></div>

<p>For <span class="SimpleMath">S = U_5(2)</span> and <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">11</span>, we have <span class="SimpleMath">𝕄(S,s) = { L_2(11) }</span>, the subgroup extends to <span class="SimpleMath">L_2(11).2</span> in <span class="SimpleMath">S.2</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 73]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "U5(2).2" ), "11AB",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ CharacterTable( "L2(11).2" ) ], [ 1 ], "outer" );</span>
1/288
</pre></div>

<p>Here we clean the workspace for the first time. This may save more than <span class="SimpleMath">100</span> megabytes, due to the fact that the caches for tables of marks and character tables are flushed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CleanWorkspace();</span>
</pre></div>

<p><a id="X78B856907ED13545" name="X78B856907ED13545"></a></p>

<h5>11.4-5 <span class="Heading"><span class="SimpleMath">O_8^-(3)</span></span></h5>

<p>We show that <span class="SimpleMath">S = O_8^-(3) = Ω^-(8,3)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">41</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">L_2(81).2_1 = Ω^-(4,9).2</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 1/567</span>.</p>

</dd>
</dl>
<p>The only maximal subgroups of <span class="SimpleMath">S</span> containing elements of order <span class="SimpleMath">41</span> have the type <span class="SimpleMath">L_2(81).2_1</span>, and there is one class of these subgroups, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 141]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "O8-(3)" ), "41A",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ CharacterTable( "L2(81).2_1" ) ], [ 1 ] );</span>
1/567
</pre></div>

<p><a id="X84AB334886DCA746" name="X84AB334886DCA746"></a></p>

<h5>11.4-6 <span class="Heading"><span class="SimpleMath">O_10^+(2)</span></span></h5>

<p>We show that <span class="SimpleMath">S = O_10^+(2) = Ω^+(10,2)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>Ford<span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">45</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">(A_5 × U_4(2)).2 = (Ω^-(4,2) × Ω^-(6,2)).2</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 43/4216</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p>For <span class="SimpleMath">s</span> as in (a), the maximal subgroup in (a) extends to <span class="SimpleMath">S_5 × U_4(2).2</span> in <span class="SimpleMath">G = Aut(S) = S.2</span>, and <span class="SimpleMath">σ^'(G,s) = 23/248</span>.</p>

</dd>
</dl>
<p>The only maximal subgroups of <span class="SimpleMath">S</span> containing elements of order <span class="SimpleMath">45</span> are one class of groups <span class="SimpleMath">H = (A_5 × U_4(2)):2</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 146]</a>. (Note that none of the groups <span class="SimpleMath">S_8(2)</span>, <span class="SimpleMath">O_8^+(2)</span>, <span class="SimpleMath">L_5(2)</span>, <span class="SimpleMath">O_8^-(2)</span>, and <span class="SimpleMath">A_8</span> contains elements of order <span class="SimpleMath">45</span>.) <span class="SimpleMath">H</span> extends to subgroups of the type <span class="SimpleMath">H.2 = S_5 × U_4(2):2</span> in <span class="SimpleMath">G</span>, so we can compute <span class="SimpleMath">1_H^S = (1_H.2^G)_S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAny( [ "S8(2)", "O8+(2)", "L5(2)", "O8-(2)", "A8" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; 45 in OrdersClassRepresentatives( CharacterTable( x ) ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "O10+(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "O10+(2).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s2:= CharacterTable( "A5.2" ) * CharacterTable( "U4(2).2" );</span>
CharacterTable( "A5.2xU4(2).2" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters( s2, t2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t2 ), 45 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( pi, spos );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( approx{ ClassPositionsOfDerivedSubgroup( t2 ) } );</span>
43/4216
</pre></div>

<p>Statement (c) follows from considering the outer classes of prime element order.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( approx{ Difference(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ClassPositionsOfDerivedSubgroup( t2 ) ) } );</span>
23/248
</pre></div>

<p>Alternatively, we can use <code class="code">SigmaFromMaxes</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( t2, "45AB", [ s2 ], [ 1 ], "outer" );</span>
23/248
</pre></div>

<p><a id="X84E3E4837BB93977" name="X84E3E4837BB93977"></a></p>

<h5>11.4-7 <span class="Heading"><span class="SimpleMath">O_10^-(2)</span></span></h5>

<p>We show that <span class="SimpleMath">S = O_10^-(2) = Ω^-(10,2)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">33</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">3 × U_5(2) = GU(5,2)</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 1/119</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p>For <span class="SimpleMath">s</span> as in (a), the maximal subgroup in (a) extends to <span class="SimpleMath">(3 × U_5(2)).2</span> in <span class="SimpleMath">G</span>, and <span class="SimpleMath">σ^'(G,s) = 1/595</span>.</p>

</dd>
</dl>
<p>The only maximal subgroups of <span class="SimpleMath">S</span> containing elements of order <span class="SimpleMath">11</span> have the types <span class="SimpleMath">A_12</span> and <span class="SimpleMath">3 × U_5(2)</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 147]</a>. So <span class="SimpleMath">3 × U_5(2)</span> is the unique class of subgroups containing elements of order <span class="SimpleMath">33</span>. This shows statement (a), and statement (b) follows using <code class="code">SigmaFromMaxes</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "O10-(2)" ), "33A",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ CharacterTable( "Cyclic", 3 ) * CharacterTable( "U5(2)" ) ], [ 1 ] );</span>
1/119
</pre></div>

<p>The structure of the maximal subgroup of <span class="SimpleMath">G</span> follows from <a href="chapBib.html#biBCCN85">[CCN+85, p. 147]</a>. We create its character table with a generic construction that is based on the fact that the outer automorphism acts nontrivially on the two direct factors; this determines the character table uniquely. (See <a href="chapBib.html#biBAuto">[Brec]</a> for details.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "U5(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG:= CharacterTable( "Cyclic", 3 ) * tblG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA:= CharacterTable( "U5(2).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">acts:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= Concatenation( List( acts, pi -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, pi,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               "(3xU5(2)).2" ) ) );</span>
[ rec( 
      MGfusMGA := [ 1, 2, 3, 4, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 12, 
          13, 13, 14, 14, 15, 15, 16, 17, 17, 18, 18, 19, 20, 21, 21, 
          22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28, 28, 29, 29, 
          30, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 
          44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 
          59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 
          74, 75, 76, 77, 31, 32, 33, 35, 34, 37, 36, 38, 39, 40, 41, 
          42, 43, 45, 44, 47, 46, 49, 48, 51, 50, 52, 54, 53, 56, 55, 
          57, 58, 60, 59, 62, 61, 64, 63, 66, 65, 68, 67, 69, 71, 70, 
          73, 72, 75, 74, 77, 76 ], 
      table := CharacterTable( "(3xU5(2)).2" ) ) ]
</pre></div>

<p>Now statement (c) follows using <code class="code">SigmaFromMaxes</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "O10-(2).2" ), "33AB",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ poss[1].table ], [ 1 ], "outer" );</span>
1/595
</pre></div>

<p><a id="X8307367E7C7C3BCE" name="X8307367E7C7C3BCE"></a></p>

<h5>11.4-8 <span class="Heading"><span class="SimpleMath">O_12^+(2)</span></span></h5>

<p>We show that <span class="SimpleMath">S = O_12^+(2) = Ω^+(12,2)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of the type <span class="SimpleMath">4^- perp 8^-</span> (i. e., <span class="SimpleMath">s</span> decomposes the natural <span class="SimpleMath">12</span>-dimensional module for <span class="SimpleMath">GO^+_12(2) = S.2</span> into an orthogonal sum of two irreducible modules of the dimensions <span class="SimpleMath">4</span> and <span class="SimpleMath">8</span>, respectively) and of order <span class="SimpleMath">85</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">G_8 = (Ω^-(4,2) × Ω^-(8,2)).2</span> and two groups of the type <span class="SimpleMath">L_4(4).2^2 = Ω^+(6,4).2^2</span> that are conjugate in <span class="SimpleMath">G = Aut(S) = S.2 = SO^+(12,2)</span> but <em>not</em> conjugate in <span class="SimpleMath">S</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 7675/1031184</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">σ^'(G,s) = 73/1008</span>.</p>

</dd>
</dl>
<p>The element <span class="SimpleMath">s</span> is a ppd<span class="SimpleMath">(12,2;8)</span>-element in the sense of <a href="chapBib.html#biBGPPS">[GPPS99]</a>, so the maximal subgroups of <span class="SimpleMath">S</span> that contain <span class="SimpleMath">s</span> are among the nine cases (2.1)–(2.9) listed in this paper; in the notation of this paper, we have <span class="SimpleMath">q = 2</span>, <span class="SimpleMath">d = 12</span>, <span class="SimpleMath">e = 8</span>, and <span class="SimpleMath">r = 17</span>. Case (2.1) does not occur for orthogonal groups and <span class="SimpleMath">q = 2</span>, according to <a href="chapBib.html#biBKlL90">[KL90]</a>; case (2.2) contributes a unique maximal subgroup, the stabilizer <span class="SimpleMath">G_8</span> of the orthogonal decomposition; the cases (2.3), (2.4) (a), (2.5), and (2.6) (a) do not occur because <span class="SimpleMath">r ≠ e+1</span> in our situation; case (2.4) (b) describes extension field type subgroups that are contained in <span class="SimpleMath">ΓL(6,4)</span>, which yields the candidates <span class="SimpleMath">GU(6,2).2 ≅ 3.U_6(2).S_3</span> –but <span class="SimpleMath">3.U_6(2).3</span> does not contain elements of order <span class="SimpleMath">85</span>– and <span class="SimpleMath">Ω^+(6,4).2^2 ≅ L_4(4).2^2</span> (two classes by <a href="chapBib.html#biBKlL90">[KL90, Prop. 4.3.14]</a>); the cases (2.6) (b)–(c) and (2.8) do not occur because they require <span class="SimpleMath">d ≤ 8</span>; case (2.7) does not occur because <a href="chapBib.html#biBGPPS">[GPPS99, Table 5]</a> contains no entry for <span class="SimpleMath">r = 2e+1 = 17</span>; finally, case (2.9) does not occur because it requires <span class="SimpleMath">e ∈ { d-1, d }</span> in the case <span class="SimpleMath">r = 2e+1</span>.</p>

<p>So we need the permutation characters of the actions on the cosets of <span class="SimpleMath">L_4(4).2^2</span> (two classes) and <span class="SimpleMath">G_8</span>. According to <a href="chapBib.html#biBKlL90">[KL90, Prop. 4.1.6]</a>, <span class="SimpleMath">G_8</span> has the structure <span class="SimpleMath">(Ω^-(4,2) × Ω^-(8,2)).2</span>.</p>

<p>Newer versions of the <strong class="pkg">GAP</strong> Character Table Library contain the character table of <span class="SimpleMath">S</span>, but it is still easier to work with the table of <span class="SimpleMath">G</span>, which was already available at the times when the first version of these examples was created.</p>

<p>The two classes of <span class="SimpleMath">L_4(4).2^2</span> type subgroups in <span class="SimpleMath">S</span> are fused in <span class="SimpleMath">G</span>. This can be seen from the fact that inducing the trivial character of a subgroup <span class="SimpleMath">H_1 = L_4(4).2^2</span> of <span class="SimpleMath">S</span> to <span class="SimpleMath">G</span> yields a character <span class="SimpleMath">ψ</span> whose values are not all even; note that if <span class="SimpleMath">H_1</span> would extend in <span class="SimpleMath">G</span> to a subgroup of twice the size of <span class="SimpleMath">H_1</span> then <span class="SimpleMath">ψ</span> would be induced from a degree two character of this subgroup whose values are all even, and induction preserves this property.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "O12+(2).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h1:= CharacterTable( "L4(4).2^2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psi:= PossiblePermutationCharacters( h1, t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( psi );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAny( psi[1], IsOddInt );</span>
true
</pre></div>

<p>The fixed element <span class="SimpleMath">s</span> of order <span class="SimpleMath">85</span> is contained in a member of each of the two conjugacy classes of the type <span class="SimpleMath">L_4(4).2^2</span> in <span class="SimpleMath">S</span>, since <span class="SimpleMath">S</span> contains only one class of subgroups of the order <span class="SimpleMath">85</span>; note that the order of the Sylow <span class="SimpleMath">17</span> centralizer (in both <span class="SimpleMath">S</span> and <span class="SimpleMath">G</span>) is not divisible by <span class="SimpleMath">25</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesCentralizers( t ){ PositionsProperty(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       OrdersClassRepresentatives( t ), x -&gt; x = 17 ) } / 25;</span>
[ 408/5, 408/5 ]
</pre></div>

<p>This implies that the restriction of <span class="SimpleMath">ψ</span> to <span class="SimpleMath">S</span> is the sum <span class="SimpleMath">ψ_S = π_1 + π_2</span>, say, of the first two interesting permutation characters of <span class="SimpleMath">S</span>.</p>

<p>The subgroup <span class="SimpleMath">G_8</span> of <span class="SimpleMath">S</span> extends to a group of the structure <span class="SimpleMath">H_2 = Ω^-(4,2).2 × Ω^-(8,2).2</span> in <span class="SimpleMath">G</span>, inducing the trivial characters of <span class="SimpleMath">H_2</span> to <span class="SimpleMath">G</span> yields a permutation character <span class="SimpleMath">φ</span> of <span class="SimpleMath">G</span> whose restriction to <span class="SimpleMath">S</span> is the third permutation character <span class="SimpleMath">φ_S = π_3</span>, say.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h2:= CharacterTable( "S5" ) * CharacterTable( "O8-(2).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi:= PossiblePermutationCharacters( h2, t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( phi );</span>
1
</pre></div>

<p>We have <span class="SimpleMath">π_1(1) = π_2(1)</span> and <span class="SimpleMath">π_1(s) = π_2(s)</span>, the latter again because <span class="SimpleMath">S</span> contains only one class of subgroups of order <span class="SimpleMath">85</span>.</p>

<p>Now statement (a) follows from the fact that <span class="SimpleMath">π_i(s) = 1</span> holds for <span class="SimpleMath">1 ≤ i ≤ 3</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= Concatenation( psi, phi );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 85 );</span>
213
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( prim, x -&gt; x[ spos ] );</span>
[ 2, 1 ]
</pre></div>

<p>For statement (b), we compute <span class="SimpleMath">σ(S,s)</span>. Note that we have to consider only classes inside <span class="SimpleMath">S = G^'</span>, and that</p>

<p class="pcenter">σ( g, s ) = ∑_i=1^3 fracπ_i(s) ⋅ π_i(g)π_i(1) = fracψ(s) ⋅ ψ(g)ψ(1) + fracφ(s) ⋅ φ(g)φ(1)</p>

<p>holds for <span class="SimpleMath">g ∈ S^×</span>, so the characters <span class="SimpleMath">ψ</span> and <span class="SimpleMath">φ</span> are sufficient.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( prim, spos );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( approx{ ClassPositionsOfDerivedSubgroup( t ) } );</span>
7675/1031184
</pre></div>

<p>Statement (c) follows from considering the outer involution classes. Note that by <a href="chapBib.html#biBBGK">[BGK08, Remark after Proposition 5.14]</a>, only the subgroup <span class="SimpleMath">H_2</span> need to be considered, no novelties appear.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( approx{ Difference(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     PositionsProperty( OrdersClassRepresentatives( t ), IsPrimeInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ClassPositionsOfDerivedSubgroup( t ) ) } );</span>
73/1008
</pre></div>

<p><a id="X834FE1B58119A5FF" name="X834FE1B58119A5FF"></a></p>

<h5>11.4-9 <span class="Heading"><span class="SimpleMath">O_12^-(2)</span></span></h5>

<p>We show that <span class="SimpleMath">S = O_12^-(2) = Ω^-(12,2)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> irreducible of order <span class="SimpleMath">2^6+1 = 65</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of two groups of the types <span class="SimpleMath">U_4(4).2 = Ω^-(6,4).2</span> and <span class="SimpleMath">L_2(64).3 = Ω^-(4,8).3</span>, respectively.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 1/1023</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">σ^'(Aut(S),s) = 1/347820</span>.</p>

</dd>
</dl>
<p>By <a href="chapBib.html#biBBe00">[Ber00]</a>, <span class="SimpleMath">𝕄(S,s)</span> consists of extension field subgroups, which have the structures <span class="SimpleMath">U_4(4).2</span> and <span class="SimpleMath">L_2(64).3</span>, respectively, and by <a href="chapBib.html#biBKlL90">[KL90, Prop. 4.3.16]</a>, there is just one class of each of these types.</p>

<p>Newer versions of the <strong class="pkg">GAP</strong> Character Table Library contain the character table of <span class="SimpleMath">S</span>, but using this table for the computations is not easier than using the table of <span class="SimpleMath">G = Aut(S) = O_12^-(2).2</span>, which was already available at the times when the first version of these examples was created. So we compute the permutation characters <span class="SimpleMath">π_1, π_2</span> of the extensions of the groups in <span class="SimpleMath">𝕄(S,s)</span> to <span class="SimpleMath">G</span> –these maximal subgroups have the structures <span class="SimpleMath">U_4(4).4</span> and <span class="SimpleMath">L_2(64).6</span>, respectively– and compute the fixed point ratios of the restrictions to <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "O12-(2).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:= CharacterTable( "U4(4).4" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1:= PossiblePermutationCharacters( s1, t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s2:= CharacterTable( "L2(64).6" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2:= PossiblePermutationCharacters( s2, t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= Concatenation( pi1, pi2 );;  Length( prim );</span>
2
</pre></div>

<p>Now statement (a) follows from the fact that <span class="SimpleMath">π_1(s) = π_2(s) = 1</span> holds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 65 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( prim, x -&gt; x[ spos ] );</span>
[ 1, 1 ]
</pre></div>

<p>For statement (b), we compute <span class="SimpleMath">σ(S,s)</span>; note that we have to consider only classes inside <span class="SimpleMath">S = G^'</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( prim, spos );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( approx{ ClassPositionsOfDerivedSubgroup( t ) } );</span>
1/1023
</pre></div>

<p>Statement (c) follows from the values on the outer involution classes.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( approx{ Difference(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     PositionsProperty( OrdersClassRepresentatives( t ), IsPrimeInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ClassPositionsOfDerivedSubgroup( t ) ) } );</span>
1/347820
</pre></div>

<p><a id="X7C5980A385C088FA" name="X7C5980A385C088FA"></a></p>

<h5>11.4-10 <span class="Heading"><span class="SimpleMath">S_6(4)</span></span></h5>

<p>We show that <span class="SimpleMath">S = S_6(4) = Sp(6,4)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> irreducible of order <span class="SimpleMath">65</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of two groups of the types <span class="SimpleMath">U_4(4).2 = Ω^-(6,4).2</span> and <span class="SimpleMath">L_2(64).3 = Sp(2,64).3</span>, respectively.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 16/63</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">σ^'(Aut(S),s) = 0</span>.</p>

</dd>
</dl>
<p>By <a href="chapBib.html#biBBe00">[Ber00]</a>, the element <span class="SimpleMath">s</span> is contained in maximal subgroups of the given types, and by <a href="chapBib.html#biBKlL90">[KL90, Prop. 4.3.10, 4.8.6]</a>, there is exactly one class of these subgroups.</p>

<p>The character tables of these two subgroups are currently not contained in the <strong class="pkg">GAP</strong> Character Table Library. We compute the permutation character induced from the first subgroup as the unique character of the right degree that is combinatorially possible (cf. <a href="chapBib.html#biBBP98copy">[BP98]</a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "S6(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">degree:= Size( t ) / ( 2 * Size( CharacterTable( "U4(4)" ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1:= PermChars( t, rec( torso:= [ degree ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( pi1 );</span>
1
</pre></div>

<p>The index of the second subgroup is too large for this simpleminded approach; therefore, we first restrict the set of possible irreducible constituents of the permutation character to those of <span class="SimpleMath">1_H^G</span>, where <span class="SimpleMath">H</span> is the derived subgroup of <span class="SimpleMath">L_2(64).3</span>, for which the character table is available.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterTable( "L2(64).3" );  CharacterTable( "U4(4).2" );</span>
fail
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= CharacterTable( "L2(64)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">subpi:= PossiblePermutationCharacters( s, t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( subpi );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">scp:= MatScalarProducts( t, Irr( t ), subpi );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nonzero:= PositionsProperty( scp[1], x -&gt; x &lt;&gt; 0 );</span>
[ 1, 11, 13, 14, 17, 18, 32, 33, 56, 58, 59, 73, 74, 77, 78, 79, 80, 
  93, 95, 96, 103, 116, 117, 119, 120 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">const:= RationalizedMat( Irr( t ){ nonzero } );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">degree:= Size( t ) / ( 3 * Size( s ) );</span>
5222400
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2:= PermChars( t, rec( torso:= [ degree ], chars:= const ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( pi2 );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= Concatenation( pi1, pi2 );;</span>
</pre></div>

<p>Now statement (a) follows from the fact that <span class="SimpleMath">π_1(s) = π_2(s) = 1</span> holds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 65 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( prim, x -&gt; x[ spos ] );</span>
[ 1, 1 ]
</pre></div>

<p>For statement (b), we compute <span class="SimpleMath">σ(G,s)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( ApproxP( prim, spos ) );</span>
16/63
</pre></div>

<p>In order to prove statement (c), we have to consider only the extensions of the above permutation characters of <span class="SimpleMath">S</span> to <span class="SimpleMath">Aut(S) ≅ S.2</span> (cf. <a href="chapBib.html#biBBGK">[BGK08, Section 2.2]</a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "S6(4).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tfust2:= GetFusionMap( t, t2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= List( prim, x -&gt; CompositionMaps( x, InverseMap( tfust2 ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= List( cand, pi -&gt; PermChars( t2, rec( torso:= pi ) ) );</span>
[ [ Character( CharacterTable( "S6(4).2" ),
      [ 2016, 512, 96, 128, 32, 120, 0, 6, 16, 40, 24, 0, 8, 136, 1, 
          6, 6, 1, 32, 0, 8, 6, 2, 0, 2, 0, 0, 4, 0, 16, 32, 1, 8, 2, 
          6, 2, 1, 2, 4, 0, 0, 1, 6, 0, 1, 10, 0, 1, 1, 0, 10, 10, 4, 
          0, 1, 0, 2, 0, 2, 1, 2, 2, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 
          0, 0, 0, 32, 0, 0, 8, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 8, 0, 
          0, 0, 2, 2, 0, 2, 2, 0, 2, 2, 2, 0, 0 ] ) ], 
  [ Character( CharacterTable( "S6(4).2" ),
      [ 5222400, 0, 0, 0, 1280, 0, 960, 120, 0, 0, 0, 0, 0, 0, 1600, 
          0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1, 0, 0, 15, 0, 0, 0, 0, 0, 
          0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 
          0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 
          0, 0, 960, 0, 0, 0, 16, 0, 24, 12, 0, 0, 0, 0, 0, 0, 0, 0, 
          0, 0, 0, 0, 4, 1, 0, 0, 3, 0, 0, 0, 0, 0 ] ) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos2:= Position( OrdersClassRepresentatives( t2 ), 65 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sigma:= ApproxP( Concatenation( ext ), spos2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( approx{ Difference(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ClassPositionsOfDerivedSubgroup( t2 ) ) } );</span>
0
</pre></div>

<p>For the simple group, we can <em>alternatively</em> consider a reducible element <span class="SimpleMath">s: 2 perp 4</span> of order <span class="SimpleMath">85</span>, which is a multiple of the primitive prime divisor <span class="SimpleMath">r = 17</span> of <span class="SimpleMath">4^4-1</span>. So we have <span class="SimpleMath">e = 4</span>, <span class="SimpleMath">d = 6</span>, and <span class="SimpleMath">q = 4</span>, in the terminology of <a href="chapBib.html#biBGPPS">[GPPS99]</a>. Then <span class="SimpleMath">𝕄(S,s)</span> consists of two groups, of the types <span class="SimpleMath">Ω^+(6,4).2 ≅ L_4(4).2_2</span> and <span class="SimpleMath">Sp(2,4) × Sp(4,4)</span>. This can be shown by checking <a href="chapBib.html#biBGPPS">[GPPS99, Ex. 2.1–2.9]</a>. Ex. 2.1 yields the candidates <span class="SimpleMath">Ω^±(6,4).2</span>, but only <span class="SimpleMath">Ω^+(6,4).2</span> contains elements of order <span class="SimpleMath">85</span>. Ex. 2.2 yields the stabilizer of a two-dimensional subspace, which has the structure <span class="SimpleMath">Sp(2,4) × Sp(4,4)</span>, by <a href="chapBib.html#biBKlL90">[KL90]</a>. All other cases except Ex. 2.4 (b) are excluded by the fact that <span class="SimpleMath">r = 4e+1</span>, and Ex. 2.4 (b) does not apply because <span class="SimpleMath">d/gcd(d,e)</span> is odd.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "S6(4)" ), "85A",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ CharacterTable( "L4(4).2_2" ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     CharacterTable( "A5" ) * CharacterTable( "S4(4)" ) ], [ 1, 1 ] );</span>
142/455
</pre></div>

<p>This bound is not as good as the one obtained from the irreducible element of order <span class="SimpleMath">65</span> used above.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">16/63 &lt; 142/455;</span>
true
</pre></div>

<p><a id="X829EDF7F7C0BCB8E" name="X829EDF7F7C0BCB8E"></a></p>

<h5>11.4-11 <span class="Heading"><span class="SimpleMath">∗</span> <span class="SimpleMath">S_6(5)</span></span></h5>

<p>We show that <span class="SimpleMath">S = S_6(5) = PSp(6,5)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of the type <span class="SimpleMath">2 perp 4</span> (i. e., the preimage of <span class="SimpleMath">s</span> in <span class="SimpleMath">Sp(6,5) = 2.G</span> decomposes the natural <span class="SimpleMath">6</span>-dimensional module for <span class="SimpleMath">Sp(6,5)</span> into an orthogonal sum of two irreducible modules of the dimensions <span class="SimpleMath">2</span> and <span class="SimpleMath">4</span>, respectively) and of order <span class="SimpleMath">78</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">G_2 = 2.(PSp(2,5) × PSp(4,5))</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 9/217</span>.</p>

</dd>
</dl>
<p>The order of <span class="SimpleMath">s</span> is a multiple of the primitive prime divisor <span class="SimpleMath">r = 13</span> of <span class="SimpleMath">5^4-1</span>, so we have <span class="SimpleMath">e = 4</span>, <span class="SimpleMath">d = 6</span>, and <span class="SimpleMath">q = 5</span>, in the terminology of <a href="chapBib.html#biBGPPS">[GPPS99]</a>. We check <a href="chapBib.html#biBGPPS">[GPPS99, Ex. 2.1–2.9]</a>. Ex. 2.1 does not apply because the classes <span class="SimpleMath">C_5</span> and <span class="SimpleMath">C_8</span> are empty by <a href="chapBib.html#biBKlL90">[KL90, Table 3.5.C]</a>, Ex. 2.2 yields exactly the stabilizer <span class="SimpleMath">G_2</span> of a <span class="SimpleMath">2</span>-dimensional subspace, Ex. 2.4 (b) does not apply because <span class="SimpleMath">d/gcd(d,e)</span> is odd, and all other cases are excluded by the fact that <span class="SimpleMath">r = 3e+1</span>.</p>

<p>The group <span class="SimpleMath">G_2</span> has the structure <span class="SimpleMath">2.(PSp(2,5) × PSp(4,5))</span>, which is a central product of <span class="SimpleMath">Sp(2,5) ≅ 2.A_5</span> and <span class="SimpleMath">Sp(4,5) = 2.S_4(5)</span> (see <a href="chapBib.html#biBKlL90">[KL90, Prop. 4.1.3]</a>). The character table of <span class="SimpleMath">G_2</span> can be derived from that of the direct product of <span class="SimpleMath">2.A_5</span> and <span class="SimpleMath">2.S_4(5)</span>, by factoring out the diagonal central subgroup of order two.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "S6(5)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:= CharacterTable( "2.A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s2:= CharacterTable( "2.S4(5)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dp:= s1 * s2;</span>
CharacterTable( "2.A5x2.S4(5)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:= Difference( ClassPositionsOfCentre( dp ), Union(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       GetFusionMap( s1, dp ), GetFusionMap( s2, dp ) ) );</span>
[ 62 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= dp / c;</span>
CharacterTable( "2.A5x2.S4(5)/[ 1, 62 ]" )
</pre></div>

<p>Now we compute <span class="SimpleMath">σ(S,s)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( t, "78A", [ s ], [ 1 ] );</span>
9/217
</pre></div>

<p><a id="X85162B297E4B67EB" name="X85162B297E4B67EB"></a></p>

<h5>11.4-12 <span class="Heading"><span class="SimpleMath">S_8(3)</span></span></h5>

<p>We show that <span class="SimpleMath">S = S_8(3) = PSp(8,3)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> irreducible of order <span class="SimpleMath">41</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group <span class="SimpleMath">M</span> of the type <span class="SimpleMath">S_4(9).2 = PSp(4,9).2</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 1/546</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p>The preimage of <span class="SimpleMath">s</span> in the matrix group <span class="SimpleMath">2.S_8(3) = Sp(8,3)</span> can be chosen of order <span class="SimpleMath">82</span>, and the preimage of <span class="SimpleMath">M</span> is <span class="SimpleMath">2.S_4(9).2 = Sp(4,9).2</span>.</p>

</dd>
</dl>
<p>By <a href="chapBib.html#biBBe00">[Ber00]</a>, the only maximal subgroups of <span class="SimpleMath">S</span> that contain irreducible elements of order <span class="SimpleMath">(3^4+1)/2 = 41</span> are of extension field type, and by <a href="chapBib.html#biBKlL90">[KL90, Prop. 4.3.10]</a>, these groups have the structure <span class="SimpleMath">S_4(9).2</span> and there is exactly one class of these groups.</p>

<p>The group <span class="SimpleMath">U = S_4(9)</span> has three nontrivial outer automorphisms, the character table of the subgroup <span class="SimpleMath">U.2</span> in question has the identifier <code class="code">"S4(9).2_1"</code>, which follows from the fact that the extensions of <span class="SimpleMath">U</span> by the other two outer automorphisms do not admit a class fusion into <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "S8(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= List( [ "S4(9).2_1", "S4(9).2_2", "S4(9).2_3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              name -&gt; PossiblePermutationCharacters(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                          CharacterTable( name ), t ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( pi, Length );</span>
[ 1, 0, 0 ]
</pre></div>

<p>Now statement (a) follows from the fact that <span class="SimpleMath">(1_U.2)^S(s) = 1</span> holds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 41 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi[1][1][ spos ];</span>
1
</pre></div>

<p>Now we compute <span class="SimpleMath">σ(S,s)</span> in order to show statement (b).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( ApproxP( pi[1], spos ) );</span>
1/546
</pre></div>

<p>Statement (c) is clear from the description of extension field type subgroups in <a href="chapBib.html#biBKlL90">[KL90]</a>.</p>

<p><a id="X8495C2BF7B6EFFEF" name="X8495C2BF7B6EFFEF"></a></p>

<h5>11.4-13 <span class="Heading"><span class="SimpleMath">U_4(4)</span></span></h5>

<p>We show that <span class="SimpleMath">S = U_4(4) = SU(4,4)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of the type <span class="SimpleMath">1 perp 3</span> (i. e., <span class="SimpleMath">s</span> decomposes the natural <span class="SimpleMath">4</span>-dimensional module for <span class="SimpleMath">SU(4,4)</span> into an orthogonal sum of two irreducible modules of the dimensions <span class="SimpleMath">1</span> and <span class="SimpleMath">3</span>, respectively) and of order <span class="SimpleMath">4^3+1 = 65</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">G_1 = 5 × U_3(4) = GU(3,4)</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 209/3264</span>.</p>

</dd>
</dl>
<p>By <a href="chapBib.html#biBMSW94">[MSW94]</a>, the only maximal subgroups of <span class="SimpleMath">S</span> that contain <span class="SimpleMath">s</span> are one class of stabilizers <span class="SimpleMath">H ≅ 5 × U_3(4)</span> of this decomposition, and clearly there is only one such group containing <span class="SimpleMath">s</span>.</p>

<p>Note that <span class="SimpleMath">H</span> has index <span class="SimpleMath">3264</span> in <span class="SimpleMath">S</span>, since <span class="SimpleMath">S</span> has two orbits on the <span class="SimpleMath">1</span>-dimensional subspaces, of lengths <span class="SimpleMath">1105</span> and <span class="SimpleMath">3264</span>, respectively, and elements of order <span class="SimpleMath">13 = 65/5</span> lie in the stabilizers of points in the latter orbit.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SU(4,4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( g, NormedRowVectors( GF(16)^4 ), OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orblen:= List( orbs, Length );</span>
[ 1105, 3264 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orblen, x -&gt; x mod 13 );</span>
[ 0, 1 ]
</pre></div>

<p>We compute the permutation character <span class="SimpleMath">1_G_1^S</span>; there is exactly one combinatorially possible permutation character of degree <span class="SimpleMath">3264</span> (cf. <a href="chapBib.html#biBBP98copy">[BP98]</a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "U4(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PermChars( t, rec( torso:= [ orblen[2] ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( pi );</span>
1
</pre></div>

<p>Now we compute <span class="SimpleMath">σ(S,s)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 65 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( ApproxP( pi, spos ) );</span>
209/3264
</pre></div>

<p><a id="X7A3BB5AA83A2BDF3" name="X7A3BB5AA83A2BDF3"></a></p>

<h5>11.4-14 <span class="Heading"><span class="SimpleMath">U_6(2)</span></span></h5>

<p>We show that <span class="SimpleMath">S = U_6(2) = PSU(6,2)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">11</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">U_5(2) = SU(5,2)</span> and three groups of the type <span class="SimpleMath">M_22</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 5/21</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p>The preimage of <span class="SimpleMath">s</span> in the matrix group <span class="SimpleMath">SU(6,2) = 3.U_6(2)</span> can be chosen of order <span class="SimpleMath">33</span>, and the preimages of the groups in <span class="SimpleMath">𝕄(S,s)</span> have the structures <span class="SimpleMath">3 × U_5(2) ≅ GU(5,2)</span> and <span class="SimpleMath">3.M_22</span>, respectively.</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>With <span class="SimpleMath">s</span> as in (a), the automorphic extensions <span class="SimpleMath">S.2</span>, <span class="SimpleMath">S.3</span> of <span class="SimpleMath">S</span> satisfy <span class="SimpleMath">σ^'(S.2,s) = 5/96</span> and <span class="SimpleMath">σ^'(S.3,s) = 59/224</span>.</p>

</dd>
</dl>
<p>According to the list of maximal subgroups of <span class="SimpleMath">S</span> in <a href="chapBib.html#biBCCN85">[CCN+85, p. 115]</a>, <span class="SimpleMath">s</span> is contained exactly in maximal subgroups of the types <span class="SimpleMath">U_5(2)</span> (one class) and <span class="SimpleMath">M_22</span> (three classes).</p>

<p>The permutation character of the action on the cosets of <span class="SimpleMath">U_5(2)</span> type subgroups is uniquely determined by the character tables. We get three possibilities for the permutation character on the cosets of <span class="SimpleMath">M_22</span> type subgroups; they correspond to the three classes of such subgroups, because each of these classes contains elements in exactly one of the conjugacy classes <code class="code">4C</code>, <code class="code">4D</code>, and <code class="code">4E</code> of elements in <span class="SimpleMath">S</span>, and these classes are fused under the outer automorphism of <span class="SimpleMath">S</span> of order three.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "U6(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:= CharacterTable( "U5(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1:= PossiblePermutationCharacters( s1, t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( pi1 );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s2:= CharacterTable( "M22" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2:= PossiblePermutationCharacters( s2, t );</span>
[ Character( CharacterTable( "U6(2)" ),
  [ 20736, 0, 384, 0, 0, 0, 54, 0, 0, 0, 0, 48, 0, 16, 6, 0, 0, 0, 0, 
      0, 0, 6, 0, 2, 0, 0, 0, 4, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 0, 0, 0 ] ), Character( CharacterTable( "U6(2)" ),
  [ 20736, 0, 384, 0, 0, 0, 54, 0, 0, 0, 48, 0, 0, 16, 6, 0, 0, 0, 0, 
      0, 0, 6, 0, 2, 0, 0, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 0, 0, 0 ] ), Character( CharacterTable( "U6(2)" ),
  [ 20736, 0, 384, 0, 0, 0, 54, 0, 0, 48, 0, 0, 0, 16, 6, 0, 0, 0, 0, 
      0, 0, 6, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 0, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">imgs:= Set( pi2, x -&gt; Position( x, 48 ) );</span>
[ 10, 11, 12 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasClassNames( t ){ imgs };</span>
[ "4C", "4D", "4E" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetFusionMap( t, CharacterTable( "U6(2).3" ) ){ imgs };</span>
[ 10, 10, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= Concatenation( pi1, pi2 );;</span>
</pre></div>

<p>Now statement (a) follows from the fact that the permutation characters have the value <span class="SimpleMath">1</span> on <span class="SimpleMath">s</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 11 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( prim, x -&gt; x[ spos ] );</span>
[ 1, 1, 1, 1 ]
</pre></div>

<p>For statement (b), we compute <span class="SimpleMath">σ(S,s)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( ApproxP( prim, spos ) );</span>
5/21
</pre></div>

<p>Statement (c) follows from <a href="chapBib.html#biBCCN85">[CCN+85]</a>, plus the information that <span class="SimpleMath">3.U_6(2)</span> does not contain groups of the structure <span class="SimpleMath">3 × M_22</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossibleClassFusions(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "Cyclic", 3 ) * CharacterTable( "M22" ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "3.U6(2)" ) );</span>
[  ]
</pre></div>

<p>For statement (d), we need that the relevant maximal subgroups of <span class="SimpleMath">S.2</span> are <span class="SimpleMath">U_5(2).2</span> and one subgroup <span class="SimpleMath">M_22.2</span>, and that the relevant maximal subgroup of <span class="SimpleMath">S.3</span> is <span class="SimpleMath">U_5(2) × 3</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 115]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "U6(2).2" ), "11AB",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ CharacterTable( "U5(2).2" ), CharacterTable( "M22.2" ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ 1, 1 ], "outer" );</span>
5/96
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "U6(2).3" ), "11A",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ CharacterTable( "U5(2)" ) * CharacterTable( "Cyclic", 3 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ 1 ], "outer" );</span>
59/224
</pre></div>

<p><a id="X8237B8617D6F6027" name="X8237B8617D6F6027"></a></p>

<h4>11.5 <span class="Heading">Computations using Groups</span></h4>

<p>Before we start the computations using groups, we clean the workspace.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CleanWorkspace();</span>
</pre></div>

<p><a id="X815320787B601000" name="X815320787B601000"></a></p>

<h5>11.5-1 <span class="Heading"><span class="SimpleMath">A_2m+1</span>, <span class="SimpleMath">2 ≤ m ≤ 11</span></span></h5>

<p>For alternating groups of odd degree <span class="SimpleMath">n = 2m+1</span>, we choose <span class="SimpleMath">s</span> to be an <span class="SimpleMath">n</span>-cycle. The interesting cases in <a href="chapBib.html#biBBGK">[BGK08, Proposition 6.7]</a> are <span class="SimpleMath">5 ≤ n ≤ 23</span>.</p>

<p>In each case, we compute representatives of the maximal subgroups of <span class="SimpleMath">A_n</span>, consider only those that contain an <span class="SimpleMath">n</span>-cycle, and then compute the permutation characters. Additionally, we show also the names that are used for the subgroups in the <strong class="pkg">GAP</strong> Library of Transitive Groups, see <a href="chapBib.html#biBHulpkeTG">[Hul05]</a> and the documentation of this library in the <strong class="pkg">GAP</strong> Reference Manual.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrimitivesInfoForOddDegreeAlternatingGroup:= function( n )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local G, max, cycle, spos, prim, nonz;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    G:= AlternatingGroup( n );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Compute representatives of the classes of maximal subgroups.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    max:= MaximalSubgroupClassReps( G );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Omit subgroups that cannot contain an `n'-cycle.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    max:= Filtered( max, m -&gt; IsTransitive( m, [ 1 .. n ] ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Compute the permutation characters.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    cycle:= [];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    cycle[ n-1 ]:= 1;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    spos:= PositionProperty( ConjugacyClasses( CharacterTable( G ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               c -&gt; CycleStructurePerm( Representative( c ) ) = cycle );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    prim:= List( max, m -&gt; TrivialCharacter( m )^G );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    nonz:= PositionsProperty( prim, x -&gt; x[ spos ] &lt;&gt; 0 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Compute the subgroup names and the multiplicities.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return rec( spos := spos,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                prim := prim{ nonz },</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                grps := List( max{ nonz },</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                              m -&gt; TransitiveGroup( n,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                       TransitiveIdentification( m ) ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                mult := List( prim{ nonz }, x -&gt; x[ spos ] ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p>The sets <span class="SimpleMath">𝕄/~(s)</span> and the values <span class="SimpleMath">σ(A_n,s)</span> are as follows. For each degree in question, the first list shows names for representatives of the conjugacy classes of maximal subgroups containing a fixed <span class="SimpleMath">n</span>-cycle, and the second list shows the number of conjugates in each class.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for n in [ 5, 7 .. 23 ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     prim:= PrimitivesInfoForOddDegreeAlternatingGroup( n );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     bound:= Maximum( ApproxP( prim.prim, prim.spos ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Print( n, ": ", prim.grps, ", ", prim.mult, ", ", bound, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">od;</span>
5: [ D(5) = 5:2 ], [ 1 ], 1/3
7: [ L(7) = L(3,2), L(7) = L(3,2) ], [ 1, 1 ], 2/5
9: [ 1/2[S(3)^3]S(3), L(9):3=P|L(2,8) ], [ 1, 3 ], 9/35
11: [ M(11), M(11) ], [ 1, 1 ], 2/105
13: [ F_78(13)=13:6, L(13)=PSL(3,3), L(13)=PSL(3,3) ], [ 1, 2, 2 ], 4/
1155
15: [ 1/2[S(3)^5]S(5), 1/2[S(5)^3]S(3), L(15)=A_8(15)=PSL(4,2), 
  L(15)=A_8(15)=PSL(4,2) ], [ 1, 1, 1, 1 ], 29/273
17: [ L(17):4=PYL(2,16), L(17):4=PYL(2,16) ], [ 1, 1 ], 2/135135
19: [ F_171(19)=19:9 ], [ 1 ], 1/6098892800
21: [ t21n150, t21n161, t21n91 ], [ 1, 1, 2 ], 29/285
23: [ M(23), M(23) ], [ 1, 1 ], 2/130945815
</pre></div>

<p>In the above output, a subgroup printed as <code class="code">1/2[S(</code><span class="SimpleMath">n_1</span><code class="code">)^</code><span class="SimpleMath">n_2</span><code class="code">]S(</code><span class="SimpleMath">n_2</span><code class="code">)</code>, <code class="code">1/2[S(</code><span class="SimpleMath">n_1</span><code class="code">)^</code><span class="SimpleMath">n_2</span><code class="code">]S(</code><span class="SimpleMath">n_2</span><code class="code">)</code>, where <span class="SimpleMath">n = n_1 n_2</span> holds, denotes the intersection of <span class="SimpleMath">A_n</span> with the wreath product <span class="SimpleMath">S_n_1 ≀ S_n_2 ≤ S_n</span>. (Note that the <strong class="pkg">Atlas</strong> denotes the subgroup <code class="code">1/2[S(3)^3]S(3)</code> of <span class="SimpleMath">A_9</span> as <span class="SimpleMath">3^3:S_4</span>.) The groups printed as <code class="code">P|L(2,8)</code> and <code class="code">PYL(2,16)</code> denote <span class="SimpleMath">PΓL(2,8)</span> and <span class="SimpleMath">PΓL(2,16)</span>, respectively. And the three subgroups of <span class="SimpleMath">A_21</span> have the structures <span class="SimpleMath">(S_3 ≀ S_7) ∩ A_21</span>, <span class="SimpleMath">(S_7 ≀ S_3) ∩ A_21</span>, and <span class="SimpleMath">PGL(3,4)</span>, respectively.</p>

<p>Note that <span class="SimpleMath">A_9</span> contains two conjugacy classes of maximal subgroups of the type <span class="SimpleMath">PΓL(2,8) ≅ L_2(8):3</span>, and that each <span class="SimpleMath">9</span>-cycle in <span class="SimpleMath">A_9</span> is contained in exactly three <em>conjugate</em> subgroups of this type. For <span class="SimpleMath">n ∈ { 13, 15, 17 }</span>, <span class="SimpleMath">A_n</span> contains two conjugacy classes of isomorphic maximal subgroups of linear type, and each <span class="SimpleMath">n</span>-cycle is contained in subgroups from each class. Finally, <span class="SimpleMath">A_21</span> contains only one class of maximal subgroups of linear type.</p>

<p>For the two groups <span class="SimpleMath">A_5</span> and <span class="SimpleMath">A_7</span>, the values computed above are not sufficient. See Section <a href="chap11.html#X7B5321337B28100B"><span class="RefLink">11.5-2</span></a> and <a href="chap11.html#X85B3C7217B105D4D"><span class="RefLink">11.5-4</span></a> for a further treatment.</p>

<p>The above computations look like a brute-force approach, but note that the computation of the maximal subgroups of alternating and symmetric groups in <strong class="pkg">GAP</strong> uses the classification of these subgroups, and also the conjugacy classes of elements in alternating and symmetric groups can be computed cheaply.</p>

<p>Alternative (character-theoretic) computations for <span class="SimpleMath">n ∈ { 5, 7, 9, 11, 13 }</span> were shown in Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>. (A hand calculation for the case <span class="SimpleMath">n = 19</span> can be found in <a href="chapBib.html#biBBW1">[BW75]</a>.)</p>

<p><a id="X7B5321337B28100B" name="X7B5321337B28100B"></a></p>

<h5>11.5-2 <span class="Heading"><span class="SimpleMath">A_5</span></span></h5>

<p>We show that <span class="SimpleMath">S = A_5</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">σ(S) = 1/3</span>, and this value is attained exactly for <span class="SimpleMath">σ(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">5</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">5</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">D_10</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">P(S) = 1/3</span>, and this value is attained exactly for <span class="SimpleMath">P(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">5</span>.</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>Each element in <span class="SimpleMath">S</span> together with one of <span class="SimpleMath">(1,2)(3,4)</span>, <span class="SimpleMath">(1,3)(2,4)</span>, <span class="SimpleMath">(1,4)(2,3)</span> generates a proper subgroup of <span class="SimpleMath">S</span>.</p>

</dd>
<dt><strong class="Mark">(e)</strong></dt>
<dd><p>Both the spread and the uniform spread of <span class="SimpleMath">S</span> is exactly two (see <a href="chapBib.html#biBBW1">[BW75]</a>), with <span class="SimpleMath">s</span> of order <span class="SimpleMath">5</span>.</p>

</dd>
</dl>
<p>Statement (a) follows from inspection of the primitive permutation characters, cf. Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoSimple( t );</span>
[ "A5", 1/3, 2, [ "5A" ], [ 1 ] ]
</pre></div>

<p>Statement (b) can be read off from the primitive permutation characters, and the fact that the unique class of maximal subgroups that contain elements of order <span class="SimpleMath">5</span> consists of groups of the structure <span class="SimpleMath">D_10</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 2]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( t );</span>
[ 1, 2, 3, 5, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrimitivePermutationCharacters( t );</span>
[ Character( CharacterTable( "A5" ), [ 5, 1, 2, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 6, 2, 0, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 10, 2, 1, 0, 0 ] ) ]
</pre></div>

<p>For statement (c), we compute that for all nonidentity elements <span class="SimpleMath">s ∈ S</span> and involutions <span class="SimpleMath">g ∈ S</span>, <span class="SimpleMath">P(g,s) ≥ 1/3</span> holds, with equality if and only if <span class="SimpleMath">s</span> has order <span class="SimpleMath">5</span>. We actually compute, for class representatives <span class="SimpleMath">s</span>, the proportion of involutions <span class="SimpleMath">g</span> such that <span class="SimpleMath">⟨ g, s ⟩ ≠ S</span> holds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= AlternatingGroup( 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv:= g.1^2 * g.2;</span>
(1,4)(2,5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cclreps:= List( ConjugacyClasses( g ), Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SortParallel( List( cclreps, Order ), cclreps );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( cclreps, Order );</span>
[ 1, 2, 3, 5, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( ConjugacyClass( g, inv ) );</span>
15
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prop:= List( cclreps,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                r -&gt; RatioOfNongenerationTransPermGroup( g, inv, r ) );</span>
[ 1, 1, 3/5, 1/3, 1/3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Minimum( prop );</span>
1/3
</pre></div>

<p>Statement (d) follows by explicit computations.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">triple:= [ (1,2)(3,4), (1,3)(2,4), (1,4)(2,3) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CommonGeneratorWithGivenElements( g, cclreps, triple );</span>
fail
</pre></div>

<p>As for statement (e), we know from (a) that the uniform spread of <span class="SimpleMath">S</span> is at least two, and from (d) that the spread is less than three.</p>

<p><a id="X82C3B4287B0C7BEE" name="X82C3B4287B0C7BEE"></a></p>

<h5>11.5-3 <span class="Heading"><span class="SimpleMath">A_6</span></span></h5>

<p>We show that <span class="SimpleMath">S = A_6</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">σ(S) = 2/3</span>, and this value is attained exactly for <span class="SimpleMath">σ(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">5</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s</span> of order <span class="SimpleMath">5</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of two nonconjugate groups of the type <span class="SimpleMath">A_5</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">P(S) = 5/9</span>, and this value is attained exactly for <span class="SimpleMath">P(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">5</span>.</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>Each element in <span class="SimpleMath">S</span> together with one of <span class="SimpleMath">(1,2)(3,4)</span>, <span class="SimpleMath">(1,3)(2,4)</span>, <span class="SimpleMath">(1,4)(2,3)</span> generates a proper subgroup of <span class="SimpleMath">S</span>.</p>

</dd>
<dt><strong class="Mark">(e)</strong></dt>
<dd><p>Both the spread and the uniform spread of <span class="SimpleMath">S</span> is exactly two (see <a href="chapBib.html#biBBW1">[BW75]</a>), with <span class="SimpleMath">s</span> of order <span class="SimpleMath">4</span>.</p>

</dd>
<dt><strong class="Mark">(f)</strong></dt>
<dd><p>For <span class="SimpleMath">x</span>, <span class="SimpleMath">y ∈ S_6^×</span>, there is <span class="SimpleMath">s ∈ S_6</span> such that <span class="SimpleMath">S ⊆ ⟨ x, s ⟩ ∩ ⟨ y, s ⟩</span>. It is <em>not</em> possible to find <span class="SimpleMath">s ∈ S</span> with this property, or <span class="SimpleMath">s</span> in a prescribed conjugacy class of <span class="SimpleMath">S_6</span>.</p>

</dd>
<dt><strong class="Mark">(g)</strong></dt>
<dd><p><span class="SimpleMath">σ( PGL(2,9) ) = 1/6</span> and <span class="SimpleMath">σ( M_10 ) = 1/9</span>, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">10</span> and <span class="SimpleMath">8</span>, respectively.</p>

</dd>
</dl>
<p>(Note that in this example, the optimal choice of <span class="SimpleMath">s</span> for <span class="SimpleMath">P(S)</span> cannot be used to obtain the result on the exact spread.)</p>

<p>Statement (a) follows from inspection of the primitive permutation characters, cf. Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "A6" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoSimple( t );</span>
[ "A6", 2/3, 1, [ "5A" ], [ 2 ] ]
</pre></div>

<p>Statement (b) can be read off from the permutation characters, and the fact that the two classes of maximal subgroups that contain elements of order <span class="SimpleMath">5</span> consist of groups of the structure <span class="SimpleMath">A_5</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 4]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( t );</span>
[ 1, 2, 3, 3, 4, 5, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= PrimitivePermutationCharacters( t );</span>
[ Character( CharacterTable( "A6" ), [ 6, 2, 3, 0, 0, 1, 1 ] ), 
  Character( CharacterTable( "A6" ), [ 6, 2, 0, 3, 0, 1, 1 ] ), 
  Character( CharacterTable( "A6" ), [ 10, 2, 1, 1, 2, 0, 0 ] ), 
  Character( CharacterTable( "A6" ), [ 15, 3, 3, 0, 1, 0, 0 ] ), 
  Character( CharacterTable( "A6" ), [ 15, 3, 0, 3, 1, 0, 0 ] ) ]
</pre></div>

<p>For statement (c), we first compute that for all nonidentity elements <span class="SimpleMath">s ∈ S</span> and involutions <span class="SimpleMath">g ∈ S</span>, <span class="SimpleMath">P(g,s) ≥ 5/9</span> holds, with equality if and only if <span class="SimpleMath">s</span> has order <span class="SimpleMath">5</span>. We actually compute, for class representatives <span class="SimpleMath">s</span>, the proportion of involutions <span class="SimpleMath">g</span> such that <span class="SimpleMath">⟨ g, s ⟩ ≠ S</span> holds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S:= AlternatingGroup( 6 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv:= (S.1*S.2)^2;</span>
(1,3)(2,5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cclreps:= List( ConjugacyClasses( S ), Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SortParallel( List( cclreps, Order ), cclreps );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( cclreps, Order );</span>
[ 1, 2, 3, 3, 4, 5, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:= ConjugacyClass( S, inv );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( C );</span>
45
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prop:= List( cclreps,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                r -&gt; RatioOfNongenerationTransPermGroup( S, inv, r ) );</span>
[ 1, 1, 1, 1, 29/45, 5/9, 5/9 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Minimum( prop );</span>
5/9
</pre></div>

<p>Now statement (c) follows from the fact that for <span class="SimpleMath">g ∈ S</span> of order larger than two, <span class="SimpleMath">σ(S,g) ≤ 1/2 &lt; 5/9</span> holds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxP( prim, 6 );</span>
[ 0, 2/3, 1/2, 1/2, 0, 1/3, 1/3 ]
</pre></div>

<p>Statement (d) follows by explicit computations.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">triple:= [ (1,2)(3,4), (1,3)(2,4), (1,4)(2,3) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CommonGeneratorWithGivenElements( S, cclreps, triple );</span>
fail
</pre></div>

<p>An alternative triple to that in statement (d) is the one given in <a href="chapBib.html#biBBW1">[BW75]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">triple:= [ (1,3)(2,4), (1,5)(2,6), (3,6)(4,5) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CommonGeneratorWithGivenElements( S, cclreps, triple );</span>
fail
</pre></div>

<p>Of course we can also construct such a triple, as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TripleWithProperty( [ [ inv ], C, C ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       l -&gt; ForAll( S, elm -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  ForAny( l, x -&gt; not IsGeneratorsOfTransPermGroup( S, [ elm, x ] ) ) ) );</span>
[ (1,3)(2,5), (1,3)(2,6), (1,3)(2,4) ]
</pre></div>

<p>For statement (e), we use the random approach described in Section <a href="chap11.html#X83DACCF07EF62FAE"><span class="RefLink">11.3-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= (1,2,3,4)(5,6);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= Filtered( cclreps, x -&gt; Order( x ) &gt; 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for pair in UnorderedTuples( reps, 2 ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if RandomCheckUniformSpread( S, pair, s, 40 ) &lt;&gt; true then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#E  nongeneration!\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
</pre></div>

<p>We get no output, so a suitable element of order <span class="SimpleMath">4</span> works in all cases. Note that we cannot use an element of order <span class="SimpleMath">5</span>, because it fixes a point in the natural permutation representation, and we may take <span class="SimpleMath">x_1 = (1,2,3)</span> and <span class="SimpleMath">x_2 = (4,5,6)</span>. With this argument, only elements of order <span class="SimpleMath">4</span> and double <span class="SimpleMath">3</span>-cycles are possible choices for <span class="SimpleMath">s</span>, and the latter are excluded by the fact that an outer automorphism maps the class of double <span class="SimpleMath">s</span>-cycles in <span class="SimpleMath">A_6</span> to the class of <span class="SimpleMath">3</span>-cycles. So no element in <span class="SimpleMath">A_6</span> of order different from <span class="SimpleMath">4</span> works.</p>

<p>Next we show statement (f). Already in <span class="SimpleMath">A_6.2_1 = S_6</span>, elements <span class="SimpleMath">s</span> of order <span class="SimpleMath">4</span> do in general not work because they do not generate with transpositions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= SymmetricGroup( 6 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RatioOfNongenerationTransPermGroup( G, s, (1,2) );</span>
1
</pre></div>

<p>Also, choosing <span class="SimpleMath">s</span> from a prescribed conjugacy class of <span class="SimpleMath">S_6</span> (that is, also <span class="SimpleMath">s</span> outside <span class="SimpleMath">A_6</span> is allowed) with the property that <span class="SimpleMath">A_6 ⊆ ⟨ x, s ⟩ ∩ ⟨ y, s ⟩</span> is not possible. Note that only <span class="SimpleMath">6</span>-cycles are possible for <span class="SimpleMath">s</span> if <span class="SimpleMath">x</span> and <span class="SimpleMath">y</span> are commuting transpositions, and –applying the outer automorphism– no <span class="SimpleMath">6</span>-cycle works for two commuting fixed-point free involutions. (The group is small enough for a brute force test.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">goods:= Filtered( Elements( G ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     s -&gt; IsGeneratorsOfTransPermGroup( G, [ s, (1,2) ] ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          IsGeneratorsOfTransPermGroup( G, [ s, (3,4) ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected( List( goods, CycleStructurePerm ) );</span>
[ [ [ ,,,, 1 ], 24 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">goods:= Filtered( Elements( G ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     s -&gt; IsGeneratorsOfTransPermGroup( G, [ s, (1,2)(3,4)(5,6) ] ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          IsGeneratorsOfTransPermGroup( G, [ s, (1,3)(2,4)(5,6) ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected( List( goods, CycleStructurePerm ) );</span>
[ [ [ 1, 1 ], 24 ] ]
</pre></div>

<p>However, for each pair of nonidentity element <span class="SimpleMath">x</span>, <span class="SimpleMath">y ∈ S_6</span>, there is <span class="SimpleMath">s ∈ S_6</span> such that <span class="SimpleMath">⟨ x, s ⟩</span> and <span class="SimpleMath">⟨ y, s ⟩</span> both contain <span class="SimpleMath">A_6</span>. (If <span class="SimpleMath">s</span> works for the pair <span class="SimpleMath">(x,y)</span> then <span class="SimpleMath">s^g</span> works for <span class="SimpleMath">(x^g,y^g)</span>, so it is sufficient to consider only orbit representatives <span class="SimpleMath">(x,y)</span> under the conjugation action of <span class="SimpleMath">G</span> on pairs. Thus we check conjugacy class representatives <span class="SimpleMath">x</span> and, for fixed <span class="SimpleMath">x</span>, representatives of orbits of <span class="SimpleMath">C_G(x)</span> on the classes <span class="SimpleMath">y^G</span>, i. e., representatives of <span class="SimpleMath">C_G(y)</span>-<span class="SimpleMath">C_G(x)</span>-double cosets in <span class="SimpleMath">G</span>. Moreover, clearly we can restrict the checks to elements <span class="SimpleMath">x</span>, <span class="SimpleMath">y</span> of prime order.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Sgens:= GeneratorsOfGroup( S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">primord:= Filtered( List( ConjugacyClasses( G ), Representative ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       x -&gt; IsPrimeInt( Order( x ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for x in primord do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     for y in primord do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       for pair in DoubleCosetRepsAndSizes( G, Centralizer( G, y ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       Centralizer( G, x ) ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if not ForAny( G, s -&gt; IsSubset( Group( x,s ), S ) and </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                IsSubset( Group( y^pair[1], s ), S ) ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Error( [ x, y ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
</pre></div>

<p>In other words, the spread of <span class="SimpleMath">S_6</span> is <span class="SimpleMath">2</span> but the uniform spread of <span class="SimpleMath">S_6</span> is not <span class="SimpleMath">2</span> but only <span class="SimpleMath">1</span>.</p>

<p>We cannot always find <span class="SimpleMath">s ∈ A_6</span> with the required property: If <span class="SimpleMath">x</span> is a transposition then any <span class="SimpleMath">s</span> with <span class="SimpleMath">S ⊆⟨ x, s ⟩</span> must be a <span class="SimpleMath">5</span>-cycle.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">filt:= Filtered( S, s -&gt; IsSubset( Group( (1,2), s ), S ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected( List( filt, Order ) );</span>
[ [ 5, 48 ] ]
</pre></div>

<p>Moreover, clearly such <span class="SimpleMath">s</span> fixes one of the moved points of <span class="SimpleMath">x</span>, so we may prescribe a transposition <span class="SimpleMath">y ≠ x</span> that commutes with <span class="SimpleMath">x</span>, it satisfies <span class="SimpleMath">S ⊈⟨ y, s ⟩</span>.</p>

<p>For the other two automorphic extensions <span class="SimpleMath">A_6.2_2 = PGL(2,9)</span> and <span class="SimpleMath">A_6.2_3 = M_10</span>, we compute the character-theoretic bounds <span class="SimpleMath">σ(A_6.2_2) = 1/6</span> and <span class="SimpleMath">σ(A_6.2_3) = 1/9</span>, which shows statement (g).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoSimple( CharacterTable( "A6.2_2" ) );</span>
[ "A6.2_2", 1/6, 5, [ "10A" ], [ 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoSimple( CharacterTable( "A6.2_3" ) );</span>
[ "A6.2_3", 1/9, 8, [ "8C" ], [ 1 ] ]
</pre></div>

<p>Note that <span class="SimpleMath">σ^'( PGL(2,9), s ) = 1/6</span>, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">5</span>, and <span class="SimpleMath">σ^'( M_10, s ) = 0</span> for any <span class="SimpleMath">s ∈ A_6</span> since <span class="SimpleMath">M_10</span> is a non-split extension of <span class="SimpleMath">A_6</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "A6" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "A6.2_2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= PositionsProperty( OrdersClassRepresentatives( t ), x -&gt; x = 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoAlmostSimple( t, t2, spos );</span>
[ "A6.2_2", 1/6, [ "5A", "5B" ], [ 1, 1 ] ]
</pre></div>

<p><a id="X85B3C7217B105D4D" name="X85B3C7217B105D4D"></a></p>

<h5>11.5-4 <span class="Heading"><span class="SimpleMath">A_7</span></span></h5>

<p>We show that <span class="SimpleMath">S = A_7</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">σ(S) = 2/5</span>, and this value is attained exactly for <span class="SimpleMath">σ(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of two nonconjugate subgroups of the type <span class="SimpleMath">L_2(7)</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">P(S) = 2/5</span>, and this value is attained exactly for <span class="SimpleMath">P(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span>.</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>The uniform spread of <span class="SimpleMath">S</span> is exactly three, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span>.</p>

</dd>
</dl>
<p>Statement (a) follows from inspection of the primitive permutation characters, cf. Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "A7" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoSimple( t );</span>
[ "A7", 2/5, 2, [ "7A" ], [ 2 ] ]
</pre></div>

<p>Statement (b) can be read off from the permutation characters, and the fact that the two classes of maximal subgroups that contain elements of order <span class="SimpleMath">7</span> consist of groups of the structure <span class="SimpleMath">L_2(7)</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 10]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( t );</span>
[ 1, 2, 3, 3, 4, 5, 6, 7, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= PrimitivePermutationCharacters( t );</span>
[ Character( CharacterTable( "A7" ), [ 7, 3, 4, 1, 1, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A7" ), [ 15, 3, 0, 3, 1, 0, 0, 1, 1 ] ),
  Character( CharacterTable( "A7" ), [ 15, 3, 0, 3, 1, 0, 0, 1, 1 ] ),
  Character( CharacterTable( "A7" ), [ 21, 5, 6, 0, 1, 1, 2, 0, 0 ] ),
  Character( CharacterTable( "A7" ), [ 35, 7, 5, 2, 1, 0, 1, 0, 0 ] ) 
 ]
</pre></div>

<p>For statement (c), we compute that for all nonidentity elements <span class="SimpleMath">s ∈ S</span> and involutions <span class="SimpleMath">g ∈ S</span>, <span class="SimpleMath">P(g,s) ≥ 2/5</span> holds, with equality if and only if <span class="SimpleMath">s</span> has order <span class="SimpleMath">7</span>. We actually compute, for class representatives <span class="SimpleMath">s</span>, the proportion of involutions <span class="SimpleMath">g</span> such that <span class="SimpleMath">⟨ g, s ⟩ ≠ S</span> holds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= AlternatingGroup( 7 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv:= (g.1^3*g.2)^3;</span>
(2,6)(3,7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= List( ConjugacyClasses( g ), Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SortParallel( List( ccl, Order ), ccl );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ccl, Order );</span>
[ 1, 2, 3, 3, 4, 5, 6, 7, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( ConjugacyClass( g, inv ) );</span>
105
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prop:= List( ccl, r -&gt; RatioOfNongenerationTransPermGroup( g, inv, r ) );</span>
[ 1, 1, 1, 1, 89/105, 17/21, 19/35, 2/5, 2/5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Minimum( prop );</span>
2/5
</pre></div>

<p>For statement (d), we use the random approach described in Section <a href="chap11.html#X83DACCF07EF62FAE"><span class="RefLink">11.3-3</span></a>. By the character-theoretic bounds, it suffices to consider triples of elements in the classes <code class="code">2A</code> or <code class="code">3B</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( t );</span>
[ 1, 2, 3, 3, 4, 5, 6, 7, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 7 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesCentralizers( t );</span>
[ 2520, 24, 36, 9, 4, 5, 12, 7, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxP( prim, spos );</span>
[ 0, 2/5, 0, 2/5, 2/15, 0, 0, 2/15, 2/15 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= (1,2,3,4,5,6,7);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3B:= (1,2,3)(4,5,6);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C3B:= ConjugacyClass( g, 3B );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( C3B );</span>
280
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for triple in UnorderedTuples( [ inv, 3B ], 3 ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if RandomCheckUniformSpread( g, triple, s, 80 ) &lt;&gt; true then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#E  nongeneration!\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
</pre></div>

<p>We get no output, so the uniform spread of <span class="SimpleMath">S</span> is at least three.</p>

<p>Alternatively, we can use the lemma from Section <a href="chap11.html#X79D7312484E78274"><span class="RefLink">11.2-2</span></a>; this approach is technically more involved but faster. We work with the diagonal product of the two degree <span class="SimpleMath">15</span> representations of <span class="SimpleMath">S</span>, which is constructed from the information stored in the <strong class="pkg">GAP</strong> Library of Tables of Marks.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tom:= TableOfMarks( "A7" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a7:= UnderlyingGroup( tom );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tommaxes:= MaximalSubgroupsTom( tom );</span>
[ [ 39, 38, 37, 36, 35 ], [ 7, 15, 15, 21, 35 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">index15:= List( tommaxes[1]{ [ 2, 3 ] },</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   i -&gt; RepresentativeTom( tom, i ) );</span>
[ Group([ (1,3)(2,7), (1,5,7)(3,4,6) ]), 
  Group([ (1,4)(2,3), (2,4,6)(3,5,7) ]) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">deg15:= List( index15, s -&gt; RightTransversal( a7, s ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= List( deg15, l -&gt; Action( a7, l, OnRight ) );</span>
[ Group([ (1,5,7)(2,9,10)(3,11,4)(6,12,8)(13,14,15), (1,8,15,5,12)
      (2,13,11,3,10)(4,14,9,7,6) ]), 
  Group([ (1,2,3)(4,6,5)(7,8,9)(10,12,11)(13,15,14), (1,12,3,13,10)
      (2,9,15,4,11)(5,6,14,7,8) ]) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= DiagonalProductOfPermGroups( reps );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 7;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrMovedPoints( s );</span>
28
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mpg:= MovedPoints( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fixs:= Difference( mpg, MovedPoints( s ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb_s:= Orbit( g, fixs, OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( orb_s );</span>
120
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesCentralizers( t );</span>
[ 2520, 24, 36, 9, 4, 5, 12, 7, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat 2a:= Random( g ); until Order( 2a ) = 2;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat 3b:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( 3b ) = 3 and Size( Centralizer( g, 3b ) ) = 9;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb2a:= Orbit( g, Difference( mpg, MovedPoints( 2a ) ), OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb3b:= Orbit( g, Difference( mpg, MovedPoints( 3b ) ), OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb2aor3b:= Union( orb2a, orb3b );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TripleWithProperty( [ [ orb2a[1], orb3b[1] ], orb2aor3b, orb2aor3b ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       l -&gt; ForAll( orb_s,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                f -&gt; not IsEmpty( Intersection( Union( l ), f ) ) ) );</span>
fail
</pre></div>

<p>It remains to show that for any choice of <span class="SimpleMath">s ∈ S</span>, a quadruple of elements in <span class="SimpleMath">S^×</span> exists such that <span class="SimpleMath">s</span> generates a proper subgroup of <span class="SimpleMath">S</span> together with at least one of these elements.</p>

<p>First we observe (without using <strong class="pkg">GAP</strong>) that there is a pair of <span class="SimpleMath">3</span>-cycles whose fixed points cover the seven points of the natural permutation representation. This implies the statement for all elements <span class="SimpleMath">s ∈ S</span> that fix a point in this representation. So it remains to consider elements <span class="SimpleMath">s</span> of the orders six and seven.</p>

<p>For the order seven element, the above setup and the lemma from Section <a href="chap11.html#X79D7312484E78274"><span class="RefLink">11.2-2</span></a> can be used.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QuadrupleWithProperty( [ [ orb2a[1] ], orb2a, orb2a, orb2a ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       l -&gt; ForAll( orb_s,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                f -&gt; not IsEmpty( Intersection( Union( l ), f ) ) ) );</span>
[ [ 2, 5, 12, 18, 19, 26 ], [ 7, 8, 9, 16, 21, 25 ], 
  [ 1, 6, 10, 17, 20, 27 ], [ 13, 14, 15, 28, 29, 30 ] ]
</pre></div>

<p>For the order six element, we use the diagonal product of the primitive permutation representations of the degrees <span class="SimpleMath">21</span> and <span class="SimpleMath">35</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">has6A:= List( tommaxes[1]{ [ 4, 5 ] },</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 i -&gt; RepresentativeTom( tom, i ) );</span>
[ Group([ (1,2)(3,7), (2,6,5,4)(3,7) ]), 
  Group([ (2,3)(5,7), (1,2)(4,5,6,7), (2,3)(5,6) ]) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">trans:= List( has6A, s -&gt; RightTransversal( a7, s ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= List( trans, l -&gt; Action( a7, l, OnRight ) );</span>
[ Group([ (1,16,12)(2,17,13)(3,18,11)(4,19,14)(15,20,21), (1,4,7,9,10)
      (2,5,8,3,6)(11,12,15,14,13)(16,20,19,17,18) ]), 
  Group([ (2,16,6)(3,17,7)(4,18,8)(5,19,9)(10,20,26)(11,21,27)
      (12,22,28)(13,23,29)(14,24,30)(15,25,31), (1,2,3,4,5)
      (6,10,13,15,9)(7,11,14,8,12)(16,20,23,25,19)(17,21,24,18,22)
      (26,32,35,31,28)(27,33,29,34,30) ]) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= DiagonalProductOfPermGroups( reps );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 6;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrMovedPoints( s );</span>
53
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mpg:= MovedPoints( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fixs:= Difference( mpg, MovedPoints( s ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb_s:= Orbit( g, fixs, OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( orb_s );</span>
105
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat 3a:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( 3a ) = 3 and Size( Centralizer( g, 3a ) ) = 36;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb3a:= Orbit( g, Difference( mpg, MovedPoints( 3a ) ), OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( orb3a );</span>
35
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TripleWithProperty( [ [ orb3a[1] ], orb3a, orb3a ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       l -&gt; ForAll( orb_s,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                f -&gt; not IsEmpty( Intersection( Union( l ), f ) ) ) );</span>
[ [ 1, 4, 6, 12, 14, 15, 34, 37, 40, 43, 49 ], 
  [ 1, 4, 6, 16, 19, 20, 27, 30, 33, 44, 49 ], 
  [ 2, 3, 4, 5, 7, 9, 26, 47, 48, 50, 53 ] ]
</pre></div>

<p>So we have found not only a quadruple but even a triple of <span class="SimpleMath">3</span>-cycles that excludes candidates <span class="SimpleMath">s</span> of order six.</p>

<p><a id="X84EA645A82E2BAFB" name="X84EA645A82E2BAFB"></a></p>

<h5>11.5-5 <span class="Heading"><span class="SimpleMath">L_d(q)</span></span></h5>

<p>In the treatment of small dimensional linear groups <span class="SimpleMath">S = SL(d,q)</span>, <a href="chapBib.html#biBBGK">[BGK08]</a> uses a Singer element <span class="SimpleMath">s</span> of order <span class="SimpleMath">(q^d-1)/(q-1)</span>. (So the order of the corresponding element in <span class="SimpleMath">PSL(d,q) = (q^d-1)/[(q-1) gcd(d,q-1)]</span>.) By <a href="chapBib.html#biBBe00">[Ber00]</a>, <span class="SimpleMath">𝕄(S,s)</span> consists of extension field type subgroups, except in the cases <span class="SimpleMath">d = 2</span>, <span class="SimpleMath">q ∈ { 2, 5, 7, 9 }</span>, and <span class="SimpleMath">(d,q) = (3,4)</span>. These subgroups have the structure <span class="SimpleMath">GL(d/p,q^p):α_q ∩ S</span>, for prime divisors <span class="SimpleMath">p</span> of <span class="SimpleMath">d</span>, where <span class="SimpleMath">α_q</span> denotes the Frobenius automorphism that acts on matrices by raising each entry to the <span class="SimpleMath">q</span>-th power. (If <span class="SimpleMath">q</span> is a prime then we have <span class="SimpleMath">GL(d/p,q^p):α_q = ΓL(d/p,q^p)</span>.) Since <span class="SimpleMath">s</span> acts irreducibly, it is contained in at most one conjugate of each class of extension field type subgroups (cf. <a href="chapBib.html#biBBGK">[BGK08, Lemma 2.12]</a>).</p>

<p>First we write a <strong class="pkg">GAP</strong> function <code class="code">RelativeSigmaL</code> that takes a positive integer <span class="SimpleMath">d</span> and a basis <span class="SimpleMath">B</span> of the field extension of degree <span class="SimpleMath">n</span> over the field with <span class="SimpleMath">q</span> elements, and returns the group <span class="SimpleMath">GL(d,q^n):α_q</span>, as a subgroup of <span class="SimpleMath">GL(dn,q)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelativeSigmaL:= function( d, B )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local n, F, q, glgens, diag, pi, frob, i;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    n:= Length( B );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    F:= LeftActingDomain( UnderlyingLeftModule( B ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    q:= Size( F );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Create the generating matrices inside the linear subgroup.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    glgens:= List( GeneratorsOfGroup( SL( d, q^n ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   m -&gt; BlownUpMat( B, m ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Create the matrix of a diagonal part that maps to determinant 1.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    diag:= IdentityMat( d*n, F );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    diag{ [ 1 .. n ] }{ [ 1 .. n ] }:= BlownUpMat( B, [ [ Z(q^n)^(q-1) ] ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Add( glgens, diag );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Create the matrix that realizes the Frobenius action,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # and adjust the determinant.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    pi:= List( B, b -&gt; Coefficients( B, b^q ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    frob:= NullMat( d*n, d*n, F );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    for i in [ 0 .. d-1 ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      frob{ [ 1 .. n ] + i*n }{ [ 1 .. n ] + i*n }:= pi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    diag:= IdentityMat( d*n, F );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    diag{ [ 1 .. n ] }{ [ 1 .. n ] }:= BlownUpMat( B, [ [ Z(q^n) ] ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    diag:= diag^LogFFE( Inverse( Determinant( frob ) ), Determinant( diag ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Return the result.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return Group( Concatenation( glgens, [ diag * frob ] ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p>The next function computes <span class="SimpleMath">σ(SL(d,q),s)</span>, by computing the sum of <span class="SimpleMath">μ(g,S/(GL(d/p,q^p):α_q ∩ S))</span>, for prime divisors <span class="SimpleMath">p</span> of <span class="SimpleMath">d</span>, and taking the maximum over <span class="SimpleMath">g ∈ S^×</span>. The computations take place in a permutation representation of <span class="SimpleMath">PSL(d,q)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForSL:= function( d, q )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local G, epi, PG, primes, maxes, names, ccl;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Check whether this is an admissible case (see [Be00]).</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if ( d = 2 and q in [ 2, 5, 7, 9 ] ) or ( d = 3 and q = 4 ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Create the group SL(d,q), and the map to PSL(d,q).</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    G:= SL( d, q );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    epi:= ActionHomomorphism( G, NormedRowVectors( GF(q)^d ), OnLines );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PG:= ImagesSource( epi );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Create the subgroups corresponding to the prime divisors of `d'.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    primes:= PrimeDivisors( d );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    maxes:= List( primes, p -&gt; RelativeSigmaL( d/p,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                 Basis( AsField( GF(q), GF(q^p) ) ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    names:= List( primes, p -&gt; Concatenation( "GL(", String( d/p ), ",",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                 String( q^p ), ").", String( p ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if 2 &lt; q then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      names:= List( names, name -&gt; Concatenation( name, " cap G" ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Compute the conjugacy classes of prime order elements in the maxes.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # (In order to avoid computing all conjugacy classes of these subgroups,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # we work in Sylow subgroups.)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ccl:= List( List( maxes, x -&gt; ImagesSet( epi, x ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            M -&gt; ClassesOfPrimeOrder( M, PrimeDivisors( Size( M ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                      TrivialSubgroup( M ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return [ names, UpperBoundFixedPointRatios( PG, ccl, true )[1] ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p>We apply this function to the cases that are interesting in <a href="chapBib.html#biBBGK">[BGK08, Section 5.12]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pairs:= [ [ 3, 2 ], [ 3, 3 ], [ 4, 2 ], [ 4, 3 ], [ 4, 4 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           [ 6, 2 ], [ 6, 3 ], [ 6, 4 ], [ 6, 5 ], [ 8, 2 ], [ 10, 2 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">array:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for pair in pairs do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     d:= pair[1];  q:= pair[2];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     approx:= ApproxPForSL( d, q );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Add( array, [ Concatenation( "SL(", String(d), ",", String(q), ")" ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   (q^d-1)/(q-1),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   approx[1], approx[2] ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">oldsize:= SizeScreen();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen( [ 80 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintFormattedArray( array );</span>
   SL(3,2)    7                             [ "GL(1,8).3" ]             1/4
   SL(3,3)   13                      [ "GL(1,27).3 cap G" ]            1/24
   SL(4,2)   15                             [ "GL(2,4).2" ]            3/14
   SL(4,3)   40                       [ "GL(2,9).2 cap G" ]         53/1053
   SL(4,4)   85                      [ "GL(2,16).2 cap G" ]           1/108
   SL(6,2)   63                [ "GL(3,4).2", "GL(2,8).3" ]       365/55552
   SL(6,3)  364   [ "GL(3,9).2 cap G", "GL(2,27).3 cap G" ] 22843/123845436
   SL(6,4) 1365  [ "GL(3,16).2 cap G", "GL(2,64).3 cap G" ]         1/85932
   SL(6,5) 3906 [ "GL(3,25).2 cap G", "GL(2,125).3 cap G" ]        1/484220
   SL(8,2)  255                             [ "GL(4,4).2" ]          1/7874
  SL(10,2) 1023               [ "GL(5,4).2", "GL(2,32).5" ]        1/129794
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizeScreen( oldsize );;</span>
</pre></div>

<p>The only missing case for <a href="chapBib.html#biBBGK">[BGK08]</a> is <span class="SimpleMath">S = L_3(4)</span>, for which <span class="SimpleMath">𝕄(S,s)</span> consists of three groups of the type <span class="SimpleMath">L_3(2)</span> (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 23]</a>). The group <span class="SimpleMath">L_3(4)</span> has been considered already in Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>, where <span class="SimpleMath">σ(S,s) = 1/5</span> has been proved. Also the cases <span class="SimpleMath">SL(3,3)</span>, <span class="SimpleMath">SL(4,2) ≅ A_8</span>, and <span class="SimpleMath">SL(4,3)</span> have been handled there.</p>

<p>An alternative character-theoretic proof for <span class="SimpleMath">S = L_6(2)</span> looks as follows. In this case, the subgroups in <span class="SimpleMath">𝕄(S,s)</span> have the types <span class="SimpleMath">ΓL(3,4) ≅ GL(3,4).2 ≅ 3.L_3(4).3.2_2</span> and <span class="SimpleMath">ΓL(2,8) ≅ GL(2,8).3 ≅ (7 × L_2(8)).3</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "L6(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s1:= CharacterTable( "3.L3(4).3.2_2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s2:= CharacterTable( "(7xL2(8)).3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( t, "63A", [ s1, s2 ], [ 1, 1 ] );</span>
365/55552
</pre></div>

<p><a id="X855460BE787188B9" name="X855460BE787188B9"></a></p>

<h5>11.5-6 <span class="Heading"><span class="SimpleMath">∗</span> <span class="SimpleMath">L_d(q)</span> with prime <span class="SimpleMath">d</span></span></h5>

<p>For <span class="SimpleMath">S = SL(d,q)</span> with <em>prime</em> dimension <span class="SimpleMath">d</span>, and <span class="SimpleMath">s ∈ S</span> a Singer cycle, we have <span class="SimpleMath">𝕄(S,s) = { M }</span>, where <span class="SimpleMath">M = N_S(⟨ s ⟩) ≅ ΓL(1,q^d) ∩ S</span>. So</p>

<p class="pcenter">σ(g,s) = μ(g,S/M) = |g^S ∩ M|/|g^S| &lt; |M|/|g^S| ≤ (q^d-1) ⋅ d/|g^S|</p>

<p>holds for any <span class="SimpleMath">g ∈ S ∖ Z(S)</span>, which implies <span class="SimpleMath">σ( S, s ) &lt; max{ (q^d-1) ⋅ d/|g^S|; g ∈ S ∖ Z(S) }</span>. The right hand side of this inequality is returned by the following function. In <a href="chapBib.html#biBBGK">[BGK08, Lemma 3.8]</a>, the global upper bound <span class="SimpleMath">1/q^d</span> is derived for primes <span class="SimpleMath">d ≥ 5</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperBoundForSL:= function( d, q )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local G, Msize, ccl;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if not IsPrimeInt( d ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      Error( "&lt;d&gt; must be a prime" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    G:= SL( d, q );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Msize:= (q^d-1) * d;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ccl:= Filtered( ConjugacyClasses( G ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    c -&gt;     Msize mod Order( Representative( c ) ) = 0</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         and Size( c ) &lt;&gt; 1 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return Msize / Minimum( List( ccl, Size ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p>The interesting values are <span class="SimpleMath">(d,q)</span> with <span class="SimpleMath">d ∈ { 5, 7, 11 }</span> and <span class="SimpleMath">q ∈ { 2, 3, 4 }</span>, and perhaps also <span class="SimpleMath">(d,q) ∈ { (3,2), (3,3) }</span>. (Here we exclude <span class="SimpleMath">SL(11,4)</span> because writing down the conjugacy classes of this group would exceed the permitted memory.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrConjugacyClasses( SL(11,4) );</span>
1397660
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pairs:= [ [ 3, 2 ], [ 3, 3 ], [ 5, 2 ], [ 5, 3 ], [ 5, 4 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             [ 7, 2 ], [ 7, 3 ], [ 7, 4 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             [ 11, 2 ], [ 11, 3 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">array:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for pair in pairs do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     d:= pair[1];  q:= pair[2];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     approx:= UpperBoundForSL( d, q );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Add( array, [ Concatenation( "SL(", String(d), ",", String(q), ")" ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   (q^d-1)/(q-1),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   approx ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintFormattedArray( array );</span>
   SL(3,2)     7                                   7/8
   SL(3,3)    13                                   3/4
   SL(5,2)    31                              31/64512
   SL(5,3)   121                                 10/81
   SL(5,4)   341                                15/256
   SL(7,2)   127                             7/9142272
   SL(7,3)  1093                                14/729
   SL(7,4)  5461                               21/4096
  SL(11,2)  2047 2047/34112245508649716682268134604800
  SL(11,3) 88573                              22/59049
</pre></div>

<p>The exact values are clearly better than the above bounds. We compute them for <span class="SimpleMath">L_5(2)</span> and <span class="SimpleMath">L_7(2)</span>. In the latter case, the class fusion of the <span class="SimpleMath">127:7</span> type subgroup <span class="SimpleMath">M</span> is not uniquely determined by the character tables; here we use the additional information that the elements of order <span class="SimpleMath">7</span> in <span class="SimpleMath">M</span> have centralizer order <span class="SimpleMath">49</span> in <span class="SimpleMath">L_7(2)</span>. (See Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a> for the examples with <span class="SimpleMath">d = 3</span>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( CharacterTable( "L5(2)" ), "31A",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       [ CharacterTable( "31:5" ) ], [ 1 ] );</span>
1/5376
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "L7(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= CharacterTable( "P:Q", [ 127, 7 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters( s, t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( pi );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord7:= PositionsProperty( OrdersClassRepresentatives( t ), x -&gt; x = 7 );</span>
[ 38, 45, 76, 77, 83 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sizes:= SizesCentralizers( t ){ ord7 };</span>
[ 141120, 141120, 3528, 3528, 49 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( pi, x -&gt; x[83] );</span>
[ 42, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 127 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( ApproxP( pi{ [ 1 ] }, spos ) );</span>
1/4388290560
</pre></div>

<p><a id="X7EA88CEF81962F3F" name="X7EA88CEF81962F3F"></a></p>

<h5>11.5-7 <span class="Heading">Automorphic Extensions of <span class="SimpleMath">L_d(q)</span></span></h5>

<p>For the following values of <span class="SimpleMath">d</span> and <span class="SimpleMath">q</span>, automorphic extensions <span class="SimpleMath">G</span> of <span class="SimpleMath">L_d(q)</span> had to be checked for <a href="chapBib.html#biBBGK">[BGK08, Section 5.12]</a>.</p>

<p class="pcenter">(d,q) ∈ { (3,4), (6,2), (6,3), (6,4), (6,5), (10,2) }</p>

<p>The first case has been treated in Section <a href="chap11.html#X7B1E26D586337487"><span class="RefLink">11.4-4</span></a>. For the other cases, we compute <span class="SimpleMath">σ^'(G,s)</span> below.</p>

<p>In any case, the extension by a <em>graph</em> automorphism occurs, which can be described by mapping each matrix in <span class="SimpleMath">SL(d,q)</span> to its inverse transpose. If <span class="SimpleMath">q &gt; 2</span>, also extensions by <em>diagonal</em> automorphisms occur, which are induced by conjugation with elements in <span class="SimpleMath">GL(d,q)</span>. If <span class="SimpleMath">q</span> is nonprime then also extensions by <em>field</em> automorphisms occur, which can be described by powering the matrix entries by roots of <span class="SimpleMath">q</span>. Finally, products (of prime order) of these three kinds of automorphisms have to be considered.</p>

<p>We start with the extension <span class="SimpleMath">G</span> of <span class="SimpleMath">S = SL(d,q)</span> by a graph automorphism. <span class="SimpleMath">G</span> can be embedded into <span class="SimpleMath">GL(2d,q)</span> by representing the matrix <span class="SimpleMath">A ∈ S</span> as a block diagonal matrix with diagonal blocks equal to <span class="SimpleMath">A</span> and <span class="SimpleMath">A^-tr</span>, and representing the graph automorphism by a permutation matrix that interchanges the two blocks. In order to construct the field extension type subgroups of <span class="SimpleMath">G</span>, we have to choose the basis of the field extension in such a way that the subgroup is normalized by the permutation matrix; a sufficient condition is that the matrices of the <span class="SimpleMath">𝔽_q</span>-linear mappings induced by the basis elements are symmetric.</p>

<p>(We do not give a function that computes a basis with this property from the parameters <span class="SimpleMath">d</span> and <span class="SimpleMath">q</span>. Instead, we only write down the bases that we will need.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SymmetricBasis:= function( q, n )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local vectors, B, issymmetric;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if   q = 2 and n = 2 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      vectors:= [ Z(2)^0, Z(2^2) ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif q = 2 and n = 3 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      vectors:= [ Z(2)^0, Z(2^3), Z(2^3)^5 ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif q = 2 and n = 5 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      vectors:= [ Z(2)^0, Z(2^5), Z(2^5)^4, Z(2^5)^25, Z(2^5)^26 ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif q = 3 and n = 2 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      vectors:= [ Z(3)^0, Z(3^2) ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif q = 3 and n = 3 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      vectors:= [ Z(3)^0, Z(3^3)^2, Z(3^3)^7 ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif q = 4 and n = 2 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      vectors:= [ Z(2)^0, Z(2^4)^3 ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif q = 4 and n = 3 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      vectors:= [ Z(2)^0, Z(2^3), Z(2^3)^5 ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif q = 5 and n = 2 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      vectors:= [ Z(5)^0, Z(5^2)^2 ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    elif q = 5 and n = 3 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      vectors:= [ Z(5)^0, Z(5^3)^9, Z(5^3)^27 ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      Error( "sorry, no basis for &lt;q&gt; and &lt;n&gt; stored" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    B:= Basis( AsField( GF(q), GF(q^n) ), vectors );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Check that the basis really has the required property.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    issymmetric:= M -&gt; M = TransposedMat( M );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if not ForAll( B, b -&gt; issymmetric( BlownUpMat( B, [ [ b ] ] ) ) ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      Error( "wrong basis!" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Return the result.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return B;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p>In later examples, we will need similar embeddings of matrices. Therefore, we provide a more general function <code class="code">EmbeddedMatrix</code> that takes a field <code class="code">F</code>, a matrix <code class="code">mat</code>, and a function <code class="code">func</code>, and returns a block diagonal matrix over <code class="code">F</code> whose diagonal blocks are <code class="code">mat</code> and <code class="code">func( mat )</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BindGlobal( "EmbeddedMatrix", function( F, mat, func )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local d, result;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  d:= Length( mat );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  result:= NullMat( 2*d, 2*d, F );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  result{ [ 1 .. d ] }{ [ 1 .. d ] }:= mat;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  result{ [ d+1 .. 2*d ] }{ [ d+1 .. 2*d ] }:= func( mat );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return result;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div>

<p>The following function is similar to <code class="code">ApproxPForSL</code>, the differences are that the group <span class="SimpleMath">G</span> in question is not <span class="SimpleMath">SL(d,q)</span> but the extension of this group by a graph automorphism, and that <span class="SimpleMath">σ^'(G,s)</span> is computed not <span class="SimpleMath">σ(G,s)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInExtensionOfSLByGraphAut:= function( d, q )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local embedG, swap, G, orb, epi, PG, Gprime, primes, maxes, ccl, names;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Check whether this is an admissible case (see [Be00],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # note that a graph automorphism exists only for `d &gt; 2').</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if d = 2 or ( d = 3 and q = 4 ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Provide a function that constructs a block diagonal matrix.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    embedG:= mat -&gt; EmbeddedMatrix( GF( q ), mat,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                    M -&gt; TransposedMat( M^-1 ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Create the matrix that exchanges the two blocks.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    swap:= NullMat( 2*d, 2*d, GF(q) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    swap{ [ 1 .. d ] }{ [ d+1 .. 2*d ] }:= IdentityMat( d, GF(q) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    swap{ [ d+1 .. 2*d ] }{ [ 1 .. d ] }:= IdentityMat( d, GF(q) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Create the group SL(d,q).2, and the map to the projective group.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    G:= ClosureGroupDefault( Group( List( GeneratorsOfGroup( SL( d, q ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                          embedG ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                      swap );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    orb:= Orbit( G, One( G )[1], OnLines );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    epi:= ActionHomomorphism( G, orb, OnLines );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PG:= ImagesSource( epi );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Gprime:= DerivedSubgroup( PG );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Create the subgroups corresponding to the prime divisors of `d'.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    primes:= PrimeDivisors( d );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    maxes:= List( primes,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              p -&gt; ClosureGroupDefault( Group( List( GeneratorsOfGroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         RelativeSigmaL( d/p, SymmetricBasis( q, p ) ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         embedG ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     swap ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Compute conjugacy classes of outer involutions in the maxes.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # (In order to avoid computing all conjugacy classes of these subgroups,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # we work in the Sylow $2$ subgroups.)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    maxes:= List( maxes, M -&gt; ImagesSet( epi, M ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ccl:= List( maxes, M -&gt; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    names:= List( primes, p -&gt; Concatenation( "GL(", String( d/p ), ",",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                   String( q^p ), ").", String( p ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return [ names, UpperBoundFixedPointRatios( PG, ccl, true )[1] ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p>And these are the results for the groups we are interested in (and others).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInExtensionOfSLByGraphAut( 4, 3 );</span>
[ [ "GL(2,9).2" ], 17/117 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInExtensionOfSLByGraphAut( 4, 4 );</span>
[ [ "GL(2,16).2" ], 73/1008 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInExtensionOfSLByGraphAut( 6, 2 );</span>
[ [ "GL(3,4).2", "GL(2,8).3" ], 41/1984 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInExtensionOfSLByGraphAut( 6, 3 );</span>
[ [ "GL(3,9).2", "GL(2,27).3" ], 541/352836 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInExtensionOfSLByGraphAut( 6, 4 );</span>
[ [ "GL(3,16).2", "GL(2,64).3" ], 3265/12570624 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInExtensionOfSLByGraphAut( 6, 5 );</span>
[ [ "GL(3,25).2", "GL(2,125).3" ], 13001/195250000 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInExtensionOfSLByGraphAut( 8, 2 );</span>
[ [ "GL(4,4).2" ], 367/1007872 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInExtensionOfSLByGraphAut( 10, 2 );</span>
[ [ "GL(5,4).2", "GL(2,32).5" ], 609281/476346056704 ]
</pre></div>

<p>Now we consider diagonal automorphisms. We modify the approach for <span class="SimpleMath">SL(d,q)</span> by constructing the field extension type subgroups of <span class="SimpleMath">GL(d,q) ...</span></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelativeGammaL:= function( d, B )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local n, F, q, diag;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    n:= Length( B );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    F:= LeftActingDomain( UnderlyingLeftModule( B ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    q:= Size( F );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    diag:= IdentityMat( d * n, F );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    diag{[ 1 .. n ]}{[ 1 .. n ]}:= BlownUpMat( B, [ [ Z(q^n) ] ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return ClosureGroup( RelativeSigmaL( d, B ),  diag );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p><span class="SimpleMath">...</span> and counting the elements of prime order outside the simple group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInGL:= function( d, q )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local G, epi, PG, Gprime, primes, maxes, names;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Check whether this is an admissible case (see [Be00]).</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if ( d = 2 and q in [ 2, 5, 7, 9 ] ) or ( d = 3 and q = 4 ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      return fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Create the group GL(d,q), and the map to PGL(d,q).</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    G:= GL( d, q );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    epi:= ActionHomomorphism( G, NormedRowVectors( GF(q)^d ), OnLines );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PG:= ImagesSource( epi );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Gprime:= ImagesSet( epi, SL( d, q ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    # Create the subgroups corresponding to the prime divisors of `d'.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    primes:= PrimeDivisors( d );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    maxes:= List( primes, p -&gt; RelativeGammaL( d/p,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                   Basis( AsField( GF(q), GF(q^p) ) ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    maxes:= List( maxes, M -&gt; ImagesSet( epi, M ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    names:= List( primes, p -&gt; Concatenation( "M(", String( d/p ), ",",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                   String( q^p ), ")" ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return [ names,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             UpperBoundFixedPointRatios( PG, List( maxes,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 M -&gt; ClassesOfPrimeOrder( M,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                          PrimeDivisors( Index( PG, Gprime ) ), Gprime ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 true )[1] ];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p>Here are the required results.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInGL( 6, 3 );</span>
[ [ "M(3,9)", "M(2,27)" ], 41/882090 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInGL( 4, 3 );</span>
[ [ "M(2,9)" ], 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInGL( 6, 4 );</span>
[ [ "M(3,16)", "M(2,64)" ], 1/87296 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApproxPForOuterClassesInGL( 6, 5 );</span>
[ [ "M(3,25)", "M(2,125)" ], 821563/756593750000 ]
</pre></div>

<p>(Note that the extension field type subgroup in <span class="SimpleMath">PGL(4,3) = L_4(3).2_1</span> is a <em>non-split</em> extension of its intersection with <span class="SimpleMath">L_4(3)</span>, hence the zero value.)</p>

<p>Concerning extensions by Frobenius automorphisms, only the case <span class="SimpleMath">(d,q) = (6,4)</span> is interesting in <a href="chapBib.html#biBBGK">[BGK08]</a>. In fact, we would not need to compute anything for the extension <span class="SimpleMath">G</span> of <span class="SimpleMath">S = SL(6,4)</span> by the Frobenius map that squares each matrix entry. This is because <span class="SimpleMath">𝕄^'(G,s)</span> consists of the normalizers of the two subgroups of the types <span class="SimpleMath">SL(3,16)</span> and <span class="SimpleMath">SL(2,64)</span>, and the former maximal subgroup is a <em>non-split</em> extension of its intersection with <span class="SimpleMath">S</span>, so only one maximal subgroup can contribute to <span class="SimpleMath">σ^'(G,s)</span>, which is thus smaller than <span class="SimpleMath">1/2</span>, by <a href="chapBib.html#biBBGK">[BGK08, Prop. 2.6]</a>.</p>

<p>However, it is easy enough to compute the exact value of <span class="SimpleMath">σ^'(G,s)</span>. We work with the projective action of <span class="SimpleMath">S</span> on its natural module, and compute the permutation induced by the Frobenius map as the Frobenius action on the normed row vectors.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">matgrp:= SL(6,4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dom:= NormedRowVectors( GF(4)^6 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gprime:= Action( matgrp, dom, OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PermList( List( dom, v -&gt; Position( dom, List( v, x -&gt; x^2 ) ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= ClosureGroup( Gprime, pi );;</span>
</pre></div>

<p>Then we compute the maximal subgroups, the classes of outer involutions, and the bound, similar to the situation with graph automorphisms.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxes:= List( [ 2, 3 ], p -&gt; Normalizer( G,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Action( RelativeSigmaL( 6/p,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               Basis( AsField( GF(4), GF(4^p) ) ) ), dom, OnLines ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= List( maxes, M -&gt; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ccl, Length );</span>
[ 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperBoundFixedPointRatios( G, ccl, true );</span>
[ 1/34467840, true ]
</pre></div>

<p>For <span class="SimpleMath">(d,q) = (6,4)</span>, we have to consider also the extension <span class="SimpleMath">G</span> of <span class="SimpleMath">S = SL(6,4)</span> by the product <span class="SimpleMath">α</span> of the Frobenius map and the graph automorphism. We use the same approach as for the graph automorphism, i. e., we embed <span class="SimpleMath">SL(6,4)</span> into a <span class="SimpleMath">12</span>-dimensional group of <span class="SimpleMath">6 × 6</span> block matrices, where the second block is the image of the first block under <span class="SimpleMath">α</span>, and describe <span class="SimpleMath">α</span> by the transposition of the two blocks.</p>

<p>First we construct the projective actions of <span class="SimpleMath">S</span> and <span class="SimpleMath">G</span> on an orbit of <span class="SimpleMath">1</span>-spaces.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">embedFG:= function( F, mat )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     return EmbeddedMatrix( F, mat,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                M -&gt; List( TransposedMat( M^-1 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                           row -&gt; List( row, x -&gt; x^2 ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:= 6;;  q:= 4;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha:= NullMat( 2*d, 2*d, GF(q) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha{ [ 1 .. d ] }{ [ d+1 .. 2*d ] }:= IdentityMat( d, GF(q) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha{ [ d+1 .. 2*d ] }{ [ 1 .. d ] }:= IdentityMat( d, GF(q) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gprime:= Group( List( GeneratorsOfGroup( SL(d,q) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         mat -&gt; embedFG( GF(q), mat ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= ClosureGroupDefault( Gprime, alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= Orbit( G, One( G )[1], OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= Action( G, orb, OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gprime:= Action( Gprime, orb, OnLines );;</span>
</pre></div>

<p>Next we construct the maximal subgroups, the classes of outer involutions, and the bound.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxes:= List( PrimeDivisors( d ), p -&gt; Group( List( GeneratorsOfGroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             RelativeSigmaL( d/p, Basis( AsField( GF(q), GF(q^p) ) ) ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               mat -&gt; embedFG( GF(q), mat ) ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxes:= List( maxes, x -&gt; Action( x, orb, OnLines ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxes:= List( maxes, x -&gt; Normalizer( G, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= List( maxes, M -&gt; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ccl, Length );</span>
[ 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperBoundFixedPointRatios( G, ccl, true );</span>
[ 1/10792960, true ]
</pre></div>

<p>The only missing cases are the extensions of <span class="SimpleMath">SL(6,3)</span> and <span class="SimpleMath">SL(6,5)</span> by the involutory outer automorphism that acts as the product of a diagonal and a graph automorphism.</p>

<p>In the case <span class="SimpleMath">S = SL(6,3)</span>, we can directly write down the extension <span class="SimpleMath">G</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:= 6;;  q:= 3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">diag:= IdentityMat( d, GF(q) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">diag[1][1]:= Z(q);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">embedDG:= mat -&gt; EmbeddedMatrix( GF(q), mat,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                    M -&gt; TransposedMat( M^-1 )^diag );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gprime:= Group( List( GeneratorsOfGroup( SL(d,q) ), embedDG ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha:= NullMat( 2*d, 2*d, GF(q) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha{ [ 1 .. d ] }{ [ d+1 .. 2*d ] }:= IdentityMat( d, GF(q) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha{ [ d+1 .. 2*d ] }{ [ 1 .. d ] }:= IdentityMat( d, GF(q) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= ClosureGroupDefault( Gprime, alpha );;</span>
</pre></div>

<p>The maximal subgroups are constructed as the normalizers in <span class="SimpleMath">G</span> of the extension field type subgroups in <span class="SimpleMath">S</span>. We work with a permutation representation of <span class="SimpleMath">G</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxes:= List( PrimeDivisors( d ), p -&gt; Group( List( GeneratorsOfGroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             RelativeSigmaL( d/p, Basis( AsField( GF(q), GF(q^p) ) ) ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               embedDG ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= Orbit( G, One( G )[1], OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= Action( G, orb, OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gprime:= Action( Gprime, orb, OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxes:= List( maxes, M -&gt; Normalizer( G, Action( M, orb, OnLines ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= List( maxes, M -&gt; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ccl, Length );</span>
[ 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperBoundFixedPointRatios( G, ccl, true );</span>
[ 25/352836, true ]
</pre></div>

<p>For <span class="SimpleMath">S = SL(6,5)</span>, this approach does not work because we cannot realize the diagonal involution by an involutory matrix. Instead, we consider the extension of <span class="SimpleMath">GL(6,5) ≅ 2.(2 × L_6(5)).2</span> by the graph automorphism <span class="SimpleMath">α</span>, which can be embedded into <span class="SimpleMath">GL(12,5)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:= 6;;  q:= 5;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">embedG:= mat -&gt; EmbeddedMatrix( GF(q),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                   mat, M -&gt; TransposedMat( M^-1 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gprime:= Group( List( GeneratorsOfGroup( SL(d,q) ), embedG ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxes:= List( PrimeDivisors( d ), p -&gt; Group( List( GeneratorsOfGroup(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             RelativeSigmaL( d/p, Basis( AsField( GF(q), GF(q^p) ) ) ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               embedG ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">diag:= IdentityMat( d, GF(q) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">diag[1][1]:= Z(q);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">diag:= embedG( diag );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha:= NullMat( 2*d, 2*d, GF(q) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha{ [ 1 .. d ] }{ [ d+1 .. 2*d ] }:= IdentityMat( d, GF(q) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha{ [ d+1 .. 2*d ] }{ [ 1 .. d ] }:= IdentityMat( d, GF(q) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= ClosureGroupDefault( Gprime, alpha * diag );;</span>
</pre></div>

<p>Now we switch to the permutation action of this group on the <span class="SimpleMath">1</span>-dimensional subspaces, thus factoring out the cyclic normal subgroup of order four. In this action, the involutory diagonal automorphism is represented by an involution, and we can proceed as above.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= Orbit( G, One( G )[1], OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gprime:= Action( Gprime, orb, OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= Action( G, orb, OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxes:= List( maxes, M -&gt; Action( M, orb, OnLines ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">extmaxes:= List( maxes, M -&gt; Normalizer( G, M ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= List( extmaxes, M -&gt; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ccl, Length );</span>
[ 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperBoundFixedPointRatios( G, ccl, true );</span>
[ 3863/6052750000, true ]
</pre></div>

<p>In the same way, we can recheck the values for the extensions of <span class="SimpleMath">SL(6,5)</span> by the diagonal or by the graph automorphism.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">diag:= Permutation( diag, orb, OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= ClosureGroupDefault( Gprime, diag );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">extmaxes:= List( maxes, M -&gt; Normalizer( G, M ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= List( extmaxes, M -&gt; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ccl, Length );</span>
[ 3, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperBoundFixedPointRatios( G, ccl, true );</span>
[ 821563/756593750000, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha:= Permutation( alpha, orb, OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= ClosureGroupDefault( Gprime, alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">extmaxes:= List( maxes, M -&gt; Normalizer( G, M ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= List( extmaxes, M -&gt; ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ccl, Length );</span>
[ 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperBoundFixedPointRatios( G, ccl, true );</span>
[ 13001/195250000, true ]
</pre></div>

<p>gap&gt; t2:= CharacterTable( "L6(2).2" );; gap&gt; map:= InverseMap( GetFusionMap( t, t2 ) );; gap&gt; torso:= List( Concatenation( prim ), pi -&gt; CompositionMaps( pi, map ) );; gap&gt; ext:= List( torso, x -&gt; PermChars( t2, rec( torso:= x ) ) ); [ [ Character( CharacterTable( "L6(2).2" ), [ 55552, 0, 128, 256, 337, 112, 22, 0, 0, 16, 0, 16, 2, 17, 0, 0, 8, 2, 4, 28, 0, 0, 0, 4, 1, 0, 1, 0, 0, 4, 0, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1120, 192, 32, 0, 0, 40, 13, 0, 4, 6, 0, 4, 4, 4, 0, 2, 8, 5, 0, 2, 0, 0, 0, 0, 1, 0, 1, 0 ] ) ], [ Character( CharacterTable( "L6(2).2" ), [ 1904640, 0, 0, 512, 960, 0, 120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 73, 24, 3, 0, 0, 15, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 960, 960, 0, 0, 0, 0, 24, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 0, 0 ] ) ] ] gap&gt; sigma:= ApproxP( Concatenation( ext ), &gt; Position( OrdersClassRepresentatives( t2 ), 63 ) );; gap&gt; Maximum( sigma{ Difference( PositionsProperty( &gt; OrdersClassRepresentatives( t2 ), IsPrimeInt ), &gt; ClassPositionsOfDerivedSubgroup( t2 ) ) } ); 41/1984 --&gt;</p>

<p><a id="X7C8806DB8588BB51" name="X7C8806DB8588BB51"></a></p>

<h5>11.5-8 <span class="Heading"><span class="SimpleMath">L_3(2)</span></span></h5>

<p>We show that <span class="SimpleMath">S = L_3(2) = SL(3,2)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">σ(S) = 1/4</span>, and this value is attained exactly for <span class="SimpleMath">σ(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">7:3</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">P(S) = 1/4</span>, and this value is attained exactly for <span class="SimpleMath">P(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span>.</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>The uniform spread of <span class="SimpleMath">S</span> is at exactly three, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span>, and the spread of <span class="SimpleMath">S</span> is exactly four. (This had been left open in <a href="chapBib.html#biBBW1">[BW75]</a>.)</p>

</dd>
</dl>
<p>(Note that in this example, the spread and the uniform spread differ.)</p>

<p>Statement (a) follows from inspection of the primitive permutation characters, cf. Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "L3(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoSimple( t );</span>
[ "L3(2)", 1/4, 3, [ "7A" ], [ 1 ] ]
</pre></div>

<p>Statement (b) can be read off from the permutation characters, and the fact that the unique class of maximal subgroups that contain elements of order <span class="SimpleMath">7</span> consists of groups of the structure <span class="SimpleMath">7:3</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 3]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( t );</span>
[ 1, 2, 3, 4, 7, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrimitivePermutationCharacters( t );</span>
[ Character( CharacterTable( "L3(2)" ), [ 7, 3, 1, 1, 0, 0 ] ), 
  Character( CharacterTable( "L3(2)" ), [ 7, 3, 1, 1, 0, 0 ] ), 
  Character( CharacterTable( "L3(2)" ), [ 8, 0, 2, 0, 1, 1 ] ) ]
</pre></div>

<p>For the other statements, we will use the primitive permutation representations on <span class="SimpleMath">7</span> and <span class="SimpleMath">8</span> points of <span class="SimpleMath">S</span> (computed from the <strong class="pkg">GAP</strong> Library of Tables of Marks), and their diagonal products of the degrees <span class="SimpleMath">14</span> and <span class="SimpleMath">15</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tom:= TableOfMarks( "L3(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= UnderlyingGroup( tom );</span>
Group([ (2,4)(5,7), (1,2,3)(4,5,6) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mx:= MaximalSubgroupsTom( tom );</span>
[ [ 14, 13, 12 ], [ 7, 7, 8 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxes:= List( mx[1], i -&gt; RepresentativeTom( tom, i ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr:= List( maxes, s -&gt; RightTransversal( g, s ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">acts:= List( tr, x -&gt; Action( g, x, OnRight ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g7:= acts[1];</span>
Group([ (3,4)(6,7), (1,3,2)(4,6,5) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g8:= acts[3];</span>
Group([ (1,6)(2,5)(3,8)(4,7), (1,7,3)(2,5,8) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g14:= DiagonalProductOfPermGroups( acts{ [ 1, 2 ] } );</span>
Group([ (3,4)(6,7)(11,13)(12,14), (1,3,2)(4,6,5)(8,11,9)(10,12,13) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g15:= DiagonalProductOfPermGroups( acts{ [ 2, 3 ] } );</span>
Group([ (4,6)(5,7)(8,13)(9,12)(10,15)(11,14), (1,4,2)(3,5,6)(8,14,10)
  (9,12,15) ])
</pre></div>

<p>First we compute that for all nonidentity elements <span class="SimpleMath">s ∈ S</span> and order three elements <span class="SimpleMath">g ∈ S</span>, <span class="SimpleMath">P(g,s) ≥ 1/4</span> holds, with equality if and only if <span class="SimpleMath">s</span> has order <span class="SimpleMath">7</span>; this implies statement (c). We actually compute, for class representatives <span class="SimpleMath">s</span>, the proportion of order three elements <span class="SimpleMath">g</span> such that <span class="SimpleMath">⟨ g, s ⟩ ≠ S</span> holds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= List( ConjugacyClasses( g7 ), Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SortParallel( List( ccl, Order ), ccl );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ccl, Order );</span>
[ 1, 2, 3, 4, 7, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( ConjugacyClass( g7, ccl[3] ) );</span>
56
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prop:= List( ccl,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                r -&gt; RatioOfNongenerationTransPermGroup( g7, ccl[3], r ) );</span>
[ 1, 5/7, 19/28, 2/7, 1/4, 1/4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Minimum( prop );</span>
1/4
</pre></div>

<p>Now we show that the uniform spread of <span class="SimpleMath">S</span> is less than four. In any of the primitive permutation representations of degree seven, we find three involutions whose sets of fixed points cover the seven points. The elements <span class="SimpleMath">s</span> of order different from <span class="SimpleMath">7</span> in <span class="SimpleMath">S</span> fix a point in this representation, so each such <span class="SimpleMath">s</span> generates a proper subgroup of <span class="SimpleMath">S</span> together with one of the three involutions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= g7.1;</span>
(3,4)(6,7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fix:= Difference( MovedPoints( g7 ), MovedPoints( x ) );</span>
[ 1, 2, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= Orbit( g7, fix, OnSets );</span>
[ [ 1, 2, 5 ], [ 1, 3, 4 ], [ 2, 3, 6 ], [ 2, 4, 7 ], [ 1, 6, 7 ], 
  [ 3, 5, 7 ], [ 4, 5, 6 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Union( orb{ [ 1, 2, 5 ] } ) = [ 1 .. 7 ];</span>
true
</pre></div>

<p>So we still have to exclude elements <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span>. In the primitive permutation representation of <span class="SimpleMath">S</span> on eight points, we find four elements of order three whose sets of fixed points cover the set of all points that are moved by <span class="SimpleMath">S</span>, so with each element of order seven in <span class="SimpleMath">S</span>, one of them generates an intransitive group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">three:= g8.2;</span>
(1,7,3)(2,5,8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fix:= Difference( MovedPoints( g8 ), MovedPoints( three ) );</span>
[ 4, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= Orbit( g8, fix, OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QuadrupleWithProperty( [ [ fix ], orb, orb, orb ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       list -&gt; Union( list ) = [ 1 .. 8 ] );</span>
[ [ 4, 6 ], [ 1, 7 ], [ 3, 8 ], [ 2, 5 ] ]
</pre></div>

<p>Together with statement (a), this proves that the uniform spread of <span class="SimpleMath">S</span> is exactly three, with <span class="SimpleMath">s</span> of order seven.</p>

<p>Each element of <span class="SimpleMath">S</span> fixes a point in the permutation representation on <span class="SimpleMath">15</span> points. So for proving that the spread of <span class="SimpleMath">S</span> is less than five, it is sufficient to find a quintuple of elements whose sets of fixed points cover all <span class="SimpleMath">15</span> points. (From the permutation characters it is clear that four of these elements must have order three, and the fifth must be an involution.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= g15.1;</span>
(4,6)(5,7)(8,13)(9,12)(10,15)(11,14)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fixx:= Difference( MovedPoints( g15 ), MovedPoints( x ) );</span>
[ 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbx:= Orbit( g15, fixx, OnSets );</span>
[ [ 1, 2, 3 ], [ 1, 4, 5 ], [ 1, 6, 7 ], [ 2, 4, 6 ], [ 3, 4, 7 ], 
  [ 3, 5, 6 ], [ 2, 5, 7 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y:= g15.2;</span>
(1,4,2)(3,5,6)(8,14,10)(9,12,15)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fixy:= Difference( MovedPoints( g15 ), MovedPoints( y ) );</span>
[ 7, 11, 13 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orby:= Orbit( g15, fixy, OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QuadrupleWithProperty( [ [ fixy ], orby, orby, orby ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       l -&gt; Difference( [ 1 .. 15 ], Union( l ) ) in orbx );</span>
[ [ 7, 11, 13 ], [ 5, 8, 14 ], [ 1, 10, 15 ], [ 3, 9, 12 ] ]
</pre></div>

<p>It remains to show that the spread of <span class="SimpleMath">S</span> is (at least) four. By the consideration of permutation characters, we know that we can find a suitable order seven element for all quadruples in question except perhaps quadruples of order three elements. We show that for each such case, we can choose <span class="SimpleMath">s</span> of order four. Since <span class="SimpleMath">𝕄(S,s)</span> consists of two subgroups of the type <span class="SimpleMath">S_4</span>, we work with the representation on <span class="SimpleMath">14</span> points.)</p>

<p>First we compute <span class="SimpleMath">s</span> and the <span class="SimpleMath">S</span>-orbit of its fixed points, and the <span class="SimpleMath">S</span>-orbit of the fixed points of an element <span class="SimpleMath">x</span> of order three. Then we prove that for each quadruple of conjugates of <span class="SimpleMath">x</span>, the union of their fixed points intersects the fixed points of at least one conjugate of <span class="SimpleMath">s</span> trivially.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g14 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 4;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s;</span>
(1,3)(2,6,7,5)(9,11,10,12)(13,14)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fixs:= Difference( MovedPoints( g14 ), MovedPoints( s ) );</span>
[ 4, 8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= Orbit( g14, fixs, OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( orbs );</span>
21
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">three:= g14.2;</span>
(1,3,2)(4,6,5)(8,11,9)(10,12,13)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fix:= Difference( MovedPoints( g14 ), MovedPoints( three ) );</span>
[ 7, 14 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= Orbit( g14, fix, OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( orb );</span>
28
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QuadrupleWithProperty( [ [ fix ], orb, orb, orb ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       l -&gt; ForAll( orbs, o -&gt; not IsEmpty( Intersection( o,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       Union( l ) ) ) ) );</span>
fail
</pre></div>

<p>By the lemma from Section <a href="chap11.html#X79D7312484E78274"><span class="RefLink">11.2-2</span></a>, we are done.</p>

<p><a id="X7B7061917ED3714D" name="X7B7061917ED3714D"></a></p>

<h5>11.5-9 <span class="Heading"><span class="SimpleMath">M_11</span></span></h5>

<p>We show that <span class="SimpleMath">S = M_11</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">σ(S) = 1/3</span>, and this value is attained exactly for <span class="SimpleMath">σ(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">11</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s</span> of order <span class="SimpleMath">11</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">L_2(11)</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">P(S) = 1/3</span>, and this value is attained exactly for <span class="SimpleMath">P(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">11</span>.</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>Both the uniform spread and the spread of <span class="SimpleMath">S</span> is exactly three, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">11</span>.</p>

</dd>
</dl>
<p>Statement (a) follows from inspection of the primitive permutation characters, cf. Section <a href="chap11.html#X86CE51E180A3D4ED"><span class="RefLink">11.4-1</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "M11" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoSimple( t );</span>
[ "M11", 1/3, 2, [ "11A" ], [ 1 ] ]
</pre></div>

<p>Statement (b) can be read off from the permutation characters, and the fact that the unique class of maximal subgroups that contain elements of order <span class="SimpleMath">11</span> consists of groups of the structure <span class="SimpleMath">L_2(11)</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 18]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( t );</span>
[ 1, 2, 3, 4, 5, 6, 8, 8, 11, 11 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrimitivePermutationCharacters( t );</span>
[ Character( CharacterTable( "M11" ),
  [ 11, 3, 2, 3, 1, 0, 1, 1, 0, 0 ] ), 
  Character( CharacterTable( "M11" ),
  [ 12, 4, 3, 0, 2, 1, 0, 0, 1, 1 ] ), 
  Character( CharacterTable( "M11" ),
  [ 55, 7, 1, 3, 0, 1, 1, 1, 0, 0 ] ), 
  Character( CharacterTable( "M11" ),
  [ 66, 10, 3, 2, 1, 1, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "M11" ),
  [ 165, 13, 3, 1, 0, 1, 1, 1, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maxes( t );</span>
[ "A6.2_3", "L2(11)", "3^2:Q8.2", "A5.2", "2.S4" ]
</pre></div>

<p>For the other statements, we will use the primitive permutation representations of <span class="SimpleMath">S</span> on <span class="SimpleMath">11</span> and <span class="SimpleMath">12</span> points (which are fetched from the <strong class="pkg">Atlas</strong> of Group Representations <a href="chapBib.html#biBAGRv3">[WWT+]</a>), and their diagonal product.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens11:= OneAtlasGeneratingSet( "M11", NrMovedPoints, 11 );</span>
rec( charactername := "1a+10a", constituents := [ 1, 2 ], 
  contents := "core", 
  generators := [ (2,10)(4,11)(5,7)(8,9), (1,4,3,8)(2,5,6,9) ], 
  groupname := "M11", id := "", 
  identifier := [ "M11", [ "M11G1-p11B0.m1", "M11G1-p11B0.m2" ], 1, 
      11 ], isPrimitive := true, maxnr := 1, p := 11, rankAction := 2,
  repname := "M11G1-p11B0", repnr := 1, size := 7920, 
  stabilizer := "A6.2_3", standardization := 1, transitivity := 4, 
  type := "perm" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g11:= GroupWithGenerators( gens11.generators );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens12:= OneAtlasGeneratingSet( "M11", NrMovedPoints, 12 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g12:= GroupWithGenerators( gens12.generators );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g23:= DiagonalProductOfPermGroups( [ g11, g12 ] );</span>
Group([ (2,10)(4,11)(5,7)(8,9)(12,17)(13,20)(16,18)(19,21), (1,4,3,8)
  (2,5,6,9)(12,17,18,15)(13,19)(14,20)(16,22,23,21) ])
</pre></div>

<p>First we compute that for all nonidentity elements <span class="SimpleMath">s ∈ S</span> and involutions <span class="SimpleMath">g ∈ S</span>, <span class="SimpleMath">P(g,s) ≥ 1/3</span> holds, with equality if and only if <span class="SimpleMath">s</span> has order <span class="SimpleMath">11</span>; this implies statement (c). We actually compute, for class representatives <span class="SimpleMath">s</span>, the proportion of involutions <span class="SimpleMath">g</span> such that <span class="SimpleMath">⟨ g, s ⟩ ≠ S</span> holds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv:= g11.1;</span>
(2,10)(4,11)(5,7)(8,9)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= List( ConjugacyClasses( g11 ), Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SortParallel( List( ccl, Order ), ccl );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ccl, Order );</span>
[ 1, 2, 3, 4, 5, 6, 8, 8, 11, 11 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( ConjugacyClass( g11, inv ) );</span>
165
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prop:= List( ccl,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                r -&gt; RatioOfNongenerationTransPermGroup( g11, inv, r ) );</span>
[ 1, 1, 1, 149/165, 25/33, 31/55, 23/55, 23/55, 1/3, 1/3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Minimum( prop );</span>
1/3
</pre></div>

<p>For the first part of statement (d), we have to deal only with the case of triples of involutions.</p>

<p>The <span class="SimpleMath">11</span>-cycle <span class="SimpleMath">s</span> is contained in exactly one maximal subgroup of <span class="SimpleMath">S</span>, of index <span class="SimpleMath">12</span>. By Corollary 1 in Section <a href="chap11.html#X79D7312484E78274"><span class="RefLink">11.2-2</span></a>, it is enough to show that in the primitive degree <span class="SimpleMath">12</span> representation of <span class="SimpleMath">S</span>, the fixed points of no triple <span class="SimpleMath">(x_1, x_2, x_3)</span> of involutions in <span class="SimpleMath">S</span> can cover all twelve points; equivalenly (considering complements), we show that there is no triple such that the intersection of the sets of <em>moved</em> points is empty.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv:= g12.1;</span>
(1,6)(2,9)(5,7)(8,10)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">moved:= MovedPoints( inv );</span>
[ 1, 2, 5, 6, 7, 8, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb12:= Orbit( g12, moved, OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( orb12 );</span>
165
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TripleWithProperty( [ orb12{[1]}, orb12, orb12 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       list -&gt; IsEmpty( Intersection( list ) ) );</span>
fail
</pre></div>

<p>This implies that the uniform spread of <span class="SimpleMath">S</span> is at least three.</p>

<p>Now we show that there is a quadruple consisting of one element of order three and three involutions whose fixed points cover all points in the degree <span class="SimpleMath">23</span> representation constructed above; since the permutation character of this representation is strictly positive, this implies that <span class="SimpleMath">S</span> does not have spread four, by Corollary 2 in Section <a href="chap11.html#X79D7312484E78274"><span class="RefLink">11.2-2</span></a>, and we have proved statement (d).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv:= g23.1;</span>
(2,10)(4,11)(5,7)(8,9)(12,17)(13,20)(16,18)(19,21)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">moved:= MovedPoints( inv );</span>
[ 2, 4, 5, 7, 8, 9, 10, 11, 12, 13, 16, 17, 18, 19, 20, 21 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb23:= Orbit( g23, moved, OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">three:= ( g23.1*g23.2^2 )^2;</span>
(2,6,10)(4,8,7)(5,9,11)(12,17,23)(15,18,16)(19,21,22)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">movedthree:= MovedPoints( three );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QuadrupleWithProperty( [ [ movedthree ], orb23, orb23, orb23 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       list -&gt; IsEmpty( Intersection( list ) ) );</span>
[ [ 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 21, 22, 23 ],
  [ 1, 3, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 20, 21 ], 
  [ 1, 2, 3, 4, 5, 6, 7, 11, 12, 13, 14, 15, 18, 19, 20, 23 ], 
  [ 1, 2, 3, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 20, 22, 23 ] ]
</pre></div>

<p><a id="X82E0F48A7FF82BB3" name="X82E0F48A7FF82BB3"></a></p>

<h5>11.5-10 <span class="Heading"><span class="SimpleMath">M_12</span></span></h5>

<p>We show that <span class="SimpleMath">S = M_12</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">σ(S) = 1/3</span>, and this value is attained exactly for <span class="SimpleMath">σ(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">10</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">10</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of two nonconjugate subgroups of the type <span class="SimpleMath">A_6.2^2</span>, and one group of the type <span class="SimpleMath">2 × S_5</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">P(S) = 31/99</span>, and this value is attained exactly for <span class="SimpleMath">P(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">10</span>.</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>The uniform spread of <span class="SimpleMath">S</span> is at least three, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">10</span>.</p>

</dd>
<dt><strong class="Mark">(e)</strong></dt>
<dd><p><span class="SimpleMath">σ^'(Aut(S), s) = 4/99</span>.</p>

</dd>
</dl>
<p>Statement (a) follows from inspection of the primitive permutation characters, cf. Section <a href="chap11.html#X86CE51E180A3D4ED"><span class="RefLink">11.4-1</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "M12" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoSimple( t );</span>
[ "M12", 1/3, 2, [ "10A" ], [ 3 ] ]
</pre></div>

<p>Statement (b) can be read off from the permutation characters, and the fact that the only classes of maximal subgroups that contain elements of order <span class="SimpleMath">10</span> consist of groups of the structures <span class="SimpleMath">A_6.2^2</span> (two classes) and <span class="SimpleMath">2 × S_5</span> (one class), see <a href="chapBib.html#biBCCN85">[CCN+85, p. 33]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 10 );</span>
13
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= PrimitivePermutationCharacters( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( prim, x -&gt; x{ [ 1, spos ] } );</span>
[ [ 12, 0 ], [ 12, 0 ], [ 66, 1 ], [ 66, 1 ], [ 144, 0 ], [ 220, 0 ], 
  [ 220, 0 ], [ 396, 1 ], [ 495, 0 ], [ 495, 0 ], [ 1320, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maxes( t );</span>
[ "M11", "M12M2", "A6.2^2", "M12M4", "L2(11)", "3^2.2.S4", "M12M7", 
  "2xS5", "M8.S4", "4^2:D12", "A4xS3" ]
</pre></div>

<p>For statement (c) (which implies statement (d)), we use the primitive permutation representation on <span class="SimpleMath">12</span> points.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= MathieuGroup( 12 );</span>
Group([ (1,2,3,4,5,6,7,8,9,10,11), (3,7,11,8)(4,10,5,6), (1,12)(2,11)
  (3,6)(4,8)(5,9)(7,10) ])
</pre></div>

<p>First we show that for <span class="SimpleMath">s</span> of order <span class="SimpleMath">10</span>, <span class="SimpleMath">P(S,s) = 31/99</span> holds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( prim, spos );</span>
[ 0, 3/11, 1/3, 1/11, 1/132, 13/99, 13/99, 13/396, 1/132, 1/33, 1/33, 
  1/33, 13/396, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2B:= g.2^2;</span>
(3,11)(4,5)(6,10)(7,8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( ConjugacyClass( g, 2B ) );</span>
495
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 10;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prop:= RatioOfNongenerationTransPermGroup( g, 2B, s );</span>
31/99
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Filtered( approx, x -&gt; x &gt;= prop );</span>
[ 1/3 ]
</pre></div>

<p>Next we show that for <span class="SimpleMath">s</span> of order different from <span class="SimpleMath">10</span>, <span class="SimpleMath">P(g,s)</span> is larger than <span class="SimpleMath">31/99</span> for suitable <span class="SimpleMath">g ∈ S^×</span>. Except for <span class="SimpleMath">s</span> in the class <code class="code">6A</code> (which fixes no point in the degree <span class="SimpleMath">12</span> representation), it suffices to consider <span class="SimpleMath">g</span> in the class <code class="code">2B</code> (with four fixed points).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= g.2^2;</span>
(3,11)(4,5)(6,10)(7,8)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= List( ConjugacyClasses( g ), Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SortParallel( List( ccl, Order ), ccl );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prop:= List( ccl, r -&gt; RatioOfNongenerationTransPermGroup( g, x, r ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SortedList( prop );</span>
[ 7/55, 31/99, 5/9, 5/9, 39/55, 383/495, 383/495, 43/55, 29/33, 1, 1, 
  1, 1, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bad:= Filtered( prop, x -&gt; x &lt; 31/99 );</span>
[ 7/55 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos:= Position( prop, bad[1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">[ Order( ccl[ pos ] ), NrMovedPoints( ccl[ pos ] ) ];</span>
[ 6, 12 ]
</pre></div>

<p>In the remaining case, we choose <span class="SimpleMath">g</span> in the class <code class="code">2A</code> (which is fixed point free).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= g.3;</span>
(1,12)(2,11)(3,6)(4,8)(5,9)(7,10)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= ccl[ pos ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prop:= RatioOfNongenerationTransPermGroup( g, x, s );</span>
17/33
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prop &gt; 31/99;</span>
true
</pre></div>

<p>Statement (e) has been shown already in Section <a href="chap11.html#X84E9D10F80A74A53"><span class="RefLink">11.4-2</span></a>.</p>

<p><a id="X7FF2E8F27FBEB65C" name="X7FF2E8F27FBEB65C"></a></p>

<h5>11.5-11 <span class="Heading"><span class="SimpleMath">O_7(3)</span></span></h5>

<p>We show that <span class="SimpleMath">S = O_7(3)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">σ(S) = 199/351</span>, and this value is attained exactly for <span class="SimpleMath">σ(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">14</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">14</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">2.U_4(3).2_2 = Ω^-(6,3).2</span> and two nonconjugate groups of the type <span class="SimpleMath">S_9</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">P(S) = 155/351</span>, and this value is attained exactly for <span class="SimpleMath">P(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">14</span>.</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>The uniform spread of <span class="SimpleMath">S</span> is at least three, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">14</span>.</p>

</dd>
<dt><strong class="Mark">(e)</strong></dt>
<dd><p><span class="SimpleMath">σ^'(Aut(S), s) = 1/3</span>.</p>

</dd>
</dl>
<p>Currently <strong class="pkg">GAP</strong> provides neither the table of marks of <span class="SimpleMath">S</span> nor all character tables of its maximal subgroups. First we compute those primitive permutation characters of <span class="SimpleMath">S</span> that have the degrees <span class="SimpleMath">351</span> (point stabilizer <span class="SimpleMath">2.U_4(3).2_2</span>), <span class="SimpleMath">364</span> (point stabilizer <span class="SimpleMath">3^5:U_4(2).2</span>), <span class="SimpleMath">378</span> (point stabilizer <span class="SimpleMath">L_4(3).2_2</span>), <span class="SimpleMath">1080</span> (point stabilizer <span class="SimpleMath">G_2(3)</span>, two classes), <span class="SimpleMath">1120</span> (point stabilizer <span class="SimpleMath">3^3+3:L_3(3)</span>), <span class="SimpleMath">3159</span> (point stabilizer <span class="SimpleMath">S_6(2)</span>, two classes), <span class="SimpleMath">12636</span> (point stabilizer <span class="SimpleMath">S_9</span>, two classes), <span class="SimpleMath">22113</span> (point stabilizer <span class="SimpleMath">(2^2 × U_4(2)).2</span>, which extends to <span class="SimpleMath">D_8 × U_4(2).2</span> in <span class="SimpleMath">O_7(3).2</span>), and <span class="SimpleMath">28431</span> (point stabilizer <span class="SimpleMath">2^6:A_7</span>).</p>

<p>(So we ignore the primitive permutation characters of the degrees <span class="SimpleMath">3640</span>, <span class="SimpleMath">265356</span>, and <span class="SimpleMath">331695</span>. Note that the orders of the corresponding subgroups are not divisible by <span class="SimpleMath">7</span>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "O7(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">someprim:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            CharacterTable( "2.U4(3).2_2" ), t );;  Length( pi );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( someprim, pi );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PermChars( t, rec( torso:= [ 364 ] ) );;  Length( pi );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( someprim, pi );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            CharacterTable( "L4(3).2_2" ), t );;  Length( pi );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( someprim, pi );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters( CharacterTable( "G2(3)" ), t );</span>
[ Character( CharacterTable( "O7(3)" ),
  [ 1080, 0, 0, 24, 108, 0, 0, 0, 27, 18, 9, 0, 12, 4, 0, 0, 0, 0, 0, 
      0, 0, 0, 12, 0, 0, 0, 0, 0, 3, 6, 0, 3, 2, 2, 2, 0, 0, 0, 3, 0, 
      0, 0, 0, 0, 0, 4, 0, 3, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "O7(3)" ),
  [ 1080, 0, 0, 24, 108, 0, 0, 27, 0, 18, 9, 0, 12, 4, 0, 0, 0, 0, 0, 
      0, 0, 0, 12, 0, 0, 0, 0, 3, 0, 0, 6, 3, 2, 2, 2, 0, 0, 3, 0, 0, 
      0, 0, 0, 0, 0, 4, 3, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( someprim, pi );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PermChars( t, rec( torso:= [ 1120 ] ) );;  Length( pi );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( someprim, pi );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters( CharacterTable( "S6(2)" ), t );</span>
[ Character( CharacterTable( "O7(3)" ),
  [ 3159, 567, 135, 39, 0, 81, 0, 0, 27, 27, 0, 15, 3, 3, 7, 4, 0, 
      27, 0, 0, 0, 0, 0, 9, 3, 0, 9, 0, 3, 9, 3, 0, 2, 1, 1, 0, 0, 0, 
      3, 0, 2, 0, 0, 0, 3, 0, 0, 3, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "O7(3)" ),
  [ 3159, 567, 135, 39, 0, 81, 0, 27, 0, 27, 0, 15, 3, 3, 7, 4, 0, 
      27, 0, 0, 0, 0, 0, 9, 3, 0, 9, 3, 0, 3, 9, 0, 2, 1, 1, 0, 0, 3, 
      0, 0, 2, 0, 0, 0, 3, 0, 3, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( someprim, pi );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters( CharacterTable( "S9" ), t );</span>
[ Character( CharacterTable( "O7(3)" ),
  [ 12636, 1296, 216, 84, 0, 81, 0, 0, 108, 27, 0, 6, 0, 12, 10, 1, 
      0, 27, 0, 0, 0, 0, 0, 9, 3, 0, 9, 0, 12, 9, 3, 0, 1, 0, 2, 0, 
      0, 0, 3, 1, 1, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 
      1 ] ), Character( CharacterTable( "O7(3)" ),
  [ 12636, 1296, 216, 84, 0, 81, 0, 108, 0, 27, 0, 6, 0, 12, 10, 1, 
      0, 27, 0, 0, 0, 0, 0, 9, 3, 0, 9, 12, 0, 3, 9, 0, 1, 0, 2, 0, 
      0, 3, 0, 1, 1, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 
      1 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( someprim, pi );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "O7(3).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s2:= CharacterTable( "Dihedral", 8 ) * CharacterTable( "U4(2).2" );</span>
CharacterTable( "Dihedral(8)xU4(2).2" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters( s2, t2 );;  Length( pi );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= RestrictedClassFunctions( pi, t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( someprim, pi );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            CharacterTable( "2^6:A7" ), t );;  Length( pi );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( someprim, pi );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( someprim, x -&gt; x[1] );</span>
[ 351, 364, 378, 1080, 1080, 1120, 3159, 3159, 12636, 12636, 22113, 
  28431 ]
</pre></div>

<p>Note that in the three cases where two possible permutation characters were found, there are in fact two classes of subgroups that induce different permutation characters. For the subgroups of the types <span class="SimpleMath">G_2(3)</span> and <span class="SimpleMath">S_6(2)</span>, this is stated in <a href="chapBib.html#biBCCN85">[CCN+85, p. 109]</a>, and for the subgroups of the type <span class="SimpleMath">S_9</span>, this follows from the fact that each <span class="SimpleMath">S_9</span> type subgroup in <span class="SimpleMath">S</span> contains elements in exactly one of the classes <code class="code">3D</code> or <code class="code">3E</code>, and these two classes are fused by the outer automorphism of <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cl:= PositionsProperty( AtlasClassNames( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                           x -&gt; x in [ "3D", "3E" ] );</span>
[ 8, 9 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Filtered( someprim, x -&gt; x[1] = 12636 ), pi -&gt; pi{ cl } );</span>
[ [ 0, 108 ], [ 108, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetFusionMap( t, t2 ){ cl };</span>
[ 8, 8 ]
</pre></div>

<p>Now we compute the lower bounds for <span class="SimpleMath">σ( S, s^' )</span> that are given by the sublist <code class="code">someprim</code> of the primitive permutation characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 14 );</span>
52
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( ApproxP( someprim, spos ) );</span>
199/351
</pre></div>

<p>This shows that <span class="SimpleMath">σ( S, s ) = 199/351</span> holds. For statement (a), we have to show that choosing <span class="SimpleMath">s^'</span> from another class than <code class="code">14A</code> yields a larger value for <span class="SimpleMath">σ( S, s^' )</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= List( [ 1 .. NrConjugacyClasses( t ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      i -&gt; Maximum( ApproxP( someprim, i ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositionsProperty( approx, x -&gt; x &lt;= 199/351 );</span>
[ 52 ]
</pre></div>

<p>Statement (b) can be read off from the permutation characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos:= PositionsProperty( someprim, x -&gt; x[ spos ] &lt;&gt; 0 );</span>
[ 1, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( someprim{ pos }, x -&gt; x{ [ 1, spos ] } );</span>
[ [ 351, 1 ], [ 12636, 1 ], [ 12636, 1 ] ]
</pre></div>

<p>For statement (c), we first compute <span class="SimpleMath">P(g, s)</span> for <span class="SimpleMath">g</span> in the class <code class="code">2A</code>, via explicit computations with the group. For dealing with this case, we first construct a faithful permutation representation of <span class="SimpleMath">O_7(3)</span> from the natural matrix representation of <span class="SimpleMath">SO(7,3)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">so73:= SpecialOrthogonalGroup( 7, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">o73:= DerivedSubgroup( so73 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( o73, Elements( GF(3)^7 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set( orbs, Length );</span>
[ 1, 702, 728, 756 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Action( o73, First( orbs, x -&gt; Length( x ) = 702 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( g ) = Size( t );</span>
true
</pre></div>

<p>A <code class="code">2A</code> element <span class="SimpleMath">g</span> can be found as the <span class="SimpleMath">7</span>-th power of any element of order <span class="SimpleMath">14</span> in <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 14;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2A:= s^7;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bad:= RatioOfNongenerationTransPermGroup( g, 2A, s );</span>
155/351
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bad &gt; 1/3;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( someprim, spos );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositionsProperty( approx, x -&gt; x &gt;= 1/3 );</span>
[ 2 ]
</pre></div>

<p>This shows that <span class="SimpleMath">P(g,s) = 155/351 &gt; 1/3</span>. Since <span class="SimpleMath">σ( g, s ) &lt; 1/3</span> for all nonidentity <span class="SimpleMath">g</span> not in the class <code class="code">2A</code>, we have <span class="SimpleMath">P( S, s ) = 155/351</span>. For statement (c), it remains to show that <span class="SimpleMath">P( S, s^' )</span> is larger than <span class="SimpleMath">155/351</span> whenever <span class="SimpleMath">s^'</span> is not of order <span class="SimpleMath">14</span>. First we compute <span class="SimpleMath">P( g, s^' )</span>, for <span class="SimpleMath">g</span> in the class <code class="code">2A</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">consider:= RepresentativesMaximallyCyclicSubgroups( t );</span>
[ 18, 19, 25, 26, 27, 30, 31, 32, 34, 35, 38, 39, 41, 42, 43, 44, 45, 
  46, 47, 48, 49, 50, 52, 53, 54, 56, 57, 58 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( consider );</span>
28
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">consider:= ClassesPerhapsCorrespondingToTableColumns( g, t, consider );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( consider );</span>
31
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">consider:= List( consider, Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SortParallel( List( consider, Order ), consider );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">app2A:= List( consider, c -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      RatioOfNongenerationTransPermGroup( g, 2A, c ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SortedList( app2A );</span>
[ 1/3, 1/3, 155/351, 191/351, 67/117, 23/39, 23/39, 85/117, 10/13, 
  10/13, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test:= PositionsProperty( app2A, x -&gt; x &lt;= 155/351 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( test, i -&gt; Order( consider[i] ) );</span>
[ 13, 13, 14 ]
</pre></div>

<p>We see that only for <span class="SimpleMath">s^'</span> in one of the two (algebraically conjugate) classes of element order <span class="SimpleMath">13</span>, <span class="SimpleMath">P( S, s^' )</span> has a chance to be smaller than <span class="SimpleMath">155/351</span>. This possibility is now excluded by counting elements in the class <code class="code">3A</code> that do not generate <span class="SimpleMath">S</span> together with <span class="SimpleMath">s^'</span> of order <span class="SimpleMath">13</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C3A:= First( ConjugacyClasses( g ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              c -&gt; Order( Representative( c ) ) = 3 and Size( c ) = 7280 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat ss:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( ss ) = 13;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bad:= RatioOfNongenerationTransPermGroup( g, Representative( C3A ), ss );</span>
17/35
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bad &gt; 155/351;</span>
true
</pre></div>

<p>Now we show statement (d): For each triple <span class="SimpleMath">(x_1, x_2, x_3)</span> of nonidentity elements in <span class="SimpleMath">S</span>, there is an element <span class="SimpleMath">s</span> in the class <code class="code">14A</code> such that <span class="SimpleMath">⟨ x_i, s ⟩ = S</span> holds for <span class="SimpleMath">1 ≤ i ≤ 3</span>. We can read off from the character-theoretic data that only those triples have to be checked for which at least two elements are contained in the class <code class="code">2A</code>, and the third element lies in one of the classes <code class="code">2A</code>, <code class="code">2B</code>, <code class="code">3B</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( someprim, spos );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">max:= Maximum( approx{ [ 3 .. Length( approx ) ] } );</span>
59/351
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">155 + 2*59 &lt; 351;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">third:= PositionsProperty( approx, x -&gt; 2 * 155/351 + x &gt;= 1 );</span>
[ 2, 3, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassNames( t ){ third };</span>
[ "2a", "2b", "3b" ]
</pre></div>

<p>We can find elements in the classes <code class="code">2B</code> and <code class="code">3B</code> as powers of arbitrary elements of the orders <span class="SimpleMath">20</span> and <span class="SimpleMath">15</span>, respectively.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord20:= PositionsProperty( OrdersClassRepresentatives( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                              x -&gt; x = 20 );</span>
[ 58 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PowerMap( t, 10 ){ ord20 };</span>
[ 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( x ) = 20;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2B:= x^10;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2B:= ConjugacyClass( g, 2B );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord15:= PositionsProperty( OrdersClassRepresentatives( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                              x -&gt; x = 15 );</span>
[ 53 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PowerMap( t, 10 ){ ord15 };</span>
[ 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( x ) = 15;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3B:= x^5;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C3B:= ConjugacyClass( g, 3B );;</span>
</pre></div>

<p>The existence of <span class="SimpleMath">s</span> can be shown with the random approach described in Section <a href="chap11.html#X83DACCF07EF62FAE"><span class="RefLink">11.3-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 14;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCheckUniformSpread( g, [ 2A, 2A, 2A ], s, 50 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCheckUniformSpread( g, [ 2B, 2A, 2A ], s, 50 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCheckUniformSpread( g, [ 3B, 2A, 2A ], s, 50 );</span>
true
</pre></div>

<p>Finally, we show statement (e). Let <span class="SimpleMath">G = Aut(S) = S.2</span>. By <a href="chapBib.html#biBCCN85">[CCN+85, p. 109]</a>, <span class="SimpleMath">𝕄^'(G,s)</span> consists of the extension of the <span class="SimpleMath">2.U_4(3).2_1</span> type subgroup. We compute the extension of the permutation character.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= someprim{ [ 1 ] };</span>
[ Character( CharacterTable( "O7(3)" ),
  [ 351, 127, 47, 15, 27, 45, 36, 0, 0, 9, 0, 15, 3, 3, 7, 6, 19, 19, 
      10, 11, 12, 8, 3, 5, 3, 6, 1, 0, 0, 3, 3, 0, 1, 1, 1, 6, 3, 0, 
      0, 2, 2, 0, 3, 0, 3, 3, 0, 0, 1, 0, 0, 1, 0, 4, 4, 1, 2, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( AtlasClassNames( t ), "14A" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "O7(3).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map:= InverseMap( GetFusionMap( t, t2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">torso:= List( prim, pi -&gt; CompositionMaps( pi, map ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= List( torso, x -&gt; PermChars( t2, rec( torso:= x ) ) );</span>
[ [ Character( CharacterTable( "O7(3).2" ),
      [ 351, 127, 47, 15, 27, 45, 36, 0, 9, 0, 15, 3, 3, 7, 6, 19, 
          19, 10, 11, 12, 8, 3, 5, 3, 6, 1, 0, 3, 0, 1, 1, 1, 6, 3, 
          0, 2, 2, 0, 3, 0, 3, 3, 0, 1, 0, 0, 1, 0, 4, 1, 2, 0, 117, 
          37, 21, 45, 1, 13, 5, 1, 9, 9, 18, 15, 1, 7, 9, 6, 4, 0, 3, 
          0, 3, 3, 6, 2, 2, 9, 6, 1, 3, 1, 4, 1, 2, 1, 1, 0, 3, 1, 0, 
          0, 0, 0, 1, 1, 0, 0 ] ) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( Concatenation( ext ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Position( AtlasClassNames( t2 ), "14A" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( approx{ Difference(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ClassPositionsOfDerivedSubgroup( t2 ) ) } );</span>
1/3
</pre></div>

<p><a id="X7F80F2527C424AA4" name="X7F80F2527C424AA4"></a></p>

<h5>11.5-12 <span class="Heading"><span class="SimpleMath">O_8^+(2)</span></span></h5>

<p>We show that <span class="SimpleMath">S = O_8^+(2) = Ω^+(8,2)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">σ(S) = 334/315</span>, and this value is attained exactly for <span class="SimpleMath">σ(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">15</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">15</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">S_6(2)</span>, two conjugate groups of the type <span class="SimpleMath">2^6:A_8</span>, two conjugate groups of the type <span class="SimpleMath">A_9</span>, and one group of each of the types <span class="SimpleMath">(3 × U_4(2)):2 = (3 × Ω^-(6,2)):2</span> and <span class="SimpleMath">(A_5 × A_5):2^2 = (Ω^-(4,2) × Ω^-(4,2)):2^2</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">P(S) = 29/42</span>, and this value is attained exactly for <span class="SimpleMath">P(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">15</span>.</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>Let <span class="SimpleMath">x, y ∈ S</span> such that <span class="SimpleMath">x, y, x y</span> lie in the unique involution class of length <span class="SimpleMath">1575</span> of <span class="SimpleMath">S</span>. (This is the class <code class="code">2A</code>.) Then each element in <span class="SimpleMath">S</span> together with one of <span class="SimpleMath">x</span>, <span class="SimpleMath">y</span>, <span class="SimpleMath">x y</span> generates a proper subgroup of <span class="SimpleMath">S</span>.</p>

</dd>
<dt><strong class="Mark">(e)</strong></dt>
<dd><p>Both the spread and the uniform spread of <span class="SimpleMath">S</span> is exactly two, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">15</span>.</p>

</dd>
<dt><strong class="Mark">(f)</strong></dt>
<dd><p>For each choice of <span class="SimpleMath">s ∈ S</span>, there is an extension <span class="SimpleMath">S.2</span> such that for any element <span class="SimpleMath">g</span> in the (outer) class <code class="code">2F</code>, <span class="SimpleMath">⟨ s, g ⟩</span> does not contain <span class="SimpleMath">S</span>.</p>

</dd>
<dt><strong class="Mark">(g)</strong></dt>
<dd><p>For an element <span class="SimpleMath">s</span> of order <span class="SimpleMath">15</span> in <span class="SimpleMath">S</span>, either <span class="SimpleMath">S</span> is the only maximal subgroup of <span class="SimpleMath">S.2</span> that contains <span class="SimpleMath">s</span>, or the maximal subgroups of <span class="SimpleMath">S.2</span> that contain <span class="SimpleMath">s</span> are <span class="SimpleMath">S</span> and the extensions of the subgroups listed in statement (b); these groups have the structures <span class="SimpleMath">S_6(2) × 2</span>, <span class="SimpleMath">2^6:S_8</span> (twice), <span class="SimpleMath">S_9</span> (twice), <span class="SimpleMath">S_3 × U_4(2).2</span>, and <span class="SimpleMath">S_5 ≀ 2</span>.</p>

</dd>
<dt><strong class="Mark">(h)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">15</span> and arbitrary <span class="SimpleMath">g ∈ S.3 ∖ S</span>, we have <span class="SimpleMath">⟨ s, g ⟩ = S.3</span>.</p>

</dd>
<dt><strong class="Mark">(i)</strong></dt>
<dd><p>If <span class="SimpleMath">x</span>, <span class="SimpleMath">y</span> are nonidentity elements in <span class="SimpleMath">Aut(S)</span> then there is an element <span class="SimpleMath">s</span> of order <span class="SimpleMath">15</span> in <span class="SimpleMath">S</span> such that <span class="SimpleMath">S ⊆ ⟨ x, s ⟩ ∩ ⟨ y, s ⟩</span>.</p>

</dd>
</dl>
<p>Statement (a) follows from inspection of the primitive permutation characters, cf. Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "O8+(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoSimple( t );</span>
[ "O8+(2)", 334/315, 0, [ "15A", "15B", "15C" ], [ 7, 7, 7 ] ]
</pre></div>

<p>Statement (b) can be read off from the permutation characters, and the fact that the only classes of maximal subgroups that contain elements of order <span class="SimpleMath">15</span> consist of groups of the structures as claimed, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 85]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= PrimitivePermutationCharacters( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 15 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Filtered( prim, x -&gt; x[ spos ] &lt;&gt; 0 ), l -&gt; l{ [ 1, spos ] } );</span>
[ [ 120, 1 ], [ 135, 2 ], [ 960, 2 ], [ 1120, 1 ], [ 12096, 1 ] ]
</pre></div>

<p>For the remaining statements, we take a primitive permutation representation on <span class="SimpleMath">120</span> points, and assume that the permutation character is <code class="code">1a+35a+84a</code>. (See <a href="chapBib.html#biBCCN85">[CCN+85, p. 85]</a>, note that the three classes of maximal subgroups of index <span class="SimpleMath">120</span> in <span class="SimpleMath">S</span> are conjugate under triality.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">matgroup:= DerivedSubgroup( GeneralOrthogonalGroup( 1, 8, 2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points:= NormedRowVectors( GF(2)^8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( matgroup, points );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 135, 120 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Action( matgroup, orbs[2] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( g );</span>
174182400
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= Sum( Irr( t ){ [ 1, 3, 7 ] } );</span>
Character( CharacterTable( "O8+(2)" ),
 [ 120, 24, 32, 0, 0, 8, 36, 0, 0, 3, 6, 12, 4, 8, 0, 0, 0, 10, 0, 0, 
  12, 0, 0, 8, 0, 0, 3, 6, 0, 0, 2, 0, 0, 2, 1, 2, 2, 3, 0, 0, 2, 0, 
  0, 0, 0, 0, 3, 2, 0, 0, 1, 0, 0 ] )
</pre></div>

<p>In order to show statement (c), we first observe that for <span class="SimpleMath">s</span> in the class <code class="code">15A</code> and <span class="SimpleMath">g</span> <em>not</em> in one of the classes <code class="code">2A</code>, <code class="code">2B</code>, <code class="code">3A</code>, <span class="SimpleMath">σ(g,s) &lt; 1/3</span> holds, and for the exceptional three classes, we have <span class="SimpleMath">σ(g,s) &gt; 1/2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( prim, spos );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">testpos:= PositionsProperty( approx, x -&gt; x &gt;= 1/3 );</span>
[ 2, 3, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasClassNames( t ){ testpos };</span>
[ "2A", "2B", "3A" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx{ testpos };</span>
[ 254/315, 334/315, 1093/1120 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( approx{ testpos }, x -&gt; x &gt; 1/2 );</span>
true
</pre></div>

<p>Now we compute the values <span class="SimpleMath">P(g,s)</span>, for <span class="SimpleMath">s</span> in the class <code class="code">15A</code> and <span class="SimpleMath">g</span> in one of the classes <code class="code">2A</code>, <code class="code">2B</code>, <code class="code">3A</code>.</p>

<p>By our choice of the character of the permutation representation we use, the class <code class="code">15A</code> is determined as the unique class of element order <span class="SimpleMath">15</span> with one fixed point. (Note that the three classes of element order <span class="SimpleMath">15</span> in <span class="SimpleMath">S</span> are conjugate under triality.) A <code class="code">2A</code> element can be found as the fourth power of any element of order <span class="SimpleMath">8</span> in <span class="SimpleMath">S</span>, a <code class="code">3A</code> element can be found as the fifth power of a <code class="code">15A</code> element, and a <code class="code">2B</code> element can be found as the sixth power of an element of order <span class="SimpleMath">12</span>, with <span class="SimpleMath">32</span> fixed points.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 15 and NrMovedPoints( g ) = 1 + NrMovedPoints( s );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3A:= s^5;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= Random( g ); until Order( x ) = 8;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2A:= x^4;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= Random( g ); until Order( x ) = 12 and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     NrMovedPoints( g ) = 32 + NrMovedPoints( x^6 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2B:= x^6;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prop15A:= List( [ 2A, 2B, 3A ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   x -&gt; RatioOfNongenerationTransPermGroup( g, x, s ) );</span>
[ 23/35, 29/42, 149/224 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( prop15A );</span>
29/42
</pre></div>

<p>This means that for <span class="SimpleMath">s</span> in the class <code class="code">15A</code>, we have <span class="SimpleMath">P( S, s ) = 29/42</span>, and the same holds for all <span class="SimpleMath">s</span> of order <span class="SimpleMath">15</span> since the three classes of element order <span class="SimpleMath">15</span> are conjugate under triality. Now we show that for <span class="SimpleMath">s</span> of order different from <span class="SimpleMath">15</span>, the value <span class="SimpleMath">P(g,s)</span> is larger than <span class="SimpleMath">29/42</span>, for <span class="SimpleMath">g</span> in one of the classes <code class="code">2A</code>, <code class="code">2B</code>, <code class="code">3A</code>, or their images under triality. This implies statement (c).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test:= List( [ 2A, 2B, 3A ], x -&gt; ConjugacyClass( g, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= ConjugacyClasses( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">consider:= Filtered( ccl, c -&gt; Size( c ) in List( test, Size ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( consider );</span>
7
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">filt:= Filtered( ccl, c -&gt; ForAll( consider, cc -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      RatioOfNongenerationTransPermGroup( g, Representative( cc ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          Representative( c ) ) &lt;= 29/42 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( filt );</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( filt, c -&gt; Order( Representative( c ) ) );</span>
[ 15, 15, 15 ]
</pre></div>

<p>Now we show statement (d). First we observe that all those Klein four groups in <span class="SimpleMath">S</span> whose involutions lie in the class <code class="code">2A</code> are conjugate in <span class="SimpleMath">S</span>. Note that this is the unique class of length <span class="SimpleMath">1575</span> in <span class="SimpleMath">S</span>, and also the unique class whose elements have <span class="SimpleMath">24</span> fixed points in the degree <span class="SimpleMath">120</span> permutation representation.</p>

<p>For that, we use the character table of <span class="SimpleMath">S</span> to read off that <span class="SimpleMath">S</span> contains exactly <span class="SimpleMath">14175</span> such subgroups, and we use the group to compute one such subgroup and its normalizer of index <span class="SimpleMath">14175</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesConjugacyClasses( t );</span>
[ 1, 1575, 3780, 3780, 3780, 56700, 2240, 2240, 2240, 89600, 268800, 
  37800, 340200, 907200, 907200, 907200, 2721600, 580608, 580608, 
  580608, 100800, 100800, 100800, 604800, 604800, 604800, 806400, 
  806400, 806400, 806400, 2419200, 2419200, 2419200, 7257600, 
  24883200, 5443200, 5443200, 6451200, 6451200, 6451200, 8709120, 
  8709120, 8709120, 1209600, 1209600, 1209600, 4838400, 7257600, 
  7257600, 7257600, 11612160, 11612160, 11612160 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrPolyhedralSubgroups( t, 2, 2, 2 );</span>
rec( number := 14175, type := "V4" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until     Order( x ) mod 2 = 0</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         and NrMovedPoints( x^( Order(x)/2 ) ) = 120 - 24;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= x^( Order(x)/2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat y:= x^Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until NrMovedPoints( x*y ) = 120 - 24;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v4:= SubgroupNC( g, [ x, y ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n:= Normalizer( g, v4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index( g, n );</span>
14175
</pre></div>

<p>We verify that the triple has the required property.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxorder:= RepresentativesMaximallyCyclicSubgroups( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxorderreps:= List( ClassesPerhapsCorrespondingToTableColumns( g, t,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       maxorder ), Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( maxorderreps );</span>
28
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CommonGeneratorWithGivenElements( g, maxorderreps, [ x, y, x*y ] );</span>
fail
</pre></div>

<p>For the simple group <span class="SimpleMath">S</span>, it remains to show statement (e). We want to show that for any choice of two nonidentity elements <span class="SimpleMath">x</span>, <span class="SimpleMath">y</span> in <span class="SimpleMath">S</span>, there is an element <span class="SimpleMath">s</span> in the class <code class="code">15A</code> such that <span class="SimpleMath">⟨ s, x ⟩ = ⟨ s, y ⟩ = S</span> holds. Only <span class="SimpleMath">x</span>, <span class="SimpleMath">y</span> in the classes given by the list <code class="code">testpos</code> must be considered, by the estimates <span class="SimpleMath">σ(g,s)</span>.</p>

<p>We replace the values <span class="SimpleMath">σ(g,s)</span> by the exact values <span class="SimpleMath">P(g,s)</span>, for <span class="SimpleMath">g</span> in one of these three classes. Each of the three classes is determined by its element order and its number of fixed points.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= List( ccl, Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bading:= List( testpos, i -&gt; Filtered( reps,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       r -&gt; Order( r ) = OrdersClassRepresentatives( t )[i] and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            NrMovedPoints( r ) = 120 - pi[i] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( bading, Length );</span>
[ 1, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bading:= List( bading, x -&gt; x[1] );;</span>
</pre></div>

<p>For each pair <span class="SimpleMath">(C_1, C_2)</span> of classes represented by this list, we have to show that for any choice of elements <span class="SimpleMath">x ∈ C_1</span>, <span class="SimpleMath">y ∈ C_2</span> there is <span class="SimpleMath">s</span> in the class <code class="code">15A</code> such that <span class="SimpleMath">⟨ s, x ⟩ = ⟨ s, y ⟩ = S</span> holds. This is done with the random approach that is described in Section <a href="chap11.html#X83DACCF07EF62FAE"><span class="RefLink">11.3-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for pair in UnorderedTuples( bading, 2 ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     test:= RandomCheckUniformSpread( g, pair, s, 80 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if test &lt;&gt; true then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Error( test );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
</pre></div>

<p>We get no error message, so statement (e) holds.</p>

<p>Now we turn to the automorphic extensions of <span class="SimpleMath">S</span>. First we compute a permutation representation of <span class="SimpleMath">SO^+(8,2) ≅ S.2</span> and an element <span class="SimpleMath">g</span> in the class <code class="code">2F</code>, which is the unique conjugacy class of size <span class="SimpleMath">120</span> in <span class="SimpleMath">S.2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">matgrp:= SO(1,8,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g2:= Image( IsomorphismPermGroup( matgrp ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTransitive( g2, MovedPoints( g2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= Random( g2 ); until Order( x ) = 14;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2F:= x^7;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( ConjugacyClass( g2, 2F ) );</span>
120
</pre></div>

<p>Only for <span class="SimpleMath">s</span> in six conjugacy classes of <span class="SimpleMath">S</span>, there is a nonzero probability to have <span class="SimpleMath">S.2 = ⟨ g, s ⟩</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">der:= DerivedSubgroup( g2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cclreps:= List( ConjugacyClasses( der ), Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nongen:= List( cclreps,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              x -&gt; RatioOfNongenerationTransPermGroup( g2, 2F, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">goodpos:= PositionsProperty( nongen, x -&gt; x &lt; 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">invariants:= List( goodpos, i -&gt; [ Order( cclreps[i] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Size( Centralizer( g2, cclreps[i] ) ), nongen[i] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SortedList( invariants );</span>
[ [ 10, 20, 1/3 ], [ 10, 20, 1/3 ], [ 12, 24, 2/5 ], [ 12, 24, 2/5 ], 
  [ 15, 15, 0 ], [ 15, 15, 0 ] ]
</pre></div>

<p><span class="SimpleMath">S</span> contains three classes of element order <span class="SimpleMath">10</span>, which are conjugate in <span class="SimpleMath">S.3</span>. For a fixed extension of the type <span class="SimpleMath">S.2</span>, the element <span class="SimpleMath">s</span> can be chosen only in two of these three classes, which means that there is another group of the type <span class="SimpleMath">S.2</span> (more precisely, another subgroup of index three in <span class="SimpleMath">S.S_3</span>) in which this choice of <span class="SimpleMath">s</span> is not suitable –note that the general aim is to find <span class="SimpleMath">s ∈ S</span> uniformly for all automorphic extensions of <span class="SimpleMath">S</span>. Analogous statements hold for the other possibilities for <span class="SimpleMath">s</span>, so statement (f) follows.</p>

<p>Statement (g) follows from the list of maximal subgroups in <a href="chapBib.html#biBCCN85">[CCN+85, p. 85]</a>.</p>

<p>Statement (h) follows from the fact that <span class="SimpleMath">S</span> is the only maximal subgroup of <span class="SimpleMath">S.3</span> that contains elements of order <span class="SimpleMath">15</span>, according to the list of maximal subgroups in <a href="chapBib.html#biBCCN85">[CCN+85, p. 85]</a>. Alternatively, if we do not want to assume this information, we can use explicit computations, as follows. All we have to check is that any element in the classes <code class="code">3F</code> and <code class="code">3G</code> generates <span class="SimpleMath">S.3</span> together with a fixed element of order <span class="SimpleMath">15</span> in <span class="SimpleMath">S</span>.</p>

<p>We compute a permutation representation of <span class="SimpleMath">S.3</span> as the derived subgroup of a subgroup of the type <span class="SimpleMath">S.S_3</span> inside the sporadic simple Fischer group <span class="SimpleMath">Fi_22</span>; these subgroups lie in the fourth class of maximal subgroups of <span class="SimpleMath">Fi_22</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 163]</a>. An element in the class <code class="code">3F</code> of <span class="SimpleMath">S.3</span> can be found as a power of an order <span class="SimpleMath">21</span> element, and an element in the class <code class="code">3G</code> can be found as the fourth power of a <code class="code">12P</code> element.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut:= Group( AtlasGenerators( "Fi22", 1, 4 ).generators );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( aut ) = 6 * Size( t );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g3:= DerivedSubgroup( aut );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( g3, MovedPoints( g3 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 3150, 360 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g3:= Action( g3, orbs[2] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g3 ); until Order( s ) = 15;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= Random( g3 ); until Order( x ) = 21;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3F:= x^7;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RatioOfNongenerationTransPermGroup( g3, 3F, s );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= Random( g3 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( x ) = 12 and Size( Centralizer( g3, x^4 ) ) = 648;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3G:= x^4;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RatioOfNongenerationTransPermGroup( g3, 3G, s );</span>
0
</pre></div>

<p>Finally, consider statement (i). It implies that <a href="chapBib.html#biBBGK">[BGK08, Corollary 1.5]</a> holds for <span class="SimpleMath">Ω^+(8,2)</span>, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">15</span>. Note that by part (f), <span class="SimpleMath">s</span> <em>cannot be chosen in a prescribed conjugacy class</em> of <span class="SimpleMath">S</span> that is independent of the elements <span class="SimpleMath">x</span>, <span class="SimpleMath">y</span>.</p>

<p>If <span class="SimpleMath">x</span> and <span class="SimpleMath">y</span> lie in <span class="SimpleMath">S</span> then statement (i) follows from part (e), and by part (g), the case that <span class="SimpleMath">x</span> or <span class="SimpleMath">y</span> lie in <span class="SimpleMath">S.3 ∖ S</span> is also not a problem. We now show that also <span class="SimpleMath">x</span> or <span class="SimpleMath">y</span> in <span class="SimpleMath">S.2 ∖ S</span> is not a problem. Here we have to deal with the cases that <span class="SimpleMath">x</span> and <span class="SimpleMath">y</span> lie in the same subgroup of index <span class="SimpleMath">3</span> in <span class="SimpleMath">Aut(S)</span> or in different such subgroups. Actually we show that for each index <span class="SimpleMath">3</span> subgroup <span class="SimpleMath">H = S.2 &lt; Aut(S)</span>, we can choose <span class="SimpleMath">s</span> from two of the three classes of element order <span class="SimpleMath">15</span> in <span class="SimpleMath">S</span> such that <span class="SimpleMath">S</span> is the only maximal subgroup of <span class="SimpleMath">H</span> that contains <span class="SimpleMath">s</span>, and thus <span class="SimpleMath">⟨ x, s ⟩</span> contains <span class="SimpleMath">H</span>, for any choice of <span class="SimpleMath">x ∈ H ∖ S</span>.</p>

<p>For that, we note that no novelty in <span class="SimpleMath">S.2</span> contains elements of order <span class="SimpleMath">15</span>, so all maximal subgroups of <span class="SimpleMath">S.2</span> that contain such elements –besides <span class="SimpleMath">S</span>– have one of the indices <span class="SimpleMath">120, 135, 960, 1120</span>, or <span class="SimpleMath">12096</span>, and point stabilizers of the types <span class="SimpleMath">S_6(2) × 2</span>, <span class="SimpleMath">2^6:S_8</span>, <span class="SimpleMath">S_9</span>, <span class="SimpleMath">S_3 × U_4(2):2</span>, or <span class="SimpleMath">S_5 ≀ 2</span>. We compute the corresponding permutation characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "O8+(2).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= CharacterTable( "S6(2)" ) * CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters( s, t2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= pi;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PermChars( t2, rec( torso:= [ 135 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( prim, pi );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters( CharacterTable( "A9.2" ), t2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( prim, pi );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= CharacterTable( "Dihedral(6)" ) * CharacterTable( "U4(2).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters( s, t2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( prim, pi );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= CharacterTableWreathSymmetric( CharacterTable( "S5" ), 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PossiblePermutationCharacters( s, t2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( prim, pi );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( prim );</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord15:= PositionsProperty( OrdersClassRepresentatives( t2 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                              x -&gt; x = 15 );</span>
[ 39, 40 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( prim, pi -&gt; pi{ ord15 } );</span>
[ [ 1, 0 ], [ 2, 0 ], [ 2, 0 ], [ 1, 0 ], [ 1, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ord15, i -&gt; Maximum( ApproxP( prim, i ) ) );</span>
[ 307/120, 0 ]
</pre></div>

<p>Here it is appropriate to clean the workspace again.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CleanWorkspace();</span>
</pre></div>

<p><a id="X78F0815B86253A1F" name="X78F0815B86253A1F"></a></p>

<h5>11.5-13 <span class="Heading"><span class="SimpleMath">O_8^+(3)</span></span></h5>

<p>We show that <span class="SimpleMath">S = O_8^+(3)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">σ(S) = 863/1820</span>, and this value is attained exactly for <span class="SimpleMath">σ(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">20</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">20</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of two nonconjugate groups of the type <span class="SimpleMath">O_7(3) = Ω(7,3)</span>, two conjugate subgroups of the type <span class="SimpleMath">3^6:L_4(3)</span>, two nonconjugate subgroups of the type <span class="SimpleMath">(A_4 × U_4(2)):2</span>, and one subgroup of each of the types <span class="SimpleMath">2.U_4(3).(2^2)_122</span> and <span class="SimpleMath">(A_6 × A_6):2^2</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">P(S) = 194/455</span>, and this value is attained exactly for <span class="SimpleMath">P(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">20</span>.</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>The uniform spread of <span class="SimpleMath">S</span> is at least three, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">20</span>.</p>

</dd>
<dt><strong class="Mark">(e)</strong></dt>
<dd><p>The preimage of <span class="SimpleMath">s</span> in the matrix group <span class="SimpleMath">2.S = Ω^+(8,3)</span> can be chosen of order <span class="SimpleMath">40</span>, and then the maximal subgroups of <span class="SimpleMath">2.S</span> containing <span class="SimpleMath">s</span> have the structures <span class="SimpleMath">2.O_7(3)</span>, <span class="SimpleMath">3^6:2.L_4(3)</span>, <span class="SimpleMath">4.U_4(3).2^2 = SU(4,3).2^2</span>, <span class="SimpleMath">2.(A_4 × U_4(2)).2 = 2.(PSp(2,3) ⊗ PSp(4,3)).2</span>, and <span class="SimpleMath">2.(A_6 × A_6):2^2 = 2.(Ω^-(4,3) × Ω^-(4,3)):2^2</span>, respectively.</p>

</dd>
<dt><strong class="Mark">(f)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">20</span>, we have <span class="SimpleMath">P^'(S.2_1, s) ∈ { 83/567, 574/1215 }</span>, <span class="SimpleMath">P^'(S.2_2, s) ∈ { 0, 1 }</span> (depending on the choice of <span class="SimpleMath">s</span>), and <span class="SimpleMath">σ^'(S.3, s) = 0</span>.</p>

<p>Furthermore, for any choice of <span class="SimpleMath">s^' ∈ S</span>, we have <span class="SimpleMath">σ^'(S.2_2, s^') = 1</span> for some group <span class="SimpleMath">S.2_2</span>. However, if it is allowed to choose <span class="SimpleMath">s</span> from an <span class="SimpleMath">Aut(S)</span>-class of elements of order <span class="SimpleMath">20</span> (and not from a fixed <span class="SimpleMath">S</span>-class) then we can achieve <span class="SimpleMath">σ(g,s) = 0</span> for any given <span class="SimpleMath">g ∈ S.2_2 ∖ S</span>.</p>

</dd>
<dt><strong class="Mark">(g)</strong></dt>
<dd><p>The maximal subgroups of <span class="SimpleMath">S.2_1</span> that contain an element of order <span class="SimpleMath">20</span> are either <span class="SimpleMath">S</span> and the extensions of the subgroups listed in statement (b) or they are <span class="SimpleMath">S</span> and <span class="SimpleMath">L_4(3).2^2</span>, <span class="SimpleMath">3^6:L_4(3).2</span> (twice), <span class="SimpleMath">2.U_4(3).(2^2)_122.2</span>, and <span class="SimpleMath">(A_6 × A_6):2^2.2</span>.</p>

<p>In the former case, the groups have the structures <span class="SimpleMath">O_7(3):2</span> (twice), <span class="SimpleMath">3^6:(L_4(3) × 2)</span> (twice), <span class="SimpleMath">S_4 × U_4(2).2</span> (twice), <span class="SimpleMath">2.U_4(3).(2^2)_122.2</span>, and <span class="SimpleMath">(A_6 × A_6):2^2 × 2</span>.</p>

</dd>
</dl>
<p>Statement (a) follows from inspection of the primitive permutation characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "O8+(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoSimple( t );</span>
[ "O8+(3)", 863/1820, 2, [ "20A", "20B", "20C" ], [ 8, 8, 8 ] ]
</pre></div>

<p>Also statement (b) follows from the information provided by the character table of <span class="SimpleMath">S</span> (cf. <a href="chapBib.html#biBCCN85">[CCN+85, p. 140]</a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= PrimitivePermutationCharacters( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord:= OrdersClassRepresentatives( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( ord, 20 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">filt:= PositionsProperty( prim, x -&gt; x[ spos ] &lt;&gt; 0 );</span>
[ 1, 2, 7, 15, 18, 19, 24 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maxes( t ){ filt };</span>
[ "O7(3)", "O8+(3)M2", "3^6:L4(3)", "2.U4(3).(2^2)_{122}", 
  "(A4xU4(2)):2", "O8+(3)M19", "(A6xA6):2^2" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim{ filt }{ [ 1, spos ] };</span>
[ [ 1080, 1 ], [ 1080, 1 ], [ 1120, 2 ], [ 189540, 1 ], 
  [ 7960680, 1 ], [ 7960680, 1 ], [ 9552816, 1 ] ]
</pre></div>

<p>For statement (c), we first show that <span class="SimpleMath">P(S,s) = 194/455</span> holds. Since this value is larger than <span class="SimpleMath">1/3</span>, we have to inspect only those classes <span class="SimpleMath">g^S</span> for which <span class="SimpleMath">σ(g,s) ≥ 1/3</span> holds,</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord:= OrdersClassRepresentatives( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord20:= PositionsProperty( ord, x -&gt; x = 20 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for i in ord20 do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     approx:= ApproxP( prim, i );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Add( cand, PositionsProperty( approx, x -&gt; x &gt;= 1/3 ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand;</span>
[ [ 2, 6, 7, 10 ], [ 3, 6, 8, 11 ], [ 4, 6, 9, 12 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasClassNames( t ){ cand[1] };</span>
[ "2A", "3A", "3B", "3E" ]
</pre></div>

<p>The three possibilities form one orbit under the outer automorphism group of <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t3:= CharacterTable( "O8+(3).3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tfust3:= GetFusionMap( t, t3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( cand, x -&gt; tfust3{ x } );</span>
[ [ 2, 4, 5, 6 ], [ 2, 4, 5, 6 ], [ 2, 4, 5, 6 ] ]
</pre></div>

<p>By symmetry, we may consider only the first possibility, and assume that <span class="SimpleMath">s</span> is in the class <code class="code">20A</code>.</p>

<p>We work with a permutation representation of degree <span class="SimpleMath">1080</span>, and assume that the permutation character is <code class="code">1a+260a+819a</code>. (Note that all permutation characters of <span class="SimpleMath">S</span> of degree <span class="SimpleMath">1080</span> are conjugate under <span class="SimpleMath">Aut(S)</span>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Action( SO(1,8,3), NormedRowVectors( GF(3)^8 ), OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( g );</span>
9904359628800
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= DerivedSubgroup( g );;  Size( g );</span>
4952179814400
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( g, MovedPoints( g ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 1080, 1080, 1120 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Action( g, orbs[1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositionProperty( Irr( t ), chi -&gt; chi[1] = 819 );</span>
9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">permchar:= Sum( Irr( t ){ [ 1, 2, 9 ] } );</span>
Character( CharacterTable( "O8+(3)" ),
 [ 1080, 128, 0, 0, 24, 108, 135, 0, 0, 108, 0, 0, 27, 27, 0, 0, 18, 
  9, 12, 16, 0, 0, 4, 15, 0, 0, 20, 0, 0, 12, 11, 0, 0, 20, 0, 0, 15, 
  0, 0, 12, 0, 0, 2, 0, 0, 3, 3, 0, 0, 6, 6, 0, 0, 3, 2, 2, 2, 18, 0, 
  0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 3, 0, 0, 12, 0, 0, 3, 0, 0, 0, 
  0, 0, 4, 3, 3, 0, 0, 1, 0, 0, 4, 0, 0, 1, 1, 2, 0, 0, 0, 0, 0, 3, 
  0, 0, 2, 0, 0, 5, 0, 0, 1, 0, 0 ] )
</pre></div>

<p>Now we show that for <span class="SimpleMath">s</span> in the class <code class="code">20A</code> (which fixes one point), the proportion of nongenerating elements <span class="SimpleMath">g</span> in one of the classes <code class="code">2A</code>, <code class="code">3A</code>, <code class="code">3B</code>, <code class="code">3E</code> has the maximum <span class="SimpleMath">194/455</span>, which is attained exactly for <code class="code">3A</code>. (We find a <code class="code">2A</code> element as a power of <span class="SimpleMath">s</span>, a <code class="code">3A</code> element as a power of any element of order <span class="SimpleMath">18</span>, a <code class="code">3B</code> and a <code class="code">3E</code> element as elements with <span class="SimpleMath">135</span> and <span class="SimpleMath">108</span> fixed points, respectively, which occur as powers of suitable elements of order <span class="SimpleMath">15</span>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">permchar{ ord20 };</span>
[ 1, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasClassNames( t )[ PowerMap( t, 10 )[ ord20[1] ] ];</span>
"2A"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord18:= PositionsProperty( ord, x -&gt; x = 18 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set( AtlasClassNames( t ){ PowerMap( t, 6 ){ ord18 } } );</span>
[ "3A" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord15:= PositionsProperty( ord, x -&gt; x = 15 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PowerMap( t, 5 ){ ord15 };</span>
[ 7, 8, 9, 10, 11, 12 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasClassNames( t ){ [ 7 .. 12 ] };</span>
[ "3B", "3C", "3D", "3E", "3F", "3G" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">permchar{ [ 7 .. 12 ] };</span>
[ 135, 0, 0, 108, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mp:= NrMovedPoints( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat 20A:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( 20A ) = 20 and mp - NrMovedPoints( 20A ) = 1;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2A:= 20A^10;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= Random( g ); until Order( x ) = 18;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3A:= x^6;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( x ) = 15 and mp - NrMovedPoints( x^5 ) = 135;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3B:= x^5;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( x ) = 15 and mp - NrMovedPoints( x^5 ) = 108;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3E:= x^5;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nongen:= List( [ 2A, 3A, 3B, 3E ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  c -&gt; RatioOfNongenerationTransPermGroup( g, c, 20A ) );</span>
[ 3901/9477, 194/455, 451/1092, 451/1092 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( nongen );</span>
194/455
</pre></div>

<p>Next we compute the values <span class="SimpleMath">P(g,s)</span>, for <span class="SimpleMath">g</span> is in the class <code class="code">3A</code> and certain elements <span class="SimpleMath">s</span>. It is enough to consider representatives <span class="SimpleMath">s</span> of maximally cyclic subgroups in <span class="SimpleMath">S</span>, but here we can do better, as follows. Since <code class="code">3A</code> is the unique class of length <span class="SimpleMath">72800</span>, it is fixed under <span class="SimpleMath">Aut(S)</span>, so it is enough to consider one element <span class="SimpleMath">s</span> from each <span class="SimpleMath">Aut(S)</span>-orbit on the classes of <span class="SimpleMath">S</span>. We use the class fusion between the character tables of <span class="SimpleMath">S</span> and <span class="SimpleMath">Aut(S)</span> for computing orbit representatives.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maxorder:= RepresentativesMaximallyCyclicSubgroups( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( maxorder );</span>
57
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">autt:= CharacterTable( "O8+(3).S4" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( t, autt );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbreps:= Set( fus, map -&gt; Set( ProjectionMap( map ) ) );</span>
[ [ 1, 2, 5, 6, 7, 13, 17, 18, 19, 20, 23, 24, 27, 30, 31, 37, 43, 
      46, 50, 54, 55, 56, 57, 58, 64, 68, 72, 75, 78, 84, 85, 89, 95, 
      96, 97, 100, 106, 112 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">totest:= Intersection( maxorder, orbreps[1] );</span>
[ 43, 50, 54, 56, 57, 64, 68, 75, 78, 84, 85, 89, 95, 97, 100, 106, 
  112 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( totest );</span>
17
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasClassNames( t ){ totest };</span>
[ "6Q", "6X", "6B1", "8A", "8B", "9G", "9K", "12A", "12D", "12J", 
  "12K", "12O", "13A", "14A", "15A", "18A", "20A" ]
</pre></div>

<p>This means that we have to test one element of each of the element orders <span class="SimpleMath">13</span>, <span class="SimpleMath">14</span>, <span class="SimpleMath">15</span>, and <span class="SimpleMath">18</span> (note that we know already a bound for elements of order <span class="SimpleMath">20</span>), plus certain elements of the orders <span class="SimpleMath">6</span>, <span class="SimpleMath">8</span>, <span class="SimpleMath">9</span>, and <span class="SimpleMath">12</span> which can be identified by their centralizer orders and (for elements of order <span class="SimpleMath">6</span> and <span class="SimpleMath">8</span>) perhaps the centralizer orders of some powers.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elementstotest:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for elord in [ 13, 14, 15, 18 ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     until Order( s ) = elord;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Add( elementstotest, s );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
</pre></div>

<p>The next elements to be tested are in the classes <code class="code">6B1</code> (centralizer order <span class="SimpleMath">162</span>), in one of <code class="code">9G</code>–<code class="code">9J</code> (centralizer order <span class="SimpleMath">729</span>), in one of <code class="code">9K</code>–<code class="code">9N</code> (centralizer order <span class="SimpleMath">81</span>), in one of <code class="code">12A</code>–<code class="code">12C</code> (centralizer order <span class="SimpleMath">1728</span>), in one of <code class="code">12D</code>–<code class="code">12I</code> (centralizer order <span class="SimpleMath">432</span>), in <code class="code">12J</code> (centralizer order <span class="SimpleMath">192</span>), in one of <code class="code">12K</code>–<code class="code">12N</code> (centralizer order <span class="SimpleMath">108</span>), and in one of <code class="code">12O</code>–<code class="code">12T</code> (centralizer order <span class="SimpleMath">72</span>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ordcent:= [ [ 6, 162 ], [ 9, 729 ], [ 9, 81 ], [ 12, 1728 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               [ 12, 432 ], [ 12, 192 ], [ 12, 108 ], [ 12, 72 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cents:= SizesCentralizers( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for pair in ordcent do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Print( pair, ": ", AtlasClassNames( t ){</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Filtered( [ 1 .. Length( ord ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   i -&gt; ord[i] = pair[1] and cents[i] = pair[2] ) }, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     until Order( s ) = pair[1] and Size( Centralizer( g, s ) ) = pair[2];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Add( elementstotest, s );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
[ 6, 162 ]: [ "6B1" ]
[ 9, 729 ]: [ "9G", "9H", "9I", "9J" ]
[ 9, 81 ]: [ "9K", "9L", "9M", "9N" ]
[ 12, 1728 ]: [ "12A", "12B", "12C" ]
[ 12, 432 ]: [ "12D", "12E", "12F", "12G", "12H", "12I" ]
[ 12, 192 ]: [ "12J" ]
[ 12, 108 ]: [ "12K", "12L", "12M", "12N" ]
[ 12, 72 ]: [ "12O", "12P", "12Q", "12R", "12S", "12T" ]
</pre></div>

<p>The next elements to be tested are in one of the classes <code class="code">6Q</code>–<code class="code">6S</code> (centralizer order <span class="SimpleMath">648</span>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasClassNames( t ){ Filtered( [ 1 .. Length( ord ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       i -&gt; cents[i] = 648 and cents[ PowerMap( t, 2 )[i] ] = 52488</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                           and cents[ PowerMap( t, 3 )[i] ] = 26127360 ) };</span>
[ "6Q", "6R", "6S" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 6 and Size( Centralizer( g, s ) ) = 648</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     and Size( Centralizer( g, s^2 ) ) = 52488</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     and Size( Centralizer( g, s^3 ) ) = 26127360;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Add( elementstotest, s );</span>
</pre></div>

<p>The next elements to be tested are in the class <code class="code">6X</code>–<code class="code">6A1</code> (centralizer order <span class="SimpleMath">648</span>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasClassNames( t ){ Filtered( [ 1 .. Length( ord ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       i -&gt; cents[i] = 648 and cents[ PowerMap( t, 2 )[i] ] = 52488</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                           and cents[ PowerMap( t, 3 )[i] ] = 331776 ) };</span>
[ "6X", "6Y", "6Z", "6A1" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 6 and Size( Centralizer( g, s ) ) = 648</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     and Size( Centralizer( g, s^2 ) ) = 52488</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     and Size( Centralizer( g, s^3 ) ) = 331776;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Add( elementstotest, s );</span>
</pre></div>

<p>Finally, we add elements from the classes <code class="code">8A</code> and <code class="code">8B</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasClassNames( t ){ Filtered( [ 1 .. Length( ord ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       i -&gt; ord[i] = 8 and cents[ PowerMap( t, 2 )[i] ] = 13824 ) };</span>
[ "8A" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 8 and Size( Centralizer( g, s^2 ) ) = 13824;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Add( elementstotest, s );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasClassNames( t ){ Filtered( [ 1 .. Length( ord ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       i -&gt; ord[i] = 8 and cents[ PowerMap( t, 2 )[i] ] = 1536 ) };</span>
[ "8B" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 8 and Size( Centralizer( g, s^2 ) ) = 1536;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Add( elementstotest, s );</span>
</pre></div>

<p>Now we compute the ratios. It turns out that from these candidates, only elements <span class="SimpleMath">s</span> of the orders <span class="SimpleMath">14</span> and <span class="SimpleMath">15</span> satisfy <span class="SimpleMath">P(g,s) &lt; 194/455</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nongen:= List( elementstotest,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  s -&gt; RatioOfNongenerationTransPermGroup( g, 3A, s ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">smaller:= PositionsProperty( nongen, x -&gt; x &lt; 194/455 );</span>
[ 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nongen{ smaller };</span>
[ 127/325, 1453/3640 ]
</pre></div>

<p>So the only candidates for <span class="SimpleMath">s</span> that may be better than order <span class="SimpleMath">20</span> elements are elements of order <span class="SimpleMath">14</span> or <span class="SimpleMath">15</span>. In order to exclude these two possibilities, we compute <span class="SimpleMath">P(g,s)</span> for <span class="SimpleMath">s</span> in the class <code class="code">14A</code> and <span class="SimpleMath">g = s^7</span> in the class <code class="code">2A</code>, and for <span class="SimpleMath">s</span> in the class <code class="code">15A</code> and <span class="SimpleMath">g</span> in the class <code class="code">2A</code>, which yields values that are larger than <span class="SimpleMath">194/455</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 14 and NrMovedPoints( s ) = 1078;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2A:= s^7;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nongen:= RatioOfNongenerationTransPermGroup( g, 2A, s );</span>
1573/3645
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nongen &gt; 194/455;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 15 and NrMovedPoints( s ) = 1080 - 3;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nongen:= RatioOfNongenerationTransPermGroup( g, 2A, s );</span>
490/1053
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nongen &gt; 194/455;</span>
true
</pre></div>

<p>For statement (d), we show that for each triple of elements in the union of the classes <code class="code">2A</code>, <code class="code">3A</code>, <code class="code">3B</code>, <code class="code">3E</code> there is an element in the class <code class="code">20A</code> that generates <span class="SimpleMath">S</span> together with each element of the triple.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for tup in UnorderedTuples( [ 2A, 3A, 3B, 3E ], 3 ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     cl:= ShallowCopy( tup );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     test:= RandomCheckUniformSpread( g, cl, 20A, 100 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if test &lt;&gt; true then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Error( test );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
</pre></div>

<p>We get no error message, so statement (d) is true.</p>

<p>For statement (e), first we show that <span class="SimpleMath">2.S = Ω^+(8,3)</span> contains elements of order <span class="SimpleMath">40</span> but <span class="SimpleMath">S</span> does not.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">der:= DerivedSubgroup( SO(1,8,3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= PseudoRandom( der ); until Order( x ) = 40;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">40 in ord;</span>
false
</pre></div>

<p>Thus elements of order <span class="SimpleMath">40</span> must arise as preimages of order <span class="SimpleMath">20</span> elements under the natural epimorphism from <span class="SimpleMath">2.S</span> to <span class="SimpleMath">S</span>, which means that we may choose an order <span class="SimpleMath">40</span> preimage <span class="SimpleMath">hats</span> of <span class="SimpleMath">s</span>. Then <span class="SimpleMath">𝕄(2.S, hats)</span> consists of central extensions of the subgroups listed in statement (b). The perfect subgroups <span class="SimpleMath">O_7(3)</span>, <span class="SimpleMath">L_4(3)</span>, <span class="SimpleMath">2.U_4(3)</span>, and <span class="SimpleMath">U_4(2)</span> of these groups must lift to their Schur double covers in <span class="SimpleMath">2.S</span> because otherwise the preimages would not contain elements of order <span class="SimpleMath">40</span>.</p>

<p>Next we consider the preimage of the subgroup <span class="SimpleMath">U = (A_4 × U_4(2)).2</span> of <span class="SimpleMath">S</span>. We show that the preimages of the two direct factors <span class="SimpleMath">A_4</span> and <span class="SimpleMath">U_4(2)</span> in <span class="SimpleMath">U^' = A_4 × U_4(2)</span> are Schur covers. For <span class="SimpleMath">A_4</span>, this follows from the fact that the preimage of <span class="SimpleMath">U^'</span> must contain elements of order <span class="SimpleMath">20</span>, and that <span class="SimpleMath">U_4(2)</span> does not contain elements of order <span class="SimpleMath">10</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u42:= CharacterTable( "U4(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Filtered( OrdersClassRepresentatives( u42 ), x -&gt; x mod 5 = 0 );</span>
[ 5 ]
</pre></div>

<p>In order to show that the <span class="SimpleMath">U_4(2)</span> type subgroup of <span class="SimpleMath">U^'</span> lifts to its double cover in <span class="SimpleMath">2.S</span>, we note that the class <code class="code">2B</code> of <span class="SimpleMath">U_4(2)</span> lifts to a class of elements of order four in the double cover <span class="SimpleMath">2.U_4(2)</span>, and that the corresponding class of elements in <span class="SimpleMath">U</span> is <span class="SimpleMath">S</span>-conjugate to the class of involutions in the direct factor <span class="SimpleMath">A_4</span> (which is the unique class of length three in <span class="SimpleMath">U</span>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= CharacterTable( Maxes( t )[18] );</span>
CharacterTable( "(A4xU4(2)):2" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2u42:= CharacterTable( "2.U4(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( 2u42 )[4];</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetFusionMap( 2u42, u42 )[4];</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( u42 )[3];</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( PossibleClassFusions( u42, u ), x -&gt; x[3] );</span>
[ 8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositionsProperty( SizesConjugacyClasses( u ), x -&gt; x = 3 );</span>
[ 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( PossibleClassFusions( u, t ), x -&gt; x[2] = x[8] );</span>
true
</pre></div>

<p>The last subgroup for which the structure of the preimage has to be shown is <span class="SimpleMath">U = (A_6 × A_6):2^2</span>. We claim that each of the <span class="SimpleMath">A_6</span> type subgroups in the derived subgroup <span class="SimpleMath">U^' = A_6 × A_6</span> lifts to its double cover in <span class="SimpleMath">2.S</span>. Since all elements of order <span class="SimpleMath">20</span> in <span class="SimpleMath">U</span> lie in <span class="SimpleMath">U^'</span>, at least one of the two direct factors must lift to its double cover, in order to give rise to an order <span class="SimpleMath">40</span> element in <span class="SimpleMath">U</span>. In fact both factors lift to the double cover since the two direct factors are interchanged by conjugation in <span class="SimpleMath">U</span>; the latter follows form tha fact that <span class="SimpleMath">U</span> has no normal subgroup of type <span class="SimpleMath">A_6</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= CharacterTable( Maxes( t )[24] );</span>
CharacterTable( "(A6xA6):2^2" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfDerivedSubgroup( u );</span>
[ 1 .. 22 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositionsProperty( OrdersClassRepresentatives( u ), x -&gt; x = 20 );</span>
[ 8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ClassPositionsOfNormalSubgroups( u ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         x -&gt; Sum( SizesConjugacyClasses( u ){ x } ) );</span>
[ 1, 129600, 259200, 259200, 259200, 518400 ]
</pre></div>

<p>So statement (e) holds.</p>

<p>For statement (f), we have to consider the upward extensions <span class="SimpleMath">S.2_1</span>, <span class="SimpleMath">S.2_2</span>, and <span class="SimpleMath">S.3</span>.</p>

<p>First we look at <span class="SimpleMath">S.2_1</span>, an extension by an outer automorphism that acts as a double transposition in the outer automorphism group <span class="SimpleMath">S_4</span>. Note that the symmetry between the three classes of element oder <span class="SimpleMath">20</span> in <span class="SimpleMath">S</span> is broken in <span class="SimpleMath">S.2_1</span>, two of these classes have square roots in <span class="SimpleMath">S.2_1</span>, the third has not.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "O8+(3).2_1" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord20:= PositionsProperty( OrdersClassRepresentatives( t2 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               x -&gt; x = 20 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord20:= Intersection( ord20, ClassPositionsOfDerivedSubgroup( t2 ) );</span>
[ 84, 85, 86 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ord20, x -&gt; x in PowerMap( t2, 2 ) );</span>
[ false, true, true ]
</pre></div>

<p>Changing the viewpoint, we see that for each class of element order <span class="SimpleMath">20</span> in <span class="SimpleMath">S</span>, there is a group of the type <span class="SimpleMath">S.2_1</span> in which the elements in this class do not have square roots, and there are groups of this type in which these elements have square roots. So we have to deal with two different cases, and we do this by first collecting the permutation characters induced from <em>all</em> maximal subgroups of <span class="SimpleMath">S.2_1</span> (other than <span class="SimpleMath">S</span>) that contain elements of order <span class="SimpleMath">20</span> in <span class="SimpleMath">S</span>, and then considering <span class="SimpleMath">s</span> in each of these classes of <span class="SimpleMath">S</span>.</p>

<p>We fix an embedding of <span class="SimpleMath">S</span> into <span class="SimpleMath">S.2_1</span> in which the elements in the class <code class="code">20A</code> do not have square roots. This situation is given for the stored class fusion between the tables in the <strong class="pkg">GAP</strong> Character Table Library.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tfust2:= GetFusionMap( t, t2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tfust2{ PositionsProperty( OrdersClassRepresentatives( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               x -&gt; x = 20 ) };</span>
[ 84, 85, 86 ]
</pre></div>

<p>The six different actions of <span class="SimpleMath">S</span> on the cosets of <span class="SimpleMath">O_7(3)</span> type subgroups induce pairwise different permutation characters that form an orbit under the action of <span class="SimpleMath">Aut(S)</span>. Four of these characters cannot extend to <span class="SimpleMath">S.2_1</span>, the other two extend to permutation characters of <span class="SimpleMath">S.2_1</span> on the cosets of <span class="SimpleMath">O_7(3).2</span> type subgroups; these subgroups contain <code class="code">20A</code> elements.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">primt2:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= PossiblePermutationCharacters( CharacterTable( "O7(3)" ), t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">invfus:= InverseMap( tfust2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( poss, pi -&gt; ForAll( CompositionMaps( pi, invfus ), IsInt ) );</span>
[ false, false, false, false, true, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossiblePermutationCharacters(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "O7(3)" ) * CharacterTable( "Cyclic", 2 ), t2 );</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= PossiblePermutationCharacters( CharacterTable( "O7(3).2" ), t2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ext, pi -&gt; pi{ ord20 } );</span>
[ [ 1, 0, 0 ], [ 1, 0, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( primt2, ext );</span>
</pre></div>

<p>The novelties in <span class="SimpleMath">S.2_1</span> that arise from <span class="SimpleMath">O_7(3)</span> type subgroups of <span class="SimpleMath">S</span> have the structure <span class="SimpleMath">L_4(3).2^2</span>. These subgroups contain elements in the classes <code class="code">20B</code> and <code class="code">20C</code> of <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= PossiblePermutationCharacters( CharacterTable( "L4(3).2^2" ), t2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ext, pi -&gt; pi{ ord20 } );</span>
[ [ 0, 0, 1 ], [ 0, 1, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( primt2, ext );</span>
</pre></div>

<p>Note that from the possible permutation characters of <span class="SimpleMath">S.2_1</span> on the cosets of <span class="SimpleMath">L_4(3):2 × 2</span> type subgroups, we see that such subgroups must contain <code class="code">20A</code> elements, i. e., all such subgroups of <span class="SimpleMath">S.2_1</span> lie inside <span class="SimpleMath">O_7(3).2</span> type subgroups. This means that the structure description of these novelties in <a href="chapBib.html#biBCCN85">[CCN+85, p. 140]</a> is not correct. The correct structure is <span class="SimpleMath">L_4(3).2^2</span>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( PossiblePermutationCharacters( CharacterTable( "L4(3).2_2" ) *</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             CharacterTable( "Cyclic", 2 ), t2 ), pi -&gt; pi{ ord20 } );</span>
[ [ 1, 0, 0 ] ]
</pre></div>

<p>All <span class="SimpleMath">3^6:L_4(3)</span> type subgroups of <span class="SimpleMath">S</span> extend to <span class="SimpleMath">S.2_1</span>. We compute these permutation characters as the possible permutation characters of the right degree.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= PermChars( t2, rec( torso:= [ 1120 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ext, pi -&gt; pi{ ord20 } );</span>
[ [ 2, 0, 0 ], [ 0, 0, 2 ], [ 0, 2, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( primt2, ext );</span>
</pre></div>

<p>Also all <span class="SimpleMath">2.U_4(3).2^2</span> type subgroups of <span class="SimpleMath">S</span> extend to <span class="SimpleMath">S.2_1</span>. We compute the permutation characters as the extensions of the corresponding permutation characters of <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">filt:= Filtered( prim, x -&gt; x[1] = 189540 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= List( filt, x -&gt; CompositionMaps( x, invfus ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= Concatenation( List( cand,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             pi -&gt; PermChars( t2, rec( torso:= pi ) ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ext, x -&gt; x{ ord20 } );</span>
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( primt2, ext );</span>
</pre></div>

<p>The extensions of <span class="SimpleMath">(A_4 × U_4(2)):2</span> type subgroups of <span class="SimpleMath">S</span> to <span class="SimpleMath">S.2_1</span> have the type <span class="SimpleMath">S_4 × U_4(2):2</span>, they contain <code class="code">20A</code> elements.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= PossiblePermutationCharacters( CharacterTable( "Symmetric", 4 ) *</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             CharacterTable( "U4(2).2" ), t2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ext, x -&gt; x{ ord20 } );</span>
[ [ 1, 0, 0 ], [ 1, 0, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( primt2, ext );</span>
</pre></div>

<p>All <span class="SimpleMath">(A_6 × A_6):2^2</span> type subgroups of <span class="SimpleMath">S</span> extend to <span class="SimpleMath">S.2_1</span>. We compute the permutation characters as the extensions of the corresponding permutation characters of <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">filt:= Filtered( prim, x -&gt; x[1] = 9552816 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= List( filt, x -&gt; CompositionMaps( x, InverseMap( tfust2 ) ));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= Concatenation( List( cand,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             pi -&gt; PermChars( t2, rec( torso:= pi ) ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ext, x -&gt; x{ ord20 } );</span>
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( primt2, ext );</span>
</pre></div>

<p>We have found all relevant permutation characters of <span class="SimpleMath">S.2_1</span>. This together with the list in <a href="chapBib.html#biBCCN85">[CCN+85, p. 140]</a> implies statement (g).</p>

<p>Now we compute the bounds <span class="SimpleMath">σ^'(S.2_1, s)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( primt2 );</span>
15
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= List( ord20, x -&gt; ApproxP( primt2, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">outer:= Difference(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ClassPositionsOfDerivedSubgroup( t2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( approx, l -&gt; Maximum( l{ outer } ) );</span>
[ 574/1215, 83/567, 83/567 ]
</pre></div>

<p>Next we look at <span class="SimpleMath">S.2_2</span>, an extension by an outer automorphism that acts as a transposition in the outer automorphism group <span class="SimpleMath">S_4</span>. Similar to the above situation, the symmetry between the three classes of element oder <span class="SimpleMath">20</span> in <span class="SimpleMath">S</span> is broken also in <span class="SimpleMath">S.2_2</span>: The first is a conjugacy class of <span class="SimpleMath">S.2_2</span>, the other two classes are fused in <span class="SimpleMath">S.2_2</span>,</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "O8+(3).2_2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord20:= PositionsProperty( OrdersClassRepresentatives( t2 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               x -&gt; x = 20 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord20:= Intersection( ord20, ClassPositionsOfDerivedSubgroup( t2 ) );</span>
[ 82, 83 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tfust2:= GetFusionMap( t, t2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tfust2{ PositionsProperty( OrdersClassRepresentatives( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               x -&gt; x = 20 ) };</span>
[ 82, 83, 83 ]
</pre></div>

<p>Like in the case <span class="SimpleMath">S.2_1</span>, we compute the permutation characters induced from <em>all</em> maximal subgroups of <span class="SimpleMath">S.2_2</span> (other than <span class="SimpleMath">S</span>) that contain elements of order <span class="SimpleMath">20</span> in <span class="SimpleMath">S</span>.</p>

<p>We fix the embedding of <span class="SimpleMath">S</span> into <span class="SimpleMath">S.2_2</span> in which the class <code class="code">20A</code> of <span class="SimpleMath">S</span> is a class of <span class="SimpleMath">S.2_2</span>. This situation is given for the stored class fusion between the tables in the <strong class="pkg">GAP</strong> Character Table Library.</p>

<p>Exactly two classes of <span class="SimpleMath">O_7(3)</span> type subgroups in <span class="SimpleMath">S</span> extend to <span class="SimpleMath">S.2_2</span>, these groups contain <code class="code">20A</code> elements.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">primt2:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= PermChars( t2, rec( torso:= [ 1080 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ext, pi -&gt; pi{ ord20 } );</span>
[ [ 1, 0 ], [ 1, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( primt2, ext );</span>
</pre></div>

<p>Only one class of <span class="SimpleMath">3^6:L_4(3)</span> type subgroups extends to <span class="SimpleMath">S.2_2</span>. (Note that we need not consider the novelties of the type <span class="SimpleMath">3^3+6:(L_3(3) × 2)</span>, because the order of these groups is not divisible by <span class="SimpleMath">5</span>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= PermChars( t2, rec( torso:= [ 1120 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ext, pi -&gt; pi{ ord20 } );</span>
[ [ 2, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( primt2, ext );</span>
</pre></div>

<p>Only one class of <span class="SimpleMath">2.U_4(3).2^2</span> type subgroups of <span class="SimpleMath">S</span> extends to <span class="SimpleMath">S.2_2</span>. We compute the permutation character as the extension of the corresponding permutation characters of <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">filt:= Filtered( prim, x -&gt; x[1] = 189540 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= List( filt, x -&gt; CompositionMaps( x, InverseMap( tfust2 ) ));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= Concatenation( List( cand,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             pi -&gt; PermChars( t2, rec( torso:= pi ) ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ext, x -&gt; x{ ord20 } );</span>
[ [ 1, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( primt2, ext );</span>
</pre></div>

<p>Two classes of <span class="SimpleMath">(A_4 × U_4(2)):2</span> type subgroups of <span class="SimpleMath">S</span> extend to <span class="SimpleMath">S.2_2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">filt:= Filtered( prim, x -&gt; x[1] = 7960680 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= List( filt, x -&gt; CompositionMaps( x, InverseMap( tfust2 ) ));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= Concatenation( List( cand,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             pi -&gt; PermChars( t2, rec( torso:= pi ) ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ext, x -&gt; x{ ord20 } );</span>
[ [ 1, 0 ], [ 1, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( primt2, ext );</span>
</pre></div>

<p>Exactly one class of <span class="SimpleMath">(A_6 × A_6):2^2</span> type subgroups in <span class="SimpleMath">S</span> extends to <span class="SimpleMath">S.2_2</span>, and the extensions have the structure <span class="SimpleMath">S_6 ≀ 2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= PossiblePermutationCharacters( CharacterTableWreathSymmetric(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             CharacterTable( "S6" ), 2 ), t2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ext, x -&gt; x{ ord20 } );</span>
[ [ 1, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( primt2, ext );</span>
</pre></div>

<p>We have found all relevant permutation characters of <span class="SimpleMath">S.2_2</span>, and compute the bounds <span class="SimpleMath">σ^'(S.2_2, s)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( primt2 );</span>
7
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= List( ord20, x -&gt; ApproxP( primt2, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">outer:= Difference(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ClassPositionsOfDerivedSubgroup( t2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( approx, l -&gt; Maximum( l{ outer } ) );</span>
[ 14/9, 0 ]
</pre></div>

<p>This means that there is an extension of the type <span class="SimpleMath">S.2_2</span> in which <span class="SimpleMath">s</span> cannot be chosen such that the bound is less than <span class="SimpleMath">1/2</span>. More precisely, we have <span class="SimpleMath">σ(g,s) ≥ 1/2</span> exactly for <span class="SimpleMath">g</span> in the unique outer involution class of size <span class="SimpleMath">1080</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( primt2, ord20[1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bad:= Filtered( outer, i -&gt; approx[i] &gt;= 1/2 );</span>
[ 84 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( t2 ){ bad };</span>
[ 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesConjugacyClasses( t2 ){ bad };</span>
[ 1080 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Number( SizesConjugacyClasses( t2 ), x -&gt; x = 1080 );</span>
1
</pre></div>

<p>So we compute the proportion of elements in this class that generate <span class="SimpleMath">S.2_2</span> together with an element <span class="SimpleMath">s</span> of order <span class="SimpleMath">20</span> in <span class="SimpleMath">S</span>. (As above, we have to consider two conjugacy classes.) For that, we first compute a permutation representation of <span class="SimpleMath">S.2_2</span>, using that <span class="SimpleMath">S.2_2</span> is isomporphic to the two subgroups of index <span class="SimpleMath">2</span> in <span class="SimpleMath">PGO^+(8,3) = O_8^+(3).2^2_122</span> that are different from <span class="SimpleMath">PSO^+(8,3) = O_8^+(3).2_1</span>, cf. <a href="chapBib.html#biBCCN85">[CCN+85, p. 140]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">go:= GO(1,8,3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">so:= SO(1,8,3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">outerelm:= First( GeneratorsOfGroup( go ), x -&gt; not x in so );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g2:= ClosureGroup( DerivedSubgroup( so ), outerelm );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( g2 );</span>
19808719257600
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dom:= NormedRowVectors( GF(3)^8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( g2, dom, OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 1080, 1080, 1120 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">act:= Action( g2, orbs[1], OnLines );;</span>
</pre></div>

<p>An involution <span class="SimpleMath">g</span> can be found as a power of one of the given generators.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order( outerelm );</span>
26
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Permutation( outerelm^13, orbs[1], OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( ConjugacyClass( act, g ) );</span>
1080
</pre></div>

<p>Now we find the candidates for the elements <span class="SimpleMath">s</span>, and compute their ratios of nongeneration.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord20;</span>
[ 82, 83 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesCentralizers( t2 ){ ord20 };</span>
[ 40, 20 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">der:= DerivedSubgroup( act );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat 20A:= Random( der );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( 20A ) = 20 and Size( Centralizer( act, 20A ) ) = 40;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RatioOfNongenerationTransPermGroup( act, g, 20A );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat 20BC:= Random( der );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( 20BC ) = 20 and Size( Centralizer( act, 20BC ) ) = 20;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RatioOfNongenerationTransPermGroup( act, g, 20BC );</span>
0
</pre></div>

<p>This means that for <span class="SimpleMath">s</span> in one <span class="SimpleMath">S</span>-class of elements of order <span class="SimpleMath">20</span>, we have <span class="SimpleMath">P^'(g, s) = 1</span>, and <span class="SimpleMath">s</span> in the other two <span class="SimpleMath">S</span>-classes of elements of order <span class="SimpleMath">20</span> generates with any conjugate of <span class="SimpleMath">g</span>.</p>

<p>Concerning <span class="SimpleMath">S.2_2</span>, it remains to show that we cannot find a better element than <span class="SimpleMath">s</span>. For that, we first compute class representatives <span class="SimpleMath">s^'</span> in <span class="SimpleMath">S</span>, w.r.t. conjugacy in <span class="SimpleMath">S.2_2</span>, and then compute <span class="SimpleMath">P^'( s^', g )</span>. (It would be enough to check representatives of classes of maximal element order, but computing all classes is easy enough.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= ConjugacyClasses( act );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">der:= DerivedSubgroup( act );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= Filtered( List( ccl, Representative ), x -&gt; x in der );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( reps );</span>
83
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ratios:= List( reps,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  s -&gt; RatioOfNongenerationTransPermGroup( act, g, s ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= PositionsProperty( ratios, x -&gt; x &lt; 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ratios:= ratios{ cand };;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SortParallel( ratios, cand );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ratios;</span>
[ 0, 1/10, 1/10, 16/135, 1/3, 1/3, 11/27, 7/15, 7/15 ]
</pre></div>

<p>For <span class="SimpleMath">S.2_2</span>, it remains to show that there is no element <span class="SimpleMath">s^' ∈ S</span> such that <span class="SimpleMath">P^'( s^'}^x, g ) &lt; 1</span> holds for any <span class="SimpleMath">x ∈ Aut(S)</span> and <span class="SimpleMath">g ∈ S.2_2</span>. So we are done when we can show that each class given by <code class="code">cand</code> is conjugate in <span class="SimpleMath">S.3</span> to a class outside <code class="code">cand</code>. The classes can be identified by element orders and centralizer orders.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">invs:= List( cand,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      x -&gt; [ Order( reps[x] ), Size( Centralizer( der, reps[x] ) ) ] );</span>
[ [ 20, 20 ], [ 18, 108 ], [ 18, 108 ], [ 14, 28 ], [ 15, 45 ], 
  [ 15, 45 ], [ 10, 40 ], [ 12, 72 ], [ 12, 72 ] ]
</pre></div>

<p>Namely, <code class="code">cand</code> contains no full <span class="SimpleMath">S.3</span>-orbit of classes of the element orders <span class="SimpleMath">20</span>, <span class="SimpleMath">18</span>, <span class="SimpleMath">14</span>, <span class="SimpleMath">15</span>, and <span class="SimpleMath">10</span>; also, <code class="code">cand</code> does not contain full <span class="SimpleMath">S.3</span>-orbits on the classes <code class="code">12O</code>–<code class="code">12T</code>.</p>

<p>Finally, we deal with <span class="SimpleMath">S.3</span>. The fact that no maximal subgroup of <span class="SimpleMath">S</span> containing an element of order <span class="SimpleMath">20</span> extends to <span class="SimpleMath">S.3</span> follows either from the list of maximal subgroups of <span class="SimpleMath">S</span> in <a href="chapBib.html#biBCCN85">[CCN+85, p. 140]</a> or directly from the permutation characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t3:= CharacterTable( "O8+(3).3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tfust3:= GetFusionMap( t, t3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv:= InverseMap( tfust3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">filt:= PositionsProperty( prim, x -&gt; x[ spos ] &lt;&gt; 0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( prim{ filt },</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           pi -&gt; ForAny( CompositionMaps( pi, inv ), IsList ) );</span>
true
</pre></div>

<p>So we have to consider only the classes of novelties in <span class="SimpleMath">S.3</span>, but the order of none of these groups is divisible by <span class="SimpleMath">20</span> –again see <a href="chapBib.html#biBCCN85">[CCN+85, p. 140]</a>). This means that <em>any</em> element in <span class="SimpleMath">S.3 ∖ S</span> together with an element of order <span class="SimpleMath">20</span> in <span class="SimpleMath">S</span> generates <span class="SimpleMath">S.3</span>. This is in fact stronger than statement (f), which claims this property only for elements of prime order in <span class="SimpleMath">S.3 ∖ S</span> (and their roots); note that <span class="SimpleMath">S.3 ∖ S</span> contains elements of the orders <span class="SimpleMath">9</span> and <span class="SimpleMath">27</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">outer:= Difference( [ 1 .. NrConjugacyClasses( t3 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               ClassPositionsOfDerivedSubgroup( t3 ) );</span>
[ 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 
  70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 
  87, 88, 89, 90, 91, 92, 93, 94 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set( OrdersClassRepresentatives( t3 ){ outer } );</span>
[ 3, 6, 9, 12, 18, 21, 24, 27, 36, 39 ]
</pre></div>

<p>Before we turn to the next computations, we clean the workspace.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CleanWorkspace();</span>
</pre></div>

<p><a id="X85BACC4A83F73392" name="X85BACC4A83F73392"></a></p>

<h5>11.5-14 <span class="Heading"><span class="SimpleMath">O^+_8(4)</span></span></h5>

<p>We show that <span class="SimpleMath">S = O^+_8(4) = Ω^+(8,4)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For suitable <span class="SimpleMath">s ∈ S</span> of the type <span class="SimpleMath">2^- perp 6^-</span> (i. e., <span class="SimpleMath">s</span> decomposes the natural <span class="SimpleMath">8</span>-dimensional module for <span class="SimpleMath">S</span> into an orthogonal sum of two irreducible modules of the dimensions <span class="SimpleMath">2</span> and <span class="SimpleMath">6</span>, respectively) and of order <span class="SimpleMath">65</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of exactly three pairwise nonconjugate subgroups of the type <span class="SimpleMath">(5 × O^-_6(4)).2 = (5 × Ω^-(6,4)).2</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ( S, s ) ≤ 34817 / 1645056</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p>In the extensions <span class="SimpleMath">S.2_1</span> and <span class="SimpleMath">S.3</span> of <span class="SimpleMath">S</span> by graph automorphisms, there is at most one maximal subgroup besides <span class="SimpleMath">S</span> that contains <span class="SimpleMath">s</span>. For the extension <span class="SimpleMath">S.2_2</span> of <span class="SimpleMath">S</span> by a field automorphism, we have <span class="SimpleMath">σ^'(S.2_2, s) = 0</span>. In the extension <span class="SimpleMath">S.2_3</span> of <span class="SimpleMath">S</span> by the product of an involutory graph automorphism and a field automorphism, there is a unique maximal subgroup besides <span class="SimpleMath">S</span> that contains <span class="SimpleMath">s</span>.</p>

</dd>
</dl>
<p>A safe source for determining <span class="SimpleMath">𝕄(S,s)</span> is <a href="chapBib.html#biBKle87">[Kle87]</a>. By inspection of the result matrix in this paper, we get that the only maximal subgroups of <span class="SimpleMath">S</span> that contain elements of order <span class="SimpleMath">65</span> occur in the rows 9–14 and 23–25; they have the isomorphism types <span class="SimpleMath">S_6(4) = Sp(6,4) ≅ O_7(4) = Ω(7,4)</span> and <span class="SimpleMath">(5 × O_6^-(4)).2 = (5 × Ω^-(6,4)).2</span>, respectively, and for each of these, there are three conjugacy classes of subgroups in <span class="SimpleMath">S</span>, which are conjugate under the triality graph automorphism of <span class="SimpleMath">S</span>.</p>

<p>We start with the natural matrix representation of <span class="SimpleMath">S</span>. For convenience, we compute an isomorphic permutation group on <span class="SimpleMath">5525</span> points.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q:= 4;;  n:= 8;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= DerivedSubgroup( SO( 1, n, q ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">points:= NormedRowVectors( GF(q)^n );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( G, points, OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 5525, 16320 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom:= ActionHomomorphism( G, orbs[1], OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= Image( hom );;</span>
</pre></div>

<p>The group <span class="SimpleMath">S</span> contains exactly six conjugacy classes of (cyclic) subgroups of order <span class="SimpleMath">65</span>; this follows from the fact that the centralizer of any Sylow <span class="SimpleMath">13</span> subgroup in <span class="SimpleMath">S</span> has the structure <span class="SimpleMath">5 × 5 × 13</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Collected( Factors( Size( G ) ) );</span>
[ [ 2, 24 ], [ 3, 5 ], [ 5, 4 ], [ 7, 1 ], [ 13, 1 ], [ 17, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= Random( G );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( x ) mod 13 = 0;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= x^( Order( x ) / 13 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:= Centralizer( G, x );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAbelian( c );  AbelianInvariants( c );</span>
true
[ 5, 5, 13 ]
</pre></div>

<p>The group <span class="SimpleMath">S_6(4)</span> contains exactly one class of subgroups of order <span class="SimpleMath">65</span>, since the conjugacy classes of elements of order <span class="SimpleMath">65</span> in <span class="SimpleMath">S_6(4)</span> are algebraically conjugate.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "S6(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord65:= PositionsProperty( OrdersClassRepresentatives( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                              x -&gt; x = 65 );</span>
[ 105, 106, 107, 108, 109, 110, 111, 112 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord65 = ClassOrbit( t, ord65[1] );</span>
true
</pre></div>

<p>Thus there are at least three classes of order <span class="SimpleMath">65</span> elements in <span class="SimpleMath">S</span> that are <em>not</em> contained in <span class="SimpleMath">S_6(4)</span> type subgroups of <span class="SimpleMath">S</span>. So we choose such an element <span class="SimpleMath">s</span>, and have to consider only overgroups of the type <span class="SimpleMath">(5 × Ω^-(6,4)).2</span>.</p>

<p>The group <span class="SimpleMath">Ω^-(6,4) ≅ U_4(4)</span> contains exactly one class of subgroups of order <span class="SimpleMath">65</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "U4(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ords:= OrdersClassRepresentatives( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord65:= PositionsProperty( ords, x -&gt; x = 65 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord65 = ClassOrbit( t, ord65[1] );</span>
true
</pre></div>

<p>So <span class="SimpleMath">5 × Ω^-(6,4)</span> contains exactly six such classes. Furthermore, subgroups in different classes are not <span class="SimpleMath">S</span>-conjugate.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">syl5:= SylowSubgroup( c, 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= Filtered( Elements( syl5 ), y -&gt; Order( y ) = 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= Set( elms, SmallestGeneratorPerm );;  Length( reps );</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps65:= List( reps, y -&gt; SubgroupNC( G, [ y * x ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pairs:= Filtered( UnorderedTuples( [ 1 .. 6 ], 2 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     p -&gt; p[1] &lt;&gt; p[2] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAny( pairs, p -&gt; IsConjugate( G, reps65[ p[1] ], reps65[ p[2] ] ) );</span>
false
</pre></div>

<p>We consider only subgroups <span class="SimpleMath">M ≤ S</span> in the three <span class="SimpleMath">S</span>-classes of the type <span class="SimpleMath">(5 × Ω^-(6,4)).2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= List( reps, y -&gt; Normalizer( G, SubgroupNC( G, [ y ] ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= Filtered( cand, y -&gt; Size( y ) = 10 * Size( t ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( cand );</span>
3
</pre></div>

<p>(Note that one of the members in <span class="SimpleMath">𝕄(S,s)</span> is the stabilizer in <span class="SimpleMath">S</span> of the orthogonal decomposition <span class="SimpleMath">2^- perp 6^-</span>, the other two members are not reducible.)</p>

<p>By the above, the classes of subgroups of order <span class="SimpleMath">65</span> in each such <span class="SimpleMath">M</span> are in bijection with the corresponding classes in <span class="SimpleMath">S</span>. Since <span class="SimpleMath">N_S(⟨ g ⟩) ⊆ M</span> holds for any <span class="SimpleMath">g ∈ M</span> of order <span class="SimpleMath">65</span>, also the conjugacy classes of <em>elements</em> of order <span class="SimpleMath">65</span> in <span class="SimpleMath">M</span> are in bijection with those in <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">norms:= List( reps65, y -&gt; Normalizer( G, y ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( norms, y -&gt; ForAll( cand, M -&gt; IsSubset( M, y ) ) );</span>
true
</pre></div>

<p>As a consequence, we have <span class="SimpleMath">g^S ∩ M = g^M</span> and thus <span class="SimpleMath">1_M^S(g) = 1</span>. This implies statement (a).</p>

<p>In order to show statement (b), we want to use the function <code class="code">UpperBoundFixedPointRatios</code> introduced in Section <a href="chap11.html#X83DACCF07EF62FAE"><span class="RefLink">11.3-3</span></a>. For that, we first compute the conjugacy classes of the three class representatives <span class="SimpleMath">M</span>. (Since the groups have elementary abelian Sylow <span class="SimpleMath">5</span> subgroups of the order <span class="SimpleMath">5^4</span>, computing all conjugacy classes appears to be faster than using <code class="code">ClassesOfPrimeOrder</code>.) Then we compute an upper bound for <span class="SimpleMath">σ(S,s)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">syl5:= SylowSubgroup( cand[1], 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( syl5 );  IsElementaryAbelian( syl5 );</span>
625
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperBoundFixedPointRatios( G, List( cand, ConjugacyClasses ), false );</span>
[ 34817/1645056, false ]
</pre></div>

<p><em>Remark:</em></p>

<p>Computing the exact value <span class="SimpleMath">σ(S,s)</span> in the above setup would require to test the <span class="SimpleMath">S</span>-conjugacy of certain order <span class="SimpleMath">5</span> elements in <span class="SimpleMath">M</span>. With the current <strong class="pkg">GAP</strong> implementation, some of the relevant tests need several hours of CPU time.</p>

<p>An alternative approach would be to compute the permutation action of <span class="SimpleMath">S</span> on the cosets of <span class="SimpleMath">M</span>, of degree <span class="SimpleMath">6580224</span>, and to count the fixed points of conjugacy class representatives of prime order. The currently available <strong class="pkg">GAP</strong> library methods are not sufficient for computing this in reasonable time. "Ad-hoc code" for this special case works, but it seemed to be not appropriate to include it here.</p>

<p>In the proof of statement (c), again we consult the result matrix in <a href="chapBib.html#biBKle87">[Kle87]</a>. For <span class="SimpleMath">S.3</span>, the maximal subgroups are in the rows <span class="SimpleMath">4</span>, <span class="SimpleMath">15</span>, <span class="SimpleMath">22</span>, <span class="SimpleMath">26</span>, and <span class="SimpleMath">61</span>. Only row <span class="SimpleMath">26</span> yields subgroups that contain elements <span class="SimpleMath">s</span> of order <span class="SimpleMath">65</span>, they have the isomorphism type <span class="SimpleMath">(5 × GU(3,4)).2 ≅ (5^2 × U_3(4)).2</span>. Note that the conjugacy classes of the members in <span class="SimpleMath">𝕄(S,s)</span> are permuted by the outer automorphism of order <span class="SimpleMath">3</span>, so none of the subgroups in <span class="SimpleMath">𝕄(S,s)</span> extends to <span class="SimpleMath">S.3</span>. By <a href="chapBib.html#biBBGK">[BGK08, Lemma 2.4 (2)]</a>, if there is a maximal subgroup of <span class="SimpleMath">S.3</span> besides <span class="SimpleMath">S</span> that contains <span class="SimpleMath">s</span> then this subgroup is the normalizer in <span class="SimpleMath">S.3</span> of the intersection of the three members of <span class="SimpleMath">𝕄(S,s)</span>, i. e., <span class="SimpleMath">s</span> is contained in at most one such subgroup.</p>

<p>For <span class="SimpleMath">S.2_1</span>, only the rows <span class="SimpleMath">9</span> and <span class="SimpleMath">23</span> yield maximal subgroups containing elements of order <span class="SimpleMath">65</span>, and since we had chosen <span class="SimpleMath">s</span> in such a way that row <span class="SimpleMath">9</span> was excluded already for the simple group, only extensions of the elements in <span class="SimpleMath">𝕄(S,s)</span> can appear. Exactly one of these three subgroups of <span class="SimpleMath">S</span> extends to <span class="SimpleMath">S.2_1</span>, so again we get just one maximal subgroup of <span class="SimpleMath">S.2_1</span>, besides <span class="SimpleMath">S</span>, that contains <span class="SimpleMath">s</span>.</p>

<p>All subgroups in <span class="SimpleMath">𝕄(S,s)</span> extend to <span class="SimpleMath">S.2_2</span>, see <a href="chapBib.html#biBKle87">[Kle87]</a>. We compute the extensions of the above subgroups <span class="SimpleMath">M</span> of <span class="SimpleMath">S</span> to <span class="SimpleMath">S.2_2</span>, by constructing the action of the field automorphism in the permutation representation we used for <span class="SimpleMath">S</span>. In other words, we compute the projective action of the Frobenius map.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">frob:= PermList( List( orbs[1], v -&gt; Position( orbs[1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             List( v, x -&gt; x^2 ) ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G2:= ClosureGroupDefault( G, frob );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand2:= List( cand, M -&gt; Normalizer( G2, M ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= List( cand2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               M2 -&gt; PcConjugacyClassReps( SylowSubgroup( M2, 2 ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ccl, l -&gt; Number( l, x -&gt; Order( x ) = 2 and not x in G ) );</span>
[ 0, 0, 0 ]
</pre></div>

<p>So in each case, the extension of <span class="SimpleMath">M</span> to its normalizer in <span class="SimpleMath">S.2_2</span> is non-split. This implies <span class="SimpleMath">σ^'(S.2_2,s) = 0</span>.</p>

<p>Finally, in the extension of <span class="SimpleMath">S</span> by the product of a graph automorphism and the field automorphism, exactly that member of <span class="SimpleMath">𝕄(S,s)</span> is invariant that is invariant under the graph automorphism, hence statement (c) holds.</p>

<p>It is again time to clean the workspace.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CleanWorkspace();</span>
</pre></div>

<p><a id="X86EC26F78609618E" name="X86EC26F78609618E"></a></p>

<h5>11.5-15 <span class="Heading"><span class="SimpleMath">∗</span> <span class="SimpleMath">O_9(3)</span></span></h5>

<p>The group <span class="SimpleMath">S = O_9(3) = Ω_9(3)</span> is the first member in the series dealt with in <a href="chapBib.html#biBBGK">[BGK08, Proposition 5.7]</a>, and serves as an example to illustrate this statement.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of the type <span class="SimpleMath">1 perp 8^-</span> (i. e., <span class="SimpleMath">s</span> decomposes the natural <span class="SimpleMath">9</span>-dimensional module for <span class="SimpleMath">S</span> into an orthogonal sum of two irreducible modules of the dimensions <span class="SimpleMath">1</span> and <span class="SimpleMath">8</span>, respectively) and of order <span class="SimpleMath">(3^4 + 1)/2 = 41</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">O_8^-(3).2_1 = PGO^-(8,3)</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 1/3</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p>The uniform spread of <span class="SimpleMath">S</span> is at least three, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">41</span>.</p>

</dd>
</dl>
<p>By <a href="chapBib.html#biBMSW94">[MSW94]</a>, the only maximal subgroup of <span class="SimpleMath">S</span> that contains <span class="SimpleMath">s</span> is the stabilizer <span class="SimpleMath">M</span> of the orthogonal decomposition. The group <span class="SimpleMath">2 × O_8^-(3).2_1 = GO^-(8,3)</span> embeds naturally into <span class="SimpleMath">SO(9,3)</span>, its intersection with <span class="SimpleMath">S</span> is <span class="SimpleMath">PGO^-(8,3)</span>. This proves statement (a).</p>

<p>The group <span class="SimpleMath">M</span> is the stabilizer of a <span class="SimpleMath">1</span>-space, it has index <span class="SimpleMath">3240</span> in <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SO( 9, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= DerivedSubgroup( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( g );</span>
65784756654489600
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( g, NormedRowVectors( GF(3)^9 ), OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length ) / 41;</span>
[ 3240/41, 81, 80 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( SO( 9, 3 ) ) / Size( GO( -1, 8, 3 ) );</span>
3240
</pre></div>

<p>So we compute the unique transitive permutation character of <span class="SimpleMath">S</span> that has degree <span class="SimpleMath">3240</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "O9(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PermChars( t, rec( torso:= [ 3240 ] ) );</span>
[ Character( CharacterTable( "O9(3)" ),
  [ 3240, 1080, 380, 132, 48, 324, 378, 351, 0, 0, 54, 27, 54, 27, 0, 
      118, 0, 36, 46, 18, 12, 2, 8, 45, 0, 108, 108, 135, 126, 0, 0, 
      56, 0, 0, 36, 47, 38, 27, 39, 36, 24, 12, 18, 18, 15, 24, 2, 
      18, 15, 9, 0, 0, 0, 2, 0, 18, 11, 3, 9, 6, 6, 9, 6, 3, 6, 3, 0, 
      6, 16, 0, 4, 6, 2, 45, 36, 0, 0, 0, 0, 0, 0, 0, 9, 9, 6, 3, 0, 
      0, 15, 13, 0, 5, 7, 36, 0, 10, 0, 10, 19, 6, 15, 0, 0, 0, 0, 
      12, 3, 10, 0, 3, 3, 7, 0, 6, 6, 2, 8, 0, 4, 0, 2, 0, 1, 3, 0, 
      0, 3, 0, 3, 2, 2, 3, 3, 6, 2, 2, 9, 6, 3, 0, 0, 18, 9, 0, 0, 
      12, 0, 0, 8, 0, 6, 9, 5, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 2, 1, 
      3, 3, 1, 0, 0, 4, 1, 0, 0, 1, 0, 3, 3, 1, 1, 2, 2, 0, 0, 1, 3, 
      4, 0, 1, 2, 0, 0, 1, 0, 4, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 
      1, 1, 1, 1, 0, 0, 1, 1, 1, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 41 );</span>
208
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( pi, spos );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( approx );</span>
1/3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositionsProperty( approx, x -&gt; x = 1/3 );</span>
[ 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesConjugacyClasses( t )[2];</span>
3321
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( t )[2];</span>
2
</pre></div>

<p>We see that <span class="SimpleMath">P( S, s ) = σ( S, s ) = 1/3</span> holds, and that <span class="SimpleMath">σ( g, s )</span> attains this maximum only for <span class="SimpleMath">g</span> in one class of involutions in <span class="SimpleMath">S</span>; let us call this class <code class="code">2A</code>. (This class consists of the negatives of a class of <em>reflections</em> in <span class="SimpleMath">GO(9,3)</span>.) This shows statement (b).</p>

<p>In order to show that the uniform spread of <span class="SimpleMath">S</span> is at least three, it suffices to show that for each triple of <code class="code">2A</code> elements, there is an element <span class="SimpleMath">s</span> of order <span class="SimpleMath">41</span> in <span class="SimpleMath">S</span> that generates <span class="SimpleMath">S</span> with each element of the triple.</p>

<p>We work with the primitive permutation representation of <span class="SimpleMath">S</span> on <span class="SimpleMath">3240</span> points. In this representation, <span class="SimpleMath">s</span> fixes exactly one point, and by statement (a), <span class="SimpleMath">s</span> generates <span class="SimpleMath">S</span> with <span class="SimpleMath">x ∈ S</span> if and only if <span class="SimpleMath">x</span> moves this point. Since the number of fixed points of each <code class="code">2A</code> involution in <span class="SimpleMath">S</span> is exactly one third of the moved points of <span class="SimpleMath">S</span>, it suffices to show that we cannot choose three such involutions with mutually disjoint fixed point sets. And this is shown particularly easily because it will turn out that already for any two different <code class="code">2A</code> involutions, the sets of fixed points of are never disjoint.</p>

<p>First we compute a <code class="code">2A</code> element, which is determined as an involution with exactly <span class="SimpleMath">1080</span> fixed points.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Action( g, orbs[1], OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     repeat x:= Random( g ); ord:= Order( x ); until ord mod 2 = 0;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     y:= x^(ord/2);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">until NrMovedPoints( y ) = 3240 - 1080;</span>
</pre></div>

<p>Next we compute the sets of fixed points of the elements in the class <code class="code">2A</code>, by forming the <span class="SimpleMath">S</span>-orbit of the set of fixed points of the chosen <code class="code">2A</code> element.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fp:= Difference( MovedPoints( g ), MovedPoints( y ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= Orbit( g, fp, OnSets );;</span>
</pre></div>

<p>Finally, we show that for any pair of <code class="code">2A</code> elements, their sets of fixed points intersect nontrivially. (Of course we can fix one of the two elements.) This proves statement (c).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAny( orb, l -&gt; IsEmpty( Intersection( l, fp ) ) );</span>
false
</pre></div>

<p><a id="X8393978A8773997E" name="X8393978A8773997E"></a></p>

<h5>11.5-16 <span class="Heading"><span class="SimpleMath">O_10^-(3)</span></span></h5>

<p>We show that the group <span class="SimpleMath">S = O_10^-(3) = PΩ^-(10,3)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> irreducible of order <span class="SimpleMath">(3^5 + 1)/4 = 61</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one subgroup of the type <span class="SimpleMath">SU(5,3) ≅ U_5(3)</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 1/1066</span>.</p>

</dd>
</dl>
<p>By <a href="chapBib.html#biBBe00">[Ber00]</a>, the maximal subgroups of <span class="SimpleMath">S</span> containing <span class="SimpleMath">s</span> are of extension field type, and by <a href="chapBib.html#biBKlL90">[KL90, Prop. 4.3.18 and 4.3.20]</a>, these groups have the structure <span class="SimpleMath">SU(5,3) = U_5(3)</span> (which lift to <span class="SimpleMath">2 × U_5(3) &lt; GU(5,3)</span> in <span class="SimpleMath">Ω^-(10,3) = 2.S</span>) or <span class="SimpleMath">Ω(5,9).2</span>, but the order of the latter group is not divisible by <span class="SimpleMath">|s|</span>. Furthermore, by <a href="chapBib.html#biBBGK">[BGK08, Lemma 2.12 (b)]</a>, <span class="SimpleMath">s</span> is contained in only one member of the former class.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( GO(5,9) ) / 61;</span>
6886425600/61
</pre></div>

<p><em>When the first version of these computations was written, the character tables of both <span class="SimpleMath">S</span> and <span class="SimpleMath">U_5(3)</span> were not contained in the <strong class="pkg">GAP</strong> Character Table Library, so we worked with the groups. Meanwhile the character tables are available, thus we can show also a character theoretic solution.)</em></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "O10-(3)" );  s:= CharacterTable( "U5(3)" );</span>
CharacterTable( "O10-(3)" )
CharacterTable( "U5(3)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SigmaFromMaxes( t, "61A", [ s ], [ 1 ] );</span>
1/1066
</pre></div>

<p><em>(Now follow the computations with groups.)</em></p>

<p>The first step is the construction of the embedding of <span class="SimpleMath">M = SU(5,3)</span> into the matrix group <span class="SimpleMath">2.S</span>, that is, we write the matrix generators of <span class="SimpleMath">M</span> as linear mappings on the natural module for <span class="SimpleMath">2.S</span>, and then conjugate them such that the result matrices respect the bilinear form of <span class="SimpleMath">2.S</span>. For convenience, we choose a basis for the field extension <span class="SimpleMath">𝔽_9/𝔽_3</span> such that the <span class="SimpleMath">𝔽_3</span>-linear mapping given by the invariant form of <span class="SimpleMath">M</span> is invariant under the <span class="SimpleMath">𝔽_3</span>-linear mappings given by the generators of <span class="SimpleMath">M</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:= SU(5,3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">so:= SO(-1,10,3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">omega:= DerivedSubgroup( so );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">om:= InvariantBilinearForm( so ).matrix;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( om );</span>
 . 1 . . . . . . . .
 1 . . . . . . . . .
 . . 1 . . . . . . .
 . . . 2 . . . . . .
 . . . . 2 . . . . .
 . . . . . 2 . . . .
 . . . . . . 2 . . .
 . . . . . . . 2 . .
 . . . . . . . . 2 .
 . . . . . . . . . 2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= Basis( GF(9), [ Z(3)^0, Z(3^2)^2 ] );</span>
Basis( GF(3^2), [ Z(3)^0, Z(3^2)^2 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">blow:= List( GeneratorsOfGroup( m ), x -&gt; BlownUpMat( b, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form:= BlownUpMat( b, InvariantSesquilinearForm( m ).matrix );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( blow, x -&gt; x * form * TransposedMat( x ) = form );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( form );</span>
 . . . . . . . . 1 .
 . . . . . . . . . 1
 . . . . . . 1 . . .
 . . . . . . . 1 . .
 . . . . 1 . . . . .
 . . . . . 1 . . . .
 . . 1 . . . . . . .
 . . . 1 . . . . . .
 1 . . . . . . . . .
 . 1 . . . . . . . .
</pre></div>

<p>The matrix <code class="code">om</code> of the invariant bilinear form of <span class="SimpleMath">2.S</span> is equivalent to the identity matrix <span class="SimpleMath">I</span>. So we compute matrices <code class="code">T1</code> and <code class="code">T2</code> that transform <code class="code">om</code> and <code class="code">form</code>, respectively, to <span class="SimpleMath">± I</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T1:= IdentityMat( 10, GF(3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T1{[1..3]}{[1..3]}:= [[1,1,0],[1,-1,1],[1,-1,-1]]*Z(3)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PermutationMat( (1,10)(3,8), 10, GF(3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr:= NullMat( 10,10,GF(3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr{[1, 2]}{[1, 2]}:= [[1,1],[1,-1]]*Z(3)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr{[3, 4]}{[3, 4]}:= [[1,1],[1,-1]]*Z(3)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr{[7, 8]}{[7, 8]}:= [[1,1],[1,-1]]*Z(3)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr{[9,10]}{[9,10]}:= [[1,1],[1,-1]]*Z(3)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr{[5, 6]}{[5, 6]}:= [[1,0],[0,1]]*Z(3)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr2:= IdentityMat( 10,GF(3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr2{[1,3]}{[1,3]}:= [[-1,1],[1,1]]*Z(3)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr2{[7,9]}{[7,9]}:= [[-1,1],[1,1]]*Z(3)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T2:= tr2 * tr * pi;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D:= T1^-1 * T2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblow:= List( blow, x -&gt; D * x * D^-1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubset( omega, tblow );</span>
true
</pre></div>

<p>Now we switch to a permutation representation of <span class="SimpleMath">S</span>, and use the embedding of <span class="SimpleMath">M</span> into <span class="SimpleMath">2.S</span> to obtain the corresponding subgroup of type <span class="SimpleMath">M</span> in <span class="SimpleMath">S</span>. Then we compute an upper bound for <span class="SimpleMath">max{ μ(g,S/M); g ∈ S^× }</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( omega, NormedRowVectors( GF(3)^10 ), OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 9882, 9882, 9760 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">permgrp:= Action( omega, orbs[3], OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M:= SubgroupNC( permgrp,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           List( tblow, x -&gt; Permutation( x, orbs[3], OnLines ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= ClassesOfPrimeOrder( M, PrimeDivisors( Size( M ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                              TrivialSubgroup( M ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperBoundFixedPointRatios( permgrp, [ ccl ], false );</span>
[ 1/1066, true ]
</pre></div>

<p>The entry <code class="keyw">true</code> in the second position of the result indicates that in fact the <em>exact</em> value for the maximum of <span class="SimpleMath">μ(g,S/M)</span> has been computed. This implies statement (b).</p>

<p>We clean the workspace.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CleanWorkspace();</span>
</pre></div>

<p><a id="X7BBBEEEF834F1002" name="X7BBBEEEF834F1002"></a></p>

<h5>11.5-17 <span class="Heading"><span class="SimpleMath">O_14^-(2)</span></span></h5>

<p>We show that the group <span class="SimpleMath">S = O_14^-(2) = Ω^-(14,2)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> irreducible of order <span class="SimpleMath">2^7+1 = 129</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one subgroup <span class="SimpleMath">M</span> of the type <span class="SimpleMath">GU(7,2) ≅ 3 × U_7(2)</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 1/2015</span>.</p>

</dd>
</dl>
<p>By <a href="chapBib.html#biBBe00">[Ber00]</a>, any maximal subgroup of <span class="SimpleMath">S</span> containing <span class="SimpleMath">s</span> is of extension field type, and by <a href="chapBib.html#biBKlL90">[KL90, Table 3.5.F, Prop. 4.3.18]</a>, these groups have the type <span class="SimpleMath">GU(7,2)</span>, and there is exactly one class of subgroups of this type. Furthermore, by <a href="chapBib.html#biBBGK">[BGK08, Lemma 2.12 (a)]</a>, <span class="SimpleMath">s</span> is contained in only one member of this class.</p>

<p>We embed <span class="SimpleMath">U_7(2)</span> into <span class="SimpleMath">S</span>, by first replacing each element in <span class="SimpleMath">𝔽_4</span> by the <span class="SimpleMath">2 × 2</span> matrix of the induced <span class="SimpleMath">𝔽_2</span>-linear mapping w.r.t. a suitable basis, and then conjugating the images of the generators such that the invariant quadratic form of <span class="SimpleMath">S</span> is respected.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">o:= SO(-1,14,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SU(7,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= Basis( GF(4) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">blow:= List( GeneratorsOfGroup( g ), x -&gt; BlownUpMat( b, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">form:= NullMat( 14, 14, GF(2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for i in [ 1 .. 14 ] do form[i][ 15-i ]:= Z(2); od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( blow, x -&gt; x * form * TransposedMat( x ) = form );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PermutationMat( (1,13)(3,11)(5,9), 14, GF(2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi * form * TransposedMat( pi ) = InvariantBilinearForm( o ).matrix;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2:= PermutationMat( (7,3)(8,4), 14, GF(2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D:= pi2 * pi;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblow:= List( blow, x -&gt; D * x * D^-1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubset( o, tblow );</span>
true
</pre></div>

<p>Note that the central subgroup of order three in <span class="SimpleMath">GU(7,2)</span> consists of scalar matrices.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">omega:= DerivedSubgroup( o );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubset( omega, tblow );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z:= Z(4) * One( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tz:= D * BlownUpMat( b, z ) * D^-1;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tz in omega;</span>
true
</pre></div>

<p>Now we switch to a permutation representation of <span class="SimpleMath">S</span>, and compute the conjugacy classes of prime element order in the subgroup <span class="SimpleMath">M</span>. The latter is done in two steps, first class representatives of the simple subgroup <span class="SimpleMath">U_7(2)</span> of <span class="SimpleMath">M</span> are computed, and then they are multiplied with the scalars in <span class="SimpleMath">M</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( omega, NormedRowVectors( GF(2)^14 ), OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 8127, 8256 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">omega:= Action( omega, orbs[1], OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= List( GeneratorsOfGroup( g ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            x -&gt; Permutation( D * BlownUpMat( b, x ) * D^-1, orbs[1] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Group( gens );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= ClassesOfPrimeOrder( g, PrimeDivisors( Size( g ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                              TrivialSubgroup( g ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tz:= Permutation( tz, orbs[1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">primereps:= List( ccl, Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Add( primereps, () );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= Concatenation( List( primereps,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              x -&gt; List( [ 0 .. 2 ], i -&gt; x * tz^i ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">primereps:= Filtered( reps, x -&gt; IsPrimeInt( Order( x ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( primereps );</span>
48
</pre></div>

<p>Finally, we apply <code class="code">UpperBoundFixedPointRatios</code> (see Section <a href="chap11.html#X83DACCF07EF62FAE"><span class="RefLink">11.3-3</span></a>) to compute an upper bound for <span class="SimpleMath">μ(g,S/M)</span>, for <span class="SimpleMath">g ∈ S^×</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M:= ClosureGroup( g, tz );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bccl:= List( primereps, x -&gt; ConjugacyClass( M, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperBoundFixedPointRatios( omega, [ bccl ], false );</span>
[ 1/2015, true ]
</pre></div>

<p>Although some of the classes of <span class="SimpleMath">M</span> in the list <code class="code">bccl</code> may be <span class="SimpleMath">S</span>-conjugate, the entry <code class="keyw">true</code> in the second position of the result indicates that in fact the <em>exact</em> value for the maximum of <span class="SimpleMath">μ(g,S/M)</span>, for <span class="SimpleMath">g ∈ S^×</span>, has been computed. This implies statement (b).</p>

<p>We clean the workspace.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CleanWorkspace();</span>
</pre></div>

<p><a id="X8477457780B69BC7" name="X8477457780B69BC7"></a></p>

<h5>11.5-18 <span class="Heading"><span class="SimpleMath">O_12^+(3)</span></span></h5>

<p>We show that the group <span class="SimpleMath">S = O_12^+(3) = PΩ^+(12,3)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">S</span> has a maximal subgroup <span class="SimpleMath">M</span> of the type <span class="SimpleMath">N_S(PΩ^+(6,9))</span>, which has the structure <span class="SimpleMath">PΩ^+(6,9).[4]</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">μ(g,S/M) ≤ 2/88209</span> holds for all <span class="SimpleMath">g ∈ S^×</span>.</p>

</dd>
</dl>
<p>(This result is used in the proof of <a href="chapBib.html#biBBGK">[BGK08, Proposition 5.14]</a>, where it is shown that for <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">205</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one reducible subgroup <span class="SimpleMath">G_8</span> and at most two extension field type subgroups of the type <span class="SimpleMath">N_S(PΩ^+(6,9))</span>. By <a href="chapBib.html#biBGK">[GK00, Proposition 3.16]</a>, <span class="SimpleMath">μ(g,S/G_8) ≤ 19/3^5</span> holds for all <span class="SimpleMath">g ∈ S^×</span>. This implies <span class="SimpleMath">P(g,s) ≤ 19/3^5 + 2 ⋅ 2/88209 = 6901/88209 &lt; 1/3</span>.)</p>

<p>Statement (a) follows from <a href="chapBib.html#biBKlL90">[KL90, Prop. 4.3.14]</a>.</p>

<p>For statement (b), we embed <span class="SimpleMath">GO^+(6,9) ≅ Ω^+(6,9).2^2</span> into <span class="SimpleMath">SO^+(12,3) = 2.S.2</span>, by replacing each element in <span class="SimpleMath">𝔽_9</span> by the <span class="SimpleMath">2 × 2</span> matrix of the induced <span class="SimpleMath">𝔽_3</span>-linear mapping w.r.t. a suitable basis <span class="SimpleMath">(b_1, b_2)</span>. We choose a basis with the property <span class="SimpleMath">b_1 = 1</span> and <span class="SimpleMath">b_2^2 = 1 + b_2</span>, because then the image of a symmetric matrix is again symmetric (so the image of the invariant form is an invariant form for the image of the group), and apply an appropriate transformation to the images of the generators.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">so:= SO(+1,12,3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( InvariantBilinearForm( so ).matrix );</span>
 . 1 . . . . . . . . . .
 1 . . . . . . . . . . .
 . . 1 . . . . . . . . .
 . . . 2 . . . . . . . .
 . . . . 2 . . . . . . .
 . . . . . 2 . . . . . .
 . . . . . . 2 . . . . .
 . . . . . . . 2 . . . .
 . . . . . . . . 2 . . .
 . . . . . . . . . 2 . .
 . . . . . . . . . . 2 .
 . . . . . . . . . . . 2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GO(+1,6,9);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Z(9)^2 = Z(3)^0 + Z(9);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= Basis( GF(9), [ Z(3)^0, Z(9) ] );</span>
Basis( GF(3^2), [ Z(3)^0, Z(3^2) ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">blow:= List( GeneratorsOfGroup( g ), x -&gt; BlownUpMat( b, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:= BlownUpMat( b, InvariantBilinearForm( g ).matrix );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( m );</span>
 . . 1 . . . . . . . . .
 . . . 1 . . . . . . . .
 1 . . . . . . . . . . .
 . 1 . . . . . . . . . .
 . . . . 2 . . . . . . .
 . . . . . 2 . . . . . .
 . . . . . . 2 . . . . .
 . . . . . . . 2 . . . .
 . . . . . . . . 2 . . .
 . . . . . . . . . 2 . .
 . . . . . . . . . . 2 .
 . . . . . . . . . . . 2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PermutationMat( (2,3), 12, GF(3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr:= IdentityMat( 12, GF(3) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr{[3,4]}{[3,4]}:= [[1,-1],[1,1]]*Z(3)^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D:= tr * pi;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D * m * TransposedMat( D ) = InvariantBilinearForm( so ).matrix;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblow:= List( blow, x -&gt; D * x * D^-1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubset( so, tblow );</span>
true
</pre></div>

<p>The image of <span class="SimpleMath">GO^+(6,9)</span> under the embedding into <span class="SimpleMath">SO^+(12,3)</span> does not lie in <span class="SimpleMath">Ω^+(12,3) = 2.S</span>, so a factor of two is missing in <span class="SimpleMath">GO^+(6,9) ∩ 2.S</span> for getting (the preimage <span class="SimpleMath">2.M</span> of) the required maximal subgroup <span class="SimpleMath">M</span> of <span class="SimpleMath">S</span>. Because of this, and also because currently it is time consuming to compute the derived subgroup of <span class="SimpleMath">SO^+(12,3)</span>, we work with the upward extension <span class="SimpleMath">PSO^+(12,3) = S.2</span>. Note that <span class="SimpleMath">M</span> extends to a maximal subgroup of <span class="SimpleMath">S.2</span>.</p>

<p>First we factor out the centre of <span class="SimpleMath">SO^+(12,3)</span>, and switch to a permutation representation of <span class="SimpleMath">S.2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( so, NormedRowVectors( GF(3)^12 ), OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 88452, 88452, 88816 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">act:= Action( so, orbs[1], OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetSize( act, Size( so ) / 2 );</span>
</pre></div>

<p>Next we rewrite the matrix generators for <span class="SimpleMath">GO^+(6,9)</span> accordingly, and compute the normalizer in <span class="SimpleMath">S.2</span> of the subgroup they generate; this is the maximal subgroup <span class="SimpleMath">M.2</span> we need.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= SubgroupNC( act,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           List( tblow, x -&gt; Permutation( x, orbs[1], OnLines ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n:= Normalizer( act, u );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( n ) / Size( u );</span>
2
</pre></div>

<p>Now we compute class representatives of prime order in <span class="SimpleMath">M.2</span>, in a smaller faithful permutation representation, and then the desired upper bound for <span class="SimpleMath">μ(g, S/M)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">norbs:= OrbitsDomain( n, MovedPoints( n ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( norbs, Length );</span>
[ 58968, 29484 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom:= ActionHomomorphism( n, norbs[2] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nact:= Image( hom );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( nact ) = Size( n );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= ClassesOfPrimeOrder( nact, PrimeDivisors( Size( nact ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                              TrivialSubgroup( nact ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( ccl );</span>
26
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">preim:= List( ccl,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       x -&gt; PreImagesRepresentative( hom, Representative( x ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pccl:= List( preim, x -&gt; ConjugacyClass( n, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for i in [ 1 .. Length( pccl ) ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     SetSize( pccl[i], Size( ccl[i] ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UpperBoundFixedPointRatios( act, [ pccl ], false );</span>
[ 2/88209, true ]
</pre></div>

<p>Note that we have computed <span class="SimpleMath">max{ μ(g,S.2/M.2), g ∈ S.2^× } ≥ max{ μ(g,S.2/M.2), g ∈ S^× } = max{ μ(g,S/M), g ∈ S^× }</span>.</p>

<p><a id="X854D85F287767342" name="X854D85F287767342"></a></p>

<h5>11.5-19 <span class="Heading"><span class="SimpleMath">∗</span> <span class="SimpleMath">S_4(8)</span></span></h5>

<p>We show that the group <span class="SimpleMath">S = S_4(8) = Sp(4,8)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> irreducible of order <span class="SimpleMath">65</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of two nonconjugate subgroups of the type <span class="SimpleMath">S_2(64).2 = Sp(2,64).2 ≅ L_2(64).2 ≅ O_4^-(8).2 = Ω^-(4,8).2</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 8/63</span>.</p>

</dd>
</dl>
<p>By <a href="chapBib.html#biBBe00">[Ber00]</a>, the only maximal subgroups of <span class="SimpleMath">S</span> that contain <span class="SimpleMath">s</span> are <span class="SimpleMath">O_4^-(8).2 = SO^-(4,8)</span> or of extension field type. By <a href="chapBib.html#biBKlL90">[KL90, Prop. 4.3.10, 4.8.6]</a>, there is one class of each of these subgroups (which happen to be isomorphic).</p>

<p>These classes of subgroups induce different permutation characters. One argument to see this is that the involutions in the outer half of extension field type subgroup <span class="SimpleMath">S_2(64).2 &lt; S_4(8)</span> have a two-dimensional fixed space, whereas the outer involutions in <span class="SimpleMath">SO^-(4,8)</span> have a three-dimensional fixed space.</p>

<p>The former statement can be seen by using a normal basis of the field extension <span class="SimpleMath">𝔽_64/𝔽_8</span>, such that the action of the Frobenius automorphism (which yields a suitable outer involution) is just a double transposition on the basis vectors of the natural module for <span class="SimpleMath">S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sp:= SP(4,8);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( InvariantBilinearForm( sp ).matrix );</span>
 . . . 1
 . . 1 .
 . 1 . .
 1 . . .
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z:= Z(64);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:= AsField( GF(8), GF(64) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     b:= Basis( f, [ z, z^8 ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     z:= z * Z(64);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">until b &lt;&gt; fail;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sub:= SP(2,64);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( InvariantBilinearForm( sub ).matrix );</span>
 . 1
 1 .
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ext:= Group( List( GeneratorsOfGroup( sub ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                      x -&gt; BlownUpMat( b, x ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr:= PermutationMat( (3,4), 4, GF(2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">conj:= ConjugateGroup( ext, tr );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubset( sp, conj );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv:= [[0,1,0,0],[1,0,0,0],[0,0,0,1],[0,0,1,0]] * Z(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv in sp;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv in conj;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( NullspaceMat( inv - inv^0 ) );</span>
2
</pre></div>

<p>The latter statement can be shown by looking at an outer involution in <span class="SimpleMath">SO^-(4,8)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">so:= SO(-1,4,8);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">der:= DerivedSubgroup( so );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= First( GeneratorsOfGroup( so ), x -&gt; not x in der );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= x^( Order(x)/2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( NullspaceMat( x - x^0 ) );</span>
3
</pre></div>

<p>The character table of <span class="SimpleMath">L_2(64).2</span> is currently not available in the <strong class="pkg">GAP</strong> Character Table Library, so we compute the possible permutation characters with a combinatorial approach, and show statement (a).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterTable( "L2(64).2" );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "S4(8)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">degree:= Size( t ) / ( 2 * Size( SL(2,64) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PermChars( t, rec( torso:= [ degree ] ) );</span>
[ Character( CharacterTable( "S4(8)" ),
  [ 2016, 0, 256, 32, 0, 36, 0, 8, 1, 0, 4, 0, 0, 0, 28, 28, 28, 0, 
      0, 0, 0, 0, 0, 36, 36, 36, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 
      4, 4, 4, 0, 0, 0, 4, 4, 4, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
      1, 1, 1 ] ), Character( CharacterTable( "S4(8)" ),
  [ 2016, 256, 0, 32, 36, 0, 0, 8, 1, 4, 0, 28, 28, 28, 0, 0, 0, 0, 
      0, 0, 36, 36, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 4, 4, 4, 
      0, 0, 0, 4, 4, 4, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 
      1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
      1, 1, 1 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 65 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( pi, x -&gt; x[ spos ] );</span>
[ 1, 1 ]
</pre></div>

<p>Now we compute <span class="SimpleMath">σ(S,s)</span>, which yields statement (b).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( ApproxP( pi, spos ) );</span>
8/63
</pre></div>

<p>We clean the workspace.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CleanWorkspace();</span>
</pre></div>

<p><a id="X82CFBAF07D3487A0" name="X82CFBAF07D3487A0"></a></p>

<h5>11.5-20 <span class="Heading"><span class="SimpleMath">S_6(2)</span></span></h5>

<p>We show that the group <span class="SimpleMath">S = S_6(2) = Sp(6,2)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">σ(S) = 4/7</span>, and this value is attained exactly for <span class="SimpleMath">σ(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">9</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">9</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one subgroup of the type <span class="SimpleMath">U_4(2).2 = Ω^-(6,2).2</span> and three conjugate subgroups of the type <span class="SimpleMath">L_2(8).3 = Sp(2,8).3</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">9</span>, and <span class="SimpleMath">g ∈ S^×</span>, we have <span class="SimpleMath">P(g,s) &lt; 1/3</span>, except if <span class="SimpleMath">g</span> is in one of the classes <code class="code">2A</code> (the transvection class) or <code class="code">3A</code>.</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">15</span>, and <span class="SimpleMath">g ∈ S^×</span>, we have <span class="SimpleMath">P(g,s) &lt; 1/3</span>, except if <span class="SimpleMath">g</span> is in one of the classes <code class="code">2A</code> or <code class="code">2B</code>.</p>

</dd>
<dt><strong class="Mark">(e)</strong></dt>
<dd><p><span class="SimpleMath">P(S) = 11/21</span>, and this value is attained exactly for <span class="SimpleMath">P(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">15</span>.</p>

</dd>
<dt><strong class="Mark">(f)</strong></dt>
<dd><p>For all <span class="SimpleMath">s^' ∈ S</span>, we have <span class="SimpleMath">P(g,s^') &gt; 1/3</span> for <span class="SimpleMath">g</span> in at least two classes.</p>

</dd>
<dt><strong class="Mark">(g)</strong></dt>
<dd><p>The uniform spread of <span class="SimpleMath">S</span> is at least two, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">9</span>.</p>

</dd>
</dl>
<p>(Note that in this example, the optimal choice of <span class="SimpleMath">s</span> w.r.t. <span class="SimpleMath">σ(S,s)</span> is not optimal w.r.t. <span class="SimpleMath">P(S,s)</span>.)</p>

<p>Statement (a) follows from the inspection of the primitive permutation characters, cf. Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "S6(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoSimple( t );</span>
[ "S6(2)", 4/7, 1, [ "9A" ], [ 4 ] ]
</pre></div>

<p>Also statement (b) follows from the information provided by the character table of <span class="SimpleMath">S</span> (cf. <a href="chapBib.html#biBCCN85">[CCN+85, p. 46]</a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= PrimitivePermutationCharacters( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord:= OrdersClassRepresentatives( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( ord, 9 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">filt:= PositionsProperty( prim, x -&gt; x[ spos ] &lt;&gt; 0 );</span>
[ 1, 8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maxes( t ){ filt };</span>
[ "U4(2).2", "L2(8).3" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( prim{ filt }, x -&gt; x[ spos ] );</span>
[ 1, 3 ]
</pre></div>

<p>Now we consider statement (c). For <span class="SimpleMath">s</span> of order <span class="SimpleMath">9</span> and <span class="SimpleMath">g</span> in one of the classes <code class="code">2A</code>, <code class="code">3A</code>, we observe that <span class="SimpleMath">P(g,s) = σ(g,s)</span> holds. This is because exactly one maximal subgroup of <span class="SimpleMath">S</span> contains both <span class="SimpleMath">s</span> and <span class="SimpleMath">g</span>. For all other elements <span class="SimpleMath">g</span>, we have even <span class="SimpleMath">σ(g,s) &lt; 1/3</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= PrimitivePermutationCharacters( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos9:= Position( ord, 9 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx9:= ApproxP( prim, spos9 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">filt9:= PositionsProperty( approx9, x -&gt; x &gt;= 1/3 );</span>
[ 2, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasClassNames( t ){ filt9 };</span>
[ "2A", "3A" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx9{ filt9 };</span>
[ 4/7, 5/14 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Filtered( prim, x -&gt; x[ spos9 ] &lt;&gt; 0 ), x -&gt; x{ filt9 } );</span>
[ [ 16, 10 ], [ 0, 0 ] ]
</pre></div>

<p>Similarly, statement (d) follows. For <span class="SimpleMath">s</span> of order <span class="SimpleMath">15</span> and <span class="SimpleMath">g</span> in one of the classes <code class="code">2A</code>, <code class="code">2B</code>, already the degree <span class="SimpleMath">36</span> permutation character yields <span class="SimpleMath">P(g,s) ≥ 1/3</span>. And for all other elements <span class="SimpleMath">g</span>, again we have <span class="SimpleMath">σ(g,s) &lt; 1/3</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos15:= Position( ord, 15 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx15:= ApproxP( prim, spos15 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">filt15:= PositionsProperty( approx15, x -&gt; x &gt;= 1/3 );</span>
[ 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositionsProperty( ApproxP( prim{ [ 2 ] }, spos15 ), x -&gt; x &gt;= 1/3 );</span>
[ 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasClassNames( t ){ filt15 };</span>
[ "2A", "2B" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx15{ filt15 };</span>
[ 46/63, 8/21 ]
</pre></div>

<p>For the remaining statements, we use explicit computations with <span class="SimpleMath">S</span>, in the transitive degree <span class="SimpleMath">63</span> permutation representation. We start with a function that computes a transvection in <span class="SimpleMath">S_d(2)</span>; note that the invariant bilinear form used for symplectic groups in <strong class="pkg">GAP</strong> is described by a matrix with nonzero entries exactly in the positions <span class="SimpleMath">(i,d+1-i)</span>, for <span class="SimpleMath">1 ≤ i ≤ d</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">transvection:= function( d )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    local mat;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    mat:= IdentityMat( d, Z(2) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    mat{ [ 1, d ] }{ [ 1, d ] }:= [ [ 0, 1 ], [ 1, 0 ] ] * Z(2);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return mat;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p>First we compute, for statement (d), the exact values <span class="SimpleMath">P(g,s)</span> for <span class="SimpleMath">g</span> in one of the classes <code class="code">2A</code> or <code class="code">2B</code>, and <span class="SimpleMath">s</span> of order <span class="SimpleMath">15</span>. Note that the classes <code class="code">2A</code>, <code class="code">2B</code> are the unique classes of the lengths <span class="SimpleMath">63</span> and <span class="SimpleMath">315</span>, respectively.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositionsProperty( SizesConjugacyClasses( t ), x -&gt; x in [ 63, 315 ] );</span>
[ 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:= 6;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">matgrp:= Sp(d,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom:= ActionHomomorphism( matgrp, NormedRowVectors( GF(2)^d ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Image( hom, matgrp );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s15:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s15 ) = 15;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2A:= Image( hom, transvection( d ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( ConjugacyClass( g, 2A ) );</span>
63
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTransitive( g, MovedPoints( g ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RatioOfNongenerationTransPermGroup( g, 2A, s15 );</span>
11/21
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat 12C:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( 12C ) = 12 and Size( Centralizer( g, 12C ) ) = 12;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2B:= 12C^6;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( ConjugacyClass( g, 2B ) );</span>
315
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RatioOfNongenerationTransPermGroup( g, 2B, s15 );</span>
8/21
</pre></div>

<p>For statement (e), we compute <span class="SimpleMath">P(g, s^')</span>, for a transvection <span class="SimpleMath">g</span> and class representatives <span class="SimpleMath">s^'</span> of <span class="SimpleMath">S</span>. It turns out that the minimum is <span class="SimpleMath">11/21</span>, and it is attained for exactly one <span class="SimpleMath">s^'</span>; by the above, this element has order <span class="SimpleMath">15</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= ConjugacyClasses( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= List( ccl, Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nongen2A:= List( reps,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       x -&gt; RatioOfNongenerationTransPermGroup( g, 2A, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">min:= Minimum( nongen2A );</span>
11/21
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Number( nongen2A, x -&gt; x = min );</span>
1
</pre></div>

<p>For statement (f), we show that for any choice of <span class="SimpleMath">s^'</span>, at least two of the values <span class="SimpleMath">P(g,s^')</span>, with <span class="SimpleMath">g</span> in the classes <code class="code">2A</code>, <code class="code">2B</code>, or <code class="code">3A</code>, are larger than <span class="SimpleMath">1/3</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nongen2B:= List( reps,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       x -&gt; RatioOfNongenerationTransPermGroup( g, 2B, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3A:= s15^5;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nongen3A:= List( reps,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       x -&gt; RatioOfNongenerationTransPermGroup( g, 3A, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bad:= List( [ 1 .. NrConjugacyClasses( t ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               i -&gt; Number( [ nongen2A, nongen2B, nongen3A ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                            x -&gt; x[i] &gt; 1/3 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Minimum( bad );</span>
2
</pre></div>

<p>Finally, for statement (g), we have to consider only the case that the two elements <span class="SimpleMath">x</span>, <span class="SimpleMath">y</span> are transvections.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositionsProperty( approx9, x -&gt; x + approx9[2] &gt;= 1 );</span>
[ 2 ]
</pre></div>

<p>We use the random approach described in Section <a href="chap11.html#X83DACCF07EF62FAE"><span class="RefLink">11.3-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s9:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s9 ) = 9;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCheckUniformSpread( g, [ 2A, 2A ], s9, 20 );</span>
true
</pre></div>

<p><a id="X826658207D9D6570" name="X826658207D9D6570"></a></p>

<h5>11.5-21 <span class="Heading"><span class="SimpleMath">S_8(2)</span></span></h5>

<p>We show that the group <span class="SimpleMath">S = S_8(2)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">17</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one subgroup of each of the types <span class="SimpleMath">O_8^-(2).2 = Ω^-(8,2).2</span>, <span class="SimpleMath">S_4(4).2 = Sp(4,4).2</span>, and <span class="SimpleMath">L_2(17) = PSL(2,17)</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">17</span>, and <span class="SimpleMath">g ∈ S^×</span>, we have <span class="SimpleMath">P(g,s) &lt; 1/3</span>, except if <span class="SimpleMath">g</span> is a transvection.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p>The uniform spread of <span class="SimpleMath">S</span> is at least two, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">17</span>.</p>

</dd>
</dl>
<p>Statement (a) follows from the list of maximal subgroups of <span class="SimpleMath">S</span> in <a href="chapBib.html#biBCCN85">[CCN+85, p. 123]</a>, and the fact that <span class="SimpleMath">1_H^S(s) = 1</span> holds for each <span class="SimpleMath">H ∈ 𝕄(S,s)</span>. Note that <span class="SimpleMath">17</span> divides the indices of the maximal subgroups of the types <span class="SimpleMath">O_8^+(2).2</span> and <span class="SimpleMath">2^7 : S_6(2)</span> in <span class="SimpleMath">S</span>, and obviously <span class="SimpleMath">17</span> does not divide the orders of the remaining maximal subgroups.</p>

<p>The permutation characters induced from the first two subgroups are uniquely determined by the ordinary character tables. The permutation character induced from the last subgroup is uniquely determined if one considers also the corresponding Brauer tables; the correct class fusion is stored in the <strong class="pkg">GAP</strong> Character Table Library, see <a href="chapBib.html#biBAmbigFus">[Brea]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "S8(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1:= PossiblePermutationCharacters( CharacterTable( "O8-(2).2" ), t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2:= PossiblePermutationCharacters( CharacterTable( "S4(4).2" ), t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi3:= [ TrivialCharacter( CharacterTable( "L2(17)" ) )^t ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= Concatenation( pi1, pi2, pi3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( prim );</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 17 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( prim, x -&gt; x[ spos ] );</span>
[ 1, 1, 1 ]
</pre></div>

<p>For statement (b), we observe that <span class="SimpleMath">σ(g,s) &lt; 1/3</span> if <span class="SimpleMath">g</span> is not a transvection, and that <span class="SimpleMath">P(g,s) = σ(g,s)</span> for transvections <span class="SimpleMath">g</span> because exactly one of the three permutation characters is nonzero on both <span class="SimpleMath">s</span> and the class of transvections.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( prim, spos );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositionsProperty( approx, x -&gt; x &gt;= 1/3 );</span>
[ 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Number( prim, pi -&gt; pi[2] &lt;&gt; 0 and pi[ spos ] &lt;&gt; 0 );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx[2];</span>
8/15
</pre></div>

<p>In statement (c), we have to consider only the case that the two elements <span class="SimpleMath">x</span>, <span class="SimpleMath">y</span> are transvections.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositionsProperty( approx, x -&gt; x + approx[2] &gt;= 1 );</span>
[ 2 ]
</pre></div>

<p>We use the random approach described in Section <a href="chap11.html#X83DACCF07EF62FAE"><span class="RefLink">11.3-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:= 8;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">matgrp:= Sp(d,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom:= ActionHomomorphism( matgrp, NormedRowVectors( GF(2)^d ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= Image( hom, transvection( d ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Image( hom, matgrp );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:= ConjugacyClass( g, x );;  Size( C );</span>
255
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 17;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCheckUniformSpread( g, [ x, x ], s, 20 );</span>
true
</pre></div>

<p><a id="X82A6496887F80843" name="X82A6496887F80843"></a></p>

<h5>11.5-22 <span class="Heading"><span class="SimpleMath">∗</span> <span class="SimpleMath">S_10(2)</span></span></h5>

<p>We show that the group <span class="SimpleMath">S = S_10(2)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">33</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one subgroup of each of the types <span class="SimpleMath">Ω^-(10,2).2</span> and <span class="SimpleMath">L_2(32).5 = Sp(2,32).5</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">33</span>, and <span class="SimpleMath">g ∈ S^×</span>, we have <span class="SimpleMath">P(g,s) &lt; 1/3</span>, except if <span class="SimpleMath">g</span> is a transvection.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p>The uniform spread of <span class="SimpleMath">S</span> is at least two, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">33</span>.</p>

</dd>
</dl>
<p>By <a href="chapBib.html#biBBe00">[Ber00]</a>, the only maximal subgroups of <span class="SimpleMath">S</span> that contain <span class="SimpleMath">s</span> have the types stated in (a), and by <a href="chapBib.html#biBKlL90">[KL90, Prop. 4.3.10 and 4.8.6]</a>, there is exactly one class of each of these subgroups.</p>

<p>We compute the values <span class="SimpleMath">σ( g, s )</span>, for all <span class="SimpleMath">g ∈ S^×</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "S10(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1:= PossiblePermutationCharacters( CharacterTable( "O10-(2).2" ), t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2:= PossiblePermutationCharacters( CharacterTable( "L2(32).5" ), t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= Concatenation( pi1, pi2 );;  Length( prim );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 33 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( prim, spos );;</span>
</pre></div>

<p>For statement (b), we observe that <span class="SimpleMath">σ(g,s) &lt; 1/3</span> if <span class="SimpleMath">g</span> is not a transvection, and that <span class="SimpleMath">P(g,s) = σ(g,s)</span> for transvections <span class="SimpleMath">g</span> because exactly one of the two permutation characters is nonzero on both <span class="SimpleMath">s</span> and the class of transvections.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PositionsProperty( approx, x -&gt; x &gt;= 1/3 );</span>
[ 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Number( prim, pi -&gt; pi[2] &lt;&gt; 0 and pi[ spos ] &lt;&gt; 0 );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx[2];</span>
16/31
</pre></div>

<p>In statement (c), we have to consider only the case that the two elements <span class="SimpleMath">x</span>, <span class="SimpleMath">y</span> are transvections. We use the random approach described in Section <a href="chap11.html#X83DACCF07EF62FAE"><span class="RefLink">11.3-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d:= 10;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">matgrp:= Sp(d,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom:= ActionHomomorphism( matgrp, NormedRowVectors( GF(2)^d ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= Image( hom, transvection( d ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Image( hom, matgrp );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:= ConjugacyClass( g, x );;  Size( C );</span>
1023
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 33;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCheckUniformSpread( g, [ x, x ], s, 20 );</span>
true
</pre></div>

<p><a id="X7A03F8EC839AF0B5" name="X7A03F8EC839AF0B5"></a></p>

<h5>11.5-23 <span class="Heading"><span class="SimpleMath">U_4(2)</span></span></h5>

<p>We show that <span class="SimpleMath">S = U_4(2) = SU(4,2) ≅ S_4(3) = PSp(4,3)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">σ(S) = 21/40</span>, and this value is attained exactly for <span class="SimpleMath">σ(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">12</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">9</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of two groups, of the types <span class="SimpleMath">3^1+2_+ : 2A_4 = GU(3,2)</span> and <span class="SimpleMath">3^3 : S_4</span>, respectively.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">P(S) = 2/5</span>, and this value is attained exactly for <span class="SimpleMath">P(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">9</span>.</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>The uniform spread of <span class="SimpleMath">S</span> is at least three, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">9</span>.</p>

</dd>
<dt><strong class="Mark">(e)</strong></dt>
<dd><p><span class="SimpleMath">σ^'(Aut(S),s) = 7/20</span>.</p>

</dd>
</dl>
<p>(Note that in this example, the optimal choice of <span class="SimpleMath">s</span> w.r.t. <span class="SimpleMath">σ(S,s)</span> is not optimal w.r.t. <span class="SimpleMath">P(S,s)</span>.)</p>

<p>Statement (a) follows from inspection of the primitive permutation characters, cf. Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "U4(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoSimple( t );</span>
[ "U4(2)", 21/40, 1, [ "12A" ], [ 2 ] ]
</pre></div>

<p>Statement (b) can be read off from the permutation characters, and the fact that the only classes of maximal subgroups that contain elements of order <span class="SimpleMath">9</span> consist of groups of the structures <span class="SimpleMath">3^1+2_+:2A_4</span> and <span class="SimpleMath">3^3:S_4</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 26]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( t );</span>
[ 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, 6, 6, 6, 6, 6, 9, 9, 12, 12 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= PrimitivePermutationCharacters( t );</span>
[ Character( CharacterTable( "U4(2)" ),
  [ 27, 3, 7, 0, 0, 9, 0, 3, 1, 2, 0, 0, 3, 3, 0, 1, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "U4(2)" ),
  [ 36, 12, 8, 0, 0, 6, 3, 0, 2, 1, 0, 0, 0, 0, 3, 2, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "U4(2)" ),
  [ 40, 8, 0, 13, 13, 4, 4, 4, 0, 0, 5, 5, 2, 2, 2, 0, 1, 1, 1, 1 ] ),
  Character( CharacterTable( "U4(2)" ),
  [ 40, 16, 4, 4, 4, 1, 7, 0, 2, 0, 4, 4, 1, 1, 1, 1, 1, 1, 0, 0 ] ), 
  Character( CharacterTable( "U4(2)" ),
  [ 45, 13, 5, 9, 9, 6, 3, 1, 1, 0, 1, 1, 4, 4, 1, 2, 0, 0, 1, 1 ] ) ]
</pre></div>

<p>For statement (c), we use a primitive permutation representation on <span class="SimpleMath">40</span> points that occurs in the natural action of <span class="SimpleMath">SU(4,2)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SU(4,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( g, NormedRowVectors( GF(4)^4 ), OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 45, 40 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Action( g, orbs[2], OnLines );;</span>
</pre></div>

<p>First we show that for <span class="SimpleMath">s</span> of order <span class="SimpleMath">9</span>, <span class="SimpleMath">P(S,s) = 2/5</span> holds. For that, we have to consider only <span class="SimpleMath">P(g,s)</span>, with <span class="SimpleMath">g</span> in one of the classes <code class="code">2A</code> (of length <span class="SimpleMath">45</span>) and <code class="code">3A</code> (of length <span class="SimpleMath">40</span>); since the class <code class="code">3B</code> contains the inverses of the elements in the class <code class="code">3A</code>, we need not test it.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 9 );</span>
17
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( prim, spos );</span>
[ 0, 3/5, 1/10, 17/40, 17/40, 1/8, 11/40, 1/10, 1/20, 0, 9/40, 9/40, 
  3/40, 3/40, 3/40, 1/40, 1/20, 1/20, 1/40, 1/40 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">badpos:= PositionsProperty( approx, x -&gt; x &gt;= 2/5 );</span>
[ 2, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PowerMap( t, 2 )[4];</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( t );</span>
[ 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, 6, 6, 6, 6, 6, 9, 9, 12, 12 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesConjugacyClasses( t );</span>
[ 1, 45, 270, 40, 40, 240, 480, 540, 3240, 5184, 360, 360, 720, 720, 
  1440, 2160, 2880, 2880, 2160, 2160 ]
</pre></div>

<p>A representative <span class="SimpleMath">g</span> of a class of length <span class="SimpleMath">40</span> can be found as the third power of any order <span class="SimpleMath">9</span> element.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PowerMap( t, 3 )[ spos ];</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 9;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( ConjugacyClass( g, s^3 ) );</span>
40
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prop:= RatioOfNongenerationTransPermGroup( g, s^3, s );</span>
13/40
</pre></div>

<p>Next we examine <span class="SimpleMath">g</span> in the class <code class="code">2A</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= Random( g ); until Order( x ) = 12;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( ConjugacyClass( g, x^6 ) );</span>
45
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prop:= RatioOfNongenerationTransPermGroup( g, x^6, s );</span>
2/5
</pre></div>

<p>Finally, we compute that for <span class="SimpleMath">s</span> of order different from <span class="SimpleMath">9</span> and <span class="SimpleMath">g</span> in the class <code class="code">2A</code>, <span class="SimpleMath">P(g,s)</span> is larger than <span class="SimpleMath">2/5</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ccl:= List( ConjugacyClasses( g ), Representative );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SortParallel( List( ccl, Order ), ccl );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( ccl, Order );</span>
[ 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, 6, 6, 6, 6, 6, 9, 9, 12, 12 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prop:= List( ccl, r -&gt; RatioOfNongenerationTransPermGroup( g, x^6, r ) );</span>
[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 5/9, 1, 1, 1, 1, 1, 1, 2/5, 2/5, 7/15, 
  7/15 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Minimum( prop );</span>
2/5
</pre></div>

<p>In order to show statement (d), we have to consider triples <span class="SimpleMath">(x_1, x_2, x_3)</span> with <span class="SimpleMath">x_i</span> of prime order and <span class="SimpleMath">∑_i=1^3 P(x_i,s) ≥ 1</span>. This means that it suffices to check <span class="SimpleMath">x</span> in the class <code class="code">2A</code>, <span class="SimpleMath">y</span> in <code class="code">2A</code><span class="SimpleMath">∪</span><code class="code">3A</code>, and <span class="SimpleMath">z</span> in <code class="code">2A</code><span class="SimpleMath">∪</span><code class="code">3A</code><span class="SimpleMath">∪</span><code class="code">3D</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx[2]:= 2/5;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx[4]:= 13/40;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">primeord:= PositionsProperty( OrdersClassRepresentatives( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                 IsPrimeInt );</span>
[ 2, 3, 4, 5, 6, 7, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RemoveSet( primeord, 5 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">primeord;</span>
[ 2, 3, 4, 6, 7, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx{ primeord };</span>
[ 2/5, 1/10, 13/40, 1/8, 11/40, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AtlasClassNames( t ){ primeord };</span>
[ "2A", "2B", "3A", "3C", "3D", "5A" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">triples:= Filtered( UnorderedTuples( primeord, 3 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 t -&gt; Sum( approx{ t } ) &gt;= 1 );</span>
[ [ 2, 2, 2 ], [ 2, 2, 4 ], [ 2, 2, 7 ], [ 2, 4, 4 ], [ 2, 4, 7 ] ]
</pre></div>

<p>We use the random approach described in Section <a href="chap11.html#X83DACCF07EF62FAE"><span class="RefLink">11.3-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat 6E:= Random( g );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( 6E ) = 6 and Size( Centralizer( g, 6E ) ) = 18;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2A:= 6E^3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3A:= s^3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3D:= 6E^2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCheckUniformSpread( g, [ 2A, 2A, 2A ], s, 50 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCheckUniformSpread( g, [ 2A, 2A, 3A ], s, 50 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCheckUniformSpread( g, [ 3D, 2A, 2A ], s, 50 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCheckUniformSpread( g, [ 2A, 3A, 3A ], s, 50 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RandomCheckUniformSpread( g, [ 3D, 3A, 2A ], s, 50 );</span>
true
</pre></div>

<p>Statement (e) can be proved using <code class="code">ProbGenInfoAlmostSimple</code>, cf. Section <a href="chap11.html#X7B1E26D586337487"><span class="RefLink">11.4-4</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "U4(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "U4(2).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= PositionsProperty( OrdersClassRepresentatives( t ), x -&gt; x = 9 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoAlmostSimple( t, t2, spos );</span>
[ "U4(2).2", 7/20, [ "9AB" ], [ 2 ] ]
</pre></div>

<p><a id="X7D738BE5804CF22E" name="X7D738BE5804CF22E"></a></p>

<h5>11.5-24 <span class="Heading"><span class="SimpleMath">U_4(3)</span></span></h5>

<p>We show that <span class="SimpleMath">S = U_4(3) = PSU(4,3)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p><span class="SimpleMath">σ(S) = 53/153</span>, and this value is attained exactly for <span class="SimpleMath">σ(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of order <span class="SimpleMath">7</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of two nonconjugate groups of the type <span class="SimpleMath">L_3(4)</span>, one group of the type <span class="SimpleMath">U_3(3)</span>, and four pairwise nonconjugate groups of the type <span class="SimpleMath">A_7</span>.</p>

</dd>
<dt><strong class="Mark">(c)</strong></dt>
<dd><p><span class="SimpleMath">P(S) = 43/135</span>, and this value is attained exactly for <span class="SimpleMath">P(S,s)</span> with <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span>.</p>

</dd>
<dt><strong class="Mark">(d)</strong></dt>
<dd><p>The uniform spread of <span class="SimpleMath">S</span> is at least three, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span>.</p>

</dd>
<dt><strong class="Mark">(e)</strong></dt>
<dd><p>The preimage of <span class="SimpleMath">s</span> in the matrix group <span class="SimpleMath">SU(4,3) ≅ 4.U_4(3)</span> has order <span class="SimpleMath">28</span>, the preimages of the groups in <span class="SimpleMath">𝕄(S,s)</span> have the structures <span class="SimpleMath">4_2.L_3(4)</span>, <span class="SimpleMath">4 × U_3(3) ≅ GU(3,3)</span>, and <span class="SimpleMath">4.A_7</span> (the latter being a central product of a cyclic group of order four and <span class="SimpleMath">2.A_7</span>).</p>

</dd>
<dt><strong class="Mark">(f)</strong></dt>
<dd><p><span class="SimpleMath">P^'(S.2_1,s) = 13/27</span>, <span class="SimpleMath">σ^'(S.2_2) = 1/3</span>, and <span class="SimpleMath">σ^'(S.2_3) = 31/162</span>, with <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span> in each case.</p>

</dd>
</dl>
<p>Statement (a) follows from inspection of the primitive permutation characters, cf. Section <a href="chap11.html#X80DA58F187CDCF5F"><span class="RefLink">11.4-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "U4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProbGenInfoSimple( t );</span>
[ "U4(3)", 53/135, 2, [ "7A" ], [ 7 ] ]
</pre></div>

<p>Statement (b) can be read off from the permutation characters, and the fact that the only classes of maximal subgroups that contain elements of order <span class="SimpleMath">7</span> consist of groups of the structures as claimed, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 52]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= PrimitivePermutationCharacters( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t ), 7 );</span>
13
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( Filtered( prim, x -&gt; x[ spos ] &lt;&gt; 0 ), l -&gt; l{ [ 1, spos ] } );</span>
[ [ 162, 1 ], [ 162, 1 ], [ 540, 1 ], [ 1296, 1 ], [ 1296, 1 ], 
  [ 1296, 1 ], [ 1296, 1 ] ]
</pre></div>

<p>In order to show statement (c) (which then implies statement (d)), we use a permutation representation on <span class="SimpleMath">112</span> points. It corresponds to an orbit of one-dimensional subspaces in the natural module of <span class="SimpleMath">Ω^-(6,3) ≅ S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">matgrp:= DerivedSubgroup( SO( -1, 6, 3 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( matgrp, NormedRowVectors( GF(3)^6 ), OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 126, 126, 112 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= Action( matgrp, orbs[3], OnLines );;</span>
</pre></div>

<p>It is sufficient to compute <span class="SimpleMath">P(g,s)</span>, for involutions <span class="SimpleMath">g ∈ S</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">approx:= ApproxP( prim, spos );</span>
[ 0, 53/135, 1/10, 1/24, 1/24, 7/45, 4/45, 1/27, 1/36, 1/90, 1/216, 
  1/216, 7/405, 7/405, 1/270, 0, 0, 0, 0, 1/270 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Filtered( approx, x -&gt; x &gt;= 43/135 );</span>
[ 53/135 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( t );</span>
[ 1, 2, 3, 3, 3, 3, 4, 4, 5, 6, 6, 6, 7, 7, 8, 9, 9, 9, 9, 12 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ResetGlobalRandomNumberGenerators();</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat g:= Random( G ); until Order(g) = 2;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( G );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order(s) = 7;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bad:= RatioOfNongenerationTransPermGroup( G, g, s );</span>
43/135
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bad &lt; 1/3;</span>
true
</pre></div>

<p>Statement (e) can be shown easily with character-theoretic methods, as follows. Since <span class="SimpleMath">SU(4,3)</span> is a Schur cover of <span class="SimpleMath">S</span> and the groups in <span class="SimpleMath">𝕄(S,s)</span> are simple, only very few possibilities have to be checked. The Schur multiplier of <span class="SimpleMath">U_3(3)</span> is trivial (see, e. g., <a href="chapBib.html#biBCCN85">[CCN+85, p. 14]</a>), so the preimage in <span class="SimpleMath">SU(4,3)</span> is a direct product of <span class="SimpleMath">U_3(3)</span> and the centre of <span class="SimpleMath">SU(4,3)</span>. Neither <span class="SimpleMath">L_3(4)</span> nor its double cover <span class="SimpleMath">2.L_3(4)</span> can be a subgroup of <span class="SimpleMath">SU(4,3)</span>, so the preimage of <span class="SimpleMath">L_3(4)</span> must be a Schur cover of <span class="SimpleMath">L_3(4)</span>, i. e., it must have either the type <span class="SimpleMath">4_1.L_3(4)</span> or <span class="SimpleMath">4_2.L_3(4)</span> (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 23]</a>); only the type <span class="SimpleMath">4_2.L_3(4)</span> turns out to be possible.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">4t:= CharacterTable( "4.U4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( PossibleClassFusions( CharacterTable( "L3(4)" ), 4t ) );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( PossibleClassFusions( CharacterTable( "2.L3(4)" ), 4t ) );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( PossibleClassFusions( CharacterTable( "4_1.L3(4)" ), 4t ) );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( PossibleClassFusions( CharacterTable( "4_2.L3(4)" ), 4t ) );</span>
4
</pre></div>

<p>As for the preimage of the <span class="SimpleMath">A_7</span> type subgroups, we first observe that the double cover of <span class="SimpleMath">A_7</span> cannot be a subgroup of the double cover of <span class="SimpleMath">S</span>, so the preimage of <span class="SimpleMath">A_7</span> in the double cover of <span class="SimpleMath">U_4(3)</span> is a direct product <span class="SimpleMath">2 × A_7</span>. The group <span class="SimpleMath">SU(4,3)</span> does not contain <span class="SimpleMath">A_7</span> type subgroups, thus the <span class="SimpleMath">A_7</span> type subgroups in <span class="SimpleMath">2.U_4(3)</span> lift to double covers of <span class="SimpleMath">A_7</span> in <span class="SimpleMath">SU(4,3)</span>. This proves the claimed structure.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2t:= CharacterTable( "2.U4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( PossibleClassFusions( CharacterTable( "2.A7" ), 2t ) );</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( PossibleClassFusions( CharacterTable( "A7" ), 4t ) );</span>
0
</pre></div>

<p>For statement (f), we consider automorphic extensions of <span class="SimpleMath">S</span>. The bound for <span class="SimpleMath">S.2_3</span> has been computed in Section <a href="chap11.html#X7B1E26D586337487"><span class="RefLink">11.4-4</span></a>. That for <span class="SimpleMath">S.2_2</span> can be computed form the fact that the classes of maximal subgroups of <span class="SimpleMath">S.2_2</span> containing <span class="SimpleMath">s</span> of order <span class="SimpleMath">7</span> are <span class="SimpleMath">S</span>, one class of <span class="SimpleMath">U_3(3).2</span> type subgroups, and two classes of <span class="SimpleMath">S_7</span> type subgroups which induce the same permutation character (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 52]</a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "U4(3).2_2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1:= PossiblePermutationCharacters( CharacterTable( "U3(3).2" ), t2 );</span>
[ Character( CharacterTable( "U4(3).2_2" ),
  [ 540, 12, 54, 0, 0, 9, 8, 0, 0, 6, 0, 0, 1, 2, 0, 0, 0, 2, 0, 24, 
      4, 0, 0, 0, 0, 0, 0, 3, 2, 0, 4, 0, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2:= PossiblePermutationCharacters( CharacterTable( "A7.2" ), t2 );</span>
[ Character( CharacterTable( "U4(3).2_2" ),
  [ 1296, 48, 0, 27, 0, 9, 0, 4, 1, 0, 3, 0, 1, 0, 0, 0, 0, 0, 216, 
      24, 0, 4, 0, 0, 0, 9, 0, 3, 0, 1, 0, 1, 0, 0 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">prim:= Concatenation( pi1, pi2, pi2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">outer:= Difference(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ClassPositionsOfDerivedSubgroup( t2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">spos:= Position( OrdersClassRepresentatives( t2 ), 7 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Maximum( ApproxP( prim, spos ){ outer } );</span>
1/3
</pre></div>

<p>Finally, Section <a href="chap11.html#X7B1E26D586337487"><span class="RefLink">11.4-4</span></a> shows that the character tables are not sufficient for what we need, so we compute the exact proportion of nongeneration for <span class="SimpleMath">U_4(3).2_1 ≅ SO^-(6,3)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">matgrp:= SO( -1, 6, 3 );</span>
SO(-1,6,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( matgrp, NormedRowVectors( GF(3)^6 ), OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 126, 126, 112 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G:= Action( matgrp, orbs[3], OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat s:= Random( G );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Order( s ) = 7;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     repeat 2B:= Random( G ); until Order( 2B ) mod 2 = 0;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     2B:= 2B^( Order( 2B ) / 2 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     c:= Centralizer( G, 2B );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Size( c ) = 12096;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RatioOfNongenerationTransPermGroup( G, 2B, s );</span>
13/27
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     repeat 2C:= Random( G ); until Order( 2C ) mod 2 = 0;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     2C:= 2C^( Order( 2C ) / 2 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     c:= Centralizer( G, 2C );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   until Size( c ) = 1440;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RatioOfNongenerationTransPermGroup( G, 2C, s );</span>
0
</pre></div>

<p><a id="X7D4BC6A38074BF68" name="X7D4BC6A38074BF68"></a></p>

<h5>11.5-25 <span class="Heading"><span class="SimpleMath">U_6(3)</span></span></h5>

<p>We show that <span class="SimpleMath">S = U_6(3) = PSU(6,3)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of the type <span class="SimpleMath">1 perp 5</span> (i. e., the preimage of <span class="SimpleMath">s</span> in <span class="SimpleMath">2.S = SU(6,3)</span> decomposes the natural <span class="SimpleMath">6</span>-dimensional module for <span class="SimpleMath">2.S</span> into an orthogonal sum of two irreducible modules of the dimensions <span class="SimpleMath">1</span> and <span class="SimpleMath">5</span>, respectively) and of order <span class="SimpleMath">(3^5 + 1)/2 = 122</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">2 × U_5(3)</span>, which lifts to a subgroup of the type <span class="SimpleMath">4 × U_5(3) = GU(5,3)</span> in <span class="SimpleMath">2.S</span>. (The preimage of <span class="SimpleMath">s</span> in <span class="SimpleMath">2.S</span> has order <span class="SimpleMath">3^5 + 1 = 244</span>.)</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 353/3159</span>.</p>

</dd>
</dl>
<p>By <a href="chapBib.html#biBMSW94">[MSW94]</a>, the only maximal subgroup of <span class="SimpleMath">S</span> that contains <span class="SimpleMath">s</span> is the stabilizer <span class="SimpleMath">H ≅ 2 × U_5(3)</span> of the orthogonal decomposition. This proves statement (a).</p>

<p>The character table of <span class="SimpleMath">S</span> is currently not available in the <strong class="pkg">GAP</strong> Character Table Library. We consider the permutation action of <span class="SimpleMath">S</span> on the orbit of the stabilized <span class="SimpleMath">1</span>-space. So <span class="SimpleMath">M</span> can be taken as a point stabilizer in this action.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterTable( "U6(3)" );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SU(6,3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( g, NormedRowVectors( GF(9)^6 ), OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 22204, 44226 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= PseudoRandom( g ); until Order( x ) = 244;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, o -&gt; Number( o, v -&gt; OnLines( v, x ) = v ) );</span>
[ 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Action( g, orbs[2], OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M:= Stabilizer( g, 1 );;</span>
</pre></div>

<p>Then we compute a list of elements in <span class="SimpleMath">M</span> that covers the conjugacy classes of prime element order, from which the numbers of fixed points and thus <span class="SimpleMath">max{ μ( S/M, g ); g ∈ M^× } = σ( S, s )</span> can be derived. This way we avoid completely to check the <span class="SimpleMath">S</span>-conjugacy of elements (class representatives of Sylow subgroups in <span class="SimpleMath">M</span>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for p in PrimeDivisors( Size( M ) ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     syl:= SylowSubgroup( M, p );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Append( elms, Filtered( PcConjugacyClassReps( syl ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                             r -&gt; Order( r ) = p ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">1 - Minimum( List( elms, NrMovedPoints ) ) / Length( orbs[2] );</span>
353/3159
</pre></div>

<p><a id="X7A92577A830B5F23" name="X7A92577A830B5F23"></a></p>

<h5>11.5-26 <span class="Heading"><span class="SimpleMath">U_8(2)</span></span></h5>

<p>We show that <span class="SimpleMath">S = U_8(2) = SU(8,2)</span> satisfies the following.</p>


<dl>
<dt><strong class="Mark">(a)</strong></dt>
<dd><p>For <span class="SimpleMath">s ∈ S</span> of the type <span class="SimpleMath">1 perp 7</span> (i. e., <span class="SimpleMath">s</span> decomposes the natural <span class="SimpleMath">8</span>-dimensional module for <span class="SimpleMath">S</span> into an orthogonal sum of two irreducible modules of the dimensions <span class="SimpleMath">1</span> and <span class="SimpleMath">7</span>, respectively) and of order <span class="SimpleMath">2^7 + 1 = 129</span>, <span class="SimpleMath">𝕄(S,s)</span> consists of one group of the type <span class="SimpleMath">3 × U_7(2) = GU(7,2)</span>.</p>

</dd>
<dt><strong class="Mark">(b)</strong></dt>
<dd><p><span class="SimpleMath">σ(S,s) = 2753/10880</span>.</p>

</dd>
</dl>
<p>By <a href="chapBib.html#biBMSW94">[MSW94]</a>, the only maximal subgroup of <span class="SimpleMath">S</span> that contains <span class="SimpleMath">s</span> is the stabilizer <span class="SimpleMath">M ≅ GU(7,2)</span> of the orthogonal decomposition. This proves statement (a).</p>

<p>The character table of <span class="SimpleMath">S</span> is currently not available in the <strong class="pkg">GAP</strong> Character Table Library. We proceed exactly as in Section <a href="chap11.html#X7D4BC6A38074BF68"><span class="RefLink">11.5-25</span></a> in order to prove statement (b).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacterTable( "U8(2)" );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= SU(8,2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( g, NormedRowVectors( GF(4)^8 ), OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 10965, 10880 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= PseudoRandom( g ); until Order( x ) = 129;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, o -&gt; Number( o, v -&gt; OnLines( v, x ) = v ) );</span>
[ 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Action( g, orbs[2], OnLines );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M:= Stabilizer( g, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for p in PrimeDivisors( Size( M ) ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     syl:= SylowSubgroup( M, p );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Append( elms, Filtered( PcConjugacyClassReps( syl ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                             r -&gt; Order( r ) = p ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( elms );</span>
611
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">1 - Minimum( List( elms, NrMovedPoints ) ) / Length( orbs[2] );</span>
2753/10880
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap10.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
