<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (CTblLibXpls) - Chapter 2: Using Table Automorphisms for Constructing Character Tables in GAP</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2_mj.html">[MathJax on]</a></p>
<p><a id="X7B77FD307F0DE563" name="X7B77FD307F0DE563"></a></p>
<div class="ChapSects"><a href="chap2.html#X7B77FD307F0DE563">2 <span class="Heading">Using Table Automorphisms for Constructing Character Tables in <strong class="pkg">GAP</strong></span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X8389AD927B74BA4A">2.1 <span class="Heading">Overview</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7B6AEBDF7B857E2E">2.2 <span class="Heading">Theoretical Background</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X78EBF9BA7A34A9C2">2.2-1 <span class="Heading">Character Table Automorphisms</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X832525DE7AB34F16">2.2-2 <span class="Heading">Permutation Equivalence of Character Tables</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7906869F7F190E76">2.2-3 <span class="Heading">Class Fusions</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X80C37276851D5E39">2.2-4 <span class="Heading">Constructing Character Tables of Certain Isoclinic Groups</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7AEFFEEC84511FD0">2.2-5 <span class="Heading">Character Tables of Isoclinic Groups of the Structure <span class="SimpleMath">p.G.p</span>
(October 2016)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X78F41D2A78E70BEE">2.2-6 <span class="Heading">Isoclinic Double Covers of Almost Simple Groups</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X834B42A07E98FBC6">2.2-7 <span class="Heading">Characters of Normal Subgroups</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X787F430E7FDB8765">2.3 <span class="Heading">The Constructions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X82E75B6880EC9E6C">2.3-1 <span class="Heading">Character Tables of Groups of the Structure <span class="SimpleMath">M.G.A</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7CCABDDE864E6300">2.3-2 <span class="Heading">Character Tables of Groups of the Structure <span class="SimpleMath">G.S_3</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7D3EF3BC83BE05CF">2.3-3 <span class="Heading">Character Tables of Groups of the Structure <span class="SimpleMath">G.2^2</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X81464C4B8178C85A">2.3-4 <span class="Heading">Character Tables of Groups of the Structure <span class="SimpleMath">2^2.G</span>
(August 2005)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X86CF6A607B0827EE">2.3-5 <span class="Heading"><span class="SimpleMath">p</span>-Modular Tables of Extensions by <span class="SimpleMath">p</span>-singular Automorphisms</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X788591D78451C024">2.3-6 <span class="Heading">Character Tables of Subdirect Products of Index Two (July 2007)</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X817D2134829FA8FA">2.4 <span class="Heading">Examples for the Type <span class="SimpleMath">M.G.A</span></span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F2DBAB48437052C">2.4-1 <span class="Heading">Character Tables of Dihedral Groups</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7925DBFA7C5986B5">2.4-2 <span class="Heading">An <span class="SimpleMath">M.G.A</span> Type Example with <span class="SimpleMath">M</span> noncentral in <span class="SimpleMath">M.G</span> (May 2004)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7ED45AB379093A70">2.4-3 <span class="Heading"><strong class="pkg">Atlas</strong> Tables of the Type <span class="SimpleMath">M.G.A</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7A236EDE7A7A28F9">2.4-4 <span class="Heading">More <strong class="pkg">Atlas</strong> Tables of the Type <span class="SimpleMath">M.G.A</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X794EC2FD7F69B4E6">2.4-5 <span class="Heading">The Character Tables of <span class="SimpleMath">4_2.L_3(4).2_3</span> and <span class="SimpleMath">12_2.L_3(4).2_3</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7E3E748E85AEDDB3">2.4-6 <span class="Heading">The Character Tables of <span class="SimpleMath">12_1.U_4(3).2_2'</span> and
<span class="SimpleMath">12_2.U_4(3).2_3'</span> (December 2015)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8379003582D06130">2.4-7 <span class="Heading">Groups of the Structures <span class="SimpleMath">3.U_3(8).3_1</span> and <span class="SimpleMath">3.U_3(8).6</span>
(February 2017)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7B46C77B850D3B4D">2.4-8 <span class="Heading">The Character Table of <span class="SimpleMath">(2^2 × F_4(2)):2 &lt; B</span>
(March 2003)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8254AA4A843F99BE">2.4-9 <span class="Heading">The Character Table of <span class="SimpleMath">2.(S_3 × Fi_22.2) &lt; 2.B</span> (March 2003)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7AF125168239D208">2.4-10 <span class="Heading">The Character Table of <span class="SimpleMath">(2 × 2.Fi_22):2 &lt; Fi_24</span> (November 2008)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X79C93F7D87D9CF1D">2.4-11 <span class="Heading">The Character Table of <span class="SimpleMath">S_3 × 2.U_4(3).2_2 ≤ 2.Fi_22</span> (September 2002)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X83724BCE86FCD77B">2.4-12 <span class="Heading">The Character Table of <span class="SimpleMath">4.HS.2 ≤ HN.2</span> (May 2002)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7E9A88DA7CBF6426">2.4-13 <span class="Heading">The Character Tables of <span class="SimpleMath">4.A_6.2_3</span>, <span class="SimpleMath">12.A_6.2_3</span>,
and <span class="SimpleMath">4.L_2(25).2_3</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7BD79BA37C3E729B">2.4-14 <span class="Heading">The Character Table of <span class="SimpleMath">4.L_2(49).2_3</span> (December 2020)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X817A961487D2DFD1">2.4-15 <span class="Heading">The Character Table of <span class="SimpleMath">4.L_2(81).2_3</span> (December 2020)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7AF324AF7A54798F">2.4-16 <span class="Heading">The Character Table of <span class="SimpleMath">9.U_3(8).3_3</span> (March 2017)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7E0C603880157C4E">2.4-17 <span class="Heading">Pseudo Character Tables of the Type <span class="SimpleMath">M.G.A</span> (May 2004)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X844185EF7A8F2A99">2.4-18 <span class="Heading">Some Extra-ordinary <span class="SimpleMath">p</span>-Modular Tables of the Type <span class="SimpleMath">M.G.A</span>
(September 2005)</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7F50C782840F06E4">2.5 <span class="Heading">Examples for the Type <span class="SimpleMath">G.S_3</span></span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F0DC29F874AA09F">2.5-1 <span class="Heading">Small Examples</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X80F9BC057980A9E9">2.5-2 <span class="Heading"><strong class="pkg">Atlas</strong> Tables of the Type <span class="SimpleMath">G.S_3</span></span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7EA489E07D7C7D86">2.6 <span class="Heading">Examples for the Type <span class="SimpleMath">G.2^2</span></span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X8054FDE679053B1C">2.6-1 <span class="Heading">The Character Table of <span class="SimpleMath">A_6.2^2</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7FEC3AB081487AF2">2.6-2 <span class="Heading"><strong class="pkg">Atlas</strong> Tables of the Type <span class="SimpleMath">G.2^2</span> – Easy Cases</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X869B65D3863EDEC3">2.6-3 <span class="Heading">The Character Table of <span class="SimpleMath">S_4(9).2^2</span> (September 2011)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7B38006380618543">2.6-4 <span class="Heading">The Character Tables of Groups of the Type <span class="SimpleMath">2.L_3(4).2^2</span>
(June 2010)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X79818ABD7E972370">2.6-5 <span class="Heading">The Character Tables of Groups of the Type <span class="SimpleMath">6.L_3(4).2^2</span>
(October 2011)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X878889308653435F">2.6-6 <span class="Heading">The Character Tables of Groups of the Type <span class="SimpleMath">2.U_4(3).2^2</span>
(February 2012)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7DC42AE57E9EED4D">2.6-7 <span class="Heading">The Character Tables of Groups of the Type <span class="SimpleMath">4_1.L_3(4).2^2</span>
(October 2011)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7E9AF180869B4786">2.6-8 <span class="Heading">The Character Tables of Groups of the Type <span class="SimpleMath">4_2.L_3(4).2^2</span>
(October 2011)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7EAF9CD07E536120">2.6-9 <span class="Heading">The Character Table of Aut<span class="SimpleMath">(L_2(81))</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X78AED04685EDCC19">2.6-10 <span class="Heading">The Character Table of <span class="SimpleMath">O_8^+(3).2^2_111</span></span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X845BAA2A7FD768B0">2.7 <span class="Heading">Examples for the Type <span class="SimpleMath">2^2.G</span></span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X87EEBDB987249117">2.7-1 <span class="Heading">The Character Table of <span class="SimpleMath">2^2.Sz(8)</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X83652A0282A64D14">2.7-2 <span class="Heading"><strong class="pkg">Atlas</strong> Tables of the Type <span class="SimpleMath">2^2.G</span> (September 2005)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7F63DDF77870F967">2.7-3 <span class="Heading">The Character Table of <span class="SimpleMath">2^2.O_8^+(3)</span> (March 2009)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X86A1607787DE6BB9">2.7-4 <span class="Heading">The Character Table of the Schur Cover of <span class="SimpleMath">L_3(4)</span>
(September 2005)</span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X8711DBB083655A25">2.8 <span class="Heading">Examples of Extensions by <span class="SimpleMath">p</span>-singular Automorphisms</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X81C08739850E4AAE">2.8-1 <span class="Heading">Some <span class="SimpleMath">p</span>-Modular Tables of Groups of the Type <span class="SimpleMath">M.G.A</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7FED618F83ACB7C2">2.8-2 <span class="Heading">Some <span class="SimpleMath">p</span>-Modular Tables of Groups of the Type <span class="SimpleMath">G.S_3</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X7EEF6A7F8683177A">2.8-3 <span class="Heading"><span class="SimpleMath">2</span>-Modular Tables of Groups of the Type <span class="SimpleMath">G.2^2</span></span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X875F8DD77C0997FA">2.8-4 <span class="Heading">The <span class="SimpleMath">3</span>-Modular Table of <span class="SimpleMath">U_3(8).3^2</span></span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X7A4D6044865E516B">2.9 <span class="Heading">Examples of Subdirect Products of Index Two</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X850FF694801700CF">2.9-1 <span class="Heading">Certain Dihedral Groups as Subdirect Products of Index Two</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X80C5D6FA83D7E2CF">2.9-2 <span class="Heading">The Character Table of <span class="SimpleMath">(D_10 × HN).2 &lt; M</span> (June 2008)</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap2.html#X85EECFD47EC252A2">2.9-3 <span class="Heading">A Counterexample (August 2015)</span></a>
</span>
</div></div>
</div>

<h3>2 <span class="Heading">Using Table Automorphisms for Constructing Character Tables in <strong class="pkg">GAP</strong></span></h3>

<p>Date: June 27th, 2004</p>

<p>This chapter has three aims. First it shows how character table automorphisms can be utilized to construct certain character tables from others using the <strong class="pkg">GAP</strong> system <a href="chapBib.html#biBGAP">[GAP21]</a>; the <strong class="pkg">GAP</strong> functions used for that are part of the <strong class="pkg">GAP</strong> Character Table Library <a href="chapBib.html#biBCTblLib">[Bre22]</a>. Second it documents several constructions of character tables which are contained in the <strong class="pkg">GAP</strong> Character Table Library. Third it serves as a testfile for the involved <strong class="pkg">GAP</strong> functions.</p>

<p><a id="X8389AD927B74BA4A" name="X8389AD927B74BA4A"></a></p>

<h4>2.1 <span class="Heading">Overview</span></h4>

<p>Several types of constructions of character tables of finite groups from known tables of smaller groups are described in Section <a href="chap2.html#X787F430E7FDB8765"><span class="RefLink">2.3</span></a>. Selecting suitable character table automorphisms is an important ingredient of these constructions.</p>

<p>Section <a href="chap2.html#X7B6AEBDF7B857E2E"><span class="RefLink">2.2</span></a> collects the few representation theoretical facts on which these constructions are based.</p>

<p>The remaining sections show examples of the constructions in <strong class="pkg">GAP</strong>. These examples use the <strong class="pkg">GAP</strong> Character Table Library, therefore we load this package first.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "ctbllib", "1.1.4", false );</span>
true
</pre></div>

<p><a id="X7B6AEBDF7B857E2E" name="X7B6AEBDF7B857E2E"></a></p>

<h4>2.2 <span class="Heading">Theoretical Background</span></h4>

<p><a id="X78EBF9BA7A34A9C2" name="X78EBF9BA7A34A9C2"></a></p>

<h5>2.2-1 <span class="Heading">Character Table Automorphisms</span></h5>

<p>Let <span class="SimpleMath">G</span> be a finite group, <span class="SimpleMath">Irr(G)</span> be the matrix of ordinary irreducible characters of <span class="SimpleMath">G</span>, <span class="SimpleMath">Cl(G)</span> be the set of conjugacy classes of elements in <span class="SimpleMath">G</span>, <span class="SimpleMath">g^G</span> the <span class="SimpleMath">G</span>-conjugacy class of <span class="SimpleMath">g ∈ G</span>, and let</p>

<p class="pcenter">pow_p : Cl(G) → Cl(G), g^G ↦ (g^p)^G</p>

<p>be the <span class="SimpleMath">p</span>-th power map, for each prime integer <span class="SimpleMath">p</span>.</p>

<p>A <em>table automorphism</em> of <span class="SimpleMath">G</span> is a permutation <span class="SimpleMath">σ : Cl(G) → Cl(G)</span> with the properties that <span class="SimpleMath">χ ∘ σ ∈ Irr(G)</span> holds for all <span class="SimpleMath">χ ∈ Irr(G)</span> and that <span class="SimpleMath">σ</span> commutes with <span class="SimpleMath">pow_p</span>, for all prime integers <span class="SimpleMath">p</span> that divide the order of <span class="SimpleMath">G</span>. Note that for prime integers <span class="SimpleMath">p</span> that are coprime to the order of <span class="SimpleMath">G</span>, <span class="SimpleMath">pow_p</span> commutes with each <span class="SimpleMath">σ</span> that permutes <span class="SimpleMath">Irr(G)</span>, since <span class="SimpleMath">pow_p</span> acts as a field automorphism on the character values.</p>

<p>In <strong class="pkg">GAP</strong>, a character table covers the irreducible characters –a matrix <span class="SimpleMath">M</span> of character values– as well as the power maps of the underlying group –each power map <span class="SimpleMath">pow_p</span> being represented as a list <span class="SimpleMath">pow_p^'</span> of positive integers denoting the positions of the image classes. The group of table automorphisms of a character table is represented as a permutation group on the column positions of the table; it can be computed with the <strong class="pkg">GAP</strong> function <code class="func">AutomorphismsOfTable</code> (<a href="../../../doc/ref/chap71.html#X7C2753DE8094F4BA"><span class="RefLink">Reference: AutomorphismsOfTable</span></a>).</p>

<p>In the following, we will mainly use that each <em>group automorphism</em> <span class="SimpleMath">σ</span> of <span class="SimpleMath">G</span> induces a table automorphism that maps the class of each element in <span class="SimpleMath">G</span> to the class of its image under <span class="SimpleMath">σ</span>.</p>

<p><a id="X832525DE7AB34F16" name="X832525DE7AB34F16"></a></p>

<h5>2.2-2 <span class="Heading">Permutation Equivalence of Character Tables</span></h5>

<p>Two character tables with matrices <span class="SimpleMath">M_1</span>, <span class="SimpleMath">M_2</span> of irreducibles and <span class="SimpleMath">p</span>-th power maps <span class="SimpleMath">pow_{1,p}</span>, <span class="SimpleMath">pow_{2,p}</span> are <em>permutation equivalent</em> if permutations <span class="SimpleMath">ψ</span> and <span class="SimpleMath">π</span> of row and column positions of the <span class="SimpleMath">M_i</span> exist such that <span class="SimpleMath">[ M_1 ]_{i,j} = [ M_2 ]_{i ψ, j π}</span> holds for all indices <span class="SimpleMath">i</span>, <span class="SimpleMath">j</span>, and such that <span class="SimpleMath">π ⋅ pow_{2,p}^' = pow_{1,p}^' ⋅ π</span> holds for all primes <span class="SimpleMath">p</span> that divide the (common) group order. The first condition is equivalent to the existence of a permutation <span class="SimpleMath">π</span> such that permuting the columns of <span class="SimpleMath">M_1</span> with <span class="SimpleMath">π</span> maps the set of rows of <span class="SimpleMath">M_1</span> to the set of rows of <span class="SimpleMath">M_2</span>.</p>

<p><span class="SimpleMath">π</span> is of course determined only up to table automorphisms of the two character tables, that is, two transforming permutations <span class="SimpleMath">π_1</span>, <span class="SimpleMath">π_2</span> satisfy that <span class="SimpleMath">π_1 ⋅ π_2^-1</span> is a table automorphism of the first table, and <span class="SimpleMath">π_1^-1 ⋅ π_2</span> is a table automorphism of the second.</p>

<p>Clearly two isomorphic groups have permutation equivalent character tables.</p>

<p>The <strong class="pkg">GAP</strong> library function <code class="func">TransformingPermutationsCharacterTables</code> (<a href="../../../doc/ref/chap71.html#X849731AA7EC9FA73"><span class="RefLink">Reference: TransformingPermutationsCharacterTables</span></a>) returns a record that contains transforming permutations of rows and columns if the two argument tables are permutation equivalent, and <code class="keyw">fail</code> otherwise.</p>

<p>In the example sections, the following function for computing representatives from a list of character tables w.r.t. permutation equivalence will be used. More precisely, the input is either a list of character tables or a list of records which have a component <code class="code">table</code> whose value is a character table, and the output is a sublist of the input.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentativesCharacterTables:= function( list )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   local reps, entry, r;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   reps:= [];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   for entry in list do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if ForAll( reps, r -&gt; ( IsCharacterTable( r ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            TransformingPermutationsCharacterTables( entry, r ) = fail )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          or ( IsRecord( r ) and TransformingPermutationsCharacterTables(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                   entry.table, r.table ) = fail ) ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Add( reps, entry );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return reps;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end;;</span>
</pre></div>

<p><a id="X7906869F7F190E76" name="X7906869F7F190E76"></a></p>

<h5>2.2-3 <span class="Heading">Class Fusions</span></h5>

<p>For two groups <span class="SimpleMath">H</span>, <span class="SimpleMath">G</span> such that <span class="SimpleMath">H</span> is isomorphic with a subgroup of <span class="SimpleMath">G</span>, any embedding <span class="SimpleMath">ι : H → G</span> induces a class function</p>

<p class="pcenter">fus_ι : Cl(H) → Cl(G), h^G ↦ (ι(h))^G</p>

<p>the <em>class fusion</em> of <span class="SimpleMath">H</span> in <span class="SimpleMath">G</span> via <span class="SimpleMath">ι</span>. Analogously, for a normal subgroup <span class="SimpleMath">N</span> of <span class="SimpleMath">G</span>, any epimorphism <span class="SimpleMath">π : G → G/N</span> induces a class function</p>

<p class="pcenter">fus_π : Cl(G) → Cl(G/N), g^G ↦ (π(g))^G</p>

<p>the <em>class fusion</em> of <span class="SimpleMath">G</span> onto <span class="SimpleMath">G/N</span> via <span class="SimpleMath">π</span>.</p>

<p>When one works only with character tables and not with groups, these class fusions are the objects that describe subgroup and factor group relations between character tables. Technically, class fusions are necessary for restricting, inducing, and inflating characters from one character table to another. If one is faced with the problem to compute the class fusion between the character tables of two groups <span class="SimpleMath">H</span> and <span class="SimpleMath">G</span> for which it is known that <span class="SimpleMath">H</span> can be embedded into <span class="SimpleMath">G</span> then one can use character-theoretic necessary conditions, concerning that the restriction of all irreducible characters of <span class="SimpleMath">G</span> to <span class="SimpleMath">H</span> (via the class fusion) must decompose into the irreducible characters of <span class="SimpleMath">H</span>, and that the class fusion must commute with the power maps of <span class="SimpleMath">H</span> and <span class="SimpleMath">G</span>.</p>

<p>With this character-theoretic approach, one can clearly determine possible class fusions only up to character table automorphisms. Note that one can interpret each character table automorphism of <span class="SimpleMath">G</span> as a class fusion from the table of <span class="SimpleMath">G</span> to itself.</p>

<p>If <span class="SimpleMath">N</span> is a normal subgroup in <span class="SimpleMath">G</span> then the class fusion of <span class="SimpleMath">N</span> in <span class="SimpleMath">G</span> determines the orbits of the conjugation action of <span class="SimpleMath">G</span> on the classes of <span class="SimpleMath">N</span>. Often the knowledge of these orbits suffices to identify the subgroup of table automorphisms of <span class="SimpleMath">N</span> that corresponds to this action of <span class="SimpleMath">G</span>; for example, this is always the case if <span class="SimpleMath">N</span> has index <span class="SimpleMath">2</span> in <span class="SimpleMath">G</span>.</p>

<p><strong class="pkg">GAP</strong> library functions for dealing with class fusions, power maps, and character table automorphisms are described in the chapter "Maps Concerning Character Tables" in the <strong class="pkg">GAP</strong> Reference Manual.</p>

<p><a id="X80C37276851D5E39" name="X80C37276851D5E39"></a></p>

<h5>2.2-4 <span class="Heading">Constructing Character Tables of Certain Isoclinic Groups</span></h5>

<p>As is stated in <a href="chapBib.html#biBCCN85">[CCN+85, p. xxiii]</a>, two groups <span class="SimpleMath">G</span>, <span class="SimpleMath">H</span> are called <em>isoclinic</em> if they can be embedded into a group <span class="SimpleMath">K</span> such that <span class="SimpleMath">K</span> is generated by <span class="SimpleMath">Z(K)</span> and <span class="SimpleMath">G</span>, and also by <span class="SimpleMath">Z(K)</span> and <span class="SimpleMath">H</span>. In the following, two special cases of isoclinism will be used, where the character tables of the isoclinic groups are closely related.</p>


<dl>
<dt><strong class="Mark">(1)</strong></dt>
<dd><p><span class="SimpleMath">G ≅ 2 × U</span> for a group <span class="SimpleMath">U</span> that has a central subgroup <span class="SimpleMath">N</span> of order <span class="SimpleMath">2</span>, and <span class="SimpleMath">H</span> is the central product of <span class="SimpleMath">U</span> and a cyclic group of order four. Here we can set <span class="SimpleMath">K = 2 × H</span>.</p>

</dd>
<dt><strong class="Mark">(2)</strong></dt>
<dd><p><span class="SimpleMath">G ≅ 2 × U</span> for a group <span class="SimpleMath">U</span> that has a normal subgroup <span class="SimpleMath">N</span> of index <span class="SimpleMath">2</span>, and <span class="SimpleMath">H</span> is the subdirect product of <span class="SimpleMath">U</span> and a cyclic group of order four, Here we can set <span class="SimpleMath">K = 4 × U</span>.</p>

</dd>
</dl>
<p><center> <img src="ctblcons01.png" alt="two constructions of K"/> </center></p>

<p>Starting from the group <span class="SimpleMath">K</span> containing both <span class="SimpleMath">G</span> and <span class="SimpleMath">H</span>, we first note that each irreducible representation of <span class="SimpleMath">G</span> or <span class="SimpleMath">H</span> extends to <span class="SimpleMath">K</span>. More specifically, if <span class="SimpleMath">ρ_G</span> is an irreducible representation of <span class="SimpleMath">G</span> then we can define an extension <span class="SimpleMath">ρ</span> of <span class="SimpleMath">K</span> by defining it suitably on <span class="SimpleMath">Z(K)</span> and then form <span class="SimpleMath">ρ_H</span>, the restriction of <span class="SimpleMath">ρ</span> to <span class="SimpleMath">H</span>.</p>

<p>In our two cases, we set <span class="SimpleMath">S = G ∩ H</span>, so <span class="SimpleMath">K = S ∪ G ∖ S ∪ H ∖ S ∪ z S</span> holds for some element <span class="SimpleMath">z ∈ Z(K) ∖ ( G ∪ H )</span> of order four, and <span class="SimpleMath">G = S ∪ g S</span> for some <span class="SimpleMath">g ∈ G ∖ S</span>, and <span class="SimpleMath">H = S ∪ h S</span> where <span class="SimpleMath">h = z ⋅ g ∈ H ∖ S</span>. For defining <span class="SimpleMath">ρ_H</span>, it suffices to consider <span class="SimpleMath">ρ(h) = ρ(z) ρ(g)</span>, where <span class="SimpleMath">ρ(z) = ϵ_ρ(z) ⋅ I</span> is a scalar matrix.</p>

<p>As for the character table heads of <span class="SimpleMath">G</span> and <span class="SimpleMath">H</span>, we have <span class="SimpleMath">s^G = s^H</span> and <span class="SimpleMath">z (g ⋅ s)^G = (h ⋅ s)^H</span> for each <span class="SimpleMath">s ∈ S</span>, so this defines a bijection of the conjugacy classes of <span class="SimpleMath">G</span> and <span class="SimpleMath">H</span>. For a prime integer <span class="SimpleMath">p</span>, <span class="SimpleMath">(h ⋅ s)^p = (z ⋅ g ⋅ s)^p = z^p ⋅ (g ⋅ s)^p</span> holds for all <span class="SimpleMath">s ∈ S</span>, so the <span class="SimpleMath">p</span>-th power maps of <span class="SimpleMath">G</span> and <span class="SimpleMath">H</span> are related as follows: Inside <span class="SimpleMath">S</span> they coincide for any <span class="SimpleMath">p</span>. If <span class="SimpleMath">p ≡ 1 mod 4</span> they coincide also outside <span class="SimpleMath">S</span>, if <span class="SimpleMath">p ≡ -1 mod 4</span> the images differ by exchanging the classes of <span class="SimpleMath">(h ⋅ s)^p</span> and <span class="SimpleMath">z^2 ⋅ (h ⋅ s)^p</span> (if these elements lie in different classes), and for <span class="SimpleMath">p = 2</span> the images (which lie inside <span class="SimpleMath">S</span>) differ by exchanging the classes of <span class="SimpleMath">(h ⋅ s)^2</span> and <span class="SimpleMath">z^2 ⋅ (g ⋅ s)^2</span> (if these elements lie in different classes).</p>

<p>Let <span class="SimpleMath">ρ</span> be an irreducible representation of <span class="SimpleMath">K</span>. Then <span class="SimpleMath">ρ_G</span> and <span class="SimpleMath">ρ_H</span> are related as follows: <span class="SimpleMath">ρ_G(s) = ρ_H(s)</span> and <span class="SimpleMath">ρ(z) ⋅ ρ_G(g ⋅ s) = ρ_H(h ⋅ s)</span> for all <span class="SimpleMath">s ∈ S</span>. If <span class="SimpleMath">χ_G</span> and <span class="SimpleMath">χ_H</span> are the characters afforded by <span class="SimpleMath">ρ_G</span> and <span class="SimpleMath">ρ_H</span>, respectively, then <span class="SimpleMath">χ_G(s) = χ_H(s)</span> and <span class="SimpleMath">ϵ_ρ(z) ⋅ χ_G(g ⋅ s) = χ_H(h ⋅ s)</span> hold for all <span class="SimpleMath">s ∈ S</span>. In the case <span class="SimpleMath">χ_G(z^2) = χ(1)</span> we have <span class="SimpleMath">ϵ_ρ(z) = ± 1</span>, and both cases actually occur if one considers all irreducible representations of <span class="SimpleMath">K</span>. In the case <span class="SimpleMath">χ_G(z^2) = - χ(1)</span> we have <span class="SimpleMath">ϵ_ρ(z) = ± i</span>, and again both cases occur. So we obtain the irreducible characters of <span class="SimpleMath">H</span> from those of <span class="SimpleMath">G</span> by multiplying the values outside <span class="SimpleMath">S</span> in all those characters by <span class="SimpleMath">i</span> that do not have <span class="SimpleMath">z^2</span> in their kernels.</p>

<p>In <strong class="pkg">GAP</strong>, the function <code class="func">CharacterTableIsoclinic</code> (<a href="../../../doc/ref/chap71.html#X85BE46F784B83938"><span class="RefLink">Reference: CharacterTableIsoclinic</span></a>) can be used for computing the character table of <span class="SimpleMath">H</span> from that of <span class="SimpleMath">G</span>, and vice versa. (Note that in the above two cases, also the groups <span class="SimpleMath">U</span> and <span class="SimpleMath">H</span> are isoclinic by definition, but <code class="func">CharacterTableIsoclinic</code> (<a href="../../../doc/ref/chap71.html#X85BE46F784B83938"><span class="RefLink">Reference: CharacterTableIsoclinic</span></a>) does not transfer the character table of <span class="SimpleMath">U</span> to that of <span class="SimpleMath">H</span>.)</p>

<p>One could construct the character tables mentioned above by forming the character tables of certain factor groups or normal subgroups of direct products. However, the construction via <code class="func">CharacterTableIsoclinic</code> (<a href="../../../doc/ref/chap71.html#X85BE46F784B83938"><span class="RefLink">Reference: CharacterTableIsoclinic</span></a>) has the advantage that the result stores from which sources it arose, and this information can be used to derive also the Brauer character tables, provided that the Brauer character tables of the source tables are known.</p>

<p><a id="X7AEFFEEC84511FD0" name="X7AEFFEEC84511FD0"></a></p>

<h5>2.2-5 <span class="Heading">Character Tables of Isoclinic Groups of the Structure <span class="SimpleMath">p.G.p</span>
(October 2016)</span></h5>

<p>Since the release of <strong class="pkg">GAP</strong> 4.11, <code class="func">CharacterTableIsoclinic</code> (<a href="../../../doc/ref/chap71.html#X85BE46F784B83938"><span class="RefLink">Reference: CharacterTableIsoclinic</span></a>) admits the construction of the character tables of the isoclinic variants of groups of the structure <span class="SimpleMath">p.G.p</span>, also for odd primes <span class="SimpleMath">p</span>.</p>

<p>This feature will be used in the construction of the character table of <span class="SimpleMath">9.U_3(8).3_3</span>, in order to construct the table of the subgroup <span class="SimpleMath">3.(3 × U_3(8))</span> and of the factor group <span class="SimpleMath">(3 × U_3(8)).3_3</span>, see Section <a href="chap2.html#X7AF324AF7A54798F"><span class="RefLink">2.4-16</span></a>. These constructions are a straightforward generalization of those described in detail in Section <a href="chap2.html#X80C37276851D5E39"><span class="RefLink">2.2-4</span></a>.</p>

<p>There are several examples of <strong class="pkg">Atlas</strong> groups of the structure <span class="SimpleMath">3.G.3</span>. The character table of one such group is shown in the <strong class="pkg">Atlas</strong>, the tables of their isoclinic variants can now be obtained from <code class="func">CharacterTableIsoclinic</code> (<a href="../../../doc/ref/chap71.html#X85BE46F784B83938"><span class="RefLink">Reference: CharacterTableIsoclinic</span></a>).</p>

<p>For example, the group GL<span class="SimpleMath">(3,4)</span> has the structure <span class="SimpleMath">3.L_3(4).3</span>. There are three pairwise nonisomorphic isoclinic variants of groups of this structure.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "3.L3(4).3" );</span>
CharacterTable( "3.L3(4).3" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso1:= CharacterTableIsoclinic( t );</span>
CharacterTable( "Isoclinic(3.L3(4).3,1)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso2:= CharacterTableIsoclinic( t, rec( k:= 2 ) );</span>
CharacterTable( "Isoclinic(3.L3(4).3,2)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( t, iso1 );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( t, iso2 );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( iso1, iso2 );</span>
fail
</pre></div>

<p>The character table of GL<span class="SimpleMath">(3,4)</span> is in fact the one which is shown in the <strong class="pkg">Atlas</strong>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( t,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( GL( 3, 4 ) ) ) );</span>
true
</pre></div>

<p><a id="X78F41D2A78E70BEE" name="X78F41D2A78E70BEE"></a></p>

<h5>2.2-6 <span class="Heading">Isoclinic Double Covers of Almost Simple Groups</span></h5>

<p>The function <code class="func">CharacterTableIsoclinic</code> (<a href="../../../doc/ref/chap71.html#X85BE46F784B83938"><span class="RefLink">Reference: CharacterTableIsoclinic</span></a>) can also be used to switch between the character tables of double covers of groups of the type <span class="SimpleMath">G.2</span>, where <span class="SimpleMath">G</span> is a perfect group, see <a href="chapBib.html#biBCCN85">[CCN+85, Section 6.7]</a>. Typical examples are the double covers of symmetric groups.</p>

<p>Note that these double covers may be isomorphic. This happens for <span class="SimpleMath">2.S_6</span>. More generally, this happens for all semilinear groups <span class="SimpleMath">Σ</span>L<span class="SimpleMath">(2,p^2)</span>, for odd primes <span class="SimpleMath">p</span>. The smallest examples are <span class="SimpleMath">Σ</span>L<span class="SimpleMath">(2,9) = 2.A_6.2_1</span> and <span class="SimpleMath">Σ</span>L<span class="SimpleMath">(2,25) = 2.L_2(25).2_2</span>. This implies that the character table and its isoclinic variant are permutation isomorphic.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "2.A6.2_1" );</span>
CharacterTable( "2.A6.2_1" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( t,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTableIsoclinic( t ) );</span>
rec( columns := (4,6)(5,7)(11,12)(14,16)(15,17), 
  group := Group([ (16,17), (14,15) ]), 
  rows := (3,5)(4,6)(10,11)(12,15,13,14) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "2.L2(25).2_2" );</span>
CharacterTable( "2.L2(25).2_2" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( t,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTableIsoclinic( t ) );</span>
rec( columns := (7,9)(8,10)(20,21)(23,24)(25,27)(26,28), 
  group := &lt;permutation group with 4 generators&gt;, 
  rows := (3,5)(4,6)(14,15)(16,17)(19,22,20,21) )
</pre></div>

<p>For groups of the type <span class="SimpleMath">4.G.2</span>, two different situations can occur. Either the distinguished central cyclic subgroup of order four in <span class="SimpleMath">4.G</span> is inverted by the elements in <span class="SimpleMath">4.G.2 ∖ 4.G</span>, or this subgroup is central in <span class="SimpleMath">4.G.2</span>. In the first case, calling <code class="func">CharacterTableIsoclinic</code> (<a href="../../../doc/ref/chap71.html#X85BE46F784B83938"><span class="RefLink">Reference: CharacterTableIsoclinic</span></a>) with the character table of <span class="SimpleMath">4.G.2</span> yields a character table with the same set of irreducibles, only the <span class="SimpleMath">2</span>-power map will in general differ from that of the input table. In the second case, the one argument version of <code class="func">CharacterTableIsoclinic</code> (<a href="../../../doc/ref/chap71.html#X85BE46F784B83938"><span class="RefLink">Reference: CharacterTableIsoclinic</span></a>) returns a permutation isomorphic table. By supplying additional arguments, there is a chance to construct tables of different groups.</p>

<p>We demonstrate this phenomenon with the various groups of the structure <span class="SimpleMath">4.L_3(4).2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for m in [ "4_1", "4_2" ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     for a in [ "2_1", "2_2", "2_3" ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Add( tbls, CharacterTable( Concatenation( m, ".L3(4).", a ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls;</span>
[ CharacterTable( "4_1.L3(4).2_1" ), CharacterTable( "4_1.L3(4).2_2" )
    , CharacterTable( "4_1.L3(4).2_3" ), 
  CharacterTable( "4_2.L3(4).2_1" ), CharacterTable( "4_2.L3(4).2_2" )
    , CharacterTable( "4_2.L3(4).2_3" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">case1:= Filtered( tbls, t -&gt; Size( ClassPositionsOfCentre( t ) ) = 2 );</span>
[ CharacterTable( "4_1.L3(4).2_1" ), CharacterTable( "4_1.L3(4).2_2" )
    , CharacterTable( "4_2.L3(4).2_1" ), 
  CharacterTable( "4_2.L3(4).2_3" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">case2:= Filtered( tbls, t -&gt; Size( ClassPositionsOfCentre( t ) ) = 4 );</span>
[ CharacterTable( "4_1.L3(4).2_3" ), 
  CharacterTable( "4_2.L3(4).2_2" ) ]
</pre></div>

<p>The centres of the groups <span class="SimpleMath">4_1.L_3(4).2_1</span>, <span class="SimpleMath">4_1.L_3(4).2_2</span>, <span class="SimpleMath">4_2.L_3(4).2_1</span>, and <span class="SimpleMath">4_2.L_3(4).2_3</span> have order two, that is, these groups belong to the first case. Each of these groups is not permutation equivalent to its isoclinic variant but has the same irreducible characters.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isos1:= List( case1, CharacterTableIsoclinic );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( [ 1 .. 4 ], i -&gt; Irr( case1[i] ) = Irr( isos1[i] ) );</span>
[ true, true, true, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( [ 1 .. 4 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     i -&gt; TransformingPermutationsCharacterTables( case1[i], isos1[i] ) );</span>
[ fail, fail, fail, fail ]
</pre></div>

<p>The groups <span class="SimpleMath">4_1.L_3(4).2_3</span> and <span class="SimpleMath">4_2.L_3(4).2_2</span> belong to the second case because their centres have order four.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isos2:= List( case2, CharacterTableIsoclinic );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( [ 1, 2 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     i -&gt; TransformingPermutationsCharacterTables( case2[i], isos2[i] ) );</span>
[ rec( columns := (26,27,28,29)(30,31,32,33)(38,39,40,41)(42,43,44,45)
        , group := &lt;permutation group with 5 generators&gt;, 
      rows := (16,17)(18,19)(20,21)(22,23)(28,29)(32,33)(36,37)(40,
        41) ), 
  rec( columns := (28,29,30,31)(32,33)(34,35,36,37)(38,39,40,41)(42,
        43,44,45)(46,47,48,49), 
      group := &lt;permutation group with 3 generators&gt;, 
      rows := (15,16)(17,18)(20,21)(22,23)(24,25)(26,27)(28,29)(34,
        35)(38,39)(42,43)(46,47) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isos3:= List( case2, t -&gt; CharacterTableIsoclinic( t,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                               ClassPositionsOfCentre( t ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( [ 1, 2 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     i -&gt; TransformingPermutationsCharacterTables( case2[i], isos3[i] ) );</span>
[ fail, fail ]
</pre></div>

<p><a id="X834B42A07E98FBC6" name="X834B42A07E98FBC6"></a></p>

<h5>2.2-7 <span class="Heading">Characters of Normal Subgroups</span></h5>

<p>Let <span class="SimpleMath">G</span> be a group and <span class="SimpleMath">N</span> be a normal subgroup of <span class="SimpleMath">G</span>. We will need the following well-known facts about the relation between the irreducible characters of <span class="SimpleMath">G</span> and <span class="SimpleMath">N</span>.</p>

<p>For an irreducible (Brauer) character <span class="SimpleMath">χ</span> of <span class="SimpleMath">N</span> and <span class="SimpleMath">g ∈ G</span>, we define <span class="SimpleMath">χ^g</span> by <span class="SimpleMath">χ^g(n) = χ(n^g)</span> for all <span class="SimpleMath">n ∈ N</span>, and set <span class="SimpleMath">I_G(χ) = { g ∈ G; χ^g = χ }</span> (see <a href="chapBib.html#biBFeit82">[Fei82, p. 86]</a>).</p>

<p>If <span class="SimpleMath">I_G(χ) = N</span> then the induced character <span class="SimpleMath">χ^G</span> is an irreducible (Brauer) character of <span class="SimpleMath">G</span> (see <a href="chapBib.html#biBFeit82">[Fei82, Lemma III 2.11]</a> or <a href="chapBib.html#biBNav98">[Nav98, Theorem 8.9]</a> or <a href="chapBib.html#biBLP10">[LP10, Corollary 4.3.8]</a>).</p>

<p>If <span class="SimpleMath">G/N</span> is cyclic and if <span class="SimpleMath">I_G(χ) = G</span> then <span class="SimpleMath">χ = ψ_N</span> for an irreducible (Brauer) character <span class="SimpleMath">ψ</span> of <span class="SimpleMath">G</span>, and each irreducible (Brauer) character <span class="SimpleMath">θ</span> with the property <span class="SimpleMath">χ = θ_N</span> is of the form <span class="SimpleMath">θ = ψ ⋅ ϵ</span>, where <span class="SimpleMath">ϵ</span> is an irreducible (Brauer) character of <span class="SimpleMath">G/N</span> (see <a href="chapBib.html#biBFeit82">[Fei82, Theorem III 2.14]</a> or <a href="chapBib.html#biBNav98">[Nav98, Theorem 8.12]</a> or <a href="chapBib.html#biBLP10">[LP10, Theorem 3.6.13]</a>).</p>

<p>Clifford's theorem (<a href="chapBib.html#biBFeit82">[Fei82, Theorem III 2.12]</a> or <a href="chapBib.html#biBNav98">[Nav98, Corollary 8.7]</a> or <a href="chapBib.html#biBLP10">[LP10, Theorem 3.6.2]</a>) states that the restriction of an irreducible (Brauer) character of <span class="SimpleMath">G</span> to <span class="SimpleMath">N</span> has the form <span class="SimpleMath">e ∑_i=1^t φ_i</span> for a positive integer <span class="SimpleMath">e</span> and irreducible (Brauer) characters <span class="SimpleMath">φ_i</span> of <span class="SimpleMath">N</span>, where <span class="SimpleMath">t</span> is the index of <span class="SimpleMath">I_G(φ_1)</span> in <span class="SimpleMath">G</span>.</p>

<p>Now assume that <span class="SimpleMath">G</span> is a normal subgroup in a larger group <span class="SimpleMath">H</span>, that <span class="SimpleMath">G/N</span> is an abelian chief factor of <span class="SimpleMath">H</span> and that <span class="SimpleMath">ψ</span> is an ordinary irreducible character of <span class="SimpleMath">G</span> such that <span class="SimpleMath">I_H(ψ) = H</span>. Then either <span class="SimpleMath">t = 1</span> and <span class="SimpleMath">e^2</span> is one of <span class="SimpleMath">1</span>, <span class="SimpleMath">|G/N|</span>, or <span class="SimpleMath">t = |G/N|</span> and <span class="SimpleMath">e = 1</span> (see <a href="chapBib.html#biBIsa76">[Isa76, Theorem 6.18]</a>).</p>

<p><a id="X787F430E7FDB8765" name="X787F430E7FDB8765"></a></p>

<h4>2.3 <span class="Heading">The Constructions</span></h4>

<p><a id="X82E75B6880EC9E6C" name="X82E75B6880EC9E6C"></a></p>

<h5>2.3-1 <span class="Heading">Character Tables of Groups of the Structure <span class="SimpleMath">M.G.A</span></span></h5>

<p>(This kind of table construction is described in <a href="chapBib.html#biBBre11">[Bre11]</a>.)</p>

<p>Let <span class="SimpleMath">N</span> denote a downward extension of the finite group <span class="SimpleMath">G</span> by a finite group <span class="SimpleMath">M</span>, let <span class="SimpleMath">H</span> denote an automorphic (upward) extension of <span class="SimpleMath">N</span> by a finite cyclic group <span class="SimpleMath">A</span> such that <span class="SimpleMath">M</span> is normal in <span class="SimpleMath">H</span>, and set <span class="SimpleMath">F = H / M</span>. We consider the situation that each irreducible character of <span class="SimpleMath">N</span> that does not contain <span class="SimpleMath">M</span> in its kernel induces irreducibly to <span class="SimpleMath">H</span>. Equivalently, the action of <span class="SimpleMath">A = ⟨ a ⟩</span> on the characters of <span class="SimpleMath">N</span>, via <span class="SimpleMath">χ ↦ χ^a</span>, has only orbits of length exactly <span class="SimpleMath">|A|</span> on the set <span class="SimpleMath">{ χ ∈ Irr(N); M ⊈ ker(χ) }</span>.</p>

<p><center> <img src="ctblcons02.png" alt="groups of the structure M.G.A"/> </center></p>

<p>This occurs for example if <span class="SimpleMath">M</span> is central in <span class="SimpleMath">N</span> and <span class="SimpleMath">A</span> acts fixed-point freely on <span class="SimpleMath">M</span>, we have <span class="SimpleMath">|M| ≡ 1 mod |A|</span> in this case. If <span class="SimpleMath">M</span> has prime order then it is sufficient that <span class="SimpleMath">A</span> does not centralize <span class="SimpleMath">M</span>.</p>

<p>The ordinary (or <span class="SimpleMath">p</span>-modular) irreducible characters of <span class="SimpleMath">H</span> are then given by the ordinary (or <span class="SimpleMath">p</span>-modular) irreducible characters of <span class="SimpleMath">F</span> and <span class="SimpleMath">N</span>, the class fusions from the table of <span class="SimpleMath">N</span> onto the table of <span class="SimpleMath">G</span> and from the table of <span class="SimpleMath">G</span> into that of <span class="SimpleMath">F</span>, and the permutation <span class="SimpleMath">π</span> that is induced by the action of <span class="SimpleMath">A</span> on the conjugacy classes of <span class="SimpleMath">N</span>.</p>

<p>In general, the action of <span class="SimpleMath">A</span> on the classes of <span class="SimpleMath">M</span> is not the right thing to look at, one really must consider the action on the relevant characters of <span class="SimpleMath">M.G</span>. For example, take <span class="SimpleMath">H</span> the quaternion group or the dihedral group of order eight, <span class="SimpleMath">N</span> a cyclic subgroup of index two, and <span class="SimpleMath">M</span> the centre of <span class="SimpleMath">H</span>; here <span class="SimpleMath">A</span> acts trivially on <span class="SimpleMath">M</span>, but the relevant fact is that the action of <span class="SimpleMath">A</span> swaps those two irreducible characters of <span class="SimpleMath">N</span> that take the value <span class="SimpleMath">-1</span> on the involution in <span class="SimpleMath">M</span> –these are the faithful irreducible characters of <span class="SimpleMath">N</span>.</p>

<p>If the orders of <span class="SimpleMath">M</span> and <span class="SimpleMath">A</span> are coprime then also the power maps of <span class="SimpleMath">H</span> can be computed from the above data. For each prime <span class="SimpleMath">p</span> that divides the orders of both <span class="SimpleMath">M</span> and <span class="SimpleMath">A</span>, the <span class="SimpleMath">p</span>-th power map is in general not uniquely determined by these input data. In this case, we can compute the (finitely many) candidates for the character table of <span class="SimpleMath">H</span> that are described by these data. One possible reason for ambiguities is the existence of several isoclinic but nonisomorphic groups that can arise from the input tables (cf. Section <a href="chap2.html#X80C37276851D5E39"><span class="RefLink">2.2-4</span></a>, see Section <a href="chap2.html#X83724BCE86FCD77B"><span class="RefLink">2.4-12</span></a> for an example).</p>

<p>With the <strong class="pkg">GAP</strong> function <code class="func">PossibleActionsForTypeMGA</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7899AA12836EEF8F"><span class="RefLink">CTblLib: PossibleActionsForTypeMGA</span></a>), one can compute the possible orbit structures induced by <span class="SimpleMath">G.A</span> on the classes of <span class="SimpleMath">M.G</span>, and <code class="func">PossibleCharacterTablesOfTypeMGA</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X78F82DD67E083B88"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeMGA</span></a>) computes the possible ordinary character tables for a given orbit structure. For constructing the <span class="SimpleMath">p</span>-modular Brauer table of a group <span class="SimpleMath">H</span> of the structure <span class="SimpleMath">M.G.A</span>, the <strong class="pkg">GAP</strong> function <code class="func">BrauerTableOfTypeMGA</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X83BE977185ADC24B"><span class="RefLink">CTblLib: BrauerTableOfTypeMGA</span></a>) takes the ordinary character table of <span class="SimpleMath">H</span> and the <span class="SimpleMath">p</span>-modular tables of the subgroup <span class="SimpleMath">M.G</span> and the factor group <span class="SimpleMath">G.A</span> as its input. The <span class="SimpleMath">p</span>-modular table of <span class="SimpleMath">G</span> is not explicitly needed in the construction, it is implicitly given by the class fusions from <span class="SimpleMath">M.G</span> into <span class="SimpleMath">M.G.A</span> and from <span class="SimpleMath">M.G.A</span> onto <span class="SimpleMath">G.A</span>; these class fusions must of course be available.</p>

<p>The <strong class="pkg">GAP</strong> Character Table Library contains many tables of groups of the structure <span class="SimpleMath">M.G.A</span> as described above, which are encoded by references to the tables of the groups <span class="SimpleMath">M.G</span> and <span class="SimpleMath">G.A</span>, plus the fusion and action information. This reduces the space needed for storing these character tables.</p>

<p>For examples, see Section <a href="chap2.html#X817D2134829FA8FA"><span class="RefLink">2.4</span></a>.</p>

<p><a id="X7CCABDDE864E6300" name="X7CCABDDE864E6300"></a></p>

<h5>2.3-2 <span class="Heading">Character Tables of Groups of the Structure <span class="SimpleMath">G.S_3</span></span></h5>

<p>Let <span class="SimpleMath">G</span> be a finite group, and <span class="SimpleMath">H</span> be an upward extension of <span class="SimpleMath">G</span> such that the factor group <span class="SimpleMath">H / G</span> is a Frobenius group <span class="SimpleMath">F = K C</span> with abelian kernel <span class="SimpleMath">K</span> and cyclic complement <span class="SimpleMath">C</span> of prime order <span class="SimpleMath">c</span>. (Typical cases for <span class="SimpleMath">F</span> are the symmetric group <span class="SimpleMath">S_3</span> on three points and the alternating group <span class="SimpleMath">A_4</span> on four points.) Let <span class="SimpleMath">N</span> and <span class="SimpleMath">U</span> denote the preimages of <span class="SimpleMath">K</span> and <span class="SimpleMath">C</span> under the natural epimorphism from <span class="SimpleMath">H</span> onto <span class="SimpleMath">F</span>.</p>

<p><center> <img src="ctblcons03.png" alt="Groups of the structure G.3.2"/> </center></p>

<p>For certain isomorphism types of <span class="SimpleMath">F</span>, the ordinary (or <span class="SimpleMath">p</span>-modular) character table of <span class="SimpleMath">H</span> can be computed from the ordinary (or <span class="SimpleMath">p</span>-modular) character tables of <span class="SimpleMath">G</span>, <span class="SimpleMath">U</span>, and <span class="SimpleMath">N</span>, the class fusions from the table of <span class="SimpleMath">G</span> into those of <span class="SimpleMath">U</span> and <span class="SimpleMath">N</span>, and the permutation <span class="SimpleMath">π</span> induced by <span class="SimpleMath">H</span> on the conjugacy classes of <span class="SimpleMath">N</span>. This holds for example for <span class="SimpleMath">F = S_3</span> and in the ordinary case also for <span class="SimpleMath">F = A_4</span>.</p>

<p>Each class of <span class="SimpleMath">H</span> is either a union of <span class="SimpleMath">π</span>-orbits or an <span class="SimpleMath">H</span>-class of <span class="SimpleMath">U ∖ G</span>; the latter classes are in bijection with the <span class="SimpleMath">U</span>-classes of <span class="SimpleMath">U ∖ G</span>, they are just <span class="SimpleMath">|K|</span> times larger since the <span class="SimpleMath">|K|</span> conjugates of <span class="SimpleMath">U</span> in <span class="SimpleMath">H</span> are fused. The power maps of <span class="SimpleMath">H</span> are uniquely determined from the power maps of <span class="SimpleMath">U</span> and <span class="SimpleMath">N</span>, because each element in <span class="SimpleMath">F</span> lies in <span class="SimpleMath">K</span> or in an <span class="SimpleMath">F</span>-conjugate of <span class="SimpleMath">C</span>.</p>

<p>Concerning the computation of the ordinary irreducible characters of <span class="SimpleMath">H</span>, we could induce the irreducible characters of <span class="SimpleMath">U</span> and <span class="SimpleMath">N</span> to <span class="SimpleMath">H</span>, and then take the union of the irreducible characters among those and the irreducible differences of those. (For the case <span class="SimpleMath">F = S_3</span>, this approach has been described in the Appendix of <a href="chapBib.html#biBHL94">[HL94]</a>.)</p>

<p>The <strong class="pkg">GAP</strong> function <code class="func">CharacterTableOfTypeGS3</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7E06095E7CB3316D"><span class="RefLink">CTblLib: CharacterTableOfTypeGS3</span></a>) proceeds in a different way, which is suitable also for the construction of <span class="SimpleMath">p</span>-modular character tables of <span class="SimpleMath">H</span>.</p>

<p>By the facts listed in Section <a href="chap2.html#X834B42A07E98FBC6"><span class="RefLink">2.2-7</span></a>, for an irreducible (Brauer) character <span class="SimpleMath">χ</span> of <span class="SimpleMath">N</span>, we have <span class="SimpleMath">I_H(χ)</span> equal to either <span class="SimpleMath">N</span> or <span class="SimpleMath">H</span>. In the former case, <span class="SimpleMath">χ</span> induces irreducibly to <span class="SimpleMath">H</span>. In the latter case, there are extensions <span class="SimpleMath">ψ^(i)</span>, <span class="SimpleMath">1 ≤ i ≤ |C|</span> (or <span class="SimpleMath">|C|_p^'</span>), to <span class="SimpleMath">H</span>, and we have the following possibilities, depending on the restriction <span class="SimpleMath">χ_G</span>.</p>

<p>If <span class="SimpleMath">χ_G = e φ</span>, for an irreducible character <span class="SimpleMath">φ</span> of <span class="SimpleMath">G</span>, then <span class="SimpleMath">I_U(φ) = U</span> holds, hence the <span class="SimpleMath">ψ^(i)_U</span> are <span class="SimpleMath">|C|</span> (or <span class="SimpleMath">|C|_p^'</span>) extensions of <span class="SimpleMath">χ_G</span> to <span class="SimpleMath">U</span>. Moreover, we have either <span class="SimpleMath">e = 1</span> or <span class="SimpleMath">e^2 = |K|</span>. In the case <span class="SimpleMath">e = 1</span>, this determines the values of the <span class="SimpleMath">ψ^(i)</span> on the classes of <span class="SimpleMath">U</span> outside <span class="SimpleMath">G</span>. In the case <span class="SimpleMath">e ≠ 1</span>, we have the problem to combine <span class="SimpleMath">e</span> extensions of <span class="SimpleMath">φ</span> to a character of <span class="SimpleMath">U</span> that extends to <span class="SimpleMath">H</span>.</p>

<p>(One additional piece of information in the case of ordinary character tables is that the norm of this linear combination equals <span class="SimpleMath">1 + (|K|-1)/|C|</span>, which determines the <span class="SimpleMath">ψ^(i)_U</span> if <span class="SimpleMath">F = A_4 ≅ 2^2:3</span> or <span class="SimpleMath">F = 2^3:7</span> holds; in the former case, the sum of each two out of the three different extensions of <span class="SimpleMath">φ</span> extends to <span class="SimpleMath">U</span>; in the latter case, the sum of all different extensions plus one of the extensions extends. Note that for <span class="SimpleMath">F = S_3</span>, the case <span class="SimpleMath">e ≠ 1</span> does not occur.)</p>

<p>The remaining case is that <span class="SimpleMath">χ_G</span> is not a multiple of an irreducible character of <span class="SimpleMath">G</span>. Then <span class="SimpleMath">χ_G = φ_1 + φ_2 + ... + φ_|K|</span>, for pairwise different irreducible characters <span class="SimpleMath">φ_i</span>, <span class="SimpleMath">1 ≤ i ≤ |K|</span>, of <span class="SimpleMath">G</span> with the property <span class="SimpleMath">φ_i^N = χ</span>. The action of <span class="SimpleMath">U</span> on <span class="SimpleMath">G</span> fixes at least one of the <span class="SimpleMath">φ_i</span>, since <span class="SimpleMath">|K| ≡ 1 mod |C|</span>. Without loss of generality, let <span class="SimpleMath">I_U(φ_1) = U</span>, and let <span class="SimpleMath">φ_1^(i)</span>, <span class="SimpleMath">1 ≤ i ≤ |C|</span>, be the extensions of <span class="SimpleMath">φ_1</span> to <span class="SimpleMath">U</span>. (In fact exactly <span class="SimpleMath">φ_1</span> is fixed by <span class="SimpleMath">U</span> since otherwise <span class="SimpleMath">k ∈ K</span> would exist with <span class="SimpleMath">φ_1^k ≠ φ_1</span> and such that also <span class="SimpleMath">φ_1^k</span> would be invariant in <span class="SimpleMath">U</span>; but then <span class="SimpleMath">φ_1</span> would be invariant under both <span class="SimpleMath">C</span> and <span class="SimpleMath">C^k</span>, which generate <span class="SimpleMath">F</span>. So each of the <span class="SimpleMath">|K|</span> constituents is invariant in exactly one of the <span class="SimpleMath">|K|</span> subgroups of type <span class="SimpleMath">U</span> above <span class="SimpleMath">G</span>.)</p>

<p>Then <span class="SimpleMath">((φ_1^(i))^H)_N = φ_1^N = χ</span>, hence the values of <span class="SimpleMath">ψ^(i)</span> on the classes of <span class="SimpleMath">U ∖ G</span> are given by those of <span class="SimpleMath">(φ_1^(i))^H</span>. (These are exactly the values of <span class="SimpleMath">φ_1^(i)</span>. So in both cases, we take the values of <span class="SimpleMath">χ</span> on <span class="SimpleMath">N</span>, and on the classes of <span class="SimpleMath">U ∖ G</span> the values of the extensions of the unique extendible constituent of <span class="SimpleMath">χ_G</span>.)</p>

<p>For examples, see Section <a href="chap2.html#X7F50C782840F06E4"><span class="RefLink">2.5</span></a>.</p>

<p><a id="X7D3EF3BC83BE05CF" name="X7D3EF3BC83BE05CF"></a></p>

<h5>2.3-3 <span class="Heading">Character Tables of Groups of the Structure <span class="SimpleMath">G.2^2</span></span></h5>

<p>Let <span class="SimpleMath">G</span> be a finite group, and <span class="SimpleMath">H</span> be an upward extension of <span class="SimpleMath">G</span> such that the factor group <span class="SimpleMath">H / G</span> is a Klein four group. We assume that the ordinary character tables of <span class="SimpleMath">G</span> and of the three index two subgroups <span class="SimpleMath">U_1</span>, <span class="SimpleMath">U_2</span>, and <span class="SimpleMath">U_3</span> (of the structures <span class="SimpleMath">G.2_1</span>, <span class="SimpleMath">G.2_2</span>, and <span class="SimpleMath">G.2_3</span>, respectively) of <span class="SimpleMath">H</span> above <span class="SimpleMath">G</span> are known, as well as the class fusions of <span class="SimpleMath">G</span> into these groups. The idea behind the method that is described in this section is that in this situation, there are only few possibilities for the ordinary character table of <span class="SimpleMath">H</span>.</p>

<p><center> <img src="ctblcons04.png" alt="groups of the structure G.V4"/> </center></p>

<p>Namely, the action of <span class="SimpleMath">H</span> on the classes of <span class="SimpleMath">G.2_i</span> is given by a table automorphism <span class="SimpleMath">π_i</span> of <span class="SimpleMath">G.2_i</span>, and <span class="SimpleMath">H</span> realizes compatible choices of such automorphisms <span class="SimpleMath">π_1</span>, <span class="SimpleMath">π_2</span>, <span class="SimpleMath">π_3</span> in the sense that the orbits of all three <span class="SimpleMath">π_i</span> on the classes of <span class="SimpleMath">G</span> inside the groups <span class="SimpleMath">G.2_i</span> coincide. Furthermore, if <span class="SimpleMath">G.2_i</span> has <span class="SimpleMath">n_i</span> conjugacy classes then an action <span class="SimpleMath">π_i</span> that is a product of <span class="SimpleMath">f_i</span> disjoint transpositions leads to a character table candidate for <span class="SimpleMath">G.2^2</span> that has <span class="SimpleMath">2 n_i - 3 f_i</span> classes, so also the <span class="SimpleMath">f_i</span> must be compatible.</p>

<p>Taking the "inner" classes, i.e., the orbit sums of the classes inside <span class="SimpleMath">G</span> under the <span class="SimpleMath">π_i</span>, plus the union of the <span class="SimpleMath">π_i</span>-orbits of the classes of <span class="SimpleMath">G.2_i ∖ G</span> gives a possibility for the classes of <span class="SimpleMath">H</span>. Furthermore, the power maps of the groups <span class="SimpleMath">G.2_i</span> determine the power maps of the candidate table constructed this way.</p>

<p>Concerning the computation of the irreducible characters of <span class="SimpleMath">H</span>, we consider also the case of <span class="SimpleMath">p</span>-modular characters tables, where we assume that the ordinary character table of <span class="SimpleMath">H</span> is already known and the only task is to compute the irreducible <span class="SimpleMath">p</span>-modular Brauer characters.</p>

<p>Let <span class="SimpleMath">χ</span> be an irreducible (<span class="SimpleMath">p</span>-modular Brauer) character of <span class="SimpleMath">G</span>. By the facts that are listed in Section <a href="chap2.html#X834B42A07E98FBC6"><span class="RefLink">2.2-7</span></a>, there are three possibilities.</p>


<dl>
<dt><strong class="Mark">1.</strong></dt>
<dd><p><span class="SimpleMath">I_H(χ) = G</span>; then <span class="SimpleMath">χ^H</span> is irreducible.</p>

</dd>
<dt><strong class="Mark">2.</strong></dt>
<dd><p><span class="SimpleMath">I_H(χ) = G.2_i</span> for <span class="SimpleMath">i</span> one of <span class="SimpleMath">1</span>, <span class="SimpleMath">2</span>, <span class="SimpleMath">3</span>; then <span class="SimpleMath">I_G.2_i(χ) = G.2_i</span> for this <span class="SimpleMath">i</span>, so <span class="SimpleMath">χ</span> extends to <span class="SimpleMath">G.2_i</span>; none of these extensions extends to <span class="SimpleMath">H</span> (because otherwise <span class="SimpleMath">χ</span> would be invariant in <span class="SimpleMath">H</span>), so they induce irreducible characters of <span class="SimpleMath">H</span>.</p>

</dd>
<dt><strong class="Mark">3.</strong></dt>
<dd><p><span class="SimpleMath">I_H(χ) = H</span>; then <span class="SimpleMath">χ</span> extends to each of the three groups <span class="SimpleMath">G.2_i</span>, and either all these extensions induce the same character of <span class="SimpleMath">H</span> (which vanishes on <span class="SimpleMath">H ∖ G</span>) or they are invariant in <span class="SimpleMath">H</span> and thus extend to <span class="SimpleMath">H</span>.</p>

</dd>
</dl>
<p>In the latter part of case 3. (except if <span class="SimpleMath">p = 2</span>), the problem is to combine the values of six irreducible characters of the groups <span class="SimpleMath">G.2_i</span> to four characters of <span class="SimpleMath">H</span>. This yields essentially two choices, and we try to exclude one possibility by forming scalar products with the <span class="SimpleMath">2</span>-nd symmetrizations of the known irreducibles. If several possibilities remain then we get several possible tables.</p>

<p>So we end up with a list of possible character tables of <span class="SimpleMath">H</span>. The first step is to specify a list of possible triples <span class="SimpleMath">(π_1, π_2, π_3)</span>, using the table automorphisms of the groups <span class="SimpleMath">G.2_i</span>; this can be done using the <strong class="pkg">GAP</strong> function <code class="func">PossibleActionsForTypeGV4</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7CCD5A2979883144"><span class="RefLink">CTblLib: PossibleActionsForTypeGV4</span></a>). Then the <strong class="pkg">GAP</strong> function <code class="func">PossibleCharacterTablesOfTypeGV4</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7CACDDED7A8C1CF9"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeGV4</span></a>) can be used for computing the character table candidates for each given triple of permutations; it may of course happen that some triples of automorphisms are excluded in this second step.</p>

<p>For examples, see Section <a href="chap2.html#X7EA489E07D7C7D86"><span class="RefLink">2.6</span></a>.</p>

<p><a id="X81464C4B8178C85A" name="X81464C4B8178C85A"></a></p>

<h5>2.3-4 <span class="Heading">Character Tables of Groups of the Structure <span class="SimpleMath">2^2.G</span>
(August 2005)</span></h5>

<p>Let <span class="SimpleMath">G</span> be a finite group, and <span class="SimpleMath">H</span> be a central extension of <span class="SimpleMath">G</span> by a Klein four group <span class="SimpleMath">Z = ⟨ z_1, z_2 ⟩</span>; set <span class="SimpleMath">z_3 = z_1 z_2</span> and <span class="SimpleMath">Z_i = ⟨ z_i ⟩</span>, for <span class="SimpleMath">1 ≤ i ≤ 3</span>. We assume that the ordinary character tables of the three factor groups <span class="SimpleMath">2_i.G = H / Z_i</span> of <span class="SimpleMath">H</span> are known, as well as the class fusions from these groups to <span class="SimpleMath">G</span>. The idea behind the method described in this section is that in this situation, there are only few possibilities for the ordinary character table of <span class="SimpleMath">H</span>.</p>

<p><center> <img src="ctblcons05.png" alt="groups of the structure V4.G"/> </center></p>

<p>Namely, the irreducible (<span class="SimpleMath">p</span>-modular) characters of <span class="SimpleMath">H</span> are exactly the inflations of the irreducible (<span class="SimpleMath">p</span>-modular) characters of the three factor groups <span class="SimpleMath">H / Z_i</span>. (Note that for any noncyclic central subgroup <span class="SimpleMath">C</span> of <span class="SimpleMath">H</span> and any <span class="SimpleMath">χ ∈ Irr(H)</span>, we have <span class="SimpleMath">|ker(χ) ∩ C| &gt; 1</span>. To see this, let <span class="SimpleMath">N = ker(χ)</span>. Then clearly <span class="SimpleMath">|N| &gt; 1</span>, and <span class="SimpleMath">χ</span> can be regarded as a faithful irreducible character of <span class="SimpleMath">H/N</span>. If <span class="SimpleMath">N ∩ C</span> would be trivial then <span class="SimpleMath">N C / N ≅ C</span> would be a noncyclic central subgroup of <span class="SimpleMath">H/N</span>. This cannot happen by <a href="chapBib.html#biBIsa76">[Isa76, Thm. 2.32 (a)]</a>, so the statement can be regarded as an obvious refinement of this theorem.) So all we have to construct is the character table head of <span class="SimpleMath">H</span> –classes and power maps– and the factor fusions from <span class="SimpleMath">H</span> to these groups.</p>

<p>For fixed <span class="SimpleMath">h ∈ H</span>, we consider the question in which <span class="SimpleMath">H</span>-classes the elements <span class="SimpleMath">h</span>, <span class="SimpleMath">h z_1</span>, <span class="SimpleMath">h z_2</span>, and <span class="SimpleMath">h z_3</span> lie. There are three possibilities.</p>

<ol>
<li><p>The four elements are all conjugate in <span class="SimpleMath">H</span>. Then in each of the three groups <span class="SimpleMath">H/Z_i</span>, the two preimages of <span class="SimpleMath">h Z ∈ H/Z</span> are conjugate.</p>

</li>
<li><p>We are not in case 1. but two of the four elements are conjugate in <span class="SimpleMath">H</span>, i. e., <span class="SimpleMath">g^-1 h g = h z_i</span> for some <span class="SimpleMath">g ∈ H</span> and some <span class="SimpleMath">i</span>; then <span class="SimpleMath">g^-1 h z_j g = h z_i z_j</span> for each <span class="SimpleMath">j</span>, so the four elements lie in exactly two <span class="SimpleMath">H</span>-classes. This implies that for <span class="SimpleMath">i ≠ j</span>, the elements <span class="SimpleMath">h</span> and <span class="SimpleMath">h z_j</span> are not <span class="SimpleMath">H</span>-conjugate, so <span class="SimpleMath">h Z_i</span> is not conjugate to <span class="SimpleMath">h z_j Z_i</span> in <span class="SimpleMath">H/Z_i</span> and <span class="SimpleMath">h Z_j</span> is conjugate to <span class="SimpleMath">h z_i Z_j</span> in <span class="SimpleMath">H/Z_j</span>.</p>

</li>
<li><p>The four elements are pairwise nonconjugate in <span class="SimpleMath">H</span>. Then in each of the three groups <span class="SimpleMath">H/Z_i</span>, the two preimages of <span class="SimpleMath">h Z ∈ H/Z</span> are nonconjugate.</p>

</li>
</ol>
<p>We observe that the question which case actually applies for <span class="SimpleMath">h ∈ H</span> can be decided from the three factor fusions from <span class="SimpleMath">H/Z_i</span> to <span class="SimpleMath">G</span>. So we attempt to construct the table head of <span class="SimpleMath">H</span> and the three factor fusions from <span class="SimpleMath">H</span> to the groups <span class="SimpleMath">H/Z_i</span>, as follows. Each class <span class="SimpleMath">g^G</span> of <span class="SimpleMath">G</span> yields either one or two or four preimage classes in <span class="SimpleMath">H</span>.</p>

<p>In case 1., we get one preimage class in <span class="SimpleMath">H</span>, and have no choice for the factor fusions.</p>

<p>In case 2., we get two preimage classes, there is exactly one group <span class="SimpleMath">H/Z_i</span> in which <span class="SimpleMath">g^G</span> has two preimage classes –which are in bijection with the two preimage classes of <span class="SimpleMath">H</span>– and for the other two groups <span class="SimpleMath">H/Z_j</span>, the factor fusions from <span class="SimpleMath">H</span> map the two classes of <span class="SimpleMath">H</span> to the unique preimage class of <span class="SimpleMath">g^G</span>. (In the following picture, this is shown for <span class="SimpleMath">i = 1</span>.)</p>

<p><center> <img src="ctblcons06.png" alt="Two preimages for a class"/> </center></p>

<p>In case 3., the three factor fusions are in general not uniquely determined: We get four classes, which are defined as two pairs of preimages of the two preimages of <span class="SimpleMath">g^G</span> in <span class="SimpleMath">H/Z_1</span> and in <span class="SimpleMath">H/Z_2</span> –so we choose the relevant images in the two factor fusions to <span class="SimpleMath">H/Z_1</span> and <span class="SimpleMath">H/Z_2</span>, respectively. Note that the class of <span class="SimpleMath">h</span> in <span class="SimpleMath">H</span> is the unique class that maps to the class of <span class="SimpleMath">h Z_1</span> in <span class="SimpleMath">H/Z_1</span> and to the class of <span class="SimpleMath">h Z_2</span> in <span class="SimpleMath">H/Z_2</span>, and so on, and we define four classes of <span class="SimpleMath">H</span> via the four possible combinations of image classes in <span class="SimpleMath">H/Z_1</span> and <span class="SimpleMath">H/Z_2</span> (see the picture below).</p>

<p><center> <img src="ctblcons07.png" alt="Four preimages for a class (part 1)"/> </center></p>

<p>Due to the fact that in general we do not know which of the two preimage classes of <span class="SimpleMath">g^G</span> in <span class="SimpleMath">H/Z_3</span> is the class of <span class="SimpleMath">h Z_3</span>, there are in general the following <em>two</em> possibilities for the fusion from <span class="SimpleMath">H</span> to <span class="SimpleMath">H/Z_3</span>.</p>

<p><center> <img src="ctblcons08.png" alt="Four preimages for a class (part 2)"/> </center></p>

<p>This means that we can inflate the irreducible characters of <span class="SimpleMath">H/Z_1</span> and of <span class="SimpleMath">H/Z_2</span> to <span class="SimpleMath">H</span> but that for the inflations of those irreducible characters of <span class="SimpleMath">H/Z_3</span> to <span class="SimpleMath">H</span> that are not characters of <span class="SimpleMath">G</span>, the values on classes where case 3. applies are determined only up to sign.</p>

<p>The <strong class="pkg">GAP</strong> function <code class="func">PossibleCharacterTablesOfTypeV4G</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7E7043A5857B9240"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeV4G</span></a>) computes the candidates for the table of <span class="SimpleMath">H</span> from the tables of the groups <span class="SimpleMath">H/Z_i</span> by setting up the character table head of <span class="SimpleMath">H</span> using the class fusions from <span class="SimpleMath">H/Z_1</span> and <span class="SimpleMath">H/Z_2</span> to <span class="SimpleMath">G</span>, and then forming the possible class fusions from <span class="SimpleMath">H</span> to <span class="SimpleMath">H/Z_3</span>.</p>

<p>If case 3. applies for a class <span class="SimpleMath">g^G</span> with <span class="SimpleMath">g</span> of <em>odd</em> element order then exactly one preimage class in <span class="SimpleMath">H</span> has odd element order, and we can identify this class in the groups <span class="SimpleMath">H/Z_i</span>, which resolves the ambiguity in this situation. More generally, if <span class="SimpleMath">g = k^2</span> holds for some <span class="SimpleMath">k ∈ G</span> then all preimages of <span class="SimpleMath">k^G</span> in <span class="SimpleMath">H</span> square to the same class of <span class="SimpleMath">H</span>, so again this class can be identified. In fact <code class="func">PossibleCharacterTablesOfTypeV4G</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7E7043A5857B9240"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeV4G</span></a>) checks whether the <span class="SimpleMath">p</span>-th power maps of the candidate table for <span class="SimpleMath">H</span> and the <span class="SimpleMath">p</span>-th power map of <span class="SimpleMath">H/Z_3</span> together with the fusion candidate form a commutative diagram.</p>

<p>An additional criterion used by <code class="func">PossibleCharacterTablesOfTypeV4G</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7E7043A5857B9240"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeV4G</span></a>) is given by the property that the product of two characters inflated from <span class="SimpleMath">H/Z_1</span> and <span class="SimpleMath">H/Z_2</span>, respectively, that are not characters of <span class="SimpleMath">G</span> is a character of <span class="SimpleMath">H</span> that contains <span class="SimpleMath">Z_3</span> in its kernel, so it is checked whether the scalar products of these characters with all characters that are inflated from <span class="SimpleMath">H/Z_3</span> via the candidate fusion are nonnegative integers.</p>

<p>Once the fusions from <span class="SimpleMath">H</span> to the groups <span class="SimpleMath">H/Z_i</span> are known, the computation of the irreducible <span class="SimpleMath">p</span>-modular characters of <span class="SimpleMath">H</span> from those of the groups <span class="SimpleMath">H/Z_i</span> is straightforward.</p>

<p>The only open question is why this construction is described in this note. That is, how is it related to table automorphisms?</p>

<p>The answer is that in several interesting cases, the three subgroups <span class="SimpleMath">Z_1</span>, <span class="SimpleMath">Z_2</span>, <span class="SimpleMath">Z_3</span> are conjugate under an order three automorphism <span class="SimpleMath">σ</span>, say, of <span class="SimpleMath">H</span>. In this situation, the three factor groups <span class="SimpleMath">2_i.G = H/Z_i</span> are isomorphic, and we can describe the input tables and fusions by the character table of <span class="SimpleMath">2_1.G</span>, the factor fusion from this group to <span class="SimpleMath">G</span>, and the automorphism <span class="SimpleMath">σ'</span> of <span class="SimpleMath">G</span> that is induced by <span class="SimpleMath">σ</span>. Assume that <span class="SimpleMath">σ(Z_1) = Z_2</span> holds, and choose <span class="SimpleMath">h ∈ H</span>. Then <span class="SimpleMath">σ(h Z_1) = σ(h) Z_2</span> is mapped to <span class="SimpleMath">σ(h) Z = σ'(h Z)</span> under the factor fusion from <span class="SimpleMath">2_2.G</span> to <span class="SimpleMath">G</span>. Let us start with the character table of <span class="SimpleMath">2_1.G</span>, and fix the class fusion to the character table of <span class="SimpleMath">G</span>. We may choose the identity map as isomorphism from the table of <span class="SimpleMath">2_1.G</span> to the tables of <span class="SimpleMath">2_2.G</span> and <span class="SimpleMath">2_3.G</span>, which implies that the class of <span class="SimpleMath">h Z_1</span> is identified with the class of <span class="SimpleMath">h Z_2</span> and in turn the class fusion from the table of <span class="SimpleMath">2_2.G</span> to that of <span class="SimpleMath">G</span> can be chosen as the class fusion from the table of <span class="SimpleMath">2_1.G</span> followed by the permutation of classes of <span class="SimpleMath">G</span> induced by <span class="SimpleMath">σ'</span>; analogously, the fusion from the table of <span class="SimpleMath">2_3.G</span> is obtained by applying this permutation twice to the class fusion from the table of <span class="SimpleMath">2_1.G</span>.</p>

<p>For examples, see Section <a href="chap2.html#X845BAA2A7FD768B0"><span class="RefLink">2.7</span></a>.</p>

<p><a id="X86CF6A607B0827EE" name="X86CF6A607B0827EE"></a></p>

<h5>2.3-5 <span class="Heading"><span class="SimpleMath">p</span>-Modular Tables of Extensions by <span class="SimpleMath">p</span>-singular Automorphisms</span></h5>

<p>Let <span class="SimpleMath">G</span> be a finite group, and <span class="SimpleMath">H</span> be an upward extension of <span class="SimpleMath">G</span> by an automorphism of prime order <span class="SimpleMath">p</span>, say. <span class="SimpleMath">H</span> induces a table automorphism of the <span class="SimpleMath">p</span>-modular character table of <span class="SimpleMath">G</span>; let <span class="SimpleMath">π</span> denote the corresponding permutation of classes of <span class="SimpleMath">G</span>. The columns of the <span class="SimpleMath">p</span>-modular character table of <span class="SimpleMath">H</span> are given by the orbits of <span class="SimpleMath">π</span>, and the irreducible Brauer characters of <span class="SimpleMath">H</span> are exactly the orbit sums of <span class="SimpleMath">π</span> on the irreducible Brauer characters of <span class="SimpleMath">G</span>.</p>

<p>Note that for computing the <span class="SimpleMath">p</span>-modular character table of <span class="SimpleMath">H</span> from that of <span class="SimpleMath">G</span>, it is sufficient to know the orbits of <span class="SimpleMath">π</span> and not <span class="SimpleMath">π</span> itself. Also the ordinary character table of <span class="SimpleMath">H</span> is not needed, but since <strong class="pkg">GAP</strong> stores Brauer character tables relative to their ordinary tables, we are interested mainly in cases where the ordinary character tables of <span class="SimpleMath">G</span> and <span class="SimpleMath">H</span> and the <span class="SimpleMath">p</span>-modular character table of <span class="SimpleMath">G</span> are known. Assuming that the class fusion between the ordinary tables of <span class="SimpleMath">G</span> and <span class="SimpleMath">H</span> is stored on the table of <span class="SimpleMath">G</span>, the orbits of the action of <span class="SimpleMath">H</span> on the <span class="SimpleMath">p</span>-regular classes of <span class="SimpleMath">G</span> can be read off from it.</p>

<p>The <strong class="pkg">GAP</strong> function <code class="func">IBrOfExtensionBySingularAutomorphism</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7AF3EA6C783FCFF9"><span class="RefLink">CTblLib: IBrOfExtensionBySingularAutomorphism</span></a>) can be used to compute the <span class="SimpleMath">p</span>-modular irreducibles of <span class="SimpleMath">H</span>.</p>

<p>For examples, see Section <a href="chap2.html#X8711DBB083655A25"><span class="RefLink">2.8</span></a>.</p>

<p><a id="X788591D78451C024" name="X788591D78451C024"></a></p>

<h5>2.3-6 <span class="Heading">Character Tables of Subdirect Products of Index Two (July 2007)</span></h5>

<p>Let <span class="SimpleMath">C_2</span> denote the cyclic group of order two, let <span class="SimpleMath">G_1</span>, <span class="SimpleMath">G_2</span> be two finite groups, and for <span class="SimpleMath">i ∈ { 1, 2 }</span>, let <span class="SimpleMath">φ_i: G_i → C_2</span> be an epimorphism with kernel <span class="SimpleMath">H_i</span>. Let <span class="SimpleMath">G</span> be the subdirect product (pullback) of <span class="SimpleMath">G_1</span> and <span class="SimpleMath">G_2</span> w.r.t. the epimorphisms <span class="SimpleMath">φ_i</span>, i.e.,</p>

<p class="pcenter">G = { (g_1, g_2) ∈ G_1 × G_2; φ_1(g_1) = φ_2(g_2) } .</p>

<p>The group <span class="SimpleMath">G</span> has index two in the direct product <span class="SimpleMath">G_1 × G_2</span>, and <span class="SimpleMath">G</span> contains <span class="SimpleMath">H_1 × H_2</span> as a subgroup of index two.</p>

<p>In the following, we describe how the ordinary (or <span class="SimpleMath">p</span>-modular) character table of <span class="SimpleMath">G</span> can be computed from the ordinary (or <span class="SimpleMath">p</span>-modular) character tables of the groups <span class="SimpleMath">G_i</span> and <span class="SimpleMath">H_i</span>, and the class fusions from <span class="SimpleMath">H_i</span> to <span class="SimpleMath">G_i</span>.</p>

<p>(For the case that one of the groups <span class="SimpleMath">G_i</span> is a cyclic group of order four, an alternative way to construct the character table of <span class="SimpleMath">G</span> is described in Section <a href="chap2.html#X80C37276851D5E39"><span class="RefLink">2.2-4</span></a>. For the case that one of the groups <span class="SimpleMath">G_i</span> acts fixed point freely on the nontrivial irreducible characters of <span class="SimpleMath">H_i</span>, an alternative construction is described in Section <a href="chap2.html#X82E75B6880EC9E6C"><span class="RefLink">2.3-1</span></a>.)</p>

<p><center> <img src="ctblcons09.png" alt="Subdirect products of index two"/> </center></p>

<p>Each conjugacy class of <span class="SimpleMath">G</span> is either contained in <span class="SimpleMath">H_1 × H_2</span> or not. In the former case, let <span class="SimpleMath">h_i ∈ H_i</span> and <span class="SimpleMath">g_i ∈ G_i ∖ H_i</span>; in particular, <span class="SimpleMath">(g_1, g_2) ∈ G</span> because both <span class="SimpleMath">φ_1(g_1)</span> and <span class="SimpleMath">φ_2(g_2)</span> are not the identity. There are four possibilities.</p>


<dl>
<dt><strong class="Mark">1.</strong></dt>
<dd><p>If <span class="SimpleMath">h_1^{H_1} = h_1^{G_1}</span> and <span class="SimpleMath">h_2^{H_2} = h_2^{G_2}</span> then <span class="SimpleMath">(h_1, h_2)^{H_1 × H_2} = (h_1, h_2)^{G_1 × G_2}</span> holds, hence this class is equal to <span class="SimpleMath">(h_1, h_2)^G</span>.</p>

</dd>
<dt><strong class="Mark">2.</strong></dt>
<dd><p>If <span class="SimpleMath">h_1^{H_1} ≠ h_1^{G_1}</span> and <span class="SimpleMath">h_2^{H_2} ≠ h_2^{G_2}</span> then the four <span class="SimpleMath">H_1 × H_2</span>-classes with the representatives <span class="SimpleMath">(h_1, h_2)</span>, <span class="SimpleMath">(h_1^{g_1}, h_2)</span>, <span class="SimpleMath">(h_1, h_2^{g_2})</span>, and <span class="SimpleMath">(h_1^{g_1}, h_2^{g_2})</span> fall into two <span class="SimpleMath">G</span>-classes, where <span class="SimpleMath">(h_1, h_2)</span> is <span class="SimpleMath">G</span>-conjugate with <span class="SimpleMath">(h_1^{g_1}, h_2^{g_2})</span>, and <span class="SimpleMath">(h_1^{g_1}, h_2)</span> is <span class="SimpleMath">G</span>-conjugate with <span class="SimpleMath">(h_1, h_2^{g_2})</span>.</p>

</dd>
<dt><strong class="Mark">3.</strong></dt>
<dd><p>If <span class="SimpleMath">h_1^{H_1} = h_1^{G_1}</span> and <span class="SimpleMath">h_2^{H_2} ≠ h_2^{G_2}</span> then the two <span class="SimpleMath">H_1 × H_2</span>-classes with the representatives <span class="SimpleMath">(h_1, h_2)</span> and <span class="SimpleMath">(h_1, h_2^{g_2})</span> fuse in <span class="SimpleMath">G</span>; note that there is <span class="SimpleMath">tildeg_1 ∈ C_{G_1}(h_1) ∖ H_1</span>, so <span class="SimpleMath">(tildeg_1, g_2) ∈ G</span> holds.</p>

</dd>
<dt><strong class="Mark">4.</strong></dt>
<dd><p>The case of <span class="SimpleMath">h_1^{H_1} ≠ h_1^{G_1}</span> and <span class="SimpleMath">h_2^{H_2} = h_2^{G_2}</span> is analogous to case 3.</p>

</dd>
</dl>
<p>It remains to deal with the <span class="SimpleMath">G</span>-classes that are not contained in <span class="SimpleMath">H_1 × H_2</span>. Each such class is in fact a conjugacy class of <span class="SimpleMath">G_1 × G_2</span>. Note that two elements <span class="SimpleMath">g_1, g_2 ∈ G_1 ∖ H_1</span> are <span class="SimpleMath">G_1</span>-conjugate if and only if they are <span class="SimpleMath">H_1</span>-conjugate. (If <span class="SimpleMath">g_1^x = g_2</span> for <span class="SimpleMath">x ∈ G_1 ∖ H_1</span> then <span class="SimpleMath">g_1^{g_1 x} = g_2</span> holds, and <span class="SimpleMath">g_1 x ∈ H_1</span>.) This implies <span class="SimpleMath">(g_1, g_2)^{G_1 × G_2} = (g_1, g_2)^{H_1 × H_2}</span>, and thus this class is equal to <span class="SimpleMath">(g_1, g_2)^G</span>.</p>

<p>The (ordinary or <span class="SimpleMath">p</span>-modular) irreducible characters of <span class="SimpleMath">G</span> are given by the restrictions <span class="SimpleMath">χ_G</span> of all those irreducible characters <span class="SimpleMath">χ</span> of <span class="SimpleMath">G_1 × G_2</span> whose restriction to <span class="SimpleMath">H_1 × H_2</span> is irreducible, plus the induced characters <span class="SimpleMath">φ^G</span>, where <span class="SimpleMath">φ</span> runs over all those irreducible characters of <span class="SimpleMath">H_1 × H_2</span> that do not occur as restrictions of characters of <span class="SimpleMath">G_1 × G_2</span>.</p>

<p>In other words, no irreducible character of <span class="SimpleMath">H_1 × H_2</span> has inertia subgroup <span class="SimpleMath">G</span> inside <span class="SimpleMath">G_1 × G_2</span>. This can be seen as follows. Let <span class="SimpleMath">φ</span> be an irreducible character of <span class="SimpleMath">H_1 × H_2</span>. Then <span class="SimpleMath">φ = φ_1 ⋅ φ_2</span>, where <span class="SimpleMath">φ_1</span>, <span class="SimpleMath">φ_2</span> are irreducible characters of <span class="SimpleMath">H_1 × H_2</span> with the properties that <span class="SimpleMath">H_2 ⊆ ker(φ_1)</span> and <span class="SimpleMath">H_1 ⊆ ker(φ_2)</span>. Sloppy speaking, <span class="SimpleMath">φ_i</span> is an irreducible character of <span class="SimpleMath">H_i</span>.</p>

<p>There are four possibilities.</p>

<ol>
<li><p>If <span class="SimpleMath">φ_1</span> extends to <span class="SimpleMath">G_1</span> and <span class="SimpleMath">φ_2</span> extends to <span class="SimpleMath">G_2</span> then <span class="SimpleMath">φ</span> extends to <span class="SimpleMath">G</span>, so <span class="SimpleMath">φ</span> has inertia subgroup <span class="SimpleMath">G_1 × G_2</span>.</p>

</li>
<li><p>If <span class="SimpleMath">φ_1</span> does not extend to <span class="SimpleMath">G_1</span> and <span class="SimpleMath">φ_2</span> does not extend to <span class="SimpleMath">G_2</span> then <span class="SimpleMath">φ^{G_1 × G_2}</span> is irreducible, so <span class="SimpleMath">φ</span> has inertia subgroup <span class="SimpleMath">H_1 × H_2</span>.</p>

</li>
<li><p>If <span class="SimpleMath">φ_1</span> extends to <span class="SimpleMath">G_1</span> and <span class="SimpleMath">φ_2</span> does not extend to <span class="SimpleMath">G_2</span> then <span class="SimpleMath">φ</span> extends to <span class="SimpleMath">G_1 × H_2</span> but not to <span class="SimpleMath">G_1 × G_2</span>, so <span class="SimpleMath">φ</span> has inertia subgroup <span class="SimpleMath">G_1 × H_2</span>.</p>

</li>
<li><p>The case that <span class="SimpleMath">φ_1</span> does not extend to <span class="SimpleMath">G_1</span> and <span class="SimpleMath">φ_2</span> extends to <span class="SimpleMath">G_2</span> is analogous to case 3, <span class="SimpleMath">φ</span> has inertia subgroup <span class="SimpleMath">H_1 × G_2</span>.</p>

</li>
</ol>
<p>For examples, see Section <a href="chap2.html#X7A4D6044865E516B"><span class="RefLink">2.9</span></a>.</p>

<p><a id="X817D2134829FA8FA" name="X817D2134829FA8FA"></a></p>

<h4>2.4 <span class="Heading">Examples for the Type <span class="SimpleMath">M.G.A</span></span></h4>

<p><a id="X7F2DBAB48437052C" name="X7F2DBAB48437052C"></a></p>

<h5>2.4-1 <span class="Heading">Character Tables of Dihedral Groups</span></h5>

<p>Let <span class="SimpleMath">n = 2^k ⋅ m</span> where <span class="SimpleMath">k</span> is a nonnegative integer and <span class="SimpleMath">m</span> is an odd integer, and consider the dihedral group <span class="SimpleMath">D_2n</span> of order <span class="SimpleMath">2n</span>. Let <span class="SimpleMath">N</span> denote the derived subgroup of <span class="SimpleMath">D_2n</span>.</p>

<p>If <span class="SimpleMath">k = 0</span> then <span class="SimpleMath">D_2n</span> has the structure <span class="SimpleMath">M.G.A</span>, with <span class="SimpleMath">M = N</span> and <span class="SimpleMath">G</span> the trivial group, and <span class="SimpleMath">A</span> a cyclic group of order two that inverts each element of <span class="SimpleMath">N</span> and hence acts fixed-point freely on <span class="SimpleMath">N</span>. The smallest nontrivial example is of course that of <span class="SimpleMath">D_6 ≅ S_3</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG:= CharacterTable( "Cyclic", 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "Cyclic", 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblMG, [ 1, 1, 1 ], tblG );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblG, [ 1 ], tblGA );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= Elements( AutomorphismsOfTable( tblMG ) );</span>
[ (), (2,3) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= [ [ 1 ], [ 2, 3 ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">new:= PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, orbs,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             "S3" );</span>
[ rec( MGfusMGA := [ 1, 2, 2 ], table := CharacterTable( "S3" ) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( new[1].table );</span>
S3

     2  1  .  1
     3  1  1  .

       1a 3a 2a
    2P 1a 3a 1a
    3P 1a 1a 2a

X.1     1  1  1
X.2     1  1 -1
X.3     2 -1  .
</pre></div>

<p>If <span class="SimpleMath">k &gt; 0</span> then <span class="SimpleMath">D_2n</span> has the structure <span class="SimpleMath">M.G.A</span>, with <span class="SimpleMath">M = N</span> and <span class="SimpleMath">G</span> a cyclic group of order two such that <span class="SimpleMath">M.G</span> is cyclic, and <span class="SimpleMath">A</span> is a cyclic group of order two that inverts each element of <span class="SimpleMath">M.G</span> and hence acts fixed-point freely on <span class="SimpleMath">M.G</span>. The smallest nontrivial example is of course that of <span class="SimpleMath">D_8</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG:= CharacterTable( "Cyclic", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA:= CharacterTable( "2^2" );;           </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( tblMG );</span>
[ 1, 4, 2, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblMG, [ 1, 2, 1, 2 ], tblG ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblG, [ 1, 2 ], tblGA );      </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= Elements( AutomorphismsOfTable( tblMG ) );</span>
[ (), (2,4) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= Orbits( Group( elms[2] ), [ 1 ..4 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">new:= PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, orbs,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             "order8" );</span>
[ rec( MGfusMGA := [ 1, 2, 3, 2 ], 
      table := CharacterTable( "order8" ) ), 
  rec( MGfusMGA := [ 1, 2, 3, 2 ], 
      table := CharacterTable( "order8" ) ) ]
</pre></div>

<p>Here we get two possible tables, which are the character tables of the dihedral and the quaternion group of order eight, respectively.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( new, x -&gt; OrdersClassRepresentatives( x.table ) );</span>
[ [ 1, 4, 2, 2, 2 ], [ 1, 4, 2, 4, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( new[1].table );</span>
order8

     2  3  2  3  2  2

       1a 4a 2a 2b 2c
    2P 1a 2a 1a 1a 1a

X.1     1  1  1  1  1
X.2     1  1  1 -1 -1
X.3     1 -1  1  1 -1
X.4     1 -1  1 -1  1
X.5     2  . -2  .  .
</pre></div>

<p>For each <span class="SimpleMath">k &gt; 1</span> and <span class="SimpleMath">m = 1</span>, we get two possible tables this way, that of the dihedral group of order <span class="SimpleMath">2^k+1</span> and that of the generalized quaternion group of order <span class="SimpleMath">2^k+1</span>.</p>

<p><a id="X7925DBFA7C5986B5" name="X7925DBFA7C5986B5"></a></p>

<h5>2.4-2 <span class="Heading">An <span class="SimpleMath">M.G.A</span> Type Example with <span class="SimpleMath">M</span> noncentral in <span class="SimpleMath">M.G</span> (May 2004)</span></h5>

<p>The Sylow <span class="SimpleMath">7</span> normalizer in the symmetric group <span class="SimpleMath">S_12</span> has the structure <span class="SimpleMath">7:6 × S_5</span>, its intersection <span class="SimpleMath">N</span> with the alternating group <span class="SimpleMath">A_12</span> is of index two, it has the structure <span class="SimpleMath">(7:3 × A_5):2</span>.</p>

<p>Let <span class="SimpleMath">M</span> denote the normal subgroup of order <span class="SimpleMath">7</span> in <span class="SimpleMath">N</span>, let <span class="SimpleMath">G</span> denote the normal subgroup of the type <span class="SimpleMath">3 × A_5</span> in <span class="SimpleMath">F = N/M ≅ 3 × S_5</span>, and <span class="SimpleMath">A = F/G</span>, the cyclic group of order two. Then <span class="SimpleMath">N</span> has the structure <span class="SimpleMath">M.G.A</span>, where <span class="SimpleMath">A</span> acts fixed-point freely on the irreducible characters of <span class="SimpleMath">M.G = 7:3 × A_5</span> that do not contain <span class="SimpleMath">M</span> in their kernels, hence the character table of <span class="SimpleMath">N</span> is determined by the character tables of <span class="SimpleMath">M.G</span> and <span class="SimpleMath">F</span>, and the action of <span class="SimpleMath">A</span> on <span class="SimpleMath">M.G</span>.</p>

<p>Note that in this example, the group <span class="SimpleMath">M</span> is not central in <span class="SimpleMath">M.G</span>, unlike in most of our examples.</p>

<p><center> <img src="ctblcons10.png" alt="The structure of (7:3 x A_5):2)"/> </center></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG:= CharacterTable( "7:3" ) * CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= ClassPositionsOfNormalSubgroups( tblMG );</span>
[ [ 1 ], [ 1, 6 .. 11 ], [ 1 .. 5 ], [ 1, 6 .. 21 ], [ 1 .. 15 ], 
  [ 1 .. 25 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( nsg, x -&gt; Sum( SizesConjugacyClasses( tblMG ){ x } ) );</span>
[ 1, 7, 60, 21, 420, 1260 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= tblMG / nsg[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA:= CharacterTable( "Cyclic", 3 ) * CharacterTable( "A5.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GfusGA:= PossibleClassFusions( tblG, tblGA );</span>
[ [ 1, 2, 3, 4, 4, 8, 9, 10, 11, 11, 15, 16, 17, 18, 18 ], 
  [ 1, 2, 3, 4, 4, 15, 16, 17, 18, 18, 8, 9, 10, 11, 11 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= RepresentativesFusions( Group(()), GfusGA, tblGA );</span>
[ [ 1, 2, 3, 4, 4, 8, 9, 10, 11, 11, 15, 16, 17, 18, 18 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblG, reps[1], tblGA );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">acts:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );</span>
[ [ [ 1 ], [ 2 ], [ 3 ], [ 4, 5 ], [ 6, 11 ], [ 7, 12 ], [ 8, 13 ], 
      [ 9, 15 ], [ 10, 14 ], [ 16 ], [ 17 ], [ 18 ], [ 19, 20 ], 
      [ 21 ], [ 22 ], [ 23 ], [ 24, 25 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              acts[1], "A12N7" );</span>
[ rec( 
      MGfusMGA := [ 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 5, 6, 7, 9, 8, 10, 
          11, 12, 13, 13, 14, 15, 16, 17, 17 ], 
      table := CharacterTable( "A12N7" ) ) ]
</pre></div>

<p>Let us compare the result table with the table of the Sylow <span class="SimpleMath">7</span> normalizer in <span class="SimpleMath">A_12</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= AlternatingGroup( 12 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( poss[1].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               CharacterTable( Normalizer( g, SylowSubgroup( g, 7 ) ) ) ) );</span>
true
</pre></div>

<p>Since July 2007, an alternative way to construct the character table of <span class="SimpleMath">N</span> from other character tables is to exploit its structure as a subdirect product of index two in the group <span class="SimpleMath">7:6 × S_5</span>, see Section <a href="chap2.html#X788591D78451C024"><span class="RefLink">2.3-6</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblh1:= CharacterTable( "7:3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblg1:= CharacterTable( "7:6" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblh2:= CharacterTable( "A5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblg2:= CharacterTable( "A5.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">subdir:= CharacterTableOfIndexTwoSubdirectProduct( tblh1, tblg1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                tblh2, tblg2, "(7:3xA5).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( poss[1].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               subdir.table ) );</span>
true
</pre></div>

<p>For storing the table of <span class="SimpleMath">N</span> in the <strong class="pkg">GAP</strong> Character Table Library, the construction as a subdirect product is more suitable, since the "auxiliary table" of the direct product <span class="SimpleMath">7:3 × A_5</span> need not be stored in the library.</p>

<p><a id="X7ED45AB379093A70" name="X7ED45AB379093A70"></a></p>

<h5>2.4-3 <span class="Heading"><strong class="pkg">Atlas</strong> Tables of the Type <span class="SimpleMath">M.G.A</span></span></h5>

<p>We show the construction of some character tables of groups of the type <span class="SimpleMath">M.G.A</span> that are contained in the <strong class="pkg">GAP</strong> Character Table Library. Each entry in the following input list contains the names of the library character tables of <span class="SimpleMath">M.G</span>, <span class="SimpleMath">G</span>, <span class="SimpleMath">G.A</span>, and <span class="SimpleMath">M.G.A</span>.</p>

<p>First we consider the situation where <span class="SimpleMath">G</span> is a simple group or a central extension of a simple group whose character table is shown in the <strong class="pkg">Atlas</strong>, and <span class="SimpleMath">M</span> and <span class="SimpleMath">A</span> are cyclic groups such that <span class="SimpleMath">M</span> is central in <span class="SimpleMath">M.G</span>.</p>

<p>In the following cases, the character tables are uniquely determined by the input tables. Note that in each of these cases, <span class="SimpleMath">|A|</span> and <span class="SimpleMath">|M|</span> are coprime.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">listMGA:= [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.A6",        "A6",        "A6.2_1",        "3.A6.2_1"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.A6",        "A6",        "A6.2_2",        "3.A6.2_2"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6.A6",        "2.A6",      "2.A6.2_1",      "6.A6.2_1"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6.A6",        "2.A6",      "2.A6.2_2",      "6.A6.2_2"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.A7",        "A7",        "A7.2",          "3.A7.2"         ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6.A7",        "2.A7",      "2.A7.2",        "6.A7.2"         ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.L3(4)",     "L3(4)",     "L3(4).2_2",     "3.L3(4).2_2"    ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.L3(4)",     "L3(4)",     "L3(4).2_3",     "3.L3(4).2_3"    ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6.L3(4)",     "2.L3(4)",   "2.L3(4).2_2",   "6.L3(4).2_2"    ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6.L3(4)",     "2.L3(4)",   "2.L3(4).2_3",   "6.L3(4).2_3"    ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "12_1.L3(4)",  "4_1.L3(4)", "4_1.L3(4).2_2", "12_1.L3(4).2_2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "12_1.L3(4)",  "4_1.L3(4)", "4_1.L3(4).2_3", "12_1.L3(4).2_3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "12_2.L3(4)",  "4_2.L3(4)", "4_2.L3(4).2_2", "12_2.L3(4).2_2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "12_2.L3(4)",  "4_2.L3(4)", "4_2.L3(4).2_3", "12_2.L3(4).2_3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.U3(5)",     "U3(5)",     "U3(5).2",       "3.U3(5).2"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.M22",       "M22",       "M22.2",         "3.M22.2"        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6.M22",       "2.M22",     "2.M22.2",       "6.M22.2"        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "12.M22",      "4.M22",     "4.M22.2",       "12.M22.2"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.L3(7)",     "L3(7)",     "L3(7).2",       "3.L3(7).2"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3_1.U4(3)",   "U4(3)",     "U4(3).2_1",     "3_1.U4(3).2_1"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3_1.U4(3)",   "U4(3)",     "U4(3).2_2'",    "3_1.U4(3).2_2'" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3_2.U4(3)",   "U4(3)",     "U4(3).2_1",     "3_2.U4(3).2_1"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3_2.U4(3)",   "U4(3)",     "U4(3).2_3'",    "3_2.U4(3).2_3'" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6_1.U4(3)",   "2.U4(3)",   "2.U4(3).2_1",   "6_1.U4(3).2_1"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6_1.U4(3)",   "2.U4(3)",   "2.U4(3).2_2'",  "6_1.U4(3).2_2'" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6_2.U4(3)",   "2.U4(3)",   "2.U4(3).2_1",   "6_2.U4(3).2_1"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6_2.U4(3)",   "2.U4(3)",   "2.U4(3).2_3'",  "6_2.U4(3).2_3'" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "12_1.U4(3)",  "4.U4(3)",   "4.U4(3).2_1",   "12_1.U4(3).2_1" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "12_2.U4(3)",  "4.U4(3)",   "4.U4(3).2_1",   "12_2.U4(3).2_1" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.G2(3)",     "G2(3)",     "G2(3).2",       "3.G2(3).2"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.U3(8)",     "U3(8)",     "U3(8).2",       "3.U3(8).2"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.U3(8).3_1", "U3(8).3_1", "U3(8).6",       "3.U3(8).6"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.J3",        "J3",        "J3.2",          "3.J3.2"         ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.U3(11)",    "U3(11)",    "U3(11).2",      "3.U3(11).2"     ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.McL",       "McL",       "McL.2",         "3.McL.2"        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.O7(3)",     "O7(3)",     "O7(3).2",       "3.O7(3).2"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6.O7(3)",     "2.O7(3)",   "2.O7(3).2",     "6.O7(3).2"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.U6(2)",     "U6(2)",     "U6(2).2",       "3.U6(2).2"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6.U6(2)",     "2.U6(2)",   "2.U6(2).2",     "6.U6(2).2"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.Suz",       "Suz",       "Suz.2",         "3.Suz.2"        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6.Suz",       "2.Suz",     "2.Suz.2",       "6.Suz.2"        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.ON",        "ON",        "ON.2",          "3.ON.2"         ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.Fi22",      "Fi22",      "Fi22.2",        "3.Fi22.2"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6.Fi22",      "2.Fi22",    "2.Fi22.2",      "6.Fi22.2"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.2E6(2)",    "2E6(2)",    "2E6(2).2",      "3.2E6(2).2"     ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "6.2E6(2)",    "2.2E6(2)",  "2.2E6(2).2",    "6.2E6(2).2"     ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.F3+",       "F3+",       "F3+.2",         "3.F3+.2"        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">];;</span>
</pre></div>

<p>(We need not consider groups <span class="SimpleMath">3.U_3(8).6'</span> and <span class="SimpleMath">3.U_3(8).6'</span>, see Section <a href="chap2.html#X8379003582D06130"><span class="RefLink">2.4-7</span></a>.)</p>

<p>Note that the groups of the types <span class="SimpleMath">12_1.L_3(4).2_1</span> and <span class="SimpleMath">12_2.L_3(4).2_1</span> have central subgroups of order six, so we cannot choose <span class="SimpleMath">G</span> equal to <span class="SimpleMath">4_1.L_3(4)</span> and <span class="SimpleMath">4_2.L_3(4)</span>, respectively, in these cases. See Section <a href="chap2.html#X7A236EDE7A7A28F9"><span class="RefLink">2.4-4</span></a> for the construction of these tables.</p>

<p>Also in the following cases, <span class="SimpleMath">|A|</span> and <span class="SimpleMath">|M|</span> are coprime, we have <span class="SimpleMath">|M| = 3</span> and <span class="SimpleMath">|A| = 2</span>. The group <span class="SimpleMath">M.G</span> has a central subgroup of the type <span class="SimpleMath">2^2 × 3</span>, and <span class="SimpleMath">A</span> acts on this group by inverting the elements in the subgroup of order <span class="SimpleMath">3</span> and by swapping two involutions in the Klein four group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( listMGA, [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "(2^2x3).L3(4)",  "2^2.L3(4)",   "2^2.L3(4).2_2", "(2^2x3).L3(4).2_2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "(2^2x3).L3(4)",  "2^2.L3(4)",   "2^2.L3(4).2_3", "(2^2x3).L3(4).2_3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "(2^2x3).U6(2)",  "2^2.U6(2)",   "2^2.U6(2).2",   "(2^2x3).U6(2).2"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "(2^2x3).2E6(2)", "2^2.2E6(2)",  "2^2.2E6(2).2",  "(2^2x3).2E6(2).2"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">] );</span>
</pre></div>

<p>Additionally, there are a few cases where <span class="SimpleMath">A</span> has order two, and <span class="SimpleMath">G.A</span> has a factor group of the type <span class="SimpleMath">2^2</span>, and a few cases where <span class="SimpleMath">M</span> has the type <span class="SimpleMath">2^2</span> and <span class="SimpleMath">A</span> is of order three and acts transitively on the involutions in <span class="SimpleMath">M</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( listMGA, [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.A6.2_3",       "A6.2_3",    "A6.2^2",      "3.A6.2^2"          ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.L3(4).2_1",    "L3(4).2_1", "L3(4).2^2",   "3.L3(4).2^2"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3_1.U4(3).2_2",  "U4(3).2_2", "U4(3).(2^2)_{122}",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                            "3_1.U4(3).(2^2)_{122}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3_2.U4(3).2_3",  "U4(3).2_3", "U4(3).(2^2)_{133}",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                            "3_2.U4(3).(2^2)_{133}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3^2.U4(3).2_3'", "3_2.U4(3).2_3'", "3_2.U4(3).(2^2)_{133}",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                            "3^2.U4(3).(2^2)_{133}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.L3(4)",      "L3(4)",     "L3(4).3",     "2^2.L3(4).3"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "(2^2x3).L3(4)",  "3.L3(4)",   "3.L3(4).3",   "(2^2x3).L3(4).3"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.L3(4).2_1",  "L3(4).2_1", "L3(4).6",     "2^2.L3(4).6"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.Sz(8)",      "Sz(8)",     "Sz(8).3",     "2^2.Sz(8).3"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.U6(2)",      "U6(2)",     "U6(2).3",     "2^2.U6(2).3"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "(2^2x3).U6(2)",  "3.U6(2)",   "3.U6(2).3",   "(2^2x3).U6(2).3"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.O8+(2)",     "O8+(2)",    "O8+(2).3",    "2^2.O8+(2).3"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.O8+(3)",     "O8+(3)",    "O8+(3).3",    "2^2.O8+(3).3"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.2E6(2)",     "2E6(2)",    "2E6(2).3",    "2^2.2E6(2).3"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">] );</span>
</pre></div>

<p>The constructions of the character tables of groups of the types <span class="SimpleMath">4_2.L_3(4).2_3</span>, <span class="SimpleMath">12_2.L_3(4).2_3</span>, <span class="SimpleMath">12_1.U_4(3).2_2'</span> and <span class="SimpleMath">12_2.U_4(3).2_3'</span> is described in Section <a href="chap2.html#X794EC2FD7F69B4E6"><span class="RefLink">2.4-5</span></a> and <a href="chap2.html#X7E3E748E85AEDDB3"><span class="RefLink">2.4-6</span></a>, in these cases the <strong class="pkg">GAP</strong> functions return several possible tables.</p>

<p>The construction of the various character table of groups of the types <span class="SimpleMath">4_1.L_3(4).2^2</span> and <span class="SimpleMath">4_2.L_3(4).2^2</span> are described in Section <a href="chap2.html#X7DC42AE57E9EED4D"><span class="RefLink">2.6-7</span></a>.</p>

<p>The following function takes the ordinary character tables of the groups <span class="SimpleMath">M.G</span>, <span class="SimpleMath">G</span>, and <span class="SimpleMath">G.A</span>, a string to be used as the <code class="func">Identifier</code> (<a href="../../../doc/ref/chap70.html#X810E53597B5BB4F8"><span class="RefLink">Reference: Identifier for tables of marks</span></a>) value of the character table of <span class="SimpleMath">M.G.A</span>, and the character table of <span class="SimpleMath">M.G.A</span> that is contained in the <strong class="pkg">GAP</strong> Character Table Library; the function first computes the possible actions of <span class="SimpleMath">G.A</span> on the classes of <span class="SimpleMath">M.G</span>, using the function <code class="func">PossibleActionsForTypeMGA</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7899AA12836EEF8F"><span class="RefLink">CTblLib: PossibleActionsForTypeMGA</span></a>), then computes the union of possible character tables for these actions, and then representatives up to permutation equivalence; if there is only one solution then the result table is compared with the library table.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstructOrdinaryMGATable:= function( tblMG, tblG, tblGA, name, lib )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     local acts, poss, trans;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     acts:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= Concatenation( List( acts, pi -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, pi,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    name ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= RepresentativesCharacterTables( poss );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if Length( poss ) = 1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       # Compare the computed table with the library table.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if not IsCharacterTable( lib ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         List( poss, x -&gt; AutomorphismsOfTable( x.table ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#I  no library table for ", name, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         trans:= TransformingPermutationsCharacterTables( poss[1].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if not IsRecord( trans ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed table and library table for ", name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         # Compare the computed fusion with the stored one.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if OnTuples( poss[1].MGfusMGA, trans.columns )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                &lt;&gt; GetFusionMap( tblMG, lib ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed and stored fusion for ", name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     elif Length( poss ) = 0 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#E  no solution for ", name, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#E  ", Length( poss ), " possibilities for ", name, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     return poss;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end;;</span>
</pre></div>

<p>The following function takes the ordinary character tables of the groups <span class="SimpleMath">M.G</span>, <span class="SimpleMath">G.A</span>, and <span class="SimpleMath">M.G.A</span>, and tries to construct the <span class="SimpleMath">p</span>-modular character tables of <span class="SimpleMath">M.G.A</span> from the <span class="SimpleMath">p</span>-modular character tables of the first two of these tables, for all prime divisors <span class="SimpleMath">p</span> of the order of <span class="SimpleMath">M.G.A</span>. Note that the tables of <span class="SimpleMath">G</span> are not needed in the construction, only the class fusions from <span class="SimpleMath">M.G</span> to <span class="SimpleMath">M.G.A</span> and from <span class="SimpleMath">M.G.A</span> to <span class="SimpleMath">G.A</span> must be stored.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstructModularMGATables:= function( tblMG, tblGA, ordtblMGA )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   local name, poss, p, modtblMG, modtblGA, modtblMGA, modlib, trans;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   name:= Identifier( ordtblMGA );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   poss:= [];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   for p in PrimeDivisors( Size( ordtblMGA ) ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modtblMG := tblMG mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modtblGA := tblGA mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if ForAll( [ modtblMG, modtblGA ], IsCharacterTable ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modtblMGA:= BrauerTableOfTypeMGA( modtblMG, modtblGA, ordtblMGA );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Add( poss, modtblMGA );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modlib:= ordtblMGA mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if IsCharacterTable( modlib ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         trans:= TransformingPermutationsCharacterTables( modtblMGA.table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     modlib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if not IsRecord( trans ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed table and library table for ", name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " mod ", p, " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         AutomorphismsOfTable( modtblMGA.table );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#I  no library table for ", name, " mod ", p, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  not all input tables for ", name, " mod ", p,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              " available\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return poss;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end;;</span>
</pre></div>

<p>Now we run the constructions for the cases in the list. Note that in order to avoid conflicts of the class fusions that arise in the construction with the class fusions that are already stored on the library tables, we choose identifiers for the result tables that are different from the identifiers of the library tables.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for  input in listMGA do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblMG := CharacterTable( input[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblG  := CharacterTable( input[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblGA := CharacterTable( input[3] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     name  := Concatenation( "new", input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     lib   := CharacterTable( input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if 1 &lt;&gt; Length( poss ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  ", Length( poss ), " possibilities for ", name, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     elif lib = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  no library table for ", input[4], "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       ConstructModularMGATables( tblMG, tblGA, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
#I  not all input tables for 3.2E6(2).2 mod 2 available
#I  not all input tables for 3.2E6(2).2 mod 3 available
#I  not all input tables for 3.2E6(2).2 mod 5 available
#I  not all input tables for 3.2E6(2).2 mod 7 available
#I  not all input tables for 3.2E6(2).2 mod 11 available
#I  not all input tables for 3.2E6(2).2 mod 13 available
#I  not all input tables for 3.2E6(2).2 mod 17 available
#I  not all input tables for 3.2E6(2).2 mod 19 available
#I  not all input tables for 6.2E6(2).2 mod 2 available
#I  not all input tables for 6.2E6(2).2 mod 3 available
#I  not all input tables for 6.2E6(2).2 mod 5 available
#I  not all input tables for 6.2E6(2).2 mod 7 available
#I  not all input tables for 6.2E6(2).2 mod 11 available
#I  not all input tables for 6.2E6(2).2 mod 13 available
#I  not all input tables for 6.2E6(2).2 mod 17 available
#I  not all input tables for 6.2E6(2).2 mod 19 available
#I  not all input tables for 3.F3+.2 mod 2 available
#I  not all input tables for 3.F3+.2 mod 3 available
#I  not all input tables for 3.F3+.2 mod 5 available
#I  not all input tables for 3.F3+.2 mod 7 available
#I  not all input tables for 3.F3+.2 mod 13 available
#I  not all input tables for 3.F3+.2 mod 17 available
#I  not all input tables for 3.F3+.2 mod 29 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 2 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 3 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 5 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 7 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 11 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 13 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 17 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 19 available
#I  not all input tables for 3^2.U4(3).(2^2)_{133} mod 2 available
#I  not all input tables for 3^2.U4(3).(2^2)_{133} mod 5 available
#I  not all input tables for 3^2.U4(3).(2^2)_{133} mod 7 available
#I  not all input tables for 2^2.O8+(3).3 mod 5 available
#I  not all input tables for 2^2.O8+(3).3 mod 7 available
#I  not all input tables for 2^2.O8+(3).3 mod 13 available
#I  not all input tables for 2^2.2E6(2).3 mod 2 available
#I  not all input tables for 2^2.2E6(2).3 mod 3 available
#I  not all input tables for 2^2.2E6(2).3 mod 5 available
#I  not all input tables for 2^2.2E6(2).3 mod 7 available
#I  not all input tables for 2^2.2E6(2).3 mod 11 available
#I  not all input tables for 2^2.2E6(2).3 mod 13 available
#I  not all input tables for 2^2.2E6(2).3 mod 17 available
#I  not all input tables for 2^2.2E6(2).3 mod 19 available
</pre></div>

<p>We do not get any unexpected output, so the character tables in question are determined by the inputs.</p>

<p>Alternative constructions of the character tables of <span class="SimpleMath">3.A_6.2^2</span>, <span class="SimpleMath">3.L_3(4).2^2</span>, and <span class="SimpleMath">3_2.U_4(3).(2^2)_133</span> can be found in Section <a href="chap2.html#X7FEC3AB081487AF2"><span class="RefLink">2.6-2</span></a>.</p>

<p><a id="X7A236EDE7A7A28F9" name="X7A236EDE7A7A28F9"></a></p>

<h5>2.4-4 <span class="Heading">More <strong class="pkg">Atlas</strong> Tables of the Type <span class="SimpleMath">M.G.A</span></span></h5>

<p>In the following situations, we have <span class="SimpleMath">|A| = 2</span>, and <span class="SimpleMath">|M|</span> is a multiple of <span class="SimpleMath">2</span>. The result turns out to be unique up to isoclinism, see Section <a href="chap2.html#X82E75B6880EC9E6C"><span class="RefLink">2.3-1</span></a>.</p>

<p>First, there are some cases where the centre of <span class="SimpleMath">M.G</span> is a cyclic group of order four, and <span class="SimpleMath">|M| = 2</span> holds.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">listMGA2:= [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "4_1.L3(4)",  "2.L3(4)",   "2.L3(4).2_1",   "4_1.L3(4).2_1"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "4_1.L3(4)",  "2.L3(4)",   "2.L3(4).2_2",   "4_1.L3(4).2_2"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "4_2.L3(4)",  "2.L3(4)",   "2.L3(4).2_1",   "4_2.L3(4).2_1"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "4.M22",      "2.M22",     "2.M22.2",       "4.M22.2"        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "4.U4(3)",    "2.U4(3)",   "2.U4(3).2_2",   "4.U4(3).2_2"    ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "4.U4(3)",    "2.U4(3)",   "2.U4(3).2_3",   "4.U4(3).2_3"    ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">];;</span>
</pre></div>

<p>Note that the groups <span class="SimpleMath">4_1.L3(4).2_3</span> and <span class="SimpleMath">4_2.L3(4).2_2</span> and their isoclinic variants have centres of order four, so they do not appear here. The construction of the character table of <span class="SimpleMath">4_2.L_3(4).2_3</span> is more involved, it is described in Section <a href="chap2.html#X794EC2FD7F69B4E6"><span class="RefLink">2.4-5</span></a>.</p>

<p>Also in the following cases, we have <span class="SimpleMath">|M| = 2</span>, but the situation is different because <span class="SimpleMath">M.G</span> has a central subgroup of the type <span class="SimpleMath">2^2</span> containing a unique subgroup of order <span class="SimpleMath">2</span> that is central in <span class="SimpleMath">M.G.A</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( listMGA2, [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.L3(4)",     "2.L3(4)",     "2.L3(4).2_2",         "2^2.L3(4).2_2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.L3(4)",     "2.L3(4)",     "2.L3(4).2_3",         "2^2.L3(4).2_3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{123}", "2^2.L3(4).2^2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.O8+(2)",    "2.O8+(2)",    "2.O8+(2).2",          "2^2.O8+(2).2"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.U6(2)",     "2.U6(2)",     "2.U6(2).2",           "2^2.U6(2).2"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.2E6(2)",    "2.2E6(2)",    "2.2E6(2).2",          "2^2.2E6(2).2"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">] );</span>
</pre></div>

<p>Next there are two constructions for <span class="SimpleMath">G = 6.L_3(4)</span>, with <span class="SimpleMath">|M| = 12</span> and <span class="SimpleMath">|A| = 2</span>. Note that the groups <span class="SimpleMath">12_1.L3(4).2_1</span> and <span class="SimpleMath">12_2.L3(4).2_1</span> have central subgroups of the order six, so we cannot use the factor groups <span class="SimpleMath">4_1.L3(4).2_1</span> and <span class="SimpleMath">4_2.L3(4).2_1</span>, respectively, for the constructions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( listMGA2, [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "12_1.L3(4)", "6.L3(4)", "6.L3(4).2_1", "12_1.L3(4).2_1" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "12_2.L3(4)", "6.L3(4)", "6.L3(4).2_1", "12_2.L3(4).2_1" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">] );</span>
</pre></div>

<p>Next there are alternative constructions for tables which have been constructed in Section <a href="chap2.html#X7ED45AB379093A70"><span class="RefLink">2.4-3</span></a>. There we had viewed the groups of the structure <span class="SimpleMath">12.S.2</span>, for a simple group <span class="SimpleMath">S</span>, as <span class="SimpleMath">3.G.2</span> with <span class="SimpleMath">G = 4.S</span>. Here we view these groups as <span class="SimpleMath">2.G.2</span> with <span class="SimpleMath">G = 6.S</span>, which means that we do not prescribe the <span class="SimpleMath">4.S.2</span> type factor group. So it is not surprising that we get more than one solution, and that the computation of the <span class="SimpleMath">2</span>-power map of <span class="SimpleMath">12.S.2</span> is more involved. Note that the construction of the character table of <span class="SimpleMath">12_2.L_3(4).2_3</span> is more involved, it is described in Section <a href="chap2.html#X794EC2FD7F69B4E6"><span class="RefLink">2.4-5</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( listMGA2, [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "12.M22",     "6.M22",     "6.M22.2",       "12.M22.2"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "12_1.L3(4)", "6.L3(4)",   "6.L3(4).2_2",   "12_1.L3(4).2_2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "12_1.U4(3)", "6_1.U4(3)", "6_1.U4(3).2_2", "12_1.U4(3).2_2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "12_2.U4(3)", "6_2.U4(3)", "6_2.U4(3).2_3", "12_2.U4(3).2_3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">] );</span>
</pre></div>

<p>Finally, there are alternative constructions for the cases where the group <span class="SimpleMath">M.G</span> has a central subgroup of the type <span class="SimpleMath">2^2 × 3</span>, and <span class="SimpleMath">A</span> acts on this group by inverting the elements in the subgroup of order <span class="SimpleMath">3</span> and by swapping two involutions in the Klein four group.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( listMGA2, [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "(2^2x3).L3(4)",  "6.L3(4)",   "6.L3(4).2_2", "(2^2x3).L3(4).2_2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "(2^2x3).L3(4)",  "6.L3(4)",   "6.L3(4).2_3", "(2^2x3).L3(4).2_3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "(2^2x3).U6(2)",  "6.U6(2)",   "6.U6(2).2",   "(2^2x3).U6(2).2"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "(2^2x3).2E6(2)", "6.2E6(2)",  "6.2E6(2).2",  "(2^2x3).2E6(2).2"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">] );</span>
</pre></div>

<p>Now we run the constructions for the cases in the list.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for  input in listMGA2 do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblMG := CharacterTable( input[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblG  := CharacterTable( input[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblGA := CharacterTable( input[3] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     name  := Concatenation( "new", input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     lib   := CharacterTable( input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if Length( poss ) = 2 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       iso:= CharacterTableIsoclinic( poss[1].table );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if IsRecord( TransformingPermutationsCharacterTables( poss[2].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        iso ) ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Unbind( poss[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     elif Length( poss ) = 1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  unique up to permutation equivalence: ", name, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if 1 &lt;&gt; Length( poss ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  ", Length( poss ), " possibilities for ", name, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     elif lib = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  no library table for ", input[4], "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       ConstructModularMGATables( tblMG, tblGA, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
#E  2 possibilities for new4_1.L3(4).2_1
#E  2 possibilities for new4_1.L3(4).2_2
#E  2 possibilities for new4_2.L3(4).2_1
#E  2 possibilities for new4.M22.2
#E  2 possibilities for new4.U4(3).2_2
#E  2 possibilities for new4.U4(3).2_3
#I  unique up to permutation equivalence: new2^2.L3(4).2_2
#I  unique up to permutation equivalence: new2^2.L3(4).2_3
#I  unique up to permutation equivalence: new2^2.L3(4).2^2
#I  unique up to permutation equivalence: new2^2.O8+(2).2
#I  unique up to permutation equivalence: new2^2.U6(2).2
#I  unique up to permutation equivalence: new2^2.2E6(2).2
#I  not all input tables for 2^2.2E6(2).2 mod 2 available
#I  not all input tables for 2^2.2E6(2).2 mod 3 available
#I  not all input tables for 2^2.2E6(2).2 mod 5 available
#I  not all input tables for 2^2.2E6(2).2 mod 7 available
#E  2 possibilities for new12_1.L3(4).2_1
#E  2 possibilities for new12_2.L3(4).2_1
#E  2 possibilities for new12.M22.2
#E  2 possibilities for new12_1.L3(4).2_2
#E  2 possibilities for new12_1.U4(3).2_2
#E  2 possibilities for new12_2.U4(3).2_3
#I  unique up to permutation equivalence: new(2^2x3).L3(4).2_2
#I  unique up to permutation equivalence: new(2^2x3).L3(4).2_3
#I  unique up to permutation equivalence: new(2^2x3).U6(2).2
#I  unique up to permutation equivalence: new(2^2x3).2E6(2).2
#I  not all input tables for (2^2x3).2E6(2).2 mod 2 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 3 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 5 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 7 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 11 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 13 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 17 available
#I  not all input tables for (2^2x3).2E6(2).2 mod 19 available
</pre></div>

<p>Again, we do not get any unexpected output, so the character tables in question are determined up to isoclinism by the inputs.</p>

<p><a id="X794EC2FD7F69B4E6" name="X794EC2FD7F69B4E6"></a></p>

<h5>2.4-5 <span class="Heading">The Character Tables of <span class="SimpleMath">4_2.L_3(4).2_3</span> and <span class="SimpleMath">12_2.L_3(4).2_3</span></span></h5>

<p>In the construction of the character table of <span class="SimpleMath">M.G.A = 4_2.L_3(4).2_3</span> from the tables of <span class="SimpleMath">M.G = 4_2.L_3(4)</span> and <span class="SimpleMath">G.A = 2.L_3(4).2_3</span>, the action of <span class="SimpleMath">A</span> on the classes of <span class="SimpleMath">M.G</span> is uniquely determined, but we get four possible character tables.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG := CharacterTable( "4_2.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG  := CharacterTable( "2.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA := CharacterTable( "2.L3(4).2_3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">name  := "new4_2.L3(4).2_3";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib   := CharacterTable( "4_2.L3(4).2_3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss  := ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );</span>
#E  4 possibilities for new4_2.L3(4).2_3
[ rec( 
      MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 11, 10, 12, 
          12, 13, 14, 15, 14, 16, 17, 18, 17, 19, 20, 21, 22, 19, 22, 
          21, 20 ], table := CharacterTable( "new4_2.L3(4).2_3" ) ), 
  rec( 
      MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 11, 10, 12, 
          12, 13, 14, 15, 14, 16, 17, 18, 17, 19, 20, 21, 22, 19, 22, 
          21, 20 ], table := CharacterTable( "new4_2.L3(4).2_3" ) ), 
  rec( 
      MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 11, 10, 12, 
          12, 13, 14, 15, 14, 16, 17, 18, 17, 19, 20, 21, 22, 19, 22, 
          21, 20 ], table := CharacterTable( "new4_2.L3(4).2_3" ) ), 
  rec( 
      MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 11, 10, 12, 
          12, 13, 14, 15, 14, 16, 17, 18, 17, 19, 20, 21, 22, 19, 22, 
          21, 20 ], table := CharacterTable( "new4_2.L3(4).2_3" ) ) ]
</pre></div>

<p>The centre of <span class="SimpleMath">4_2.L_3(4)</span> is inverted by the action of the outer automorphism, so the existence of <em>two</em> possible tables can be expected because two isoclinic groups of the type <span class="SimpleMath">4_2.L_3(4).2_3</span> exist, see Section <a href="chap2.html#X78F41D2A78E70BEE"><span class="RefLink">2.2-6</span></a>.</p>

<p>Indeed the result consists of two pairs of isoclinic tables, so we have to decide which pair of tables belongs to the groups of the type <span class="SimpleMath">4_2.L_3(4).2_3</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( poss[1].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTableIsoclinic( poss[4].table ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( poss[2].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTableIsoclinic( poss[3].table ) ) );</span>
true
</pre></div>

<p>The possible tables differ only w.r.t. the <span class="SimpleMath">2</span>-power map and perhaps the element orders. The <strong class="pkg">Atlas</strong> prints the table of the split extension of <span class="SimpleMath">M.G</span>, this table is one of the first two possibilities.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( poss, x -&gt; PowerMap( x.table, 2 ) );</span>
[ [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 
      21, 19, 21, 1, 1, 6, 6, 9, 9, 11, 11, 16, 16, 13, 13 ], 
  [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 
      21, 19, 21, 1, 1, 6, 6, 11, 11, 9, 9, 16, 16, 13, 13 ], 
  [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 
      21, 19, 21, 3, 3, 8, 8, 9, 9, 11, 11, 18, 18, 15, 15 ], 
  [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 
      21, 19, 21, 3, 3, 8, 8, 11, 11, 9, 9, 18, 18, 15, 15 ] ]
</pre></div>

<p>The <span class="SimpleMath">2</span>-power map is not determined by the irreducible characters (and by the <span class="SimpleMath">2</span>-power map of the factor group <span class="SimpleMath">2.L_3(4).2_3</span>). We determine this map using the embedding of <span class="SimpleMath">4_2.L_3(4).2_3</span> into <span class="SimpleMath">4.U_4(3).2_3</span>. Note that <span class="SimpleMath">L_3(4).2_3</span> is a maximal subgroup of <span class="SimpleMath">U_4(3).2_3</span> (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 52]</a>), and that the subgroup <span class="SimpleMath">L_3(4)</span> of <span class="SimpleMath">U_4(3)</span> lifts to <span class="SimpleMath">4_2.L_3(4)</span> in <span class="SimpleMath">4.U_4(3)</span> because no embedding of <span class="SimpleMath">L_3(4)</span>, <span class="SimpleMath">2.L_3(4)</span>, or <span class="SimpleMath">4_1.L_3(4)</span> into <span class="SimpleMath">4.U_4(3)</span> is possible.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossiblePowerMaps( poss[1].table, 2 );</span>
[ [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 
      21, 19, 21, 1, 1, 6, 6, 11, 11, 9, 9, 16, 16, 13, 13 ], 
  [ 1, 3, 1, 1, 3, 6, 8, 6, 4, 4, 4, 5, 16, 18, 16, 13, 15, 13, 19, 
      21, 19, 21, 1, 1, 6, 6, 9, 9, 11, 11, 16, 16, 13, 13 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "4.U4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( [ "L3(4)", "2.L3(4)", "4_1.L3(4)", "4_2.L3(4)" ], name -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Length( PossibleClassFusions( CharacterTable( name ), t ) ) );</span>
[ 0, 0, 0, 4 ]
</pre></div>

<p>So the split extension <span class="SimpleMath">4_2.L_3(4).2_3</span> of <span class="SimpleMath">4_2.L_3(4)</span> is a subgroup of the split extension <span class="SimpleMath">4.U_4(3).2_3</span> of <span class="SimpleMath">4.U_4(3)</span>, and only one of the two possible tables of <span class="SimpleMath">4_2.L_3(4).2_3</span> admits a class fusion into the <strong class="pkg">Atlas</strong> table of <span class="SimpleMath">4.U_3(4).2_3</span>; the construction of the latter table is shown in Section <a href="chap2.html#X7ED45AB379093A70"><span class="RefLink">2.4-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTable( "4.U4(3).2_3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( poss, x -&gt; Length( PossibleClassFusions( x.table, t2 ) ) );</span>
[ 0, 16, 0, 0 ]
</pre></div>

<p>I do not know a character theoretic argument that would disprove the existence of a group whose character table is the other candidate (or its isoclinic variant). For example, the table passes the tests from Section <a href="chap2.html#X7E0C603880157C4E"><span class="RefLink">2.4-17</span></a>.</p>

<p>(It is straightforward to compute all extensions of <span class="SimpleMath">4_2.L_3(4)</span> by an automorphism of order two. The extensions with <span class="SimpleMath">34</span> conjugacy classes belong to the second candidate and its isoclinic variant.)</p>

<p>The correct table is the one that is contained in the <strong class="pkg">GAP</strong> Character Table Library.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( poss[2].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 lib ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstructModularMGATables( tblMG, tblGA, lib );;</span>
</pre></div>

<p>In the construction of the character table of <span class="SimpleMath">12_2.L_3(4).2_3</span>, the same ambiguity arises. We resolve it using the fact that <span class="SimpleMath">4_2.L_3(4).2_3</span> occurs as a factor group, modulo the unique normal subgroup of order three.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG := CharacterTable( "12_2.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG  := CharacterTable( "6.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA := CharacterTable( "6.L3(4).2_3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">name  := "new12_2.L3(4).2_3";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib   := CharacterTable( "12_2.L3(4).2_3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss  := ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );;</span>
#E  4 possibilities for new12_2.L3(4).2_3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( poss );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= ClassPositionsOfNormalSubgroups( poss[1].table );</span>
[ [ 1 ], [ 1, 5 ], [ 1, 7 ], [ 1, 4 .. 7 ], [ 1, 3 .. 7 ], 
  [ 1 .. 7 ], [ 1 .. 50 ], [ 1 .. 62 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( nsg, x -&gt; Sum( SizesConjugacyClasses( poss[1].table ){ x } ) );</span>
[ 1, 3, 2, 4, 6, 12, 241920, 483840 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">factlib:= CharacterTable( "4_2.L3(4).2_3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( poss, x -&gt; IsRecord( TransformingPermutationsCharacterTables(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        x.table / [ 1, 5 ], factlib ) ) );</span>
[ false, true, false, false ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( poss[2].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 lib ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstructModularMGATables( tblMG, tblGA, lib );;</span>
</pre></div>

<p><a id="X7E3E748E85AEDDB3" name="X7E3E748E85AEDDB3"></a></p>

<h5>2.4-6 <span class="Heading">The Character Tables of <span class="SimpleMath">12_1.U_4(3).2_2'</span> and
<span class="SimpleMath">12_2.U_4(3).2_3'</span> (December 2015)</span></h5>

<p>In the construction of the character table of <span class="SimpleMath">M.G.A = 12_1.U_4(3).2_2'</span> from the tables of <span class="SimpleMath">M.G = 12_1.U_4(3)</span> and <span class="SimpleMath">G.A = 2.U_4(3).2_2'</span>, the action of <span class="SimpleMath">A</span> on the classes of <span class="SimpleMath">M.G</span> is uniquely determined, but we get two possible character tables.</p>

<p>(Note that the groups <span class="SimpleMath">2.U_4(3).2_2</span> and <span class="SimpleMath">2.U_4(3).2_2'</span> are isomorphic, but we have to take the latter one because the stored factor fusion from <span class="SimpleMath">12_1.U_4(3)</span> to <span class="SimpleMath">2.U_4(3)</span> must be combined with the class fusion from <span class="SimpleMath">2.U_4(3)</span> to <span class="SimpleMath">2.U_4(3).2_2'</span>; using the library table of <span class="SimpleMath">2.U_4(3).2_2</span> would be technically more involved.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG := CharacterTable( "12_1.U4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG  := CharacterTable( "2.U4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA := CharacterTable( "2.U4(3).2_2'" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">name  := "new12_1.U4(3).2_2'";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib   := CharacterTable( "12_1.U4(3).2_2'" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss  := ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );;</span>
#E  2 possibilities for new12_1.U4(3).2_2'
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstructModularMGATables( tblMG, tblGA, lib );;</span>
</pre></div>

<p>This is not surprising, the two tables involve the two isoclinic variants of <span class="SimpleMath">4.U_4(3).2_2'</span> (which is isomorphic with <span class="SimpleMath">4.U_4(3).2_2</span>) as tables of factor groups. The irreducible characters of the two tables are equal, only the <span class="SimpleMath">2</span>-power map and the element orders are different.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Irr( poss[1].table ) = Irr( poss[2].table );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= CharacterTableIsoclinic( poss[1].table );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( iso, poss[2].table );</span>
rec( columns := (), group := &lt;permutation group with 5 generators&gt;, 
  rows := () )
</pre></div>

<p>The same phenomenon occurs in the construction of the character table of <span class="SimpleMath">M.G.A = 12_2.U_4(3).2_3'</span> from the tables of <span class="SimpleMath">M.G = 12_2.U_4(3)</span> and <span class="SimpleMath">G.A = 2.U_4(3).2_3'</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG := CharacterTable( "12_2.U4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG  := CharacterTable( "2.U4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA := CharacterTable( "2.U4(3).2_3'" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">name  := "new12_2.U4(3).2_3'";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib   := CharacterTable( "12_2.U4(3).2_3'" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss  := ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );;</span>
#E  2 possibilities for new12_2.U4(3).2_3'
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstructModularMGATables( tblMG, tblGA, lib );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= CharacterTableIsoclinic( poss[1].table );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( iso, poss[2].table );</span>
rec( columns := (), group := &lt;permutation group with 8 generators&gt;, 
  rows := () )
</pre></div>

<p><a id="X8379003582D06130" name="X8379003582D06130"></a></p>

<h5>2.4-7 <span class="Heading">Groups of the Structures <span class="SimpleMath">3.U_3(8).3_1</span> and <span class="SimpleMath">3.U_3(8).6</span>
(February 2017)</span></h5>

<p>The list of Improvements to the <strong class="pkg">Atlas</strong> of Finite Groups <a href="chapBib.html#biBBN95">[BN95]</a> states the following, concerning the group <span class="SimpleMath">G = U_3(8)</span>.</p>

<p>"There is a unique group of type <span class="SimpleMath">3.G.6</span> which contains the group of type <span class="SimpleMath">3.G.3</span> shown. But the (unique) groups of type <span class="SimpleMath">3.G.6'</span> and <span class="SimpleMath">3.G.6''</span> contain not this <span class="SimpleMath">3.G.3</span> but its <em>isoclines</em>."</p>

<p>In this section we will show that this statement is not correct, in the sense that the three isoclinic variants of groups of the structure <span class="SimpleMath">3.U_3(8).3_1</span> are in fact isomorphic.</p>

<p>As a consequence, there is a unique group of the structure <span class="SimpleMath">3.U_3(8).6</span>, up to isomorphism. Note that otherwise the strange situation of nonisomorphic groups <span class="SimpleMath">3.G.6</span>, <span class="SimpleMath">3.G.6'</span>, and <span class="SimpleMath">3.G.6''</span> would happen, which would be also not isoclinic because their centres are trivial.</p>

<p>A group of the structure <span class="SimpleMath">3.U_3(8).3_1</span> can be obtained as the semidirect product <span class="SimpleMath">G</span>, say, of the group SU<span class="SimpleMath">(3,8)</span> with the automorphism of the field with <span class="SimpleMath">64</span> elements that raises each field element to its fourth power. Note that the semidirect product of SU<span class="SimpleMath">(3,8)</span> with the field automorphism that squares each field element yields a group of the structure <span class="SimpleMath">3.U_3(8).6</span>.</p>

<p>First we create a permutation representation of <span class="SimpleMath">G</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= SU(3,8);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= GeneratorsOfGroup( s );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">imgs1:= List( gens, m -&gt; List( m, v -&gt; List( v, x -&gt; x^4 ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">imgs2:= List( gens, m -&gt; List( m, v -&gt; List( v, x -&gt; x^16 ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f:= GF(64);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mats:= List( gens, m -&gt; IdentityMat( 9, f ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for i in [ 1 .. Length( gens ) ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     mats[i]{ [ 1 .. 3 ] }{ [ 1 .. 3 ] }:= gens[i];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     mats[i]{ [ 4 .. 6 ] }{ [ 4 .. 6 ] }:= imgs1[i];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     mats[i]{ [ 7 .. 9 ] }{ [ 7 .. 9 ] }:= imgs2[i];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fieldaut:= NullMat( 9, 9, f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fieldaut{ [ 4 .. 6 ] }{ [ 1 .. 3 ] }:= IdentityMat( 3, f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fieldaut{ [ 7 .. 9 ] }{ [ 4 .. 6 ] }:= IdentityMat( 3, f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fieldaut{ [ 1 .. 3 ] }{ [ 7 .. 9 ] }:= IdentityMat( 3, f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v:= [ 1, 0, 0, 1, 0, 0, 1, 0, 0 ] * One( f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Group( Concatenation( mats, [ fieldaut ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= Orbit( g, v );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( orb );</span>
32319
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">act:= Action( g, orb );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( act ) = 3 * Size( s );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sm:= SmallerDegreePermutationRepresentation( act );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrMovedPoints( Image( sm ) );</span>
4617
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Image( sm );;</span>
</pre></div>

<p>The next step is the construction of the central product of <span class="SimpleMath">G</span> and a cyclic group of order nine, of the structure <span class="SimpleMath">3.(3 × U_3(8).3_1)</span>. We could try to create the factor group of <span class="SimpleMath">9 × 3.U_3(8).3_1</span> modulo a diagonal subgroup of order three, by just applying the <code class="code">/</code> operation. Since <strong class="pkg">GAP</strong> would need too much time for that, and since we know better in which situation we are, we create the desired action directly on suitable sets on pairs.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:= CyclicGroup( IsPermGroup, 9 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dp:= DirectProduct( g, c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= Image( Embedding( dp, 1 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:= Image( Embedding( dp, 2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c3:= c.1^3;</span>
(4618,4621,4624)(4619,4622,4625)(4620,4623,4626)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z:= Centre( u );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( z );  Length( GeneratorsOfGroup( z ) );</span>
3
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">diag:= Subgroup( dp, [ c3 * z.1 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= Orbit( dp, [ 1, 4618 ], OnPairs );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( orb );</span>
41553
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= Set( orb );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= List( OrbitsDomain( diag, orb, OnSets ), Set );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( orbs );</span>
13851
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cp:= Action( dp, orbs, OnSetsSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( cp );</span>
148925952
</pre></div>

<p>The three isoclinic variants of the structure <span class="SimpleMath">3.U_3(8).3_1</span> appear as subgroups of index three in this central product. (The fourth subgroup of index three is of course a central product of the structure <span class="SimpleMath">3.(3 × U_3(8))</span>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">der:= DerivedSubgroup( cp );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index( cp, der );</span>
9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inter:= IntermediateSubgroups( cp, der ).subgroups;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z:= Centre( cp );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( z );</span>
9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inter:= Filtered( inter, x -&gt; not IsSubset( x, z ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( inter, Size );</span>
[ 49641984, 49641984, 49641984 ]
</pre></div>

<p>Finally, we check that the three groups are isomorphic.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismGroups( inter[1], inter[2] ) &lt;&gt; fail;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismGroups( inter[1], inter[3] ) &lt;&gt; fail;</span>
true
</pre></div>

<p><em>Remark:</em></p>

<p>An indication that the groups might be isomorphic is the fact that their character tables are equivalent, which can be shown much easier, as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t1:= CharacterTable( "3.U3(8).3_1" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t2:= CharacterTableIsoclinic( t1, rec( k:= 1 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t3:= CharacterTableIsoclinic( t1, rec( k:= 2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( t1, t2 ) &lt;&gt; fail;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( t1, t3 ) &lt;&gt; fail;</span>
true
</pre></div>

<p><a id="X7B46C77B850D3B4D" name="X7B46C77B850D3B4D"></a></p>

<h5>2.4-8 <span class="Heading">The Character Table of <span class="SimpleMath">(2^2 × F_4(2)):2 &lt; B</span>
(March 2003)</span></h5>

<p>The sporadic simple group <span class="SimpleMath">B</span> contains a maximal subgroup <span class="SimpleMath">overlineN</span> of the type <span class="SimpleMath">(2^2 × F_4(2)):2</span>, which is the normalizer of a <code class="code">2C</code> element <span class="SimpleMath">overlinex</span> in <span class="SimpleMath">B</span> (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 217]</a>).</p>

<p>We will see below that the normal Klein four group <span class="SimpleMath">V</span> in <span class="SimpleMath">overlineN</span> contains two <code class="code">2A</code> elements in <span class="SimpleMath">B</span>. The <code class="code">2A</code> centralizer in <span class="SimpleMath">B</span>, a group of the structure <span class="SimpleMath">2.^2E_6(2).2</span>, contains maximal subgroups of the type <span class="SimpleMath">2^2 × F_4(2)</span>. So the two <code class="code">2A</code> type subgroups <span class="SimpleMath">C_1</span>, <span class="SimpleMath">C_2</span> in <span class="SimpleMath">V</span> are conjugate in <span class="SimpleMath">overlineN</span>, and <span class="SimpleMath">Z = ⟨ x ⟩</span> is the centre of <span class="SimpleMath">overlineN</span>.</p>

<p><center> <img src="ctblcons11.png" alt="The structure of (2^2 x F_4(2)):2)"/> </center></p>

<p>We start with computing the class fusion of the <span class="SimpleMath">2^2 × F_4(2)</span> type subgroup <span class="SimpleMath">U</span> of <span class="SimpleMath">overlineN</span> into <span class="SimpleMath">B</span>; in order to speed this up, we first compute the class fusion of the <span class="SimpleMath">F_4(2)</span> subgroup of <span class="SimpleMath">U</span> into <span class="SimpleMath">B</span> (which is unique), and use it and the stored embedding into <span class="SimpleMath">U</span> for prescribing an approximation of the desired class fusion. Additionally, we prescribe (without loss of generality) that the <em>first</em> involution class in <span class="SimpleMath">V</span> is mapped to the class <code class="code">2C</code> of <span class="SimpleMath">B</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f42:= CharacterTable( "F4(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v4:= CharacterTable( "2^2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dp:= v4 * f42;</span>
CharacterTable( "V4xF4(2)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= CharacterTable( "B" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f42fusb:= PossibleClassFusions( f42, b );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( f42fusb );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f42fusdp:= GetFusionMap( f42, dp );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comp:= CompositionMaps( f42fusb[1], InverseMap( f42fusdp ) );</span>
[ 1, 3, 3, 3, 5, 6, 6, 7, 9, 9, 9, 9, 14, 14, 13, 13, 10, 14, 14, 12, 
  14, 17, 15, 18, 22, 22, 22, 22, 26, 26, 22, 22, 27, 27, 28, 31, 31, 
  39, 39, 36, 36, 33, 33, 39, 39, 35, 41, 42, 47, 47, 49, 49, 49, 58, 
  58, 56, 56, 66, 66, 66, 66, 58, 58, 66, 66, 69, 69, 60, 72, 72, 75, 
  79, 79, 81, 81, 85, 86, 83, 83, 91, 91, 94, 94, 104, 104, 109, 109, 
  116, 116, 114, 114, 132, 132, 140, 140 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v4fusdp:= GetFusionMap( v4, dp );</span>
[ 1, 96 .. 286 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comp[ v4fusdp[2] ]:= 4;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dpfusb:= PossibleClassFusions( dp, b, rec( fusionmap:= comp ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( dpfusb );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set( dpfusb, x -&gt; x{ v4fusdp } );</span>
[ [ 1, 4, 2, 2 ] ]
</pre></div>

<p>As announced above, we see that <span class="SimpleMath">V</span> contains two <code class="code">2A</code> involutions.</p>

<p>Set <span class="SimpleMath">G = U / Z</span>, <span class="SimpleMath">M.G = U</span>, and <span class="SimpleMath">G.A = overlineN / Z</span>. The latter group is the direct product of <span class="SimpleMath">F_4(2).2</span> and a cyclic group of order <span class="SimpleMath">2</span>. Next we compute the class fusion from <span class="SimpleMath">G</span> into <span class="SimpleMath">G.A</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= dp / v4fusdp{ [ 1, 2 ] };;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG:= dp;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA:= c2 * CharacterTable( "F4(2).2" );</span>
CharacterTable( "C2xF4(2).2" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GfusGA:= PossibleClassFusions( tblG, tblGA );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( GfusGA );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesFusions( tblG, GfusGA, tblGA ) );</span>
1
</pre></div>

<p>In principle, we have to be careful which of these equivalent maps we choose, since the underlying symmetries may be broken in the central extension <span class="SimpleMath">M.G → G</span>, for which we choose the default factor fusion.</p>

<p>However, in this situation the fusion <span class="SimpleMath">G</span> into <span class="SimpleMath">G.A</span> is unique already up to table automorphisms of the table of <span class="SimpleMath">G.A</span>, so we are free to choose one map.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesFusions( Group( () ), GfusGA, tblGA ) );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblG, GfusGA[1], tblGA );</span>
</pre></div>

<p>The tables involved determine the character table of <span class="SimpleMath">M.G.A ≅ overlineN</span> uniquely.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( elms );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, elms[1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              "(2^2xF4(2)):2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( poss );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMGA:= poss[1].table;;</span>
</pre></div>

<p>Finally, we compare the table we constructed with the one that is contained in the <strong class="pkg">GAP</strong> Character Table Library.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( tblMGA,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( "(2^2xF4(2)):2" ) ) );</span>
true
</pre></div>

<p><a id="X8254AA4A843F99BE" name="X8254AA4A843F99BE"></a></p>

<h5>2.4-9 <span class="Heading">The Character Table of <span class="SimpleMath">2.(S_3 × Fi_22.2) &lt; 2.B</span> (March 2003)</span></h5>

<p>The sporadic simple group <span class="SimpleMath">B</span> contains a maximal subgroup <span class="SimpleMath">overlineM</span> of type <span class="SimpleMath">S_3 × Fi_22.2</span>. In order to compute the character table of its preimage <span class="SimpleMath">M</span> in the Schur cover <span class="SimpleMath">2.B</span>, we first analyse the structure of <span class="SimpleMath">M</span> and then describe the construction of the character table from known character tables.</p>

<p>Let <span class="SimpleMath">Z</span> denote the centre of <span class="SimpleMath">2.B</span>. We start with <span class="SimpleMath">overlineM = M/Z</span>. Its class fusion into <span class="SimpleMath">B</span> is uniquely determined by the character tables.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3:= CharacterTable( "Dihedral", 6 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fi222:= CharacterTable( "Fi22.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMbar:= s3 * fi222;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b:= CharacterTable( "B" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mbarfusb:= PossibleClassFusions( tblMbar, b );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( Mbarfusb );</span>
1
</pre></div>

<p>The subgroup of type <span class="SimpleMath">Fi_22</span> lifts to the double cover <span class="SimpleMath">2.Fi_22</span> (that is, a group that is <em>not</em> a direct product <span class="SimpleMath">2 × Fi_22</span>) in <span class="SimpleMath">2.B</span> since <span class="SimpleMath">2.B</span> admits no class fusion from <span class="SimpleMath">Fi_22</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2b:= CharacterTable( "2.B" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossibleClassFusions( CharacterTable( "Fi22" ), 2b );</span>
[  ]
</pre></div>

<p>So the preimage of <span class="SimpleMath">Fi_22.2</span> is one of the two nonisomorphic but isoclinic groups of type <span class="SimpleMath">2.Fi_22.2</span>, and we have to decide which one really occurs. For that, we consider the subgroup of type <span class="SimpleMath">3 × Fi_22.2</span> in <span class="SimpleMath">B</span>, which is a <code class="code">3A</code> centralizer in <span class="SimpleMath">B</span>. Its preimage has the structure <span class="SimpleMath">3 × 2.Fi_22.2</span> because the preimage of the central group of order <span class="SimpleMath">3</span> is a cyclic group of order <span class="SimpleMath">6</span> and thus contains a normal complement of the <span class="SimpleMath">2.Fi_22</span> type subgroup. And a class fusion into <span class="SimpleMath">2.B</span> is possible only from the direct product containing the <span class="SimpleMath">2.Fi_22.2</span> group that is printed in the <strong class="pkg">Atlas</strong>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c3:= CharacterTable( "Cyclic", 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2fi222:= CharacterTable( "2.Fi22.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossibleClassFusions( c3 * CharacterTableIsoclinic( 2fi222 ), 2b );</span>
[  ]
</pre></div>

<p>Next we note that the involutions in the normal subgroup <span class="SimpleMath">overlineS</span> of type <span class="SimpleMath">S_3</span> in <span class="SimpleMath">overlineM</span> lift to involutions in <span class="SimpleMath">2.B</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3inMbar:= GetFusionMap( s3, tblMbar );</span>
[ 1, 113 .. 225 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3inb:= Mbarfusb[1]{ s3inMbar };</span>
[ 1, 6, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2bfusb:= GetFusionMap( 2b, b );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2s3in2B:= InverseMap( 2bfusb ){ s3inb };</span>
[ [ 1, 2 ], [ 8, 9 ], 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CompositionMaps( OrdersClassRepresentatives( 2b ), 2s3in2B );</span>
[ [ 1, 2 ], [ 3, 6 ], 2 ]
</pre></div>

<p>Thus the preimage <span class="SimpleMath">S</span> of <span class="SimpleMath">overlineS</span> contains elements of order <span class="SimpleMath">6</span> but no elements of order <span class="SimpleMath">4</span>, which implies that <span class="SimpleMath">S</span> is a direct product <span class="SimpleMath">2 × S_3</span>.</p>

<p>The two complements <span class="SimpleMath">C_1</span>, <span class="SimpleMath">C_2</span> of <span class="SimpleMath">Z</span> in <span class="SimpleMath">S</span> are normal in the preimage <span class="SimpleMath">N</span> of <span class="SimpleMath">overlineN = S_3 × Fi_22</span>, which is thus of type <span class="SimpleMath">S_3 × 2.Fi_22</span>. However, they are conjugate under the action of <span class="SimpleMath">2.Fi_22.2</span>, as no class fusion from <span class="SimpleMath">S_3 × 2.Fi_22.2</span> into <span class="SimpleMath">2.B</span> is possible.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossibleClassFusions( s3 * 2fi222, 2b );</span>
[  ]
</pre></div>

<p>(More specifically, the classes of element order <span class="SimpleMath">36</span> in <span class="SimpleMath">2.Fi_22.2</span> have centralizer orders <span class="SimpleMath">36</span> and <span class="SimpleMath">72</span>, so their centralizer orders in <span class="SimpleMath">S_3 × 2.Fi_22.2</span> are <span class="SimpleMath">216</span> and <span class="SimpleMath">432</span>; but the centralizers of order <span class="SimpleMath">36</span> elements in <span class="SimpleMath">2.B</span> have centralizer order at most <span class="SimpleMath">216</span>.)</p>

<p>Now let us see how the character table of <span class="SimpleMath">M</span> can be constructed.</p>

<p>Let <span class="SimpleMath">Y</span> denote the normal subgroup of order <span class="SimpleMath">3</span> in <span class="SimpleMath">M</span>, and <span class="SimpleMath">U</span> its centralizer in <span class="SimpleMath">M</span>, which has index <span class="SimpleMath">2</span> in <span class="SimpleMath">M</span>. Then the character table of <span class="SimpleMath">M</span> is determined by the tables of <span class="SimpleMath">M/Y</span>, <span class="SimpleMath">U</span>, <span class="SimpleMath">U/Y ≅ 2.Fi_22.2</span>, and the action of <span class="SimpleMath">M</span> on the classes of <span class="SimpleMath">U</span>.</p>

<p>As for <span class="SimpleMath">M/Y</span>, consider the normal subgroup <span class="SimpleMath">N = N_M(C_1)</span> of index <span class="SimpleMath">2</span> in <span class="SimpleMath">M</span>. In particular, <span class="SimpleMath">S/Y</span> is central in <span class="SimpleMath">N/Y</span> but not in <span class="SimpleMath">M/Y</span>, so the character table of <span class="SimpleMath">M/Y</span> is determined by the tables of <span class="SimpleMath">M/(YZ)</span>, <span class="SimpleMath">N/Y ≅ 2 × 2.Fi_22</span>, <span class="SimpleMath">N/(YZ) ≅ 2 × Fi_22</span>, and the action of <span class="SimpleMath">M/Y</span> on the classes of <span class="SimpleMath">N/Y</span>.</p>

<p>Thus we proceed in two steps, starting with the computation of the character table of <span class="SimpleMath">M/Y</span>, for which we choose the name according to the structure <span class="SimpleMath">2^2.Fi_22.2</span>.</p>

<p><center> <img src="ctblcons12.png" alt="The structure of 2.(S_3 x Fi_22.2)"/> </center></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2fi22:= CharacterTable( "2.Fi22" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblNmodY:= c2 * 2fi22;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">centre:= GetFusionMap( 2fi22, tblNmodY ){</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                ClassPositionsOfCentre( 2fi22 ) };</span>
[ 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblNmod6:= tblNmodY / centre;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMmod6:= c2 * fi222;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( tblNmod6, tblMmod6 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( fus );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblNmod6, fus[1], tblMmod6 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeMGA( tblNmodY, tblNmod6, tblMmod6 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( elms );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= PossibleCharacterTablesOfTypeMGA( tblNmodY, tblNmod6, tblMmod6,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              elms[1], "2^2.Fi22.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( poss );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMmodY:= poss[1].table;</span>
CharacterTable( "2^2.Fi22.2" )
</pre></div>

<p>So we found a unique solution for the character table of <span class="SimpleMath">M/Y</span>. Now we compute the table of <span class="SimpleMath">M</span>. For that, we have to specify the class fusion of <span class="SimpleMath">U/Y</span> into <span class="SimpleMath">M/Y</span>; it is unique up to table automorphisms of <span class="SimpleMath">M/Y</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblU:= c3 * 2fi222;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblUmodY:= tblU / GetFusionMap( c3, tblU );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( tblUmodY, tblMmodY );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesFusions( Group( () ), fus, tblMmodY ) );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblUmodY, fus[1], tblMmodY );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeMGA( tblU, tblUmodY, tblMmodY );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( elms );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= PossibleCharacterTablesOfTypeMGA( tblU, tblUmodY, tblMmodY,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              elms[1], "(S3x2.Fi22).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( poss );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblM:= poss[1].table;</span>
CharacterTable( "(S3x2.Fi22).2" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mfus2b:= PossibleClassFusions( tblM, 2b );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesFusions( tblM, mfus2b, 2b ) );</span>
1
</pre></div>

<p>We did not construct <span class="SimpleMath">M</span> as a central extension of <span class="SimpleMath">overlineM</span>, so we verify that the tables fit together; note that this way we get also the class fusion from <span class="SimpleMath">M</span> onto <span class="SimpleMath">overlineM</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Irr( tblM / ClassPositionsOfCentre( tblM ) ) = Irr( tblMbar );</span>
true
</pre></div>

<p>Finally, we compare the table we constructed with the one that is contained in the <strong class="pkg">GAP</strong> Character Table Library.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( tblM,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( "(S3x2.Fi22).2" ) ) );</span>
true
</pre></div>

<p><a id="X7AF125168239D208" name="X7AF125168239D208"></a></p>

<h5>2.4-10 <span class="Heading">The Character Table of <span class="SimpleMath">(2 × 2.Fi_22):2 &lt; Fi_24</span> (November 2008)</span></h5>

<p>The automorphism group <span class="SimpleMath">Fi_24</span> of the sporadic simple group <span class="SimpleMath">Fi_24^'</span> contains a maximal subgroup <span class="SimpleMath">N</span> of the type <span class="SimpleMath">(2 × 2.Fi_22):2</span>, whose intersection with <span class="SimpleMath">Fi_24^'</span> is <span class="SimpleMath">2.Fi_22.2</span> (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 207]</a>).</p>

<p>The normal Klein four group <span class="SimpleMath">V</span> in <span class="SimpleMath">N</span> contains two <code class="code">2C</code> elements in <span class="SimpleMath">Fi_24</span>, because the <code class="code">2C</code> centralizer in <span class="SimpleMath">Fi_24</span>, a group of the structure <span class="SimpleMath">2 × Fi_23</span>, contains maximal subgroups of the type <span class="SimpleMath">2 × 2.Fi_22</span>, and so the two <code class="code">2C</code> type subgroups <span class="SimpleMath">C_1</span>, <span class="SimpleMath">C_2</span> in <span class="SimpleMath">V</span> are conjugate in <span class="SimpleMath">N</span>, and <span class="SimpleMath">Z = Z(N)</span> is the centre of <span class="SimpleMath">N ∩ Fi_24^'</span>.</p>

<p><center> <img src="ctblcons13.png" alt="The structure of (2 x 2.Fi_22):2"/> </center></p>

<p>With <span class="SimpleMath">U = C_N(C_1)</span>, a group of the type <span class="SimpleMath">2 × 2.Fi_22</span>, we set <span class="SimpleMath">G = U / Z</span>, <span class="SimpleMath">M.G = U</span>, and <span class="SimpleMath">G.A = N / Z</span>. The latter group is the direct product of <span class="SimpleMath">Fi_22.2</span> and a cyclic group of order <span class="SimpleMath">2</span>.</p>

<p>This is exactly the situation of the construction of the character table of the group that is called <span class="SimpleMath">2^2.Fi_22.2</span> in Section <a href="chap2.html#X8254AA4A843F99BE"><span class="RefLink">2.4-9</span></a>, where this group occurs as "<span class="SimpleMath">M/Y</span>". Since the character table is uniquely determined by the input data, it is the table we are interested in here.</p>

<p>So all we have to do is to compute the class fusion from this table into that of <span class="SimpleMath">Fi_24</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fi24:= CharacterTable( "Fi24" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "2^2.Fi22.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( t, fi24 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( fus );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesFusions( t, fus, fi24 ) );</span>
1
</pre></div>

<p>(It should be noted that we did not need the character table of the <span class="SimpleMath">2.Fi_22.2</span> type subgroup of <span class="SimpleMath">N</span> in the above construction, only the tables of <span class="SimpleMath">2.Fi_22</span> and <span class="SimpleMath">Fi_22.2</span> were used.)</p>

<p>The fact that the character table of a factor of a subgroup of <span class="SimpleMath">2.B</span> occurs as the character table of a subgroup of <span class="SimpleMath">Fi_24</span> is not a coincidence. In fact, the groups <span class="SimpleMath">3.Fi_24</span> and <span class="SimpleMath">2.B</span> are subgroups of the Monster group <span class="SimpleMath">M</span>, and the subgroup <span class="SimpleMath">U = 2.(S_3 × Fi_22.2)</span> of <span class="SimpleMath">2.B</span> normalizes an element of order three. The full normalizer of this element in <span class="SimpleMath">M</span> is <span class="SimpleMath">3.Fi_24</span>, which means that we have established <span class="SimpleMath">U</span> as a (maximal) subgroup of <span class="SimpleMath">3.Fi_24</span>. Note that we have constructed the character table of <span class="SimpleMath">U</span> in Section <a href="chap2.html#X8254AA4A843F99BE"><span class="RefLink">2.4-9</span></a>.</p>

<p>Let us compute the class fusion of <span class="SimpleMath">U</span> into <span class="SimpleMath">3.Fi_24</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "(S3x2.Fi22).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3fi24:= CharacterTable( "3.Fi24" );;                        </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( t, 3fi24 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( fus );</span>
16
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesFusions( t, fus, 3fi24 ) );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetFusionMap( t, 3fi24 ) in fus; </span>
true
</pre></div>

<p>Moreover, <span class="SimpleMath">U</span> turns out to be the full normalizer of a <code class="code">6A</code> element in <span class="SimpleMath">M</span>,</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:= CharacterTable( "M" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tfusm:= PossibleClassFusions( t, m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( tfusm );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesFusions( t, tfusm, m ) );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       x -&gt; Sum( SizesConjugacyClasses( t ){ x } ) = 6 );</span>
[ [ 1, 2, 142, 143 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set( tfusm, x -&gt; x{ nsg[1] } );</span>
[ [ 1, 2, 4, 13 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( t ){ nsg[1] };</span>
[ 1, 2, 3, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PowerMap( m, -1 )[13];</span>
13
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( t ) = 2 * SizesCentralizers( m )[13];</span>
true
</pre></div>

<p>(Thus <span class="SimpleMath">U</span> is also the full normalizer of an element of order six in <span class="SimpleMath">2.B</span> and in <span class="SimpleMath">3.Fi_24</span>.)</p>

<p><a id="X79C93F7D87D9CF1D" name="X79C93F7D87D9CF1D"></a></p>

<h5>2.4-11 <span class="Heading">The Character Table of <span class="SimpleMath">S_3 × 2.U_4(3).2_2 ≤ 2.Fi_22</span> (September 2002)</span></h5>

<p>The sporadic simple Fischer group <span class="SimpleMath">Fi_22</span> contains a maximal subgroup <span class="SimpleMath">overlineM</span> of type <span class="SimpleMath">S_3 × U_4(3).2_2</span> (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 163]</a>). We claim that the preimage <span class="SimpleMath">M</span> of <span class="SimpleMath">overlineM</span> in the central extension <span class="SimpleMath">2.Fi_22</span> has the structure <span class="SimpleMath">S_3 × 2.U_4(3).2_2</span>, where the factor of type <span class="SimpleMath">2.U_4(3).2_2</span> is the one printed in the <strong class="pkg">Atlas</strong>.</p>

<p>For that, we first note that the normal subgroup <span class="SimpleMath">overlineS</span> of type <span class="SimpleMath">S_3</span> in <span class="SimpleMath">overlineM</span> lifts to a group <span class="SimpleMath">S</span> which has the structure <span class="SimpleMath">2 × S_3</span>. This follows from the fact that all involutions in <span class="SimpleMath">Fi_22</span> lift to involutions in <span class="SimpleMath">2.Fi_22</span> or, equivalently, the central involution in <span class="SimpleMath">2.Fi_22</span> is not a square. <center> <img src="ctblcons14.png" alt="The structure of S_3 x 2.U_4(3).2_2"/> </center></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2Fi22:= CharacterTable( "2.Fi22" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassPositionsOfCentre( 2Fi22 );</span>
[ 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2 in PowerMap( 2Fi22, 2 );</span>
false
</pre></div>

<p>Second, the normal subgroup <span class="SimpleMath">overlineU ≅ U_4(3).2_2</span> of <span class="SimpleMath">Fi_22</span> lifts to a nonsplit extension <span class="SimpleMath">U</span> in <span class="SimpleMath">2.Fi_22</span>, since <span class="SimpleMath">2.Fi_22</span> contains no <span class="SimpleMath">U_4(3)</span> type subgroup. Furthermore, <span class="SimpleMath">U</span> is the <span class="SimpleMath">2.U_4(3).2_2</span> type group printed in the <strong class="pkg">Atlas</strong> because the isoclinic variant does not admit a class fusion into <span class="SimpleMath">2.Fi_22</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossibleClassFusions( CharacterTable( "U4(3)" ), 2Fi22 );</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblU:= CharacterTable( "2.U4(3).2_2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= CharacterTableIsoclinic( tblU );</span>
CharacterTable( "Isoclinic(2.U4(3).2_2)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossibleClassFusions( iso, 2Fi22 );                      </span>
[  ]
</pre></div>

<p>Now there are just two possibilities. Either the two <span class="SimpleMath">S_3</span> type subgroups in <span class="SimpleMath">S</span> are normal in <span class="SimpleMath">M</span> (and thus <span class="SimpleMath">M</span> is the direct product of any such <span class="SimpleMath">S_3</span> with the preimage of the <span class="SimpleMath">U_4(3).2_2</span> type subgroup), or they are conjugate in <span class="SimpleMath">M</span>.</p>

<p>Suppose we are in the latter situation, let <span class="SimpleMath">z</span> be a generator of the centre of <span class="SimpleMath">2.Fi_22</span>, and let <span class="SimpleMath">τ</span>, <span class="SimpleMath">σ</span> be an involution and an order three element respectively, in one of the <span class="SimpleMath">S_3</span> type subgroups.</p>

<p>Each element <span class="SimpleMath">g ∈ U ∖ U^'</span> conjugates <span class="SimpleMath">τ</span> to an involution in the other <span class="SimpleMath">S_3</span> type subgroup of <span class="SimpleMath">S</span>, so <span class="SimpleMath">g^-1 τ g = τ σ^i z</span> for some <span class="SimpleMath">i ∈ { 0, 1, 2 }</span>. Furthermore, it is possible to choose <span class="SimpleMath">g</span> as an involution.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">derpos:= ClassPositionsOfDerivedSubgroup( tblU );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">outer:= Difference( [ 1 .. NrConjugacyClasses( tblU ) ], derpos );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2 in OrdersClassRepresentatives( tblU ){ outer };</span>
true
</pre></div>

<p>With this choice, <span class="SimpleMath">(g τ)^2 = τ σ^i z τ = σ^-i z</span> holds, which means that <span class="SimpleMath">(g τ)^3</span> squares to <span class="SimpleMath">z</span>. As we have seen above, this is impossible, hence <span class="SimpleMath">M</span> is a direct product, as claimed.</p>

<p>The class fusion of <span class="SimpleMath">M</span> into <span class="SimpleMath">2.Fi_22</span> is determined by the character tables, up to table automorphisms.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblM:= CharacterTable( "Dihedral", 6 ) * tblU;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( tblM, 2Fi22 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesFusions( tblM, fus, 2Fi22 ) );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( tblM,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( "2.Fi22M8" ) ) );</span>
true
</pre></div>

<p><a id="X83724BCE86FCD77B" name="X83724BCE86FCD77B"></a></p>

<h5>2.4-12 <span class="Heading">The Character Table of <span class="SimpleMath">4.HS.2 ≤ HN.2</span> (May 2002)</span></h5>

<p>The maximal subgroup <span class="SimpleMath">U</span> of type <span class="SimpleMath">2.HS.2</span> in the sporadic simple group <span class="SimpleMath">HN</span> extends to a group <span class="SimpleMath">N</span> of structure <span class="SimpleMath">4.HS.2</span> in the automorphism group <span class="SimpleMath">HN.2</span> of <span class="SimpleMath">HN</span> (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 166]</a>).</p>

<p><span class="SimpleMath">N</span> is the normalizer of a <code class="code">4D</code> element <span class="SimpleMath">g ∈ HN.2 ∖ HN</span>. The centralizer <span class="SimpleMath">C</span> of <span class="SimpleMath">g</span> is of type <span class="SimpleMath">4.HS</span>, which is the central product of <span class="SimpleMath">2.HS</span> and the cyclic group <span class="SimpleMath">⟨ g ⟩</span> of order <span class="SimpleMath">4</span>. We have <span class="SimpleMath">Z = Z(N) = ⟨ g^2 ⟩</span>. Since <span class="SimpleMath">U/Z ≅ HS.2</span> is a complement of <span class="SimpleMath">⟨ g ⟩ / Z</span> in <span class="SimpleMath">N/Z</span>, the factor group <span class="SimpleMath">N/Z</span> is a direct product of <span class="SimpleMath">HS.2</span> and a cyclic group of order <span class="SimpleMath">2</span>.</p>

<p><center> <img src="ctblcons15.png" alt="The structure of 4.HS.2"/> </center></p>

<p>Thus <span class="SimpleMath">N</span> has the structure <span class="SimpleMath">2.G.2</span>, the normal subgroup <span class="SimpleMath">2.G</span> being <span class="SimpleMath">C</span>, the factor group <span class="SimpleMath">G.2</span> being <span class="SimpleMath">2 × HS.2</span>, and <span class="SimpleMath">G</span> being <span class="SimpleMath">2 × HS</span>. Each element in <span class="SimpleMath">N ∖ C</span> inverts <span class="SimpleMath">g</span>, so <span class="SimpleMath">N</span> acts fixed point freely on the faithful irreducible characters of <span class="SimpleMath">C</span>. Hence we can use <code class="func">PossibleCharacterTablesOfTypeMGA</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X78F82DD67E083B88"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeMGA</span></a>) for constructing the character table of <span class="SimpleMath">N</span> from the tables of <span class="SimpleMath">C</span> and <span class="SimpleMath">N/Z</span> and the action of <span class="SimpleMath">N</span> on the classes of <span class="SimpleMath">C</span>.</p>

<p>We start with the table of the central product <span class="SimpleMath">C</span>. It can be viewed as an isoclinic table of the direct product of <span class="SimpleMath">2.HS</span> and a cyclic group of order <span class="SimpleMath">2</span>, see <a href="chap2.html#X80C37276851D5E39"><span class="RefLink">2.2-4</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblC:= CharacterTableIsoclinic( CharacterTable( "2.HS" ) * c2 );;</span>
</pre></div>

<p>The table of <span class="SimpleMath">G</span> is given as that of the factor group by the unique normal subgroup of <span class="SimpleMath">C</span> that consists of two conjugacy classes.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              x -&gt; Length( x ) = 2 );</span>
[ [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblCbar:= tblC / ord2[1];;</span>
</pre></div>

<p>Finally, we construct the table of the extension <span class="SimpleMath">G.2</span> and the class fusion of <span class="SimpleMath">G</span> into this table (which is uniquely determined by the character tables).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblNbar:= CharacterTable( "HS.2" ) * c2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( tblCbar, tblNbar );</span>
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 
      19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 29, 30, 31, 32, 
      33, 34, 35, 36, 35, 36, 37, 38, 39, 40, 41, 42, 41, 42 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblCbar, fus[1], tblNbar );</span>
</pre></div>

<p>Now we compute the table automorphisms of the table of <span class="SimpleMath">C</span> that are compatible with the extension <span class="SimpleMath">N</span>; we get two solutions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeMGA( tblC, tblCbar, tblNbar );</span>
[ [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6, 8 ], [ 7 ], [ 9 ], [ 10 ], 
      [ 11 ], [ 12, 14 ], [ 13 ], [ 15 ], [ 16, 18 ], [ 17 ], [ 19 ], 
      [ 20 ], [ 21 ], [ 22 ], [ 23 ], [ 24, 26 ], [ 25 ], [ 27 ], 
      [ 28, 30 ], [ 29 ], [ 31 ], [ 32, 34 ], [ 33 ], [ 35 ], 
      [ 36, 38 ], [ 37 ], [ 39 ], [ 40, 42 ], [ 41 ], [ 43 ], 
      [ 44, 46 ], [ 45 ], [ 47 ], [ 48, 50 ], [ 49 ], [ 51, 53 ], 
      [ 52, 54 ], [ 55 ], [ 56, 58 ], [ 57 ], [ 59 ], [ 60 ], 
      [ 61, 65 ], [ 62, 68 ], [ 63, 67 ], [ 64, 66 ], [ 69 ], 
      [ 70, 72 ], [ 71 ], [ 73 ], [ 74, 76 ], [ 75 ], [ 77, 81 ], 
      [ 78, 84 ], [ 79, 83 ], [ 80, 82 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6, 8 ], [ 7 ], [ 9 ], [ 10 ], 
      [ 11 ], [ 12, 14 ], [ 13 ], [ 15, 17 ], [ 16 ], [ 18 ], [ 19 ], 
      [ 20 ], [ 21 ], [ 22 ], [ 23 ], [ 24, 26 ], [ 25 ], [ 27 ], 
      [ 28, 30 ], [ 29 ], [ 31 ], [ 32, 34 ], [ 33 ], [ 35, 37 ], 
      [ 36 ], [ 38 ], [ 39 ], [ 40, 42 ], [ 41 ], [ 43 ], [ 44, 46 ], 
      [ 45 ], [ 47, 49 ], [ 48 ], [ 50 ], [ 51, 53 ], [ 52, 54 ], 
      [ 55 ], [ 56, 58 ], [ 57 ], [ 59 ], [ 60 ], [ 61, 65 ], 
      [ 62, 68 ], [ 63, 67 ], [ 64, 66 ], [ 69, 71 ], [ 70 ], [ 72 ], 
      [ 73 ], [ 74, 76 ], [ 75 ], [ 77, 83 ], [ 78, 82 ], [ 79, 81 ], 
      [ 80, 84 ] ] ]
</pre></div>

<p>We compute the possible character tables arising from these two actions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= List( elms, pi -&gt; PossibleCharacterTablesOfTypeMGA(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                tblC, tblCbar, tblNbar, pi, "4.HS.2" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( poss, Length );</span>
[ 0, 2 ]
</pre></div>

<p>So one of the two table automorphisms turned out to be impossible; the reason is that the corresponding "character table" would not admit a <span class="SimpleMath">2</span>-power map. (Alternatively, we could exclude this action on <span class="SimpleMath">C</span> by the fact that it is not compatible with the action of <span class="SimpleMath">2.HS.2</span> on its subgroup <span class="SimpleMath">2.HS</span>, which occurs here as the restriction of the action of <span class="SimpleMath">N</span> on <span class="SimpleMath">C</span> to that of <span class="SimpleMath">U</span> on <span class="SimpleMath">C ∩ U</span>.)</p>

<p>The other table automorphism leads to two possible character tables. This is not surprising since <span class="SimpleMath">N</span> contains a subgroup of type <span class="SimpleMath">2.HS.2</span>, and the above setup does not determine which of the two isoclinism types of this group occurs. Let us look at the possible class fusions from these tables into that of <span class="SimpleMath">HN.2</span>:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result:= poss[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hn2:= CharacterTable( "HN.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">possfus:= List( result, r -&gt; PossibleClassFusions( r.table, hn2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( possfus, Length );</span>
[ 32, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentativesFusions( result[1].table, possfus[1], hn2 );</span>
[ [ 1, 46, 2, 2, 47, 3, 7, 45, 4, 58, 13, 6, 46, 47, 6, 47, 7, 48, 
      10, 62, 20, 9, 63, 21, 12, 64, 24, 27, 49, 50, 13, 59, 14, 16, 
      70, 30, 18, 53, 52, 17, 54, 20, 65, 22, 36, 56, 26, 76, 39, 77, 
      28, 59, 58, 31, 78, 41, 34, 62, 35, 65, 2, 45, 3, 45, 6, 48, 7, 
      47, 17, 54, 13, 49, 13, 50, 14, 50, 18, 53, 18, 52, 21, 56, 25, 
      57, 27, 59, 30, 60, 44, 72, 34, 66, 35, 66, 41, 71 ] ]
</pre></div>

<p>Only one of the candidates admits an embedding, and the class fusion is unique up to table automorphisms. So we are done.</p>

<p>Finally, we compare the table we have constructed with the one that is contained in the <strong class="pkg">GAP</strong> Character Table Library.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">libtbl:= CharacterTable( "4.HS.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( result[1].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 libtbl ) );</span>
true
</pre></div>

<p>(The following paragraphs have been added in May 2006.)</p>

<p>The Brauer tables of <span class="SimpleMath">N = 2.G.2</span> can be constructed as in Section <a href="chap2.html#X7ED45AB379093A70"><span class="RefLink">2.4-3</span></a>. Note that the Brauer tables of <span class="SimpleMath">C = 2.G</span> and of <span class="SimpleMath">N / Z = G.2</span> are automatically available because the ordinary tables constructed above arose as a direct product and as an isoclinic table of a direct product, and the <strong class="pkg">GAP</strong> Character Table Library contains the Brauer tables of the direct factors involved.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblC, result[1].MGfusMGA, result[1].table );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( PrimeDivisors( Size( result[1].table ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           p -&gt; IsRecord( TransformingPermutationsCharacterTables(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    BrauerTableOfTypeMGA( tblC mod p, tblNbar mod p,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        result[1].table ).table, libtbl mod p ) ) );</span>
true
</pre></div>

<p>Here it is advantageous that the Brauer table of <span class="SimpleMath">C / Z = G</span> is not needed in the construction, since <strong class="pkg">GAP</strong> does not know how to compute the <span class="SimpleMath">p</span>-modular table of the ordinary table of <span class="SimpleMath">G</span> constructed above. Of course we have <span class="SimpleMath">G ≅ 2 × HS</span>, and the <span class="SimpleMath">p</span>-modular table of <span class="SimpleMath">HS</span> is known, but in the construction of the table of <span class="SimpleMath">G</span> as a factor of the table of <span class="SimpleMath">2.G</span>, the information is missing that the nonsolvable simple direct factor of <span class="SimpleMath">2.G</span> corresponds to the library table of <span class="SimpleMath">HS</span>.</p>

<p><a id="X7E9A88DA7CBF6426" name="X7E9A88DA7CBF6426"></a></p>

<h5>2.4-13 <span class="Heading">The Character Tables of <span class="SimpleMath">4.A_6.2_3</span>, <span class="SimpleMath">12.A_6.2_3</span>,
and <span class="SimpleMath">4.L_2(25).2_3</span></span></h5>

<p>For the "broken box" cases in the <strong class="pkg">Atlas</strong> (see <a href="chapBib.html#biBCCN85">[CCN+85, p. xxiv]</a>), the character tables can be constructed with the <span class="SimpleMath">M.G.A</span> construction method from Section <a href="chap2.html#X82E75B6880EC9E6C"><span class="RefLink">2.3-1</span></a>. (The situation with <span class="SimpleMath">9.U_3(8).3_3</span> is more complicated, this group will be considered in Section <a href="chap2.html#X7AF324AF7A54798F"><span class="RefLink">2.4-16</span></a>.)</p>

<p>The group <span class="SimpleMath">N = 4.A_6.2_3</span> (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 5]</a>) can be described as an upward extension of the normal subgroup <span class="SimpleMath">C ≅ 4.A_6</span> –which is a central product of <span class="SimpleMath">U = 2.A_6</span> and a cyclic group <span class="SimpleMath">⟨ g ⟩</span> of order <span class="SimpleMath">4</span>– by a cyclic group of order <span class="SimpleMath">2</span>, such that the factor group of <span class="SimpleMath">N</span> by the central subgroup <span class="SimpleMath">Z = ⟨ g^2 ⟩</span> of order <span class="SimpleMath">2</span> is isomorphic to a subdirect product <span class="SimpleMath">overlineN</span> of <span class="SimpleMath">M_10 = A_6.2_3</span> and a cyclic group of order <span class="SimpleMath">4</span> and that <span class="SimpleMath">N</span> acts nontrivially on its normal subgroup <span class="SimpleMath">⟨ g ⟩</span>.</p>

<p><center> <img src="ctblcons16.png" alt="The structure of 4.A_6.2_3"/> </center></p>

<p>Thus <span class="SimpleMath">N</span> has the structure <span class="SimpleMath">2.G.2</span>, with <span class="SimpleMath">2.G = C</span> and <span class="SimpleMath">G.2 = overlineN</span>. These two groups are isoclinic variants of <span class="SimpleMath">2 × 2.A_6</span> and of <span class="SimpleMath">2 × M_10</span>, respectively. Each element in <span class="SimpleMath">N ∖ C</span> inverts <span class="SimpleMath">g</span>, so it acts fixed point freely on the faithful irreducible characters of <span class="SimpleMath">C</span>. Hence we can use <code class="func">PossibleCharacterTablesOfTypeMGA</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X78F82DD67E083B88"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeMGA</span></a>) for constructing the character table of <span class="SimpleMath">N</span> from the tables of <span class="SimpleMath">C</span> and <span class="SimpleMath">N/Z</span> and the action of <span class="SimpleMath">N</span> on the classes of <span class="SimpleMath">C</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2a6:= CharacterTable( "2.A6" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblC:= CharacterTableIsoclinic( 2a6 * c2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              x -&gt; Length( x ) = 2 );</span>
[ [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= tblC / ord2[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblNbar:= CharacterTableIsoclinic( CharacterTable( "A6.2_3" ) * c2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( tblG, tblNbar );</span>
[ [ 1, 2, 3, 4, 5, 6, 5, 6, 7, 8, 9, 10, 9, 10 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblG, fus[1], tblNbar );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );</span>
[ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 12 ], 
      [ 9, 13 ], [ 10, 14 ], [ 15, 17 ], [ 16, 18 ], [ 19, 23 ], 
      [ 20, 24 ], [ 21, 25 ], [ 22, 26 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 14 ], 
      [ 9, 13 ], [ 10, 12 ], [ 15 ], [ 16, 18 ], [ 17 ], [ 19, 23 ], 
      [ 20, 26 ], [ 21, 25 ], [ 22, 24 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 14 ], 
      [ 9, 13 ], [ 10, 12 ], [ 15, 17 ], [ 16 ], [ 18 ], [ 19, 23 ], 
      [ 20, 26 ], [ 21, 25 ], [ 22, 24 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= List( elms, pi -&gt; PossibleCharacterTablesOfTypeMGA(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                tblC, tblG, tblNbar, pi, "4.A6.2_3" ) );</span>
[ [  ], [  ], 
  [ 
      rec( 
          MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 9, 6, 9, 8, 7, 10, 
              11, 10, 12, 13, 14, 15, 16, 13, 16, 15, 14 ], 
          table := CharacterTable( "4.A6.2_3" ) ) ] ]
</pre></div>

<p>So we get a unique solution. It coincides with the character table of <span class="SimpleMath">4.A_6.2_3</span> that is stored in the <strong class="pkg">GAP</strong> Character Table Library.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= poss[3][1].table;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( t,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( "4.A6.2_3" ) ) );</span>
true
</pre></div>

<p>Note that the first two candidates for the action lead to tables that do not admit a <span class="SimpleMath">2</span>-power map. In fact the <span class="SimpleMath">2</span>-power map of the character table of <span class="SimpleMath">4.A_6.2_3</span> is not uniquely determined by the matrix of character values. However, the <span class="SimpleMath">2</span>-power map is unique up to automorphisms of this matrix; the function <code class="func">PossibleCharacterTablesOfTypeMGA</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X78F82DD67E083B88"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeMGA</span></a>) takes this into account, and returns only representatives, in this case one table.</p>

<p>As is mentioned in the <strong class="pkg">Atlas</strong> (see <a href="chapBib.html#biBCCN85">[CCN+85, Section 6.7]</a>), the group <span class="SimpleMath">Γ L(2,9)</span> contains subgroups of the structure <span class="SimpleMath">4.A_6.2_3</span>. We can find them as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GammaL(2,9);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi:= IsomorphismPermGroup( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">img:= Image( phi );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">der:= DerivedSubgroup( img );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">derder:= DerivedSubgroup( der );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index( img, derder );</span>
16
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inter:= Filtered( IntermediateSubgroups( img, derder ).subgroups,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               s -&gt; Size( s ) = 4 * Size( derder ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    IsCyclic( CommutatorFactorGroup( s ) ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    Size( Centre( s ) ) = 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( inter );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( inter, x -&gt; IsConjugate( img, inter[1], x ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( t,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( inter[1] ) ) );</span>
true
</pre></div>

<p>The <strong class="pkg">Atlas</strong> states in <a href="chapBib.html#biBCCN85">[CCN+85, Section 6.7]</a> that there is a group of the structure <span class="SimpleMath">2^2.A_6.2_3</span> that is isoclinic with <span class="SimpleMath">4.A_6.2_3</span>. We construct also the character table of the <span class="SimpleMath">2^2.A_6.2_3</span> type group with the <span class="SimpleMath">M.G.A</span> construction method from Section <a href="chap2.html#X82E75B6880EC9E6C"><span class="RefLink">2.3-1</span></a>.</p>

<p>The group <span class="SimpleMath">N = 2^2.A_6.2_3</span> can be described as an upward extension of the normal subgroup <span class="SimpleMath">C ≅ 2 × 2.A_6</span> by a cyclic group of order <span class="SimpleMath">2</span>, such that the factor group of <span class="SimpleMath">N</span> by the central subgroup <span class="SimpleMath">Z</span> of order <span class="SimpleMath">2</span> that is contained in <span class="SimpleMath">U = C' ≅ 2.A_6</span> is isomorphic to a subdirect product <span class="SimpleMath">overlineN</span> of <span class="SimpleMath">M_10 = A_6.2_3</span> and a cyclic group of order <span class="SimpleMath">4</span> and that <span class="SimpleMath">N</span> acts nontrivially on the centre of <span class="SimpleMath">C</span>, which is a Klein four group. <center> <img src="ctblcons17.png" alt="The structure of 2^2.A_6.2_3"/> </center></p>

<p>Thus <span class="SimpleMath">N</span> has the structure <span class="SimpleMath">2.G.2</span>, with <span class="SimpleMath">2.G = C</span> and <span class="SimpleMath">G.2 = overlineN</span>. These latter group is an isoclinic variant of <span class="SimpleMath">2 × M_10</span>, as in the construction of <span class="SimpleMath">4.A_6.2_3</span>. Each element in <span class="SimpleMath">N ∖ C</span> swaps the two involutions in <span class="SimpleMath">Z(C) ∖ Z</span>, so it acts fixed point freely on those irreducible characters of <span class="SimpleMath">C</span> whose kernels do not contain <span class="SimpleMath">Z</span>. Hence we can use <code class="func">PossibleCharacterTablesOfTypeMGA</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X78F82DD67E083B88"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeMGA</span></a>) for constructing the character table of <span class="SimpleMath">N</span> from the tables of <span class="SimpleMath">C</span> and <span class="SimpleMath">N/Z</span> and the action of <span class="SimpleMath">N</span> on the classes of <span class="SimpleMath">C</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblC:= 2a6 * c2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z:= GetFusionMap( 2a6, tblC ){ ClassPositionsOfCentre( 2a6 ) };</span>
[ 1, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= tblC / z;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblNbar:= CharacterTableIsoclinic( CharacterTable( "A6.2_3" ) * c2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( tblG, tblNbar );</span>
[ [ 1, 2, 3, 4, 5, 6, 5, 6, 7, 8, 9, 10, 9, 10 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblG, fus[1], tblNbar );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );</span>
[ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 12 ], 
      [ 9, 13 ], [ 10, 14 ], [ 15, 17 ], [ 16, 18 ], [ 19, 23 ], 
      [ 20, 24 ], [ 21, 25 ], [ 22, 26 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 14 ], 
      [ 9, 13 ], [ 10, 12 ], [ 15 ], [ 16, 18 ], [ 17 ], [ 19, 23 ], 
      [ 20, 26 ], [ 21, 25 ], [ 22, 24 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7, 11 ], [ 8, 14 ], 
      [ 9, 13 ], [ 10, 12 ], [ 15, 17 ], [ 16 ], [ 18 ], [ 19, 23 ], 
      [ 20, 26 ], [ 21, 25 ], [ 22, 24 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= List( elms, pi -&gt; PossibleCharacterTablesOfTypeMGA(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                tblC, tblG, tblNbar, pi, "2^2.A6.2_3" ) );</span>
[ [  ], [  ], 
  [ 
      rec( 
          MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 9, 6, 9, 8, 7, 10, 
              11, 10, 12, 13, 14, 15, 16, 13, 16, 15, 14 ], 
          table := CharacterTable( "2^2.A6.2_3" ) ) ] ]
</pre></div>

<p>So we get a unique solution.</p>

<p>The group <span class="SimpleMath">N = 12.A_6.2_3</span> (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 5]</a>) can be described as an upward extension of the normal subgroup <span class="SimpleMath">C ≅ 12.A_6</span> –which is a central product of <span class="SimpleMath">U = 6.A_6</span> and a cyclic group <span class="SimpleMath">⟨ g ⟩</span> of order <span class="SimpleMath">4</span>– by a cyclic group of order <span class="SimpleMath">2</span>, such that the factor group of <span class="SimpleMath">N</span> by the central subgroup <span class="SimpleMath">Z = ⟨ g^2 ⟩</span> of order <span class="SimpleMath">2</span> is isomorphic to a subdirect product <span class="SimpleMath">overlineN</span> of <span class="SimpleMath">3.M_10 = 3.A_6.2_3</span> and a cyclic group of order <span class="SimpleMath">4</span> and that <span class="SimpleMath">N</span> acts nontrivially on its normal subgroup <span class="SimpleMath">⟨ g ⟩</span>.</p>

<p>Note that <span class="SimpleMath">N</span> has a central subgroup <span class="SimpleMath">Y</span>, say, of order <span class="SimpleMath">3</span>, so the situation here differs from that for groups of the type <span class="SimpleMath">12.G.2</span> with <span class="SimpleMath">G</span> one of <span class="SimpleMath">L_3(4)</span>, <span class="SimpleMath">U_4(3)</span>, where the action on the normal subgroup of order three is nontrivial.</p>

<p><center> <img src="ctblcons18.png" alt="The structure of 12.A_6.2_3"/> </center></p>

<p>Thus <span class="SimpleMath">N</span> has the structure <span class="SimpleMath">2.G.2</span>, with <span class="SimpleMath">2.G = C</span> and <span class="SimpleMath">G.2 = overlineN</span>. These two groups are isoclinic variants of <span class="SimpleMath">2 × 6.A_6</span> and of <span class="SimpleMath">2 × 3.M_10</span>, respectively. Each element in <span class="SimpleMath">N ∖ C</span> inverts <span class="SimpleMath">g</span>, so it acts fixed point freely on the faithful irreducible characters of <span class="SimpleMath">C</span>. Hence we can use <code class="func">PossibleCharacterTablesOfTypeMGA</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X78F82DD67E083B88"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeMGA</span></a>) for constructing the character table of <span class="SimpleMath">N</span> from the tables of <span class="SimpleMath">C</span> and <span class="SimpleMath">N/Z</span> and the action of <span class="SimpleMath">N</span> on the classes of <span class="SimpleMath">C</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblC:= CharacterTableIsoclinic( CharacterTable( "6.A6" ) * c2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              x -&gt; Length( x ) = 2 );</span>
[ [ 1, 7 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= tblC / ord2[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblNbar:= CharacterTableIsoclinic( CharacterTable( "3.A6.2_3" ) * c2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( tblG, tblNbar );</span>
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 13, 14, 15, 16, 
      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 21, 22, 23, 24, 25, 26 ]
    , 
  [ 1, 2, 5, 6, 3, 4, 7, 8, 11, 12, 9, 10, 13, 14, 13, 14, 15, 16, 
      19, 20, 17, 18, 21, 22, 25, 26, 23, 24, 21, 22, 25, 26, 23, 24 
     ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rep:= RepresentativesFusions( Group( () ), fus, tblNbar );</span>
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 13, 14, 15, 16, 
      17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 21, 22, 23, 24, 25, 26 
     ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblG, rep[1], tblNbar );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );</span>
[ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7 ], [ 8 ], [ 9 ], 
      [ 10 ], [ 11 ], [ 12 ], [ 13 ], [ 14 ], [ 15 ], [ 16 ], [ 17 ], 
      [ 18 ], [ 19, 23 ], [ 20, 24 ], [ 21, 25 ], [ 22, 26 ], 
      [ 27, 33 ], [ 28, 34 ], [ 29, 35 ], [ 30, 36 ], [ 31, 37 ], 
      [ 32, 38 ], [ 39, 51 ], [ 40, 52 ], [ 41, 53 ], [ 42, 54 ], 
      [ 43, 55 ], [ 44, 56 ], [ 45, 57 ], [ 46, 58 ], [ 47, 59 ], 
      [ 48, 60 ], [ 49, 61 ], [ 50, 62 ] ], 
  [ [ 1 ], [ 2, 8 ], [ 3 ], [ 4, 10 ], [ 5 ], [ 6, 12 ], [ 7 ], 
      [ 9 ], [ 11 ], [ 13 ], [ 14 ], [ 15 ], [ 16 ], [ 17 ], [ 18 ], 
      [ 19, 23 ], [ 20, 26 ], [ 21, 25 ], [ 22, 24 ], [ 27 ], 
      [ 28, 34 ], [ 29 ], [ 30, 36 ], [ 31 ], [ 32, 38 ], [ 33 ], 
      [ 35 ], [ 37 ], [ 39, 51 ], [ 40, 58 ], [ 41, 53 ], [ 42, 60 ], 
      [ 43, 55 ], [ 44, 62 ], [ 45, 57 ], [ 46, 52 ], [ 47, 59 ], 
      [ 48, 54 ], [ 49, 61 ], [ 50, 56 ] ], 
  [ [ 1 ], [ 2, 8 ], [ 3 ], [ 4, 10 ], [ 5 ], [ 6, 12 ], [ 7 ], 
      [ 9 ], [ 11 ], [ 13 ], [ 14 ], [ 15 ], [ 16 ], [ 17 ], [ 18 ], 
      [ 19, 23 ], [ 20, 26 ], [ 21, 25 ], [ 22, 24 ], [ 27, 33 ], 
      [ 28 ], [ 29, 35 ], [ 30 ], [ 31, 37 ], [ 32 ], [ 34 ], [ 36 ], 
      [ 38 ], [ 39, 51 ], [ 40, 58 ], [ 41, 53 ], [ 42, 60 ], 
      [ 43, 55 ], [ 44, 62 ], [ 45, 57 ], [ 46, 52 ], [ 47, 59 ], 
      [ 48, 54 ], [ 49, 61 ], [ 50, 56 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= List( elms, pi -&gt; PossibleCharacterTablesOfTypeMGA(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                tblC, tblG, tblNbar, pi, "12.A6.2_3" ) );</span>
[ [  ], [  ], 
  [ 
      rec( 
          MGfusMGA := [ 1, 2, 3, 4, 5, 6, 7, 2, 8, 4, 9, 6, 10, 11, 12, 
              13, 14, 15, 16, 17, 18, 19, 16, 19, 18, 17, 20, 21, 22, 
              23, 24, 25, 20, 26, 22, 27, 24, 28, 29, 30, 31, 32, 33, 
              34, 35, 36, 37, 38, 39, 40, 29, 36, 31, 38, 33, 40, 35, 
              30, 37, 32, 39, 34 ], 
          table := CharacterTable( "12.A6.2_3" ) ) ] ]
</pre></div>

<p>So we get again a unique solution. It coincides with the character table that is stored in the <strong class="pkg">GAP</strong> Character Table Library.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( poss[3][1].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( "12.A6.2_3" ) ) );</span>
true
</pre></div>

<p>The construction of the character table of <span class="SimpleMath">4.L_2(25).2_3</span> is analogous to that of the table of <span class="SimpleMath">4.A_6.2_3</span>. We get a unique table that coincides with the table in the <strong class="pkg">GAP</strong> library.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblC:= CharacterTableIsoclinic( CharacterTable( "2.L2(25)" ) * c2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              x -&gt; Length( x ) = 2 );</span>
[ [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= tblC / ord2[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblNbar:= CharacterTableIsoclinic( CharacterTable( "L2(25).2_3" ) * c2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( tblG, tblNbar );</span>
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 10, 11, 12, 13, 14, 13, 14, 15, 
      16, 15, 16, 17, 18, 17, 18, 19, 20, 19, 20 ], 
  [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 10, 11, 12, 13, 14, 13, 14, 17, 
      18, 17, 18, 19, 20, 19, 20, 15, 16, 15, 16 ], 
  [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 10, 11, 12, 13, 14, 13, 14, 19, 
      20, 19, 20, 15, 16, 15, 16, 17, 18, 17, 18 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rep:= RepresentativesFusions( Group( () ), fus, tblNbar );</span>
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 10, 11, 12, 13, 14, 13, 14, 15, 
      16, 15, 16, 17, 18, 17, 18, 19, 20, 19, 20 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblG, rep[1], tblNbar );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );</span>
[ [ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7 ], [ 8 ], [ 9 ], 
      [ 10 ], [ 11, 13 ], [ 12, 14 ], [ 15, 19 ], [ 16, 20 ], 
      [ 17, 21 ], [ 18, 22 ], [ 23, 25 ], [ 24, 26 ], [ 27, 33 ], 
      [ 28, 34 ], [ 29, 31 ], [ 30, 32 ], [ 35, 39 ], [ 36, 40 ], 
      [ 37, 41 ], [ 38, 42 ], [ 43, 47 ], [ 44, 48 ], [ 45, 49 ], 
      [ 46, 50 ], [ 51, 55 ], [ 52, 56 ], [ 53, 57 ], [ 54, 58 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7 ], [ 8, 10 ], [ 9 ], 
      [ 11 ], [ 12, 14 ], [ 13 ], [ 15, 19 ], [ 16, 22 ], [ 17, 21 ], 
      [ 18, 20 ], [ 23, 25 ], [ 24 ], [ 26 ], [ 27, 31 ], [ 28, 34 ], 
      [ 29, 33 ], [ 30, 32 ], [ 35, 39 ], [ 36, 42 ], [ 37, 41 ], 
      [ 38, 40 ], [ 43, 47 ], [ 44, 50 ], [ 45, 49 ], [ 46, 48 ], 
      [ 51, 55 ], [ 52, 58 ], [ 53, 57 ], [ 54, 56 ] ], 
  [ [ 1 ], [ 2, 4 ], [ 3 ], [ 5 ], [ 6 ], [ 7 ], [ 8, 10 ], [ 9 ], 
      [ 11, 13 ], [ 12 ], [ 14 ], [ 15, 19 ], [ 16, 22 ], [ 17, 21 ], 
      [ 18, 20 ], [ 23, 25 ], [ 24 ], [ 26 ], [ 27, 33 ], [ 28, 32 ], 
      [ 29, 31 ], [ 30, 34 ], [ 35, 39 ], [ 36, 42 ], [ 37, 41 ], 
      [ 38, 40 ], [ 43, 47 ], [ 44, 50 ], [ 45, 49 ], [ 46, 48 ], 
      [ 51, 55 ], [ 52, 58 ], [ 53, 57 ], [ 54, 56 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= List( elms, pi -&gt; PossibleCharacterTablesOfTypeMGA(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                tblC, tblG, tblNbar, pi, "4.L2(25).2_3" ) );</span>
[ [  ], [  ], 
  [ 
      rec( 
          MGfusMGA := [ 1, 2, 3, 2, 4, 5, 6, 7, 8, 7, 9, 10, 9, 11, 12, 
              13, 14, 15, 12, 15, 14, 13, 16, 17, 16, 18, 19, 20, 21, 
              22, 21, 20, 19, 22, 23, 24, 25, 26, 23, 26, 25, 24, 27, 
              28, 29, 30, 27, 30, 29, 28, 31, 32, 33, 34, 31, 34, 33, 
              32 ], table := CharacterTable( "4.L2(25).2_3" ) ) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( poss[3][1].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( "4.L2(25).2_3" ) ) );</span>
true
</pre></div>

<p>Note that the group <span class="SimpleMath">Γ L(2,25)</span> does <em>not</em> contain subgroups of the structure <span class="SimpleMath">4.L_2(25).2_3</span>, since <span class="SimpleMath">Γ L(2,25)</span> acts on its subgroup of scalar matrices via mapping each element to its fifth power, thus the central subgroup of order four in GL<span class="SimpleMath">(2,25)</span> is central also in <span class="SimpleMath">Γ L(2,25)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GammaL(2,25);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi:= IsomorphismPermGroup( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">img:= Image( phi );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">der:= DerivedSubgroup( img );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">derder:= DerivedSubgroup( der );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index( img, derder );</span>
48
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inter:= Filtered( IntermediateSubgroups( img, derder ).subgroups,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               s -&gt; Size( s ) = 4 * Size( derder ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    IsCyclic( CommutatorFactorGroup( s ) ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    Size( Centre( s ) ) = 2 );</span>
[  ]
</pre></div>

<p>In order to construct a representation of a group of the structure <span class="SimpleMath">4.L_2(25).2_3</span>, we can use the function <code class="code">CyclicExtensions</code> from the <strong class="pkg">GAP</strong> package <strong class="pkg">GrpConst</strong>. We start from the index two subgroup <span class="SimpleMath">4.L_2(25)</span>, which is a central product of <span class="SimpleMath">SL(2,25)</span> and a cyclic group of order four, and find exactly one upwards extension by a cyclic group of order two, up to isomorphism, with the required properties.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:= Centralizer( img, derder );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( c );  IsCyclic( c );</span>
24
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cgen:= MinimalGeneratingSet( c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">four:= cgen[1]^6;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= ClosureGroup( derder, four );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "GrpConst", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">filt:= Filtered( CyclicExtensions( s, 2 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              x -&gt; Size( Centre( x ) ) = 2 and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   IsCyclic( CommutatorFactorGroup( x ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( filt );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismGroups( filt[1], filt[2] ) &lt;&gt; fail;</span>
true
</pre></div>

<p>The character table of this group coincides with the library table.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( CharacterTable( filt[1] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "4.L2(25).2_3" ) ) &lt;&gt; fail;</span>
true
</pre></div>

<p><a id="X7BD79BA37C3E729B" name="X7BD79BA37C3E729B"></a></p>

<h5>2.4-14 <span class="Heading">The Character Table of <span class="SimpleMath">4.L_2(49).2_3</span> (December 2020)</span></h5>

<p>The character tables of the simple group <span class="SimpleMath">L_2(49)</span> and of its extensions do not appear in the <strong class="pkg">Atlas</strong> of Finite Groups <a href="chapBib.html#biBCCN85">[CCN+85]</a>, but they may be regarded as <strong class="pkg">Atlas</strong> tables because a data file in the format used to produce the <strong class="pkg">Atlas</strong> has been available for a long time, as is stated in <a href="chapBib.html#biBJLPW95">[JLPW95, Appendix 2]</a>.</p>

<p>Analogous to <span class="SimpleMath">L_2(9) ≅ A_6</span> and <span class="SimpleMath">L_2(25)</span>, see Section <a href="chap2.html#X7E9A88DA7CBF6426"><span class="RefLink">2.4-13</span></a>, the <strong class="pkg">Atlas</strong> map for <span class="SimpleMath">G = L_2(49)</span> shows a "broken box", since there is no group of the form <span class="SimpleMath">2.G.2_3</span>, and a group of the structure <span class="SimpleMath">4.G.2_3</span> can be considered instead, which has a normal subgroup isomorphic with <span class="SimpleMath">2.(2 × G)</span> and a factor group isomorphic with <span class="SimpleMath">(2 × G).2_3</span>, see Section <a href="chap2.html#X7E9A88DA7CBF6426"><span class="RefLink">2.4-13</span></a>. Having its character table available has the effect that the functions <code class="func">DisplayAtlasMap</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap3.html#X875A6BB485A49976"><span class="RefLink">CTblLib: DisplayAtlasMap for the name of a simple group</span></a>) and <code class="func">BrowseAtlasTable</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap3.html#X79DC72707B08A701"><span class="RefLink">CTblLib: BrowseAtlasTable</span></a>) work with input <code class="code">"L2(49)"</code>.</p>

<p>We construct the character table of <span class="SimpleMath">4.L_2(49).2_3</span> in the same way as for the extensions of <span class="SimpleMath">L_2(9)</span> and <span class="SimpleMath">L_2(25)</span>. There is a unique solution.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2l:= CharacterTable( "2.L2(49)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblC:= CharacterTableIsoclinic( 2l * c2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              x -&gt; Length( x ) = 2 );</span>
[ [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= tblC / ord2[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblNbar:= CharacterTableIsoclinic(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( "L2(49).2_3" ) * c2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( tblG, tblNbar );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( fus );</span>
10
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblG, fus[1], tblNbar );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= List( elms, pi -&gt; PossibleCharacterTablesOfTypeMGA(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                tblC, tblG, tblNbar, pi, "4.L2(49).2_3" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( poss, Length );</span>
[ 0, 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= poss[3][1].table;</span>
CharacterTable( "4.L2(49).2_3" )
</pre></div>

<p>Analogous to the situation with <span class="SimpleMath">L_2(9)</span>, a group of the desired structure can be found inside the semilinear group <span class="SimpleMath">Γ</span>L<span class="SimpleMath">(2,49)</span>. In fact, there is a unique class of subgroups in <span class="SimpleMath">Γ</span>L<span class="SimpleMath">(2,49)</span> that contain SL<span class="SimpleMath">(2,49) ≅ 2.G</span>, have the right order, have cyclic commutator factor group, and centre of order <span class="SimpleMath">2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GammaL(2,49);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi:= IsomorphismPermGroup( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">img:= Image( phi );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">der:= DerivedSubgroup( img );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">derder:= DerivedSubgroup( der );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index( img, derder );</span>
96
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inter:= Filtered( IntermediateSubgroups( img, derder ).subgroups,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               s -&gt; Size( s ) = 4 * Size( derder ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    IsCyclic( CommutatorFactorGroup( s ) ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    Size( Centre( s ) ) = 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( inter );                                        </span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( inter, x -&gt; IsConjugate( img, inter[1], x ) );</span>
true
</pre></div>

<p>The character tables of these groups coincide with the table constructed above, and with the library table.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( t,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( inter[1] ) ) &lt;&gt; fail;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( t,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "4.L2(49).2_3" ) ) &lt;&gt; fail;</span>
true
</pre></div>

<p><a id="X817A961487D2DFD1" name="X817A961487D2DFD1"></a></p>

<h5>2.4-15 <span class="Heading">The Character Table of <span class="SimpleMath">4.L_2(81).2_3</span> (December 2020)</span></h5>

<p>We start with the character-theoretic construction of this table, analogous to the cases of <span class="SimpleMath">L_2(9)</span>, <span class="SimpleMath">L_2(25)</span>, <span class="SimpleMath">L_2(49)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2l:= CharacterTable( "2.L2(81)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblC:= CharacterTableIsoclinic( 2l * c2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord2:= Filtered( ClassPositionsOfNormalSubgroups( tblC ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              x -&gt; Length( x ) = 2 );</span>
[ [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= tblC / ord2[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblNbar:= CharacterTableIsoclinic(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( "L2(81).2_3" ) * c2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( tblG, tblNbar );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( fus );</span>
40
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fusreps:= RepresentativesFusions( tblG, fus, tblNbar );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( fusreps );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblG, fusreps[1], tblNbar );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeMGA( tblC, tblG, tblNbar );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= List( elms, pi -&gt; PossibleCharacterTablesOfTypeMGA(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                tblC, tblG, tblNbar, pi, "4.L2(81).2_3" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( poss, Length );</span>
[ 0, 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( poss[3][1].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "4.L2(81).2_3" ) ) &lt;&gt; fail;</span>
true
</pre></div>

<p>Like in the case of <span class="SimpleMath">L_2(25)</span>, there are <em>no</em> <span class="SimpleMath">4.L_2(81).2_3</span> type subgroups in <span class="SimpleMath">Γ L(2,81)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= GammaL(2,81);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi:= IsomorphismPermGroup( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">img:= Image( phi );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">der:= DerivedSubgroup( img );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">derder:= DerivedSubgroup( der );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index( img, derder );</span>
320
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inter:= Filtered( IntermediateSubgroups( img, derder ).subgroups,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               s -&gt; Size( s ) = 4 * Size( derder ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    IsCyclic( CommutatorFactorGroup( s ) ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    Size( Centre( s ) ) = 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( inter, x -&gt; IsConjugate( img, inter[1], x ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrConjugacyClasses( inter[1] );</span>
52
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrConjugacyClasses( CharacterTable( "4.L2(81).2_3" ) );</span>
112
</pre></div>

<p>The subgroups of <span class="SimpleMath">Γ L(2,81)</span> constructed above have the structure <span class="SimpleMath">2.L_2(81).4_1</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "2.L2(81).4_1" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrConjugacyClasses( t );</span>
52
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( t,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( inter[1] ) ) &lt;&gt; fail;</span>
true
</pre></div>

<p>Like in the case of <span class="SimpleMath">L_2(25)</span>, we can construct a group with the structure <span class="SimpleMath">4.L_2(81).2_3</span> via the function <code class="code">CyclicExtensions</code> from the <strong class="pkg">GAP</strong> package <strong class="pkg">GrpConst</strong>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c:= Centralizer( img, derder );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( c );  IsCyclic( c );</span>
80
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cgen:= MinimalGeneratingSet( c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">four:= cgen[1]^20;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= ClosureGroup( derder, four );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "GrpConst", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">filt:= Filtered( CyclicExtensions( s, 2 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              x -&gt; Size( Centre( x ) ) = 2 and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   IsCyclic( CommutatorFactorGroup( x ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( filt );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismGroups( filt[1], filt[2] ) &lt;&gt; fail;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TransformingPermutationsCharacterTables( CharacterTable( filt[1] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "4.L2(81).2_3" ) ) &lt;&gt; fail;</span>
true
</pre></div>

<p><a id="X7AF324AF7A54798F" name="X7AF324AF7A54798F"></a></p>

<h5>2.4-16 <span class="Heading">The Character Table of <span class="SimpleMath">9.U_3(8).3_3</span> (March 2017)</span></h5>

<p>The group that is called <span class="SimpleMath">9.U_3(8).3_3</span> in the <strong class="pkg">Atlas</strong> of Finite Groups occurs as a subgroup of <span class="SimpleMath">Γ</span>U<span class="SimpleMath">(3, 8)</span>. Note that GU<span class="SimpleMath">(3, 8)</span> has the structure <span class="SimpleMath">3.(3 × U_3(8)).3_2</span> (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 66]</a>), and extending the subgroup <span class="SimpleMath">C = 3.(3 × U_3(8))</span> by the product of an element outside <span class="SimpleMath">C</span> with the field automorphism of order three of GF<span class="SimpleMath">(64)</span> yields a group <span class="SimpleMath">N</span> of the structure <span class="SimpleMath">3.(3 × U_3(8)).3_3</span> whose centre has order three.</p>

<p>The character table of <span class="SimpleMath">N</span> can be constructed with the <span class="SimpleMath">M.G.A</span> construction method from Section <a href="chap2.html#X82E75B6880EC9E6C"><span class="RefLink">2.3-1</span></a>. The situation is similar to that with <span class="SimpleMath">4.A_6.2_3</span>, see Section <a href="chap2.html#X7E9A88DA7CBF6426"><span class="RefLink">2.4-13</span></a>, in particular the situation is described by the same picture that is shown for <span class="SimpleMath">4.A_6.2_3</span> in this section, just the subgroups <span class="SimpleMath">Z</span> and <span class="SimpleMath">⟨ g ⟩</span> have the orders three and nine, respectively, and <span class="SimpleMath">C</span> has index three in <span class="SimpleMath">N</span>.</p>

<p>The normal subgroup <span class="SimpleMath">C ≅ 9.U_3(8)</span> is a central product of <span class="SimpleMath">U = 3.U_3(8)</span> and a cyclic group <span class="SimpleMath">⟨ g ⟩</span> of order <span class="SimpleMath">9</span>, and the factor group of <span class="SimpleMath">N</span> by the central subgroup <span class="SimpleMath">Z = ⟨ g^3 ⟩</span> of order <span class="SimpleMath">3</span> is isomorphic to a subdirect product <span class="SimpleMath">overlineN</span> of <span class="SimpleMath">U_3(8).3_3</span> and a cyclic group of order <span class="SimpleMath">9</span>, such that <span class="SimpleMath">N</span> acts nontrivially on its normal subgroup <span class="SimpleMath">⟨ g ⟩</span>.</p>

<p>Thus <span class="SimpleMath">N</span> has the structure <span class="SimpleMath">3.G.3</span>, with <span class="SimpleMath">3.G = C</span> and <span class="SimpleMath">G.3 = overlineN</span>. Each element in <span class="SimpleMath">N ∖ C</span> raises <span class="SimpleMath">g</span> to its fourth or seventh power, so it acts fixed point freely on the faithful irreducible characters of <span class="SimpleMath">C</span>. Hence we can use <code class="func">PossibleCharacterTablesOfTypeMGA</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X78F82DD67E083B88"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeMGA</span></a>) for constructing the character table of <span class="SimpleMath">N</span> from the tables of <span class="SimpleMath">C</span> and <span class="SimpleMath">N/Z</span> and the action of <span class="SimpleMath">N</span> on the classes of <span class="SimpleMath">C</span>.</p>

<p>Since we want to construct also <em>Brauer tables</em> of <span class="SimpleMath">N</span>, we have to choose the class fusion that describes the embedding of <span class="SimpleMath">C / Z</span> into <span class="SimpleMath">overlineN</span> compatibly with the known Brauer tables of <span class="SimpleMath">U_3(8)</span> and <span class="SimpleMath">U_3(8).3_3</span>. Note that the <span class="SimpleMath">2</span>-modular tables of these groups impose additional conditions on the class fusion.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s:= CharacterTable( "U3(8)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3:= CharacterTable( "U3(8).3_3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= PossibleClassFusions( s, s3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( poss );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesFusions( s, poss, s3 ) );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">smod2:= s mod 2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3mod2:= s3 mod 2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">good:= [];;  modmap:= 0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for map in poss do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modmap:= CompositionMaps( InverseMap( GetFusionMap( s3mod2, s3 ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  CompositionMaps( map, GetFusionMap( smod2, s ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     rest:= List( Irr( s3mod2 ), x -&gt; x{ modmap } );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if not fail in Decomposition( Irr( smod2 ), rest, "nonnegative" ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Add( good, map );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( good );</span>
2
</pre></div>

<p>The class fusion from <span class="SimpleMath">U_3(8)</span> to <span class="SimpleMath">U_3(8).3_3</span> is determined up to complex conjugation by the <span class="SimpleMath">2</span>-modular Brauer tables. We choose the fusion that is stored on the library tables.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">good[2] = CompositionMaps( PowerMap( s3, -1 ), good[1] );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetFusionMap( s, s3 ) in good;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sfuss3:= GetFusionMap( s, s3 );;</span>
</pre></div>

<p>In the next step, we construct the character tables of <span class="SimpleMath">C / Z ≅ U_3(8) × 3</span> and <span class="SimpleMath">N / Z ≅ (U_3(8) × 3).3_3</span>, and those class fusions between the two tables that are compatible with the fusion between the factors that was chosen above (w. r. t. the stored factor fusions).</p>

<p>In order not to leave out some candidates, we have to consider also the table of <span class="SimpleMath">N/Z</span> that is obtained from the "other" construction as an isoclinic table of <span class="SimpleMath">3 × U_3(8).3_3</span>.</p>

<p>(This may look complicated. It would perhaps be more natural to construct the ordinary tables first, by considering the possible fusions, and later to adjust the choices to the conditions that are imposed by the Brauer tables. However, the technical complications of that construction would not be smaller in the end.)</p>

<p>We get four candidates, two for each of the two tables of <span class="SimpleMath">N/Z</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c3:= CharacterTable( "Cyclic", 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= s * c3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dp:= s3 * c3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA1:= CharacterTableIsoclinic( dp, rec( k:= 1 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA2:= CharacterTableIsoclinic( dp, rec( k:= 2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">good:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGmod2:= tblG mod 2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for tblGA in [ tblGA1, tblGA2 ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblGAmod2:= tblGA mod 2;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     for map in PossibleClassFusions( tblG, tblGA ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modmap:= CompositionMaps(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           InverseMap( GetFusionMap( tblGAmod2, tblGA ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           CompositionMaps( map, GetFusionMap( tblGmod2, tblG ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       rest:= List( Irr( tblGAmod2 ), x -&gt; x{ modmap } );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if not fail in Decomposition( Irr( tblGmod2 ), rest,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                          "nonnegative" ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          CompositionMaps( GetFusionMap( tblGA, s3 ), map ) =</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          CompositionMaps( sfuss3, GetFusionMap( tblG, s ) ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Add( good, [ tblGA, map ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( good, x -&gt; x[1] );</span>
[ CharacterTable( "Isoclinic(U3(8).3_3xC3,1)" ), 
  CharacterTable( "Isoclinic(U3(8).3_3xC3,1)" ), 
  CharacterTable( "Isoclinic(U3(8).3_3xC3,2)" ), 
  CharacterTable( "Isoclinic(U3(8).3_3xC3,2)" ) ]
</pre></div>

<p>The character table of <span class="SimpleMath">C</span> can be constructed with <code class="func">CharacterTableIsoclinic</code> (<a href="../../../doc/ref/chap71.html#X85BE46F784B83938"><span class="RefLink">Reference: CharacterTableIsoclinic</span></a>) from the character table of <span class="SimpleMath">3 × 3.U_3(8)</span>. (Here we need to consider only one variant of the table.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3s:= CharacterTable( "3.U3(8)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dp:= 3s * c3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG:= CharacterTableIsoclinic( dp );;</span>
</pre></div>

<p>The construction of this table does not automatically yield a factor fusion to the table of <span class="SimpleMath">C/Z</span>. We form the relevant factor table, which has the same ordering of irreducible characters, and use the factor fusion to this table.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetFusionMap( tblMG, tblG );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cen:= ClassPositionsOfCentre( tblMG );</span>
[ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( tblMG ){ cen };</span>
[ 1, 9, 9, 3, 9, 9, 3, 9, 9 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">facttbl:= tblMG / [ 1, 4, 7 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr:= TransformingPermutationsCharacterTables( facttbl, tblG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tr.rows;  tr.columns;</span>
()
()
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblMG, GetFusionMap( tblMG, facttbl ), tblG );</span>
</pre></div>

<p>Now we compute the orbits of the possible actions of <span class="SimpleMath">N</span> on the classes of <span class="SimpleMath">C</span>, and the resulting candidates for the character table of <span class="SimpleMath">N</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">posstbls:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for pair in good do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblGA:= pair[1];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     GfusGA:= pair[2];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblG:= s * c3;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     StoreFusion( tblG, GfusGA, tblGA );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     for pi in PossibleActionsForTypeMGA( tblMG, tblG, tblGA ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       for cand in PossibleCharacterTablesOfTypeMGA(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                       tblMG, tblG, tblGA, pi, "test" ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Add( posstbls, [ tblGA, cand ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( posstbls );</span>
32
</pre></div>

<p>Now we discard all those candidates that are not compatible with the <span class="SimpleMath">2</span>-modular character tables.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compatible:= [];;  r:= 0;;  modr:= 0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for pair in posstbls do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblGA:= pair[1];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     r:= pair[2];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     comp:= ComputedClassFusions( tblMG );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     pos:= PositionProperty( comp, x -&gt; x.name = Identifier( r.table ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if pos = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       StoreFusion( tblMG, r.MGfusMGA, r.table );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       comp[ pos ]:= ShallowCopy( comp[ pos ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       comp[ pos ].map:= r.MGfusMGA;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Unbind( ComputedBrauerTables( tblMG )[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modr:= BrauerTableOfTypeMGA( tblMG mod 2, tblGA mod 2, r.table );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     rest:= List( Irr( modr.table ), x -&gt; x{ modr.MGfusMGA } );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     dec:= Decomposition( Irr( tblMG mod 2 ), rest, "nonnegative" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if not fail in dec then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Add( compatible, pair );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( compatible );</span>
8
</pre></div>

<p>The remaining candidates fall into two equivalence classes.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for pair in compatible do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if ForAll( tbls, t -&gt; TransformingPermutationsCharacterTables(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                               t, pair[2].table ) = fail ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Add( tbls, pair[2].table );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( tbls );</span>
2
</pre></div>

<p>The two tables can be distinguished by their element orders  one contains the element order <span class="SimpleMath">54</span> and the other does not  or by their <span class="SimpleMath">4</span>th power maps  the classes of element order <span class="SimpleMath">171</span> in one table are not fixed by the <span class="SimpleMath">4</span>th power map, the corresponding classes in the other table are fixed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set( OrdersClassRepresentatives( tbls[1] ) );</span>
[ 1, 2, 3, 4, 6, 7, 9, 12, 18, 19, 21, 27, 36, 54, 57, 63, 171 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set( OrdersClassRepresentatives( tbls[2] ) );</span>
[ 1, 2, 3, 4, 6, 7, 9, 12, 18, 19, 21, 27, 36, 57, 63, 171 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos171:= Positions( OrdersClassRepresentatives( tbls[1] ), 171 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pow4:= PowerMap( tbls[1], 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAny( [ 1 .. Length( pos171 ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           i -&gt; pos171[i] = pow4[ pos171[i] ] );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos171:= Positions( OrdersClassRepresentatives( tbls[2] ), 171 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PowerMap( tbls[2], 4 ){ pos171 } = pos171;</span>
true
</pre></div>

<p>Thus we can use the group <span class="SimpleMath">N</span> to decide which table is correct. For that, we construct a permutation representation of <span class="SimpleMath">N</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gu:= GU(3,8);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orbs:= OrbitsDomain( gu, Elements( GF(64)^3 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( orbs, Length );</span>
[ 1, 32319, 32832, 32832, 32832, 32832, 32832, 32832, 32832 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= SortedList( First( orbs, x -&gt; Length( x ) = 32319 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">actgu:= Action( gu, orb, OnRight );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( actgu ) = Size( gu );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cen:= Centre( actgu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( cen );</span>
9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= ClosureGroup( DerivedSubgroup( actgu ), cen );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut:= v -&gt; List( v, x -&gt; x^4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= PermList( List( orb, v -&gt; PositionSorted( orb, aut( v ) ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">outer:= First( GeneratorsOfGroup( actgu ), x -&gt; not x in u );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= ClosureGroup( u, pi * outer );;</span>
</pre></div>

<p>Before we perform computations with the group, we reduce the degree of the representation by a factor of <span class="SimpleMath">7</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Group( SmallGeneratingSet( g ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">allbl:= AllBlocks( g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( allbl, Length );</span>
[ 3, 21, 63, 9, 7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">orb:= Orbit( g, First( allbl, x -&gt; Length( x ) = 7 ), OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">act:= Action( g, orb, OnSets );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( act ) = Size( g );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrMovedPoints( act );</span>
4617
</pre></div>

<p>Now we test whether an element of order <span class="SimpleMath">171</span> in <span class="SimpleMath">N</span> is conjugate in <span class="SimpleMath">N</span> to its fourth power.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat x:= PseudoRandom( act ); until Order( x ) = 171;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsConjugate( act, x, x^4 );</span>
true
</pre></div>

<p>This means that the second of the candidate tables constructed above is the right one. The character table with the identifier <code class="code">"9.U3(8).3_3"</code> in the character table library is equivalent to this table.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib:= CharacterTable( "9.U3(8).3_3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( tbls[2], lib ) );</span>
true
</pre></div>

<p><strong class="pkg">GAP</strong>'s currently available methods for the automatic computation of character tables would require too much space when called with this permutation group. Using interactive methods, one can compute the character table with <strong class="pkg">GAP</strong>. The table obtained this way is equivalent to the library character table with the identifier <code class="code">"9.U3(8).3_3"</code>.</p>

<p>I do not know how to disprove the other candidate with character-theoretic arguments. Thus this table provides an example of a pseudo character table, see Section <a href="chap2.html#X7E0C603880157C4E"><span class="RefLink">2.4-17</span></a>.</p>

<p><a id="X7E0C603880157C4E" name="X7E0C603880157C4E"></a></p>

<h5>2.4-17 <span class="Heading">Pseudo Character Tables of the Type <span class="SimpleMath">M.G.A</span> (May 2004)</span></h5>

<p>With the construction method for character tables of groups of the type <span class="SimpleMath">M.G.A</span>, one can construct tables that have many properties of character tables but that are not character tables of groups, cf. <a href="chapBib.html#biBGag86">[Gag86]</a>. For example, the group <span class="SimpleMath">3.A_6.2_3</span> has a <em>central</em> subgroup of order <span class="SimpleMath">3</span>, so it is not of the type <span class="SimpleMath">M.G.A</span> with fixed-point free action on the faithful characters of <span class="SimpleMath">M.G</span>.</p>

<p>However, if we apply the "<span class="SimpleMath">M.G.A</span> construction" to the groups <span class="SimpleMath">M.G = 3.A_6</span>, <span class="SimpleMath">G = A_6</span>, and <span class="SimpleMath">G.A = A_6.2_3</span> then we get a (in this case unique) result.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG := CharacterTable( "3.A6" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG  := CharacterTable( "A6" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA := CharacterTable( "A6.2_3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );  </span>
[ [ [ 1 ], [ 2, 3 ], [ 4 ], [ 5, 6 ], [ 7, 8 ], [ 9 ], [ 10, 11 ], 
      [ 12, 15 ], [ 13, 17 ], [ 14, 16 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= PossibleCharacterTablesOfTypeMGA(                  </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                tblMG, tblG, tblGA, elms[1], "pseudo" );    </span>
[ rec( 
      MGfusMGA := [ 1, 2, 2, 3, 4, 4, 5, 5, 6, 7, 7, 8, 9, 10, 8, 10, 
          9 ], table := CharacterTable( "pseudo" ) ) ]
</pre></div>

<p>Such a table automatically satisfies the orthogonality relations, and the tensor product of two "irreducible characters" of which at least one is a row from <span class="SimpleMath">G.A</span> decomposes into a sum of the "irreducible characters", where the coefficients are nonnegative integers.</p>

<p>In this example, any tensor product decomposes with nonnegative integral coefficients, <span class="SimpleMath">n</span>-th symmetrizations of "irreducible characters" decompose, for <span class="SimpleMath">n ≤ 5</span>, and the "class multiplication coefficients" are nonnegative integers.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pseudo:= poss[1].table;</span>
CharacterTable( "pseudo" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( pseudo );</span>
pseudo

      2  4   3  4  3  .  3   2  .   .   .  2  3  3
      3  3   3  1  1  2  1   1  1   1   1  .  .  .
      5  1   1  .  .  .  .   .  1   1   1  .  .  .

        1a  3a 2a 6a 3b 4a 12a 5a 15a 15b 4b 8a 8b
     2P 1a  3a 1a 3a 3b 2a  6a 5a 15a 15b 2a 4a 4a
     3P 1a  1a 2a 2a 1a 4a  4a 5a  5a  5a 4b 8a 8b
     5P 1a  3a 2a 6a 3b 4a 12a 1a  3a  3a 4b 8b 8a

X.1      1   1  1  1  1  1   1  1   1   1  1  1  1
X.2      1   1  1  1  1  1   1  1   1   1 -1 -1 -1
X.3     10  10  2  2  1 -2  -2  .   .   .  .  .  .
X.4     16  16  .  . -2  .   .  1   1   1  .  .  .
X.5      9   9  1  1  .  1   1 -1  -1  -1  1 -1 -1
X.6      9   9  1  1  .  1   1 -1  -1  -1 -1  1  1
X.7     10  10 -2 -2  1  .   .  .   .   .  .  B -B
X.8     10  10 -2 -2  1  .   .  .   .   .  . -B  B
X.9      6  -3 -2  1  .  2  -1  1   A  /A  .  .  .
X.10     6  -3 -2  1  .  2  -1  1  /A   A  .  .  .
X.11    12  -6  4 -2  .  .   .  2  -1  -1  .  .  .
X.12    18  -9  2 -1  .  2  -1 -2   1   1  .  .  .
X.13    30 -15 -2  1  . -2   1  .   .   .  .  .  .

A = -E(15)-E(15)^2-E(15)^4-E(15)^8
  = (-1-Sqrt(-15))/2 = -1-b15
B = E(8)+E(8)^3
  = Sqrt(-2) = i2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsInternallyConsistent( pseudo );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">irr:= Irr( pseudo );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test:= Concatenation( List( [ 2 .. 5 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              n -&gt; Symmetrizations( pseudo, irr, n ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( test, Set( Tensored( irr, irr ) ) );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fail in Decomposition( irr, test, "nonnegative" );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">if ForAny( Tuples( [ 1 .. NrConjugacyClasses( pseudo ) ], 3 ),        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     t -&gt; not ClassMultiplicationCoefficient( pseudo, t[1], t[2], t[3] )   </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              in NonnegativeIntegers ) then                           </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Error( "contradiction" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">fi;</span>
</pre></div>

<p>I do not know a character-theoretic argument for showing that this table is <em>not</em> the character table of a group, but we can use the following group-theoretic argument. Suppose that the group <span class="SimpleMath">G</span>, say, has the above character table. Then <span class="SimpleMath">G</span> has a unique composition series with factors of the orders <span class="SimpleMath">3</span>, <span class="SimpleMath">360</span>, and <span class="SimpleMath">2</span>, respectively. Let <span class="SimpleMath">N</span> denote the normal subgroup of order <span class="SimpleMath">3</span> in <span class="SimpleMath">G</span>. The factor group <span class="SimpleMath">F = G/N</span> is an automorphic extension of <span class="SimpleMath">A_6</span>, and according to <a href="chapBib.html#biBCCN85">[CCN+85, p. 4]</a> it is isomorphic with <span class="SimpleMath">M_10 = A_6.2_3</span> and has Sylow <span class="SimpleMath">3</span> normalizers of the structure <span class="SimpleMath">3^2 : Q_8</span>. Since the Sylow <span class="SimpleMath">3</span> subgroup of <span class="SimpleMath">G</span> is a self-centralizing nonabelian group of order <span class="SimpleMath">3^3</span> and of exponent <span class="SimpleMath">3</span>, the Sylow <span class="SimpleMath">3</span> normalizers in <span class="SimpleMath">G</span> have the structure <span class="SimpleMath">3^{1+2}_+ : Q_8</span>, but the <span class="SimpleMath">Q_8</span> type subgroups of Aut<span class="SimpleMath">( 3^{1+2}_+ )</span> act trivially on the centre of <span class="SimpleMath">3^{1+2}_+</span>, contrary to the situation in the above table.</p>

<p>In general, this construction need not produce tables for which all symmetrizations of irreducible characters decompose properly. For example, applying <code class="func">PossibleCharacterTablesOfTypeMGA</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X78F82DD67E083B88"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeMGA</span></a>) to the case <span class="SimpleMath">M.G = 3.L_3(4)</span> and <span class="SimpleMath">G.A = L_3(4).2_1</span> does not yield a table because the function suppresses tables that do not admit <span class="SimpleMath">p</span>-th power maps, for prime divisors <span class="SimpleMath">p</span> of the order of <span class="SimpleMath">M.G.A</span>, and in this case no compatible <span class="SimpleMath">2</span>-power map exists.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG := CharacterTable( "3.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG  := CharacterTable( "L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA := CharacterTable( "L3(4).2_1" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );</span>
[ [ [ 1 ], [ 2, 3 ], [ 4 ], [ 5, 6 ], [ 7 ], [ 8 ], [ 9, 10 ], 
      [ 11 ], [ 12, 13 ], [ 14 ], [ 15, 16 ], [ 17, 20 ], [ 18, 22 ], 
      [ 19, 21 ], [ 23, 26 ], [ 24, 28 ], [ 25, 27 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, elms[1], "?" );</span>
[  ]
</pre></div>

<p>Also, it may happen that already <code class="func">PossibleActionsForTypeMGA</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7899AA12836EEF8F"><span class="RefLink">CTblLib: PossibleActionsForTypeMGA</span></a>) returns an empty list. Examples are <span class="SimpleMath">M.G = 3_1.U_4(3)</span>, <span class="SimpleMath">G.A = U_4(3).2_2</span> and <span class="SimpleMath">M.G = 3_2.U_4(3)</span>, <span class="SimpleMath">G.A = U_4(3).2_3</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG  := CharacterTable( "U4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG := CharacterTable( "3_1.U4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA := CharacterTable( "U4(3).2_2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossibleActionsForTypeMGA( tblMG, tblG, tblGA );</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblMG:= CharacterTable( "3_2.U4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblGA:= CharacterTable( "U4(3).2_3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossibleActionsForTypeMGA( tblMG, tblG, tblGA );</span>
[  ]
</pre></div>

<p>Also the sections <a href="chap2.html#X794EC2FD7F69B4E6"><span class="RefLink">2.4-5</span></a> and <a href="chap2.html#X7AF324AF7A54798F"><span class="RefLink">2.4-16</span></a> provide examples of pseudo character tables. If one does not use the arguments about Brauer tables then the latter section presents in fact several pseudo character tables.</p>

<p><a id="X844185EF7A8F2A99" name="X844185EF7A8F2A99"></a></p>

<h5>2.4-18 <span class="Heading">Some Extra-ordinary <span class="SimpleMath">p</span>-Modular Tables of the Type <span class="SimpleMath">M.G.A</span>
(September 2005)</span></h5>

<p>For a group <span class="SimpleMath">M.G.A</span> in the sense of Section <a href="chap2.html#X82E75B6880EC9E6C"><span class="RefLink">2.3-1</span></a> such that <em>not</em> all ordinary irreducible characters <span class="SimpleMath">χ</span> have the property that <span class="SimpleMath">M</span> is contained in the kernel of <span class="SimpleMath">χ</span> or <span class="SimpleMath">χ</span> is induced from <span class="SimpleMath">M.G</span>, it may happen that there are primes <span class="SimpleMath">p</span> such that all irreducible <span class="SimpleMath">p</span>-modular characters have this property. This happens if and only if the preimages in <span class="SimpleMath">M.G.A</span> of each <span class="SimpleMath">p</span>-regular conjugacy class in <span class="SimpleMath">G.A ∖ G</span> form one conjugacy class.</p>

<p>The following function can be used to decide whether this situation applies to a character table in the <strong class="pkg">GAP</strong> Character Table Library; here we assume that for the library table of a group with the structure <span class="SimpleMath">M.G.A</span>, the class fusions from <span class="SimpleMath">M.G</span> and to <span class="SimpleMath">G.A</span> are stored.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">FindExtraordinaryCase:= function( tblMGA )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   local result, der, nsg, tblMGAclasses, orders, tblMG,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         tblMGfustblMGA, tblMGclasses, pos, M, Mimg, tblMGAfustblGA, tblGA,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         outer, inv, filt, other, primes, p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   result:= [];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   der:= ClassPositionsOfDerivedSubgroup( tblMGA );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   nsg:= ClassPositionsOfNormalSubgroups( tblMGA );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   tblMGAclasses:= SizesConjugacyClasses( tblMGA );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   orders:= OrdersClassRepresentatives( tblMGA );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   if Length( der ) &lt; NrConjugacyClasses( tblMGA ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     # Look for tables of normal subgroups of the form $M.G$.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     for tblMG in Filtered( List( NamesOfFusionSources( tblMGA ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                  CharacterTable ), x -&gt; x &lt;&gt; fail ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       tblMGfustblMGA:= GetFusionMap( tblMG, tblMGA );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       tblMGclasses:= SizesConjugacyClasses( tblMG );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       pos:= Position( nsg, Set( tblMGfustblMGA ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if pos &lt;&gt; fail and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          Size( tblMG ) = Sum( tblMGAclasses{ nsg[ pos ] } ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         # Look for normal subgroups of the form $M$.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         for M in Difference( ClassPositionsOfNormalSubgroups( tblMG ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                      [ [ 1 ], [ 1 .. NrConjugacyClasses( tblMG ) ] ] ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Mimg:= Set( tblMGfustblMGA{ M } );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           if Sum( tblMGAclasses{ Mimg } ) = Sum( tblMGclasses{ M } ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             tblMGAfustblGA:= First( ComputedClassFusions( tblMGA ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 r -&gt; ClassPositionsOfKernel( r.map ) = Mimg );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             if tblMGAfustblGA &lt;&gt; fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               tblGA:= CharacterTable( tblMGAfustblGA.name );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               tblMGAfustblGA:= tblMGAfustblGA.map;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               outer:= Difference( [ 1 .. NrConjugacyClasses( tblGA ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   CompositionMaps( tblMGAfustblGA, tblMGfustblMGA ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               inv:= InverseMap( tblMGAfustblGA ){ outer };</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               filt:= Flat( Filtered( inv, IsList ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               if not IsEmpty( filt ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 other:= Filtered( inv, IsInt );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 primes:= Filtered( PrimeDivisors( Size( tblMGA ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    p -&gt; ForAll( orders{ filt }, x -&gt; x mod p = 0 )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         and ForAny( orders{ other }, x -&gt; x mod p &lt;&gt; 0 ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 for p in primes do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   Add( result, [ Identifier( tblMG ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                  Identifier( tblMGA ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                  Identifier( tblGA ), p ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return result;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p>Let us list the tables which are found by this function.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cases:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for name in AllCharacterTableNames( IsDuplicateTable, false ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Append( cases, FindExtraordinaryCase( CharacterTable( name ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for i in Set( cases ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Print( i, "\n" ); </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
[ "2.A6", "2.A6.2_1", "A6.2_1", 3 ]
[ "2.Fi22", "2.Fi22.2", "Fi22.2", 3 ]
[ "2.L2(25)", "2.L2(25).2_2", "L2(25).2_2", 5 ]
[ "2.L2(49)", "2.L2(49).2_2", "L2(49).2_2", 7 ]
[ "2.L2(81)", "2.L2(81).2_1", "L2(81).2_1", 3 ]
[ "2.L2(81)", "2.L2(81).4_1", "L2(81).4_1", 3 ]
[ "2.L2(81).2_1", "2.L2(81).4_1", "L2(81).4_1", 3 ]
[ "2.L4(3)", "2.L4(3).2_2", "L4(3).2_2", 3 ]
[ "2.L4(3)", "2.L4(3).2_3", "L4(3).2_3", 3 ]
[ "2.S3", "2.D12", "S3x2", 3 ]
[ "2.U4(3).2_1", "2.U4(3).(2^2)_{12*2*}", "U4(3).(2^2)_{122}", 3 ]
[ "2.U4(3).2_1", "2.U4(3).(2^2)_{122}", "U4(3).(2^2)_{122}", 3 ]
[ "2.U4(3).2_1", "2.U4(3).(2^2)_{13*3*}", "U4(3).(2^2)_{133}", 3 ]
[ "2.U4(3).2_1", "2.U4(3).(2^2)_{133}", "U4(3).(2^2)_{133}", 3 ]
[ "3.U3(8)", "3.U3(8).3_1", "U3(8).3_1", 2 ]
[ "3.U3(8)", "3.U3(8).6", "U3(8).6", 2 ]
[ "3.U3(8)", "3.U3(8).6", "U3(8).6", 3 ]
[ "3.U3(8).2", "3.U3(8).6", "U3(8).6", 2 ]
[ "3^2:8", "2.A8N3", "s3wrs2", 3 ]
[ "5^(1+2):8:4", "2.HS.2N5", "HS.2N5", 5 ]
[ "6.A6", "6.A6.2_1", "3.A6.2_1", 3 ]
[ "6.A6", "6.A6.2_1", "A6.2_1", 3 ]
[ "6.Fi22", "6.Fi22.2", "3.Fi22.2", 3 ]
[ "6.Fi22", "6.Fi22.2", "Fi22.2", 3 ]
[ "Isoclinic(2.U4(3).2_1)", "2.U4(3).(2^2)_{1*2*2}", 
  "U4(3).(2^2)_{122}", 3 ]
[ "Isoclinic(2.U4(3).2_1)", "2.U4(3).(2^2)_{1*3*3}", 
  "U4(3).(2^2)_{133}", 3 ]
[ "bd10", "2.D20", "D20", 5 ]
</pre></div>

<p>The smallest example in this list is <span class="SimpleMath">2.A_6.2_1</span>, the double cover of the symmetric group on six points. The <span class="SimpleMath">3</span>-modular table of this group looks as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CharacterTable( "2.A6.2_1" ) mod 3 );</span>
2.A6.2_1mod3

     2  5   5  4  3  1   1  4  4  3
     3  2   2  .  .  .   .  1  1  .
     5  1   1  .  .  1   1  .  .  .

       1a  2a 4a 8a 5a 10a 2b 4b 8b
    2P 1a  1a 2a 4a 5a  5a 1a 2a 4a
    3P 1a  2a 4a 8a 5a 10a 2b 4b 8b
    5P 1a  2a 4a 8a 1a  2a 2b 4b 8b

X.1     1   1  1  1  1   1  1  1  1
X.2     1   1  1  1  1   1 -1 -1 -1
X.3     6   6 -2  2  1   1  .  .  .
X.4     4   4  . -2 -1  -1  2 -2  .
X.5     4   4  . -2 -1  -1 -2  2  .
X.6     9   9  1  1 -1  -1  3  3 -1
X.7     9   9  1  1 -1  -1 -3 -3  1
X.8     4  -4  .  . -1   1  .  .  .
X.9    12 -12  .  .  2  -2  .  .  .
</pre></div>

<p>We see that the two faithful irreducible characters vanish on the three classes outside <span class="SimpleMath">2.A_6</span>.</p>

<p>For the groups in the above list, the function <code class="func">BrauerTableOfTypeMGA</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X83BE977185ADC24B"><span class="RefLink">CTblLib: BrauerTableOfTypeMGA</span></a>) can be used to construct the <span class="SimpleMath">p</span>-modular tables of <span class="SimpleMath">M.G.A</span> from the tables of <span class="SimpleMath">M.G</span> and <span class="SimpleMath">G.A</span>, for the given special primes <span class="SimpleMath">p</span>. The computations can be performed as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for input in cases do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     p:= input[4];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modtblMG:=  CharacterTable( input[1] ) mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ordtblMGA:= CharacterTable( input[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modtblGA:=  CharacterTable( input[3] ) mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     name:= Concatenation( Identifier( ordtblMGA ), " mod ", String(p) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if ForAll( [ modtblMG, modtblGA ], IsCharacterTable ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       poss:= BrauerTableOfTypeMGA( modtblMG, modtblGA, ordtblMGA );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modlib:= ordtblMGA mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if IsCharacterTable( modlib ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         trans:= TransformingPermutationsCharacterTables( poss.table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     modlib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if not IsRecord( trans ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed table and library table for ", name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#I  no library table for ", name, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  not all input tables for ", name, " available\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
#I  not all input tables for 2.L2(49).2_2 mod 7 available
#I  not all input tables for 2.L2(81).2_1 mod 3 available
#I  not all input tables for 2.L2(81).4_1 mod 3 available
#I  not all input tables for 2.L2(81).4_1 mod 3 available
</pre></div>

<p>The examples <span class="SimpleMath">2.A_6.2_1</span>, <span class="SimpleMath">2.L_2(25).2_2</span>, and <span class="SimpleMath">2.L_2(49).2_2</span> belong to the infinite series of semiliniear groups <span class="SimpleMath">Σ</span>L<span class="SimpleMath">(2,p^2)</span>, for odd primes <span class="SimpleMath">p</span>. All groups in this series have the property that all faithful irreducible characters vanish on the <span class="SimpleMath">p</span>-regular classes outside SL<span class="SimpleMath">(2,p^2)</span>. (Cf. Section <a href="chap2.html#X78F41D2A78E70BEE"><span class="RefLink">2.2-6</span></a> for another property of the groups in this series.)</p>

<p><a id="X7F50C782840F06E4" name="X7F50C782840F06E4"></a></p>

<h4>2.5 <span class="Heading">Examples for the Type <span class="SimpleMath">G.S_3</span></span></h4>

<p><a id="X7F0DC29F874AA09F" name="X7F0DC29F874AA09F"></a></p>

<h5>2.5-1 <span class="Heading">Small Examples</span></h5>

<p>The symmetric group <span class="SimpleMath">S_4</span> on four points has the form <span class="SimpleMath">G.S_3</span> where <span class="SimpleMath">G</span> is the Klein four group <span class="SimpleMath">V_4</span>, <span class="SimpleMath">G.2</span> is the dihedral group <span class="SimpleMath">D_8</span> of order <span class="SimpleMath">8</span>, and <span class="SimpleMath">G.3</span> is the alternating group <span class="SimpleMath">A_4</span>. The trivial character of <span class="SimpleMath">A_4</span> extends twofold to <span class="SimpleMath">S_4</span>, in the same way as the trivial character of <span class="SimpleMath">V_4</span> extends to the dihedral group. The nontrivial linear characters of <span class="SimpleMath">A_4</span> induce irreducibly to <span class="SimpleMath">S_4</span>. The irreducible degree three character of <span class="SimpleMath">A_4</span> is induced from any of the three nontrivial linear characters of <span class="SimpleMath">V_4</span>, it extends to <span class="SimpleMath">S_4</span> in the same way as the unique constituent of the restriction to <span class="SimpleMath">V_4</span> that is invariant in the chosen <span class="SimpleMath">D_8</span> extends to <span class="SimpleMath">D_8</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= c2 * c2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tC:= CharacterTable( "Dihedral", 8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tK:= CharacterTable( "Alternating", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tfustC:= PossibleClassFusions( t, tC );</span>
[ [ 1, 3, 4, 4 ], [ 1, 3, 5, 5 ], [ 1, 4, 3, 4 ], [ 1, 4, 4, 3 ], 
  [ 1, 5, 3, 5 ], [ 1, 5, 5, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( t, tfustC[1], tC );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tfustK:= PossibleClassFusions( t, tK );</span>
[ [ 1, 2, 2, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( t, tfustK[1], tK );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeGS3( t, tC, tK );</span>
[ (3,4) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">new:= CharacterTableOfTypeGS3( t, tC, tK, elms[1], "S4" );</span>
rec( table := CharacterTable( "S4" ), 
  tblCfustblKC := [ 1, 4, 2, 2, 5 ], tblKfustblKC := [ 1, 2, 3, 3 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( new.table );</span>
S4

     2  3  3  .  2  2
     3  1  .  1  .  .

       1a 2a 3a 4a 2b
    2P 1a 1a 3a 2a 1a
    3P 1a 2a 1a 4a 2b

X.1     1  1  1  1  1
X.2     1  1  1 -1 -1
X.3     3 -1  .  1 -1
X.4     3 -1  . -1  1
X.5     2  2 -1  .  .
</pre></div>

<p>The case <span class="SimpleMath">e &gt; 1</span> occurs in the following example. We choose <span class="SimpleMath">G</span> the cyclic group of order two, <span class="SimpleMath">G.C</span> the cyclic group of order six, <span class="SimpleMath">G.K</span> the quaternion group of order eight, and construct the character table of <span class="SimpleMath">G.F = SL_2(3)</span>, with <span class="SimpleMath">F ≅ A_4</span>.</p>

<p>We get three extensions of the trivial character of <span class="SimpleMath">G.K</span> to <span class="SimpleMath">G.F</span>, a degree three character induced from the nontrivial linear characters of <span class="SimpleMath">G.K</span>, and three extensions of the irreducible degree <span class="SimpleMath">2</span> character of <span class="SimpleMath">G.K</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "Cyclic", 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tC:= CharacterTable( "Cyclic", 6 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tK:= CharacterTable( "Quaternionic", 8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tfustC:= PossibleClassFusions( t, tC );</span>
[ [ 1, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( t, tfustC[1], tC );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tfustK:= PossibleClassFusions( t, tK );</span>
[ [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( t, tfustK[1], tK );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeGS3( t, tC, tK );</span>
[ (2,5,4) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">new:= CharacterTableOfTypeGS3( t, tC, tK, elms[1], "SL(2,3)" );</span>
rec( table := CharacterTable( "SL(2,3)" ), 
  tblCfustblKC := [ 1, 4, 5, 3, 6, 7 ], 
  tblKfustblKC := [ 1, 2, 3, 2, 2 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( new.table );</span>
SL(2,3)

     2  3  2  3  1   1   1  1
     3  1  .  1  1   1   1  1

       1a 4a 2a 6a  3a  3b 6b
    2P 1a 2a 1a 3a  3b  3a 3b
    3P 1a 4a 2a 2a  1a  1a 2a

X.1     1  1  1  1   1   1  1
X.2     1  1  1  A  /A   A /A
X.3     1  1  1 /A   A  /A  A
X.4     3 -1  3  .   .   .  .
X.5     2  . -2 /A  -A -/A  A
X.6     2  . -2  1  -1  -1  1
X.7     2  . -2  A -/A  -A /A

A = E(3)
  = (-1+Sqrt(-3))/2 = b3
</pre></div>

<p><a id="X80F9BC057980A9E9" name="X80F9BC057980A9E9"></a></p>

<h5>2.5-2 <span class="Heading"><strong class="pkg">Atlas</strong> Tables of the Type <span class="SimpleMath">G.S_3</span></span></h5>

<p>We demonstrate the construction of all those ordinary and modular character tables in the <strong class="pkg">GAP</strong> Character Table Library that are of the type <span class="SimpleMath">G.S_3</span> where <span class="SimpleMath">G</span> is a simple group or a central extension of a simple group whose character table is contained in the <strong class="pkg">Atlas</strong>. Here is the list of <code class="func">Identifier</code> (<a href="../../../doc/ref/chap70.html#X810E53597B5BB4F8"><span class="RefLink">Reference: Identifier for tables of marks</span></a>) values needed for accessing the input tables and the known library tables corresponding to the output.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">listGS3:= [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "U3(5)",      "U3(5).2",      "U3(5).3",      "U3(5).S3"        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.U3(5)",    "3.U3(5).2",    "3.U3(5).3",    "3.U3(5).S3"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "L3(4)",      "L3(4).2_2",    "L3(4).3",      "L3(4).3.2_2"     ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "L3(4)",      "L3(4).2_3",    "L3(4).3",      "L3(4).3.2_3"     ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.L3(4)",    "3.L3(4).2_2",  "3.L3(4).3",    "3.L3(4).3.2_2"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.L3(4)",    "3.L3(4).2_3",  "3.L3(4).3",    "3.L3(4).3.2_3"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.L3(4)",  "2^2.L3(4).2_2","2^2.L3(4).3",  "2^2.L3(4).3.2_2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.L3(4)",  "2^2.L3(4).2_3","2^2.L3(4).3",  "2^2.L3(4).3.2_3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "U6(2)",      "U6(2).2",      "U6(2).3",      "U6(2).3.2"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.U6(2)",    "3.U6(2).2",    "3.U6(2).3",    "3.U6(2).3.2"     ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.U6(2)",  "2^2.U6(2).2",  "2^2.U6(2).3",  "2^2.U6(2).3.2"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "O8+(2)",     "O8+(2).2",     "O8+(2).3",     "O8+(2).3.2"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.O8+(2)", "2^2.O8+(2).2", "2^2.O8+(2).3", "2^2.O8+(2).3.2"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "L3(7)",      "L3(7).2",      "L3(7).3",      "L3(7).S3"        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.L3(7)",    "3.L3(7).2",    "3.L3(7).3",    "3.L3(7).S3"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "U3(8)",      "U3(8).2",      "U3(8).3_2",    "U3(8).S3"        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.U3(8)",    "3.U3(8).2",    "3.U3(8).3_2",  "3.U3(8).S3"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "U3(11)",     "U3(11).2",     "U3(11).3",     "U3(11).S3"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.U3(11)",   "3.U3(11).2",   "3.U3(11).3",   "3.U3(11).S3"     ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "O8+(3)",     "O8+(3).2_2",   "O8+(3).3",     "O8+(3).S3"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2E6(2)",     "2E6(2).2",     "2E6(2).3",     "2E6(2).S3"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.2E6(2)", "2^2.2E6(2).2", "2^2.2E6(2).3", "2^2.2E6(2).S3"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">];;</span>
</pre></div>

<p>(For <span class="SimpleMath">G</span> one of <span class="SimpleMath">L_3(4)</span>, <span class="SimpleMath">U_6(2)</span>, <span class="SimpleMath">O_8^+(2)</span>, and <span class="SimpleMath">^2E_6(2)</span>, the tables of <span class="SimpleMath">2^2.G</span>, <span class="SimpleMath">2^2.G.2</span>, and <span class="SimpleMath">2^2.G.3</span> can be constructed with the methods described in Section <a href="chap2.html#X81464C4B8178C85A"><span class="RefLink">2.3-4</span></a> and Section <a href="chap2.html#X82E75B6880EC9E6C"><span class="RefLink">2.3-1</span></a>, respectively.)</p>

<p>Analogously, the automorphism groups of <span class="SimpleMath">L_3(4)</span>, <span class="SimpleMath">U_3(8)</span>, and <span class="SimpleMath">O_8^+(3)</span> have factor groups isomorphic with <span class="SimpleMath">S_3</span>; in these cases, we choose <span class="SimpleMath">G = L_3(4).2_1</span>, <span class="SimpleMath">G = U_3(8).3_1</span>, and <span class="SimpleMath">G = O_8^+(3).2^2_111</span>, respectively.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( listGS3, [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "L3(4).2_1",          "L3(4).2^2",     "L3(4).6",     "L3(4).D12"     ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.L3(4).2_1",      "2^2.L3(4).2^2", "2^2.L3(4).6", "2^2.L3(4).D12" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "U3(8).3_1",          "U3(8).6",       "U3(8).3^2",   "U3(8).(S3x3)"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "O8+(3).(2^2)_{111}", "O8+(3).D8",     "O8+(3).A4",   "O8+(3).S4"     ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">] );</span>
</pre></div>

<p>In all these cases, the required table automorphism of <span class="SimpleMath">G.3</span> is uniquely determined. We first compute the ordinary character table of <span class="SimpleMath">G.S_3</span> and then the <span class="SimpleMath">p</span>-modular tables, for all prime divisors <span class="SimpleMath">p</span> of the order of <span class="SimpleMath">G</span> such that the <strong class="pkg">GAP</strong> Character Table Library contains the necessary <span class="SimpleMath">p</span>-modular input tables.</p>

<p>In each case, we compare the computed character tables with the ones in the <strong class="pkg">GAP</strong> Character Table Library. Note that in order to avoid conflicts of the class fusions that arise in the construction with the class fusions that are already stored on the library tables, we choose identifiers for the result tables that are different from the identifiers of the library tables.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProcessGS3Example:= function( t, tC, tK, identifier, pi )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   local tF, lib, trans, p, tmodp, tCmodp, tKmodp, modtF;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   tF:= CharacterTableOfTypeGS3( t, tC, tK, pi,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            Concatenation( identifier, "new" ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   lib:= CharacterTable( identifier );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   if lib &lt;&gt; fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     trans:= TransformingPermutationsCharacterTables( tF.table, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if not IsRecord( trans ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#E  computed table and library table for `", identifier,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              "' differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Print( "#I  no library table for `", identifier, "'\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   StoreFusion( tC, tF.tblCfustblKC, tF.table );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   StoreFusion( tK, tF.tblKfustblKC, tF.table );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   for p in PrimeDivisors( Size( t ) ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tmodp := t  mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tCmodp:= tC mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tKmodp:= tK mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if IsCharacterTable( tmodp ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IsCharacterTable( tCmodp ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IsCharacterTable( tKmodp ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modtF:= CharacterTableOfTypeGS3( tmodp, tCmodp, tKmodp,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   tF.table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   Concatenation(  identifier, "mod", String( p ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if   Length( Irr( modtF.table ) ) &lt;&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            Length( Irr( modtF.table )[1] ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#E  nonsquare result table for `",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                identifier, " mod ", p, "'\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       elif lib &lt;&gt; fail and IsCharacterTable( lib mod p ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         trans:= TransformingPermutationsCharacterTables( modtF.table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                          lib mod p );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if not IsRecord( trans ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed table and library table for `",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  identifier, " mod ", p, "' differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#I  no library table for `", identifier, " mod ",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                p, "'\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  not all inputs available for `", identifier,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              " mod ", p, "'\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
</pre></div>

<p>Now we call the function for the examples in the list.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for input in listGS3 do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     t := CharacterTable( input[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tC:= CharacterTable( input[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tK:= CharacterTable( input[3] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     identifier:= input[4];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     elms:= PossibleActionsForTypeGS3( t, tC, tK );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if Length( elms ) = 1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       ProcessGS3Example( t, tC, tK, identifier, elms[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  ", Length( elms ), " actions possible for `",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              identifier, "'\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
#I  not all inputs available for `O8+(3).S3 mod 3'
#I  not all inputs available for `2E6(2).S3 mod 2'
#I  not all inputs available for `2E6(2).S3 mod 3'
#I  not all inputs available for `2E6(2).S3 mod 5'
#I  not all inputs available for `2E6(2).S3 mod 7'
#I  not all inputs available for `2E6(2).S3 mod 11'
#I  not all inputs available for `2E6(2).S3 mod 13'
#I  not all inputs available for `2E6(2).S3 mod 17'
#I  not all inputs available for `2E6(2).S3 mod 19'
#I  not all inputs available for `2^2.2E6(2).S3 mod 2'
#I  not all inputs available for `2^2.2E6(2).S3 mod 3'
#I  not all inputs available for `2^2.2E6(2).S3 mod 5'
#I  not all inputs available for `2^2.2E6(2).S3 mod 7'
#I  not all inputs available for `2^2.2E6(2).S3 mod 11'
#I  not all inputs available for `2^2.2E6(2).S3 mod 13'
#I  not all inputs available for `2^2.2E6(2).S3 mod 17'
#I  not all inputs available for `2^2.2E6(2).S3 mod 19'
#I  not all inputs available for `U3(8).(S3x3) mod 2'
#I  not all inputs available for `U3(8).(S3x3) mod 19'
#I  not all inputs available for `O8+(3).S4 mod 3'
</pre></div>

<p>Also the ordinary character table of the automorphic extension of the simple <strong class="pkg">Atlas</strong> group <span class="SimpleMath">O_8^+(3)</span> by <span class="SimpleMath">A_4</span> can be constructed with the same approach. Here we get four possible permutations, which lead to essentially the same character table.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">input:= [ "O8+(3)", "O8+(3).3", "O8+(3).(2^2)_{111}", "O8+(3).A4" ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := CharacterTable( input[1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tC:= CharacterTable( input[2] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tK:= CharacterTable( input[3] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">identifier:= input[4];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= PossibleActionsForTypeGS3( t, tC, tK );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( elms );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">differ:= MovedPoints( Group( List( elms, x -&gt; x / elms[1] ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( elms, x -&gt; RestrictedPerm( x, differ ) );</span>
[ (118,216,169)(119,217,170)(120,218,167)(121,219,168), 
  (118,216,170)(119,217,169)(120,219,168)(121,218,167), 
  (118,217,169)(119,216,170)(120,218,168)(121,219,167), 
  (118,217,170)(119,216,169)(120,219,167)(121,218,168) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= List( elms, pi -&gt; CharacterTableOfTypeGS3( t, tC, tK, pi,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            Concatenation( identifier, "new" ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib:= CharacterTable( identifier );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( poss, r -&gt; IsRecord(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       TransformingPermutationsCharacterTables( r.table, lib ) ) );</span>
true
</pre></div>

<p>Also the construction of the <span class="SimpleMath">p</span>-modular tables of <span class="SimpleMath">O_8^+(3).A_4</span> works.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProcessGS3Example( t, tC, tK, identifier, elms[1] );</span>
#I  not all inputs available for `O8+(3).A4 mod 3'
</pre></div>

<p><a id="X7EA489E07D7C7D86" name="X7EA489E07D7C7D86"></a></p>

<h4>2.6 <span class="Heading">Examples for the Type <span class="SimpleMath">G.2^2</span></span></h4>

<p><a id="X8054FDE679053B1C" name="X8054FDE679053B1C"></a></p>

<h5>2.6-1 <span class="Heading">The Character Table of <span class="SimpleMath">A_6.2^2</span></span></h5>

<p>As the first example, we consider the automorphism group Aut<span class="SimpleMath">( A_6 ) ≅ A_6.2^2</span> of the alternating group <span class="SimpleMath">A_6</span> on six points.</p>

<p>In this case, the triple of actions on the subgroups <span class="SimpleMath">A_6.2_i</span> is uniquely determined by the condition on the number of conjugacy classes in Section <a href="chap2.html#X7D3EF3BC83BE05CF"><span class="RefLink">2.3-3</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "A6" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblsG2:= List( [ "A6.2_1", "A6.2_2", "A6.2_3" ], CharacterTable );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tblsG2, NrConjugacyClasses );</span>
[ 11, 11, 8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">possact:= List( tblsG2, x -&gt; Filtered( Elements( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       AutomorphismsOfTable( x ) ), y -&gt; Order( y ) &lt;= 2 ) );</span>
[ [ (), (3,4)(7,8)(10,11) ], 
  [ (), (8,9), (5,6)(10,11), (5,6)(8,9)(10,11) ], [ (), (7,8) ] ]
</pre></div>

<p>Note that <span class="SimpleMath">n_1 = n_2</span> implies <span class="SimpleMath">f_1 = f_2</span>, and <span class="SimpleMath">n_1 - n_3 = 3</span> implies <span class="SimpleMath">f_1 - f_3 = 2</span>, so we get <span class="SimpleMath">f_1 = 3</span> and <span class="SimpleMath">f_3 = 1</span>, and <span class="SimpleMath">A_6.2^2</span> has <span class="SimpleMath">2 ⋅ 11 - 3 ⋅ 3 = 2 ⋅ 8 - 3 ⋅ 1 = 13</span> classes.</p>

<p>(The compatibility on the classes inside <span class="SimpleMath">A_6</span> yields only that the classes <span class="SimpleMath">3</span> and <span class="SimpleMath">4</span> of <span class="SimpleMath">A_6.2_1 ≅ S_6</span> must be fused in <span class="SimpleMath">A_6.2^2</span>, as well as the classes <span class="SimpleMath">5</span> and <span class="SimpleMath">6</span> of <span class="SimpleMath">A_6.2_2 ≅</span> PGL<span class="SimpleMath">(2,9)</span>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tblsG2, x -&gt; GetFusionMap( tblG, x ) );</span>
[ [ 1, 2, 3, 4, 5, 6, 6 ], [ 1, 2, 3, 3, 4, 5, 6 ], 
  [ 1, 2, 3, 3, 4, 5, 5 ] ]
</pre></div>

<p>These arguments are used by the <strong class="pkg">GAP</strong> function <code class="func">PossibleActionsForTypeGV4</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7CCD5A2979883144"><span class="RefLink">CTblLib: PossibleActionsForTypeGV4</span></a>), which returns the list of all possible triples of permutations such that the <span class="SimpleMath">i</span>-th permutation describes the action of <span class="SimpleMath">A_6.2^2</span> on the classes of <span class="SimpleMath">A_6.2_i</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">acts:= PossibleActionsForTypeGV4( tblG, tblsG2 );    </span>
[ [ (3,4)(7,8)(10,11), (5,6)(8,9)(10,11), (7,8) ] ]
</pre></div>

<p>For the given actions, the <strong class="pkg">GAP</strong> function <code class="func">PossibleCharacterTablesOfTypeGV4</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7CACDDED7A8C1CF9"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeGV4</span></a>) then computes the possibilities for the character table of <span class="SimpleMath">A_6.2^2</span>; in this case, the result is unique.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= PossibleCharacterTablesOfTypeGV4( tblG, tblsG2, acts[1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              "A6.2^2" );</span>
[ rec( 
      G2fusGV4 := [ [ 1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8 ], 
          [ 1, 2, 3, 4, 5, 5, 9, 10, 10, 11, 11 ], 
          [ 1, 2, 3, 4, 5, 12, 13, 13 ] ], 
      table := CharacterTable( "A6.2^2" ) ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( poss[1].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( "A6.2^2" ) ) );</span>
true
</pre></div>

<p>Finally, possible <span class="SimpleMath">p</span>-modular tables can be computed from the <span class="SimpleMath">p</span>-modular input tables and the ordinary table of <span class="SimpleMath">A_6.2^2</span>; here we show this for <span class="SimpleMath">p = 3</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossibleCharacterTablesOfTypeGV4( tblG mod 3,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       List( tblsG2, t -&gt; t mod 3 ), poss[1].table );</span>
[ rec( 
      G2fusGV4 := 
        [ [ 1, 2, 3, 4, 5, 5, 6 ], [ 1, 2, 3, 4, 4, 7, 8, 8, 9, 9 ], 
          [ 1, 2, 3, 4, 10, 11, 11 ] ], 
      table := BrauerTable( "A6.2^2", 3 ) ) ]
</pre></div>

<p><a id="X7FEC3AB081487AF2" name="X7FEC3AB081487AF2"></a></p>

<h5>2.6-2 <span class="Heading"><strong class="pkg">Atlas</strong> Tables of the Type <span class="SimpleMath">G.2^2</span> – Easy Cases</span></h5>

<p>We demonstrate the construction of all those ordinary and modular character tables in the <strong class="pkg">GAP</strong> Character Table Library that are of the type <span class="SimpleMath">G.2^2</span> where <span class="SimpleMath">G</span> is a simple group or a central extension of a simple group whose character table is contained in the <strong class="pkg">Atlas</strong>. Here is the list of <code class="func">Identifier</code> (<a href="../../../doc/ref/chap70.html#X810E53597B5BB4F8"><span class="RefLink">Reference: Identifier for tables of marks</span></a>) values needed for accessing the input tables and the result tables.</p>

<p>(The construction of the character table of <span class="SimpleMath">O_8^+(3).2^2_111</span> is more involved and will be described in Section <a href="chap2.html#X78AED04685EDCC19"><span class="RefLink">2.6-10</span></a>. The construction of the character tables of groups of the type <span class="SimpleMath">2.L_3(4).2^2</span> and <span class="SimpleMath">6.L_3(4).2^2</span> is described in the sections <a href="chap2.html#X7B38006380618543"><span class="RefLink">2.6-4</span></a> and <a href="chap2.html#X79818ABD7E972370"><span class="RefLink">2.6-5</span></a>, respectively. The construction of the character tables of groups of the type <span class="SimpleMath">2.U_4(3).2^2</span> is described in Section <a href="chap2.html#X878889308653435F"><span class="RefLink">2.6-6</span></a>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">listGV4:= [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "A6",      "A6.2_1",      "A6.2_2",      "A6.2_3",      "A6.2^2"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.A6",    "3.A6.2_1",    "3.A6.2_2",    "3.A6.2_3",    "3.A6.2^2"    ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "L2(25)",  "L2(25).2_1",  "L2(25).2_2",  "L2(25).2_3",  "L2(25).2^2"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "L3(4)",   "L3(4).2_1",   "L3(4).2_2",   "L3(4).2_3",   "L3(4).2^2"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.L3(4)", "2^2.L3(4).2_1", "2^2.L3(4).2_2", "2^2.L3(4).2_3",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                        "2^2.L3(4).2^2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3.L3(4)", "3.L3(4).2_1", "3.L3(4).2_2", "3.L3(4).2_3", "3.L3(4).2^2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "U4(3)",   "U4(3).2_1",   "U4(3).2_2",   "U4(3).2_2'",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                    "U4(3).(2^2)_{122}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "U4(3)",   "U4(3).2_1",   "U4(3).2_3",   "U4(3).2_3'",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                    "U4(3).(2^2)_{133}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3_1.U4(3)", "3_1.U4(3).2_1", "3_1.U4(3).2_2", "3_1.U4(3).2_2'",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                "3_1.U4(3).(2^2)_{122}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "3_2.U4(3)", "3_2.U4(3).2_1", "3_2.U4(3).2_3", "3_2.U4(3).2_3'",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                "3_2.U4(3).(2^2)_{133}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "L2(49)",  "L2(49).2_1",  "L2(49).2_2",  "L2(49).2_3",  "L2(49).2^2"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "L2(81)",  "L2(81).2_1",  "L2(81).2_2",  "L2(81).2_3",  "L2(81).2^2"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "L3(9)",   "L3(9).2_1",   "L3(9).2_2",   "L3(9).2_3",   "L3(9).2^2"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "O8+(3)",  "O8+(3).2_1",  "O8+(3).2_2",  "O8+(3).2_2'",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                   "O8+(3).(2^2)_{122}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "O8-(3)",  "O8-(3).2_1",  "O8-(3).2_2",  "O8-(3).2_3",  "O8-(3).2^2"  ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">];;</span>
</pre></div>

<p>Analogously, the automorphism groups <span class="SimpleMath">L_3(4).D_12</span> of <span class="SimpleMath">L_3(4)</span> and <span class="SimpleMath">U_4(3).D_8</span> of <span class="SimpleMath">U_4(3)</span>, and the subgroup <span class="SimpleMath">O_8^+(3).D_8</span> of the automorphism group <span class="SimpleMath">O_8^+(3).S_4</span> have factor groups that are isomorphic with <span class="SimpleMath">2^2</span>; in these cases, we choose <span class="SimpleMath">G = L_3(4).3</span>, <span class="SimpleMath">G = U_4(3).2_1</span>, and <span class="SimpleMath">G = O_8^+(3).2_1</span>, respectively.</p>

<p>Also the group <span class="SimpleMath">2^2.L_3(4).D_12</span> has a factor group isomorphic with <span class="SimpleMath">2^2</span>. Note that the character tables of <span class="SimpleMath">L_3(4).D_12</span> and <span class="SimpleMath">2^2.L_3(4).D_12</span> have been constructed already in Section <a href="chap2.html#X80F9BC057980A9E9"><span class="RefLink">2.5-2</span></a>.</p>

<p>The automorphism groups of <span class="SimpleMath">L_4(4)</span> and <span class="SimpleMath">U_4(5)</span> have the structure <span class="SimpleMath">L_4(4).2^2</span> and <span class="SimpleMath">U_4(5).2^2</span>, respectively; their tables are contained in the <strong class="pkg">GAP</strong> Character Table Library but not in the <strong class="pkg">Atlas</strong>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append( listGV4, [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "L3(4).3", "L3(4).6",     "L3(4).3.2_2", "L3(4).3.2_3", "L3(4).D12"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "2^2.L3(4).3", "2^2.L3(4).6", "2^2.L3(4).3.2_2", "2^2.L3(4).3.2_3",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                        "2^2.L3(4).D12" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "U4(3).2_1", "U4(3).4", "U4(3).(2^2)_{122}", "U4(3).(2^2)_{133}",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                             "U4(3).D8" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "O8+(3).2_1", "O8+(3).(2^2)_{111}", "O8+(3).(2^2)_{122}", "O8+(3).4",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                            "O8+(3).D8" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "L4(4)",   "L4(4).2_1",   "L4(4).2_2",   "L4(4).2_3",   "L4(4).2^2"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ "U4(5)",   "U4(5).2_1",   "U4(5).2_2",   "U4(5).2_3",   "U4(5).2^2"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">] );</span>
</pre></div>

<p>Now we proceed in two steps, the computation of the possible ordinary character tables from the ordinary tables of the relevant subgroups, and then the computation of the Brauer tables from the Brauer tables of the relevant subgroups and from the ordinary table of the group.</p>

<p>The following function first computes the possible triples of actions on the subgroups <span class="SimpleMath">G.2_i</span>, using the function <code class="func">PossibleActionsForTypeGV4</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7CCD5A2979883144"><span class="RefLink">CTblLib: PossibleActionsForTypeGV4</span></a>). Then the union of the candidate tables for these actions is computed, this list is returned in the end. and representatives of classes of permutation equivalent candidates are inspected further with consistency checks. If there is a unique solution up to permutation equivalence, this table is compared with the one that is contained in the <strong class="pkg">GAP</strong> Character Table Library.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstructOrdinaryGV4Table:= function( tblG, tblsG2, name, lib )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     local acts, nam, poss, reps, i, trans;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     # Compute the possible actions for the ordinary tables.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     acts:= PossibleActionsForTypeGV4( tblG, tblsG2 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     # Compute the possible ordinary tables for the given actions.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     nam:= Concatenation( "new", name );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= Concatenation( List( acts, triple -&gt; </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         PossibleCharacterTablesOfTypeGV4( tblG, tblsG2, triple, nam ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     # Test the possibilities for permutation equivalence.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     reps:= RepresentativesCharacterTables( poss );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if 1 &lt; Length( reps ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  ", name, ": ", Length( reps ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              " equivalence classes\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     elif Length( reps ) = 0 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#E  ", name, ": no solution\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       # Compare the computed table with the library table.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if not IsCharacterTable( lib ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#I  no library table for ", name, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         PrintToLib( name, poss[1].table );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         for i in [ 1 .. 3 ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( LibraryFusion( tblsG2[i],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                      rec( name:= name, map:= poss[1].G2fusGV4[i] ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         trans:= TransformingPermutationsCharacterTables( poss[1].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if not IsRecord( trans ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed table and library table for ", name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         # Compare the computed fusions with the stored ones.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if List( poss[1].G2fusGV4, x -&gt; OnTuples( x, trans.columns ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                &lt;&gt; List( tblsG2, x -&gt; GetFusionMap( x, lib ) ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed and stored fusions for ", name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     return poss;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end;;</span>
</pre></div>

<p>The following function computes, for all those prime divisors <span class="SimpleMath">p</span> of the group order in question such that the <span class="SimpleMath">p</span>-modular Brauer tables of the subgroups <span class="SimpleMath">G.2_i</span> are available, the possible <span class="SimpleMath">p</span>-modular Brauer tables. If the solution is unique up to permutation equivalence, it is compared with the table that is contained in the <strong class="pkg">GAP</strong> Character Table Library.</p>

<p>It may happen (even in the case that the ordinary character table is unique up to permutation equivalence) that some candidates for the ordinary character table are excluded due to information provided by some <span class="SimpleMath">p</span>-modular table. In this case, a message is printed, and the ordinary character table from the <strong class="pkg">GAP</strong> Character Table Library is checked again under the additional restrictions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstructModularGV4Tables:= function( tblG, tblsG2, ordposs,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                         ordlibtblGV4 )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     local name, modposs, primes, checkordinary, i, record, p, tmodp,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           t2modp, poss, modlib, trans, reps;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if not IsCharacterTable( ordlibtblGV4 ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  no ordinary library table ...\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       return [];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     name:= Identifier( ordlibtblGV4 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modposs:= List( ordposs, x -&gt; [] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     primes:= ShallowCopy( PrimeDivisors( Size( tblG ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ordposs:= ShallowCopy( ordposs );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     checkordinary:= false;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     for i in [ 1 .. Length( ordposs ) ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       record:= ordposs[i];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       for p in primes do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         tmodp := tblG  mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         t2modp:= List( tblsG2, t2 -&gt; t2 mod p );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if IsCharacterTable( tmodp ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            ForAll( t2modp, IsCharacterTable ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           poss:= PossibleCharacterTablesOfTypeGV4( tmodp, t2modp,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                      record.table, record.G2fusGV4 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           poss:= RepresentativesCharacterTables( poss );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           if   Length( poss ) = 0 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Print( "#I  excluded cand. ", i, " (out of ",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    Length( ordposs ), ") for ", name, " by ", p,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    "-mod. table\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Unbind( ordposs[i] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Unbind( modposs[i] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             checkordinary:= true;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             break;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           elif Length( poss ) = 1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             # Compare the computed table with the library table.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             modlib:= ordlibtblGV4 mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             if IsCharacterTable( modlib ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               trans:= TransformingPermutationsCharacterTables(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                           poss[1].table, modlib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               if not IsRecord( trans ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 Print( "#E  computed table and library table for ",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        name, " mod ", p, " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               Print( "#I  no library table for ",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                      name, " mod ", p, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               PrintToLib( name, poss[1].table );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Print( "#I  ", name, " mod ", p, ": ", Length( poss ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    " equivalence classes\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Add( modposs[i], poss );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         elif i = 1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#I  not all input tables for ", name, " mod ", p,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " available\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           primes:= Difference( primes, [ p ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if checkordinary then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       # Test whether the ordinary table is admissible.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       ordposs:= Compacted( ordposs );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modposs:= Compacted( modposs );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       reps:= RepresentativesCharacterTables( ordposs );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if 1 &lt; Length( reps ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#I  ", name, ": ", Length( reps ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                " equivalence classes (ord. table)\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       elif Length( reps ) = 0 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#E  ", name, ": no solution (ord. table)\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         # Compare the computed table with the library table.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         trans:= TransformingPermutationsCharacterTables(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     ordposs[1].table, ordlibtblGV4 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if not IsRecord( trans ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed table and library table for ", name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         # Compare the computed fusions with the stored ones.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if List( ordposs[1].G2fusGV4, x -&gt; OnTuples( x, trans.columns ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              &lt;&gt; List( tblsG2, x -&gt; GetFusionMap( x, ordlibtblGV4 ) ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed and stored fusions for ", name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     return rec( ordinary:= ordposs, modular:= modposs );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end;;</span>
</pre></div>

<p>Finally, here is the loop over the list of tables.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for input in listGV4 do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblG   := CharacterTable( input[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblsG2 := List( input{ [ 2 .. 4 ] }, CharacterTable );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     lib    := CharacterTable( input[5] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss   := ConstructOrdinaryGV4Table( tblG, tblsG2, input[5], lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ConstructModularGV4Tables( tblG, tblsG2, poss, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
#I  excluded cand. 2 (out of 2) for L3(4).2^2 by 3-mod. table
#I  excluded cand. 2 (out of 8) for 2^2.L3(4).2^2 by 7-mod. table
#I  excluded cand. 3 (out of 8) for 2^2.L3(4).2^2 by 5-mod. table
#I  excluded cand. 4 (out of 8) for 2^2.L3(4).2^2 by 5-mod. table
#I  excluded cand. 5 (out of 8) for 2^2.L3(4).2^2 by 5-mod. table
#I  excluded cand. 6 (out of 8) for 2^2.L3(4).2^2 by 5-mod. table
#I  excluded cand. 7 (out of 8) for 2^2.L3(4).2^2 by 7-mod. table
#I  excluded cand. 2 (out of 2) for 3.L3(4).2^2 by 3-mod. table
#I  not all input tables for L2(49).2^2 mod 7 available
#I  not all input tables for L2(81).2^2 mod 3 available
#I  excluded cand. 2 (out of 2) for L3(9).2^2 by 7-mod. table
#I  not all input tables for O8+(3).(2^2)_{122} mod 3 available
#I  not all input tables for O8-(3).2^2 mod 3 available
#I  not all input tables for O8-(3).2^2 mod 5 available
#I  not all input tables for O8-(3).2^2 mod 7 available
#I  not all input tables for O8-(3).2^2 mod 13 available
#I  not all input tables for O8-(3).2^2 mod 41 available
#I  excluded cand. 2 (out of 2) for L3(4).D12 by 3-mod. table
#I  excluded cand. 2 (out of 2) for 2^2.L3(4).D12 by 7-mod. table
#I  not all input tables for O8+(3).D8 mod 3 available
#I  not all input tables for L4(4).2^2 mod 3 available
#I  not all input tables for L4(4).2^2 mod 5 available
#I  not all input tables for L4(4).2^2 mod 7 available
#I  not all input tables for L4(4).2^2 mod 17 available
#I  not all input tables for U4(5).2^2 mod 2 available
#I  not all input tables for U4(5).2^2 mod 3 available
#I  not all input tables for U4(5).2^2 mod 5 available
#I  not all input tables for U4(5).2^2 mod 7 available
#I  not all input tables for U4(5).2^2 mod 13 available
</pre></div>

<p>The groups <span class="SimpleMath">3.A_6.2^2</span>, <span class="SimpleMath">3.L_3(4).2^2</span>, and <span class="SimpleMath">3_2.U_4(3).(2^2)_133</span> have also the structure <span class="SimpleMath">M.G.A</span>, with <span class="SimpleMath">M.G</span> equal to <span class="SimpleMath">3.A_6.2_3</span>, <span class="SimpleMath">3.L_3(4).2_1</span>, and <span class="SimpleMath">3_2.U_4(3).2_3</span>, respectively, and <span class="SimpleMath">G.A</span> equal to <span class="SimpleMath">A_6.2^2</span>, <span class="SimpleMath">L_3(4).2^2</span>, and <span class="SimpleMath">U_4(3).(2^2)_133</span>, respectively (see Section <a href="chap2.html#X7ED45AB379093A70"><span class="RefLink">2.4-3</span></a>).</p>

<p>Similarly, the group <span class="SimpleMath">L_3(4).D_12</span> has also the structure <span class="SimpleMath">G.S_3</span>, with <span class="SimpleMath">G = L_3(4).2_1</span>, <span class="SimpleMath">G.2 = L_3(4).2^2</span>, and <span class="SimpleMath">G.3 = L_3(4).6</span>, respectively (see Section <a href="chap2.html#X80F9BC057980A9E9"><span class="RefLink">2.5-2</span></a>).</p>

<p><a id="X869B65D3863EDEC3" name="X869B65D3863EDEC3"></a></p>

<h5>2.6-3 <span class="Heading">The Character Table of <span class="SimpleMath">S_4(9).2^2</span> (September 2011)</span></h5>

<p>The available functions yield two possibilities for the ordinary character table of <span class="SimpleMath">S_4(9).2^2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "S4(9)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblsG2:= List( [ "S4(9).2_1", "S4(9).2_2", "S4(9).2_3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  CharacterTable );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib:= CharacterTable( "S4(9).2^2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, "newS4(9).2^2", lib );;</span>
#I  newS4(9).2^2: 2 equivalence classes
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= RepresentativesCharacterTables( poss );;</span>
</pre></div>

<p>The two candidates differ w. r. t. the action of <span class="SimpleMath">S_4(9).2^2</span> on the classes of element order <span class="SimpleMath">80</span> in <span class="SimpleMath">S_4(9).2_2</span>. In the two possible tables, each element of order <span class="SimpleMath">80</span> is conjugate to its third power or to its <span class="SimpleMath">13</span>-th power, respectively.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">order80:= PositionsProperty( OrdersClassRepresentatives( tblsG2[2] ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 x -&gt; x = 80 );</span>
[ 98, 99, 100, 101, 102, 103, 104, 105 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( poss, r -&gt; r.G2fusGV4[2]{ order80 } );</span>
[ [ 77, 77, 78, 79, 80, 78, 79, 80 ], 
  [ 77, 78, 79, 79, 77, 80, 80, 78 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PowerMap( tblsG2[2], 3 ){ order80 };</span>
[ 99, 98, 103, 104, 105, 100, 101, 102 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PowerMap( tblsG2[2], 13 ){ order80 };</span>
[ 102, 105, 101, 100, 98, 104, 103, 99 ]
</pre></div>

<p>We claim that the first candidate is the correct one. For that, first note that <span class="SimpleMath">S_4(9).2_2</span> is the extension of the simple group by a diagonal automorphism. (An easy way to see this is that for any subgroup of <span class="SimpleMath">S_4(9)</span> isomorphic with <span class="SimpleMath">S_2(81) ≅ L_2(81)</span>, the extension by a diagonal automorphism contains elements of order <span class="SimpleMath">80</span> –this group is isomorphic with PGL<span class="SimpleMath">(2,81)</span>– and only <span class="SimpleMath">S_4(9).2_2</span> contains elements of order <span class="SimpleMath">80</span>.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tblsG2, x -&gt; 80 in OrdersClassRepresentatives( x ) );</span>
[ false, true, false ]
</pre></div>

<p>Now the field automorphism of <span class="SimpleMath">S_4(9).2_2</span> maps each element <span class="SimpleMath">x</span> of order <span class="SimpleMath">80</span> in <span class="SimpleMath">S_4(9).2_2</span> to a conjugate of <span class="SimpleMath">x^3</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl:= poss[1].table;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( tbl, lib ) );</span>
true
</pre></div>

<p><a id="X7B38006380618543" name="X7B38006380618543"></a></p>

<h5>2.6-4 <span class="Heading">The Character Tables of Groups of the Type <span class="SimpleMath">2.L_3(4).2^2</span>
(June 2010)</span></h5>

<p>The outer automorphism group of the group <span class="SimpleMath">L_3(4)</span> is a dihedral group of order <span class="SimpleMath">12</span>; its Sylow <span class="SimpleMath">2</span>-subgroups are Klein four groups, so there is a unique almost simple group <span class="SimpleMath">H</span> of the type <span class="SimpleMath">L_3(4).2^2</span>, up to isomorphism. In this section, we construct the character tables of the double covers of this group with the approach from Section <a href="chap2.html#X7D3EF3BC83BE05CF"><span class="RefLink">2.3-3</span></a>.</p>

<p>The group <span class="SimpleMath">H</span> has three subgroups of index two, of the types <span class="SimpleMath">L_3(4).2_1</span>, <span class="SimpleMath">L_3(4).2_2</span>, and <span class="SimpleMath">L_3(4).2_3</span>, respectively. So any double cover of <span class="SimpleMath">H</span> contains one subgroup of each of the types <span class="SimpleMath">2.L_3(4).2_1</span>, <span class="SimpleMath">2.L_3(4).2_2</span>, and <span class="SimpleMath">2.L_3(4).2_3</span>, and there are two isoclinic variants of each of these group to consider, see Section <a href="chap2.html#X78F41D2A78E70BEE"><span class="RefLink">2.2-6</span></a>. So we start with eight different inputs for the construction of the character tables of double covers.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">names:= List( [ 1 .. 3 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 i -&gt; Concatenation( "2.L3(4).2_", String( i ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls:= List( names, CharacterTable );</span>
[ CharacterTable( "2.L3(4).2_1" ), CharacterTable( "2.L3(4).2_2" ), 
  CharacterTable( "2.L3(4).2_3" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isos:= List( names, nam -&gt; CharacterTable( Concatenation( nam, "*" ) ) );</span>
[ CharacterTable( "Isoclinic(2.L3(4).2_1)" ), 
  CharacterTable( "Isoclinic(2.L3(4).2_2)" ), 
  CharacterTable( "Isoclinic(2.L3(4).2_3)" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs:= [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], tbls[2], tbls[3], "2.L3(4).(2^2)_{123}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], isos[2], tbls[3], "2.L3(4).(2^2)_{12*3}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], tbls[2], isos[3], "2.L3(4).(2^2)_{123*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], isos[2], isos[3], "2.L3(4).(2^2)_{12*3*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], tbls[2], tbls[3], "2.L3(4).(2^2)_{1*23}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], isos[2], tbls[3], "2.L3(4).(2^2)_{1*2*3}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], tbls[2], isos[3], "2.L3(4).(2^2)_{1*23*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], isos[2], isos[3], "2.L3(4).(2^2)_{1*2*3*}" ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "2.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for input in inputs do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblsG2:= input{ [ 1 .. 3 ] };</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     lib:= CharacterTable( input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ConstructModularGV4Tables( tblG, tblsG2, poss, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Append( result, RepresentativesCharacterTables( poss ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
#I  excluded cand. 2 (out of 8) for 2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 2.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 2.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 2.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 2.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 2.L3(4).(2^2)_{1*23*} by 
5-mod. table
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result:= List( result, x -&gt; x.table );</span>
[ CharacterTable( "new2.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{12*3*}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{1*23}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{1*2*3}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{1*23*}" ), 
  CharacterTable( "new2.L3(4).(2^2)_{1*2*3*}" ) ]
</pre></div>

<p>We get exactly one character table for each input. For each of these tables, there are three possibilities to form an isoclinic table, corresponding to the three subgroups of index two. It turns out that the eight solutions form two orbits under forming some isoclinic table. Tables in different orbits are essentially different, already their numbers of conjugacy classes differ.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( result, NrConjugacyClasses );</span>
[ 39, 33, 33, 39, 33, 39, 39, 33 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= result[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= List( nsg, x -&gt; CharacterTableIsoclinic( t, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( iso, x -&gt; PositionProperty( result, y -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           TransformingPermutationsCharacterTables( x, y ) &lt;&gt; fail ) );</span>
[ 4, 7, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= result[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= List( nsg, x -&gt; CharacterTableIsoclinic( t, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( iso, x -&gt; PositionProperty( result, y -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           TransformingPermutationsCharacterTables( x, y ) &lt;&gt; fail ) );</span>
[ 3, 8, 5 ]
</pre></div>

<p>Up to now, it is not clear that the character tables we have constructed are really the character tables of some groups. The existence of groups for the first orbit of character tables can be established as follows.</p>

<p>The group <span class="SimpleMath">U_6(2).2</span> contains a maximal subgroup <span class="SimpleMath">M</span> of the type <span class="SimpleMath">L_3(4).2^2</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 115]</a>. Its derived subgroup <span class="SimpleMath">M'</span> of the type <span class="SimpleMath">L_3(4)</span> lies inside <span class="SimpleMath">U_6(2)</span>, and we claim that the preimage of <span class="SimpleMath">M'</span> under the natural epimorphism from <span class="SimpleMath">2.U_6(2)</span> to <span class="SimpleMath">U_6(2)</span> is a double cover of <span class="SimpleMath">L_3(4)</span>. Unfortunately, <span class="SimpleMath">L_3(4)</span> admits class fusions into <span class="SimpleMath">2.U_6(2)</span>, so this criterion cannot be used.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l34:= CharacterTable( "L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= CharacterTable( "U6(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2u:= CharacterTable( "2.U6(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= PossibleClassFusions( l34, 2u );</span>
[ [ 1, 5, 12, 16, 22, 22, 23, 23, 41, 41 ], 
  [ 1, 5, 12, 22, 16, 22, 23, 23, 41, 41 ], 
  [ 1, 5, 12, 22, 22, 16, 23, 23, 41, 41 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( l34 );</span>
[ 1, 2, 3, 4, 4, 4, 5, 5, 7, 7 ]
</pre></div>

<p>Consider the three classes of elements of order four in <span class="SimpleMath">L_3(4)</span>. Under the possible fusions into <span class="SimpleMath">2.U_6(2)</span>, they are mapped to the classes <span class="SimpleMath">16</span> and <span class="SimpleMath">22</span>, which are preimages of the classes <span class="SimpleMath">10</span> and <span class="SimpleMath">14</span> (<code class="code">4C</code> and <code class="code">4G</code>) of <span class="SimpleMath">U_6(2)</span>. Note that the maximal subgroups of type <span class="SimpleMath">L_3(4).2</span> in <span class="SimpleMath">U_6(2)</span> extend to <span class="SimpleMath">L_3(4).6</span> type subgroups in <span class="SimpleMath">U_6(2).3</span>, and the three classes <code class="code">4C</code>, <code class="code">4D</code>, <code class="code">4E</code> form one orbit under the action of an outer automorphism of order three of <span class="SimpleMath">U_6(2)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetFusionMap( 2u, u ){ [ 16, 22 ] };</span>
[ 10, 14 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ClassNames( u, "ATLAS" ){ [ 10, 14 ] };</span>
[ "4C", "4G" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetFusionMap( u, CharacterTable( "U6(2).3" ) );</span>
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 11, 12, 13, 14, 15, 16, 17, 
  18, 19, 20, 21, 22, 23, 24, 24, 24, 25, 26, 27, 28, 29, 30, 31, 32, 
  33, 34, 35, 36, 36, 36, 37, 38, 39, 40 ]
</pre></div>

<p>This means that any <span class="SimpleMath">L_3(4)</span> type subgroup of <span class="SimpleMath">U_6(2)</span> that extends to an <span class="SimpleMath">L_3(4).6</span> type subgroup in <span class="SimpleMath">U_6(2).3</span> either contains elements from all three classes <code class="code">4C</code>, <code class="code">4D</code>, <code class="code">4E</code> of <span class="SimpleMath">U_6(2)</span>, or contains no element from these classes. Thus we know that any double cover of <span class="SimpleMath">U_6(2).2</span> contains a double cover of <span class="SimpleMath">L_3(4).2^2</span>. Only the first of our result tables admits a class fusion into the table of <span class="SimpleMath">2.U_6(2).2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2u2:= CharacterTable( "2.U6(2).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= List( result, x -&gt; PossibleClassFusions( x, 2u2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( fus, Length );</span>
[ 4, 0, 0, 0, 0, 0, 0, 0 ]
</pre></div>

<p>As a consequence, the fourth result table is established as that of a maximal subgroup of the group isoclinic to <span class="SimpleMath">2.U_6(2).2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2u2iso:= CharacterTableIsoclinic( 2u2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= List( result, x -&gt; PossibleClassFusions( x, 2u2iso ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( fus, Length );</span>
[ 0, 0, 0, 4, 0, 0, 0, 0 ]
</pre></div>

<p>Similarly, the group <span class="SimpleMath">HS.2</span> contains a maximal subgroup <span class="SimpleMath">M</span> of the type <span class="SimpleMath">L_3(4).2^2</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 80]</a>. Its derived subgroup <span class="SimpleMath">M'</span> of the type <span class="SimpleMath">L_3(4)</span> lies inside <span class="SimpleMath">HS</span>, and the preimage of <span class="SimpleMath">M'</span> under the natural epimorphism from <span class="SimpleMath">2.HS</span> to <span class="SimpleMath">HS</span> is a double cover of <span class="SimpleMath">L_3(4)</span>, because <span class="SimpleMath">L_3(4)</span> does not admit a class fusion into <span class="SimpleMath">2.HS.2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h2:= CharacterTable( "HS.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2h2:= CharacterTable( "2.HS.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossibleClassFusions( l34, 2h2 );</span>
[  ]
</pre></div>

<p>Only the fifth of our result tables admits a class fusion into <span class="SimpleMath">2.HS.2</span>, which means that <span class="SimpleMath">2.L_3(4).(2^2)_1∗23</span> is a subgroup of <span class="SimpleMath">2.HS.2</span>, and the eighth result table –<span class="SimpleMath">2.L_3(4).(2^2)_1∗2∗3∗}</span>– admits a class fusion into the isoclinic variant of <span class="SimpleMath">2.HS.2</span> This shows the existence of groups for the tables from the second orbit.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= List( result, x -&gt; PossibleClassFusions( x, 2h2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( fus, Length );</span>
[ 0, 0, 0, 0, 4, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2h2iso:= CharacterTableIsoclinic( 2h2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= List( result, x -&gt; PossibleClassFusions( x, 2h2iso ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( fus, Length );</span>
[ 0, 0, 0, 0, 0, 0, 0, 4 ]
</pre></div>

<p><a id="X79818ABD7E972370" name="X79818ABD7E972370"></a></p>

<h5>2.6-5 <span class="Heading">The Character Tables of Groups of the Type <span class="SimpleMath">6.L_3(4).2^2</span>
(October 2011)</span></h5>

<p>We have two approaches for constructing the character tables of these groups.</p>

<p>First, we may regard them as normal products of the three normal subgroups of index two, each of them having the structure <span class="SimpleMath">6.L_3(4).2</span>, and use the approach from Section <a href="chap2.html#X7D3EF3BC83BE05CF"><span class="RefLink">2.3-3</span></a>, as we did in Section <a href="chap2.html#X7B38006380618543"><span class="RefLink">2.6-4</span></a> for the groups of the structure <span class="SimpleMath">2.L_3(4).2^2</span>.</p>

<p>Second, we may use the approach from Section <a href="chap2.html#X82E75B6880EC9E6C"><span class="RefLink">2.3-1</span></a>. Note that the factor group <span class="SimpleMath">L_3(4).2^2</span> contains each of the three groups <span class="SimpleMath">L_3(4).2_i</span> as a subgroup, for <span class="SimpleMath">1 ≤ i ≤ 3</span>, and the groups of the type <span class="SimpleMath">6.L_3(4).2_1</span> have a centre of order six, whereas the centres of the <span class="SimpleMath">6.L_3(4).2_2</span> and <span class="SimpleMath">6.L_3(4).2_3</span> type groups have order two. For that, the character tables of the subgroups <span class="SimpleMath">6.L_3(4).2_1</span> and <span class="SimpleMath">6.L_3(4).2_1^∗</span> are needed, as well as the character tables of the eight possible factor groups <span class="SimpleMath">2.L_3(4).2^2</span>; the latter tables are known from Section <a href="chap2.html#X7B38006380618543"><span class="RefLink">2.6-4</span></a>.</p>

<p>We show both approaches. (The second approach is better suited for storing the character tables in the Character Table Library, since the irreducible characters need not be stored, and since the Brauer tables of the groups can be derived from the Brauer tables of the compound tables.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls:= List( [ "1", "2", "3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     i -&gt; CharacterTable( Concatenation( "6.L3(4).2_", i ) ) );</span>
[ CharacterTable( "6.L3(4).2_1" ), CharacterTable( "6.L3(4).2_2" ), 
  CharacterTable( "6.L3(4).2_3" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isos:= List( [ "1", "2", "3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     i -&gt; CharacterTable( Concatenation( "6.L3(4).2_", i, "*" ) ) );</span>
[ CharacterTable( "Isoclinic(6.L3(4).2_1)" ), 
  CharacterTable( "Isoclinic(6.L3(4).2_2)" ), 
  CharacterTable( "Isoclinic(6.L3(4).2_3)" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs:= [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], tbls[2], tbls[3], "6.L3(4).(2^2)_{123}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], isos[2], tbls[3], "6.L3(4).(2^2)_{12*3}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], tbls[2], isos[3], "6.L3(4).(2^2)_{123*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], isos[2], isos[3], "6.L3(4).(2^2)_{12*3*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], tbls[2], tbls[3], "6.L3(4).(2^2)_{1*23}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], isos[2], tbls[3], "6.L3(4).(2^2)_{1*2*3}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], tbls[2], isos[3], "6.L3(4).(2^2)_{1*23*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], isos[2], isos[3], "6.L3(4).(2^2)_{1*2*3*}" ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "6.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for input in inputs do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblsG2:= input{ [ 1 .. 3 ] };</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     lib:= CharacterTable( input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ConstructModularGV4Tables( tblG, tblsG2, poss, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Append( result, RepresentativesCharacterTables( poss ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
#I  excluded cand. 2 (out of 8) for 6.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 6.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 6.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 6.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 6.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 6.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 6.L3(4).(2^2)_{12*3*} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 6.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 6.L3(4).(2^2)_{1*23*} by 
5-mod. table
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result:= List( result, x -&gt; x.table );</span>
[ CharacterTable( "new6.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{12*3*}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*23}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*2*3}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*23*}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*2*3*}" ) ]
</pre></div>

<p>As in Section <a href="chap2.html#X7B38006380618543"><span class="RefLink">2.6-4</span></a>, we get exactly one character table for each input, and the eight solutions lie in two orbits under isoclinism.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( result, NrConjugacyClasses );</span>
[ 59, 53, 53, 59, 53, 59, 59, 53 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= result[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= List( nsg, x -&gt; CharacterTableIsoclinic( t, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( iso, x -&gt; PositionProperty( result, y -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           TransformingPermutationsCharacterTables( x, y ) &lt;&gt; fail ) );</span>
[ 7, 6, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= result[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= List( nsg, x -&gt; CharacterTableIsoclinic( t, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( iso, x -&gt; PositionProperty( result, y -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           TransformingPermutationsCharacterTables( x, y ) &lt;&gt; fail ) );</span>
[ 8, 5, 3 ]
</pre></div>

<p>Up to now, it is not clear that the character tables we have constructed are really the character tables of some groups. The existence of groups for the first orbit of character tables can be established as follows.</p>

<p>We have shown in Section <a href="chap2.html#X7B38006380618543"><span class="RefLink">2.6-4</span></a> that the maximal subgroups <span class="SimpleMath">M</span> of the type <span class="SimpleMath">L_3(4).2^2</span> in <span class="SimpleMath">U_6(2).2</span> lift to double covers <span class="SimpleMath">2.L_3(4).2^2</span> in <span class="SimpleMath">2.U_6(2).2</span>. The preimages of these groups under the natural epimorphism from <span class="SimpleMath">6.U_6(2).2</span> have the structure <span class="SimpleMath">6.L_3(4).2^2</span>, where the derived subgroup is the six-fold cover of <span class="SimpleMath">L_3(4)</span>; this follows from the fact that <span class="SimpleMath">6.U_6(2)</span> does not admit a class fusion from the double cover <span class="SimpleMath">2.L_3(4)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2l34:= CharacterTable( "2.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">6u:= CharacterTable( "6.U6(2)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= PossibleClassFusions( 2l34, 6u );</span>
[  ]
</pre></div>

<p>This establishes the first and the fourth result as character tables of subgroups of <span class="SimpleMath">6.U_6(2)</span> and its isoclinic variant, respectively.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">6u2:= CharacterTable( "6.U6(2).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= List( result, x -&gt; PossibleClassFusions( x, 6u2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( fus, Length );</span>
[ 8, 0, 0, 0, 0, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">6u2iso:= CharacterTableIsoclinic( 6u2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= List( result, x -&gt; PossibleClassFusions( x, 6u2iso ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( fus, Length );</span>
[ 0, 0, 0, 8, 0, 0, 0, 0 ]
</pre></div>

<p>Similarly, the group <span class="SimpleMath">G_2(4).2</span> contains a maximal subgroup <span class="SimpleMath">M</span> of the type <span class="SimpleMath">3.L_3(4).2^2</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 97]</a>. Its derived subgroup <span class="SimpleMath">M'</span> of the type <span class="SimpleMath">3.L_3(4)</span> lies inside <span class="SimpleMath">G_2(4)</span>, and the preimage of <span class="SimpleMath">M'</span> under the natural epimorphism from <span class="SimpleMath">2.G_2(4)</span> to <span class="SimpleMath">G_2(4)</span> is a double cover of <span class="SimpleMath">3.L_3(4)</span>, because <span class="SimpleMath">3.L_3(4)</span> does not admit a class fusion into <span class="SimpleMath">2.G_2(4).2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3l34:= CharacterTable( "3.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g2:= CharacterTable( "G2(4).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2g2:= CharacterTable( "2.G2(4).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PossibleClassFusions( 3l34, 2g2 );</span>
[  ]
</pre></div>

<p>Only the third and eighth of our result tables admit a class fusion into <span class="SimpleMath">2.G_2(4).2</span> and its isoclinic variant, respectively. This shows the existence of groups for the tables from the second orbit.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= List( result, x -&gt; PossibleClassFusions( x, 2g2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( fus, Length );</span>
[ 0, 0, 16, 0, 0, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2g2iso:= CharacterTableIsoclinic( 2g2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= List( result, x -&gt; PossibleClassFusions( x, 2g2iso ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( fus, Length );</span>
[ 0, 0, 0, 0, 0, 0, 0, 16 ]
</pre></div>

<p>Now we try the second approach and compare the results.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">names:= [ "L3(4).(2^2)_{123}", "L3(4).(2^2)_{12*3}",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             "L3(4).(2^2)_{123*}", "L3(4).(2^2)_{12*3*}" ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs1:= List( names, nam -&gt; [ "6.L3(4).2_1", "2.L3(4).2_1",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Concatenation( "2.", nam ), Concatenation( "6.", nam ) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">names:= List( names, nam -&gt; ReplacedString( nam, "1", "1*" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs2:= List( names, nam -&gt; [ "6.L3(4).2_1*", "2.L3(4).2_1*",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Concatenation( "2.", nam ), Concatenation( "6.", nam ) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs:= Concatenation( inputs1, inputs2 );</span>
[ [ "6.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{123}", 
      "6.L3(4).(2^2)_{123}" ], 
  [ "6.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{12*3}", 
      "6.L3(4).(2^2)_{12*3}" ], 
  [ "6.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{123*}", 
      "6.L3(4).(2^2)_{123*}" ], 
  [ "6.L3(4).2_1", "2.L3(4).2_1", "2.L3(4).(2^2)_{12*3*}", 
      "6.L3(4).(2^2)_{12*3*}" ], 
  [ "6.L3(4).2_1*", "2.L3(4).2_1*", "2.L3(4).(2^2)_{1*23}", 
      "6.L3(4).(2^2)_{1*23}" ], 
  [ "6.L3(4).2_1*", "2.L3(4).2_1*", "2.L3(4).(2^2)_{1*2*3}", 
      "6.L3(4).(2^2)_{1*2*3}" ], 
  [ "6.L3(4).2_1*", "2.L3(4).2_1*", "2.L3(4).(2^2)_{1*23*}", 
      "6.L3(4).(2^2)_{1*23*}" ], 
  [ "6.L3(4).2_1*", "2.L3(4).2_1*", "2.L3(4).(2^2)_{1*2*3*}", 
      "6.L3(4).(2^2)_{1*2*3*}" ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result2:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for  input in inputs do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblMG := CharacterTable( input[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblG  := CharacterTable( input[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblGA := CharacterTable( input[3] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     name  := Concatenation( "new", input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     lib   := CharacterTable( input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Append( result2, poss );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result2:= List( result2, x -&gt; x.table );</span>
[ CharacterTable( "new6.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{12*3*}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*23}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*2*3}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*23*}" ), 
  CharacterTable( "new6.L3(4).(2^2)_{1*2*3*}" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">trans:= List( [ 1 .. 8 ], i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       TransformingPermutationsCharacterTables( result[i],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           result2[i] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( trans, IsRecord );</span>
true
</pre></div>

<p><a id="X878889308653435F" name="X878889308653435F"></a></p>

<h5>2.6-6 <span class="Heading">The Character Tables of Groups of the Type <span class="SimpleMath">2.U_4(3).2^2</span>
(February 2012)</span></h5>

<p>The outer automorphism group of the group <span class="SimpleMath">U_4(3)</span> is a dihedral group of order <span class="SimpleMath">8</span>. There are two almost simple groups of the type <span class="SimpleMath">U_4(3).2^2</span>, up to isomorphism, denoted as <span class="SimpleMath">U_4(3).(2^2)_122</span> and <span class="SimpleMath">U_4(3).(2^2)_133</span>, respectively. Note that <span class="SimpleMath">U_4(3).2_1</span> is the extension by the central involution of the outer automorphism group of <span class="SimpleMath">U_4(3)</span>, the other two subgroups of index two in <span class="SimpleMath">U_4(3).(2^2)_122</span> are <span class="SimpleMath">U_4(3).2_2</span> and <span class="SimpleMath">U_4(3).2^'_2</span>, respectively, and the other two subgroups of index two in <span class="SimpleMath">U_4(3).(2^2)_133</span> are <span class="SimpleMath">U_4(3).2_3</span> and <span class="SimpleMath">U_4(3).2^'_3</span>, respectively.</p>

<p>Since Aut<span class="SimpleMath">( U_4(3) )</span> possesses a double cover (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 52]</a>), double covers of <span class="SimpleMath">U_4(3).(2^2)_122</span> and <span class="SimpleMath">U_4(3).(2^2)_133</span> exist.</p>

<p>First we deal with the double covers of <span class="SimpleMath">U_4(3).(2^2)_122</span>. Any such group contains one subgroup of the type <span class="SimpleMath">2.U_4(3).2_1</span> and two subgroups of the type <span class="SimpleMath">2.U_4(3).2_2</span>, and there are two isoclinic variants of each of these group to consider, see Section <a href="chap2.html#X78F41D2A78E70BEE"><span class="RefLink">2.2-6</span></a>. Thus we start with six different inputs for the construction of the character tables of double covers.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls:= List( [ "1", "2", "2'" ], i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     CharacterTable( Concatenation( "2.U4(3).2_", i ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isos:= List( [ "1", "2", "2'" ], i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     CharacterTable( Concatenation( "Isoclinic(2.U4(3).2_", i, ")" ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs:= [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], tbls[2], tbls[3], "2.U4(3).(2^2)_{122}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], tbls[2], tbls[3], "2.U4(3).(2^2)_{1*22}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], isos[2], tbls[3], "2.U4(3).(2^2)_{12*2}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], isos[2], tbls[3], "2.U4(3).(2^2)_{1*2*2}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], isos[2], isos[3], "2.U4(3).(2^2)_{12*2*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], isos[2], isos[3], "2.U4(3).(2^2)_{1*2*2*}" ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "2.U4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for input in inputs do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblsG2:= input{ [ 1 .. 3 ] };</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     lib:= CharacterTable( input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ConstructModularGV4Tables( tblG, tblsG2, poss, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Append( result, RepresentativesCharacterTables( poss ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result:= List( result, x -&gt; x.table );</span>
[ CharacterTable( "new2.U4(3).(2^2)_{122}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{1*22}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{12*2}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{1*2*2}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{12*2*}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{1*2*2*}" ) ]
</pre></div>

<p>We get exactly one character table for each input. For each of these tables, there are three possibilities to form an isoclinic table, corresponding to the three subgroups of index two. It turns out that the six solutions form two orbits under forming some isoclinic table. Tables in different orbits are essentially different, already their numbers of conjugacy classes differ.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( result, NrConjugacyClasses );</span>
[ 87, 102, 102, 87, 87, 102 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= result[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= List( nsg, x -&gt; CharacterTableIsoclinic( t, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( iso, x -&gt; PositionProperty( result, y -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           TransformingPermutationsCharacterTables( x, y ) &lt;&gt; fail ) );</span>
[ 4, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= result[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= List( nsg, x -&gt; CharacterTableIsoclinic( t, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( iso, x -&gt; PositionProperty( result, y -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           TransformingPermutationsCharacterTables( x, y ) &lt;&gt; fail ) );</span>
[ 3, 3, 6 ]
</pre></div>

<p>Up to now, it is not clear that the character tables we have constructed are really the character tables of some groups. The existence of groups for the first orbit of character tables can be established as follows.</p>

<p>The group <span class="SimpleMath">O_8^+(3)</span> contains maximal subgroups of the type <span class="SimpleMath">2.U_4(3).2^2</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 140]</a>. Only the first of our result tables admits a class fusion into the table of <span class="SimpleMath">O_8^+(3)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= CharacterTable( "O8+(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= List( result, x -&gt; PossibleClassFusions( x, u ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( fus, Length );</span>
[ 24, 0, 0, 0, 0, 0 ]
</pre></div>

<p>A table in the second orbit belongs to a maximal subgroup of <span class="SimpleMath">O_7(3).2</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 109]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:= CharacterTable( "O7(3).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= List( result, x -&gt; PossibleClassFusions( x, u ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( fus, Length );</span>
[ 0, 16, 0, 0, 0, 0 ]
</pre></div>

<p>Note that this subgroup of <span class="SimpleMath">O_7(3).2 ≅ SO(7,3)</span> is the orthogonal group GO<span class="SimpleMath">_6^-(3)</span>.</p>

<p>Now we deal with the double covers of <span class="SimpleMath">U_4(3).(2^2)_133</span>. The constructions of the character tables are completely analogous to those in the case of <span class="SimpleMath">U_4(3).(2^2)_122</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls:= List( [ "1", "3", "3'" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     i -&gt; CharacterTable( Concatenation( "2.U4(3).2_", i ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isos:= List( [ "1", "3", "3'" ], i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     CharacterTable( Concatenation( "Isoclinic(2.U4(3).2_", i, ")" ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs:= [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], tbls[2], tbls[3], "2.U4(3).(2^2)_{133}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], tbls[2], tbls[3], "2.U4(3).(2^2)_{1*33}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], isos[2], tbls[3], "2.U4(3).(2^2)_{13*3}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], isos[2], tbls[3], "2.U4(3).(2^2)_{1*3*3}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], isos[2], isos[3], "2.U4(3).(2^2)_{13*3*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], isos[2], isos[3], "2.U4(3).(2^2)_{1*3*3*}" ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "2.U4(3)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for input in inputs do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblsG2:= input{ [ 1 .. 3 ] };</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     lib:= CharacterTable( input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ConstructModularGV4Tables( tblG, tblsG2, poss, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Append( result, RepresentativesCharacterTables( poss ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
#I  excluded cand. 2 (out of 4) for 2.U4(3).(2^2)_{1*33} by 
3-mod. table
#I  excluded cand. 3 (out of 4) for 2.U4(3).(2^2)_{1*33} by 
3-mod. table
#I  excluded cand. 2 (out of 4) for 2.U4(3).(2^2)_{13*3} by 
3-mod. table
#I  excluded cand. 3 (out of 4) for 2.U4(3).(2^2)_{13*3} by 
3-mod. table
#I  excluded cand. 2 (out of 4) for 2.U4(3).(2^2)_{1*3*3*} by 
3-mod. table
#I  excluded cand. 3 (out of 4) for 2.U4(3).(2^2)_{1*3*3*} by 
3-mod. table
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result:= List( result, x -&gt; x.table );</span>
[ CharacterTable( "new2.U4(3).(2^2)_{133}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{1*33}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{13*3}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{1*3*3}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{13*3*}" ), 
  CharacterTable( "new2.U4(3).(2^2)_{1*3*3*}" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( result, NrConjugacyClasses );</span>
[ 69, 72, 72, 69, 69, 72 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= result[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= List( nsg, x -&gt; CharacterTableIsoclinic( t, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( iso, x -&gt; PositionProperty( result, y -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           TransformingPermutationsCharacterTables( x, y ) &lt;&gt; fail ) );</span>
[ 4, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= result[2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= List( nsg, x -&gt; CharacterTableIsoclinic( t, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( iso, x -&gt; PositionProperty( result, y -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           TransformingPermutationsCharacterTables( x, y ) &lt;&gt; fail ) );</span>
[ 3, 3, 6 ]
</pre></div>

<p><a id="X7DC42AE57E9EED4D" name="X7DC42AE57E9EED4D"></a></p>

<h5>2.6-7 <span class="Heading">The Character Tables of Groups of the Type <span class="SimpleMath">4_1.L_3(4).2^2</span>
(October 2011)</span></h5>

<p>The situation with <span class="SimpleMath">4_1.L_3(4).2^2</span> is analogous to that with <span class="SimpleMath">6.L_3(4).2^2</span>, see Section <a href="chap2.html#X79818ABD7E972370"><span class="RefLink">2.6-5</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls:= List( [ "1", "2", "3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     i -&gt; CharacterTable( Concatenation( "4_1.L3(4).2_", i ) ) );</span>
[ CharacterTable( "4_1.L3(4).2_1" ), CharacterTable( "4_1.L3(4).2_2" )
    , CharacterTable( "4_1.L3(4).2_3" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isos:= List( [ "1", "2", "3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     i -&gt; CharacterTable( Concatenation( "4_1.L3(4).2_", i, "*" ) ) );</span>
[ CharacterTable( "Isoclinic(4_1.L3(4).2_1)" ), 
  CharacterTable( "Isoclinic(4_1.L3(4).2_2)" ), 
  CharacterTable( "4_1.L3(4).2_3*" ) ]
</pre></div>

<p>Note that the group <span class="SimpleMath">4_1.L_3(4).2_3</span> has a centre of order four, so one cannot construct the isoclinic variant by calling the one argument version of <code class="func">CharacterTableIsoclinic</code> (<a href="../../../doc/ref/chap71.html#X85BE46F784B83938"><span class="RefLink">Reference: CharacterTableIsoclinic</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tbls, ClassPositionsOfCentre );</span>
[ [ 1, 3 ], [ 1, 3 ], [ 1, 2, 3, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( tbls[3],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTableIsoclinic( tbls[3] ) ) );</span>
true
</pre></div>

<p>Again, we get eight different character tables, in two orbits.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs:= [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], tbls[2], tbls[3], "4_1.L3(4).(2^2)_{123}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], tbls[2], tbls[3], "4_1.L3(4).(2^2)_{1*23}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], isos[2], tbls[3], "4_1.L3(4).(2^2)_{12*3}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], isos[2], tbls[3], "4_1.L3(4).(2^2)_{1*2*3}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], tbls[2], isos[3], "4_1.L3(4).(2^2)_{123*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], tbls[2], isos[3], "4_1.L3(4).(2^2)_{1*23*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], isos[2], isos[3], "4_1.L3(4).(2^2)_{12*3*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], isos[2], isos[3], "4_1.L3(4).(2^2)_{1*2*3*}" ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "4_1.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for input in inputs do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblsG2:= input{ [ 1 .. 3 ] };</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     lib:= CharacterTable( input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ConstructModularGV4Tables( tblG, tblsG2, poss, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Append( result, RepresentativesCharacterTables( poss ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
#I  excluded cand. 2 (out of 8) for 4_1.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_1.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_1.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_1.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_1.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_1.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_1.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_1.L3(4).(2^2)_{12*3} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_1.L3(4).(2^2)_{1*2*3} by 
5-mod. table
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result:= List( result, x -&gt; x.table );</span>
[ CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{1*23}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{1*2*3}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{1*23*}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{12*3*}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{1*2*3*}" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( result, NrConjugacyClasses );</span>
[ 48, 48, 48, 48, 42, 42, 42, 42 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= result[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= List( nsg, x -&gt; CharacterTableIsoclinic( t, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( iso, x -&gt; PositionProperty( result, y -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           TransformingPermutationsCharacterTables( x, y ) &lt;&gt; fail ) );</span>
[ 3, 2, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= result[5];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= List( nsg, x -&gt; CharacterTableIsoclinic( t, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( iso, x -&gt; PositionProperty( result, y -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           TransformingPermutationsCharacterTables( x, y ) &lt;&gt; fail ) );</span>
[ 7, 6, 8 ]
</pre></div>

<p>Note that only two out of the eight tables of the type <span class="SimpleMath">2.L_3(4).2^2</span> occur as factors of the eight tables.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">facts:= [ CharacterTable( "2.L3(4).(2^2)_{123}" ), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             CharacterTable( "2.L3(4).(2^2)_{123*}" ) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">factresults:= List( result, t -&gt; t / ClassPositionsOfCentre( t ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( factresults, t -&gt; PositionProperty( facts, f -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           IsRecord( TransformingPermutationsCharacterTables( t, f ) ) ) );</span>
[ 1, 1, 1, 1, 2, 2, 2, 2 ]
</pre></div>

<p>This is not surprising; note that for <span class="SimpleMath">1 ≤ i ≤ 2</span>, the two isoclinic variants of <span class="SimpleMath">4_1.L_3(4).2_i</span> have isomorphic factor groups of the type <span class="SimpleMath">2.L_3(4).2_i</span>. (For <span class="SimpleMath">i = 3</span>, this is not the case.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test:= [ CharacterTable( "4_1.L3(4).2_1" ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            CharacterTable( "4_1.L3(4).2_1*" ) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( test, ClassPositionsOfCentre );</span>
[ [ 1, 3 ], [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fact:= List( test, t -&gt; t / ClassPositionsOfCentre( t ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( fact[1], fact[2] ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test:= [ CharacterTable( "4_1.L3(4).2_2" ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            CharacterTable( "4_1.L3(4).2_2*" ) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( test, ClassPositionsOfCentre );</span>
[ [ 1, 3 ], [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fact:= List( test, t -&gt; t / ClassPositionsOfCentre( t ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( fact[1], fact[2] ) );</span>
true
</pre></div>

<p>Now we try the second approach and compare the results. By the abovementioned asymmetry, it is clear that the tables are not uniquely determined by the input data.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">names:= [ "L3(4).(2^2)_{123}", "L3(4).(2^2)_{1*23}",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             "L3(4).(2^2)_{12*3}", "L3(4).(2^2)_{1*2*3}" ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs1:= List( names, nam -&gt; [ "4_1.L3(4).2_3", "2.L3(4).2_3",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Concatenation( "2.", nam ), Concatenation( "4_1.", nam ) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">names:= List( names, nam -&gt; ReplacedString( nam, "3}", "3*}" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs2:= List( names, nam -&gt; [ "4_1.L3(4).2_3*", "2.L3(4).2_3*",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Concatenation( "2.", nam ), Concatenation( "4_1.", nam ) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs:= Concatenation( inputs1, inputs2 );</span>
[ [ "4_1.L3(4).2_3", "2.L3(4).2_3", "2.L3(4).(2^2)_{123}", 
      "4_1.L3(4).(2^2)_{123}" ], 
  [ "4_1.L3(4).2_3", "2.L3(4).2_3", "2.L3(4).(2^2)_{1*23}", 
      "4_1.L3(4).(2^2)_{1*23}" ], 
  [ "4_1.L3(4).2_3", "2.L3(4).2_3", "2.L3(4).(2^2)_{12*3}", 
      "4_1.L3(4).(2^2)_{12*3}" ], 
  [ "4_1.L3(4).2_3", "2.L3(4).2_3", "2.L3(4).(2^2)_{1*2*3}", 
      "4_1.L3(4).(2^2)_{1*2*3}" ], 
  [ "4_1.L3(4).2_3*", "2.L3(4).2_3*", "2.L3(4).(2^2)_{123*}", 
      "4_1.L3(4).(2^2)_{123*}" ], 
  [ "4_1.L3(4).2_3*", "2.L3(4).2_3*", "2.L3(4).(2^2)_{1*23*}", 
      "4_1.L3(4).(2^2)_{1*23*}" ], 
  [ "4_1.L3(4).2_3*", "2.L3(4).2_3*", "2.L3(4).(2^2)_{12*3*}", 
      "4_1.L3(4).(2^2)_{12*3*}" ], 
  [ "4_1.L3(4).2_3*", "2.L3(4).2_3*", "2.L3(4).(2^2)_{1*2*3*}", 
      "4_1.L3(4).(2^2)_{1*2*3*}" ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result2:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for  input in inputs do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblMG := CharacterTable( input[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblG  := CharacterTable( input[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblGA := CharacterTable( input[3] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     name  := Concatenation( "new", input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     lib   := CharacterTable( input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Append( result2, poss );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
#E  4 possibilities for new4_1.L3(4).(2^2)_{123}
#E  no solution for new4_1.L3(4).(2^2)_{1*23}
#E  no solution for new4_1.L3(4).(2^2)_{12*3}
#E  no solution for new4_1.L3(4).(2^2)_{1*2*3}
#E  4 possibilities for new4_1.L3(4).(2^2)_{123*}
#E  no solution for new4_1.L3(4).(2^2)_{1*23*}
#E  no solution for new4_1.L3(4).(2^2)_{12*3*}
#E  no solution for new4_1.L3(4).(2^2)_{1*2*3*}
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( result2 );</span>
8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result2:= List( result2, x -&gt; x.table );</span>
[ CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new4_1.L3(4).(2^2)_{123*}" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( result, t1 -&gt; PositionsProperty( result2, t2 -&gt; IsRecord(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     TransformingPermutationsCharacterTables( t1, t2 ) ) ) );</span>
[ [ 1 ], [ 4 ], [ 3 ], [ 2 ], [ 7 ], [ 6 ], [ 5 ], [ 8 ] ]
</pre></div>

<p>At the moment, I do not know interesting groups that contain one of the <span class="SimpleMath">4_1.L_3(4).2^2</span> type groups and whose character tables are available.</p>

<p><a id="X7E9AF180869B4786" name="X7E9AF180869B4786"></a></p>

<h5>2.6-8 <span class="Heading">The Character Tables of Groups of the Type <span class="SimpleMath">4_2.L_3(4).2^2</span>
(October 2011)</span></h5>

<p>The situation with <span class="SimpleMath">4_2.L_3(4).2^2</span> is analogous to that with <span class="SimpleMath">6.L_3(4).2^2</span>, see Section <a href="chap2.html#X79818ABD7E972370"><span class="RefLink">2.6-5</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls:= List( [ "1", "2", "3" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     i -&gt; CharacterTable( Concatenation( "4_2.L3(4).2_", i ) ) );</span>
[ CharacterTable( "4_2.L3(4).2_1" ), CharacterTable( "4_2.L3(4).2_2" )
    , CharacterTable( "4_2.L3(4).2_3" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isos:= List( [ "1", "2", "3" ], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     i -&gt; CharacterTable( Concatenation( "4_2.L3(4).2_", i, "*" ) ) );</span>
[ CharacterTable( "Isoclinic(4_2.L3(4).2_1)" ), 
  CharacterTable( "4_2.L3(4).2_2*" ), 
  CharacterTable( "Isoclinic(4_2.L3(4).2_3)" ) ]
</pre></div>

<p>Note that the group <span class="SimpleMath">4_1.L_3(4).2_2</span> has a centre of order four, so one cannot construct the isoclinic variant not by calling the one argument version of <code class="func">CharacterTableIsoclinic</code> (<a href="../../../doc/ref/chap71.html#X85BE46F784B83938"><span class="RefLink">Reference: CharacterTableIsoclinic</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( tbls, ClassPositionsOfCentre );</span>
[ [ 1, 3 ], [ 1, 2, 3, 4 ], [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( tbls[2],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTableIsoclinic( tbls[2] ) ) );</span>
true
</pre></div>

<p>Again, we get eight different character tables, in two orbits.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs:= [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], tbls[2], tbls[3], "4_2.L3(4).(2^2)_{123}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], tbls[2], tbls[3], "4_2.L3(4).(2^2)_{1*23}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], isos[2], tbls[3], "4_2.L3(4).(2^2)_{12*3}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], tbls[2], isos[3], "4_2.L3(4).(2^2)_{123*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], isos[2], tbls[3], "4_2.L3(4).(2^2)_{1*2*3}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], tbls[2], isos[3], "4_2.L3(4).(2^2)_{1*23*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ tbls[1], isos[2], isos[3], "4_2.L3(4).(2^2)_{12*3*}" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[ isos[1], isos[2], isos[3], "4_2.L3(4).(2^2)_{1*2*3*}" ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "4_2.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for input in inputs do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblsG2:= input{ [ 1 .. 3 ] };</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     lib:= CharacterTable( input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= ConstructOrdinaryGV4Table( tblG, tblsG2, input[4], lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ConstructModularGV4Tables( tblG, tblsG2, poss, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Append( result, RepresentativesCharacterTables( poss ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
#I  excluded cand. 2 (out of 8) for 4_2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_2.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_2.L3(4).(2^2)_{123} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_2.L3(4).(2^2)_{123} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_2.L3(4).(2^2)_{1*23} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_2.L3(4).(2^2)_{123*} by 
5-mod. table
#I  excluded cand. 2 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 3 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 4 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 
7-mod. table
#I  excluded cand. 5 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 
7-mod. table
#I  excluded cand. 6 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 
5-mod. table
#I  excluded cand. 7 (out of 8) for 4_2.L3(4).(2^2)_{1*23*} by 
5-mod. table
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result:= List( result, x -&gt; x.table );</span>
[ CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{1*23}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{123*}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{1*2*3}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{1*23*}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{12*3*}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{1*2*3*}" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( result, NrConjugacyClasses );</span>
[ 50, 50, 44, 50, 44, 50, 44, 44 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= result[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= List( nsg, x -&gt; CharacterTableIsoclinic( t, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( iso, x -&gt; PositionProperty( result, y -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           TransformingPermutationsCharacterTables( x, y ) &lt;&gt; fail ) );</span>
[ 4, 2, 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= result[3];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= Filtered( ClassPositionsOfNormalSubgroups( t ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           x -&gt; Sum( SizesConjugacyClasses( t ){ x } ) = Size( t ) / 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:= List( nsg, x -&gt; CharacterTableIsoclinic( t, x ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( iso, x -&gt; PositionProperty( result, y -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           TransformingPermutationsCharacterTables( x, y ) &lt;&gt; fail ) );</span>
[ 7, 5, 8 ]
</pre></div>

<p>Note that only two out of the eight tables of the type <span class="SimpleMath">2.L_3(4).2^2</span> occur as factors of the eight tables.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">facts:= [ CharacterTable( "2.L3(4).(2^2)_{123}" ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             CharacterTable( "2.L3(4).(2^2)_{12*3}" ) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">factresults:= List( result, t -&gt; t / ClassPositionsOfCentre( t ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( factresults, t -&gt; PositionProperty( facts, f -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           IsRecord( TransformingPermutationsCharacterTables( t, f ) ) ) );</span>
[ 1, 1, 2, 1, 2, 1, 2, 2 ]
</pre></div>

<p>This is not surprising; note that for <span class="SimpleMath">i ∈ { 1, 3 }</span>, the two isoclinic variants of <span class="SimpleMath">4_1.L_3(4).2_i</span> have isomorphic factor groups of the type <span class="SimpleMath">2.L_3(4).2_i</span>. (For <span class="SimpleMath">i = 2</span>, this is not the case.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test:= [ CharacterTable( "4_2.L3(4).2_1" ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            CharacterTable( "4_2.L3(4).2_1*" ) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( test, ClassPositionsOfCentre );</span>
[ [ 1, 3 ], [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fact:= List( test, t -&gt; t / ClassPositionsOfCentre( t ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( fact[1], fact[2] ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test:= [ CharacterTable( "4_2.L3(4).2_3" ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            CharacterTable( "4_2.L3(4).2_3*" ) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( test, ClassPositionsOfCentre );</span>
[ [ 1, 3 ], [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fact:= List( test, t -&gt; t / ClassPositionsOfCentre( t ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( fact[1], fact[2] ) );</span>
true
</pre></div>

<p>Now we try the second approach and compare the results. By the abovementioned asymmetry, it is clear that the tables are not uniquely determined by the input data.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">names:= [ "L3(4).(2^2)_{123}", "L3(4).(2^2)_{1*23}",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             "L3(4).(2^2)_{123*}", "L3(4).(2^2)_{1*23*}" ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs1:= List( names, nam -&gt; [ "4_2.L3(4).2_2", "2.L3(4).2_2",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Concatenation( "2.", nam ), Concatenation( "4_2.", nam ) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">names:= List( names, nam -&gt; ReplacedString( nam, "23", "2*3" ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs2:= List( names, nam -&gt; [ "4_2.L3(4).2_2*", "2.L3(4).2_2*",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Concatenation( "2.", nam ), Concatenation( "4_2.", nam ) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inputs:= Concatenation( inputs1, inputs2 );</span>
[ [ "4_2.L3(4).2_2", "2.L3(4).2_2", "2.L3(4).(2^2)_{123}", 
      "4_2.L3(4).(2^2)_{123}" ], 
  [ "4_2.L3(4).2_2", "2.L3(4).2_2", "2.L3(4).(2^2)_{1*23}", 
      "4_2.L3(4).(2^2)_{1*23}" ], 
  [ "4_2.L3(4).2_2", "2.L3(4).2_2", "2.L3(4).(2^2)_{123*}", 
      "4_2.L3(4).(2^2)_{123*}" ], 
  [ "4_2.L3(4).2_2", "2.L3(4).2_2", "2.L3(4).(2^2)_{1*23*}", 
      "4_2.L3(4).(2^2)_{1*23*}" ], 
  [ "4_2.L3(4).2_2*", "2.L3(4).2_2*", "2.L3(4).(2^2)_{12*3}", 
      "4_2.L3(4).(2^2)_{12*3}" ], 
  [ "4_2.L3(4).2_2*", "2.L3(4).2_2*", "2.L3(4).(2^2)_{1*2*3}", 
      "4_2.L3(4).(2^2)_{1*2*3}" ], 
  [ "4_2.L3(4).2_2*", "2.L3(4).2_2*", "2.L3(4).(2^2)_{12*3*}", 
      "4_2.L3(4).(2^2)_{12*3*}" ], 
  [ "4_2.L3(4).2_2*", "2.L3(4).2_2*", "2.L3(4).(2^2)_{1*2*3*}", 
      "4_2.L3(4).(2^2)_{1*2*3*}" ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result2:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for  input in inputs do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblMG := CharacterTable( input[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblG  := CharacterTable( input[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblGA := CharacterTable( input[3] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     name  := Concatenation( "new", input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     lib   := CharacterTable( input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= ConstructOrdinaryMGATable( tblMG, tblG, tblGA, name, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Append( result2, poss );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
#E  4 possibilities for new4_2.L3(4).(2^2)_{123}
#E  no solution for new4_2.L3(4).(2^2)_{1*23}
#E  no solution for new4_2.L3(4).(2^2)_{123*}
#E  no solution for new4_2.L3(4).(2^2)_{1*23*}
#E  4 possibilities for new4_2.L3(4).(2^2)_{12*3}
#E  no solution for new4_2.L3(4).(2^2)_{1*2*3}
#E  no solution for new4_2.L3(4).(2^2)_{12*3*}
#E  no solution for new4_2.L3(4).(2^2)_{1*2*3*}
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( result2 );</span>
8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result2:= List( result2, x -&gt; x.table );</span>
[ CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{123}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ), 
  CharacterTable( "new4_2.L3(4).(2^2)_{12*3}" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( result, t1 -&gt; PositionsProperty( result2, t2 -&gt; IsRecord(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     TransformingPermutationsCharacterTables( t1, t2 ) ) ) );</span>
[ [ 1 ], [ 4 ], [ 7 ], [ 3 ], [ 6 ], [ 2 ], [ 5 ], [ 8 ] ]
</pre></div>

<p>The group <span class="SimpleMath">ON.2</span> contains a maximal subgroup <span class="SimpleMath">M</span> of the type <span class="SimpleMath">4_2.L_3(4).2^2</span>, see <a href="chapBib.html#biBCCN85">[CCN+85, p. 132]</a>. Only the third result table admits a class fusion into <span class="SimpleMath">ON.2</span>. This shows the existence of groups for the tables from the second orbit.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">on2:= CharacterTable( "ON.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= List( result, x -&gt; PossibleClassFusions( x, on2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( fus, Length );</span>
[ 0, 0, 16, 0, 0, 0, 0, 0 ]
</pre></div>

<p><a id="X7EAF9CD07E536120" name="X7EAF9CD07E536120"></a></p>

<h5>2.6-9 <span class="Heading">The Character Table of Aut<span class="SimpleMath">(L_2(81))</span></span></h5>

<p>The group Aut<span class="SimpleMath">(L_2(81)) ≅ L_2(81).(2 × 4)</span> has the structure <span class="SimpleMath">G.2^2</span> where <span class="SimpleMath">G = L_2(81).2_1</span>. Here we get two triples of possible actions on the tables of the groups <span class="SimpleMath">G.2_i</span>, and one possible character table for each triple.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">input:= [ "L2(81).2_1", "L2(81).4_1", "L2(81).4_2", "L2(81).2^2",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                       "L2(81).(2x4)" ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG   := CharacterTable( input[1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblsG2 := List( input{ [ 2 .. 4 ] }, CharacterTable );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">name   := Concatenation( "new", input[5] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib    := CharacterTable( input[5] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss   := ConstructOrdinaryGV4Table( tblG, tblsG2, name, lib );;</span>
#I  newL2(81).(2x4): 2 equivalence classes
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= RepresentativesCharacterTables( poss );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( reps );</span>
2
</pre></div>

<p>Due to the different underlying actions, the power maps of the two candidate tables differ.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord:= OrdersClassRepresentatives( reps[1].table );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord = OrdersClassRepresentatives( reps[2].table ); </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pos:= Position( ord, 80 );</span>
33
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PowerMap( reps[1].table, 3 )[ pos ];</span>
34
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PowerMap( reps[2].table, 3 )[ pos ];</span>
33
</pre></div>

<p>Aut<span class="SimpleMath">(L_2(81))</span> can be generated by PGL<span class="SimpleMath">(2,81) = L_2(81).2_2</span> and the Frobenius automorphism of order four that is defined on GL<span class="SimpleMath">(2,81)</span> as the map that cubes the matrix entries. The elements of order <span class="SimpleMath">80</span> in Aut<span class="SimpleMath">(L_2(81))</span> are conjugates of diagonal matrices modulo scalar matrices, which are mapped to their third powers by the Frobenius homomorphism. So the third power map of Aut<span class="SimpleMath">(L_2(81))</span> fixes the classes of elements of order <span class="SimpleMath">80</span>. In other words, the second of the two tables is the right one.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">trans:= TransformingPermutationsCharacterTables( reps[2].table, lib );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( trans );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( reps[2].G2fusGV4, x -&gt; OnTuples( x, trans.columns ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> = List( tblsG2, x -&gt; GetFusionMap( x, lib ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstructModularGV4Tables( tblG, tblsG2, poss, lib );;</span>
#I  not all input tables for L2(81).(2x4) mod 3 available
#I  not all input tables for L2(81).(2x4) mod 41 available
</pre></div>

<p><a id="X78AED04685EDCC19" name="X78AED04685EDCC19"></a></p>

<h5>2.6-10 <span class="Heading">The Character Table of <span class="SimpleMath">O_8^+(3).2^2_111</span></span></h5>

<p>The construction of the character table of the group <span class="SimpleMath">O_8^+(3).2^2_111</span> is not as straightforward as the constructions shown in Section <a href="chap2.html#X7FEC3AB081487AF2"><span class="RefLink">2.6-2</span></a>. Here we get <span class="SimpleMath">26</span> triples of actions on the tables of the three subgroups <span class="SimpleMath">G.2_i</span> of index two, but only one of them leads to candidates for the desired character table. Specifically, we get <span class="SimpleMath">64</span> such candidates, in two equivalence classes w.r.t. permutation equivalence.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">input:= [ "O8+(3)", "O8+(3).2_1",  "O8+(3).2_1'", "O8+(3).2_1''",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                 "O8+(3).(2^2)_{111}" ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG   := CharacterTable( input[1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblsG2 := List( input{ [ 2 .. 4 ] }, CharacterTable );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">name   := Concatenation( "new", input[5] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib    := CharacterTable( input[5] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss   := ConstructOrdinaryGV4Table( tblG, tblsG2, name, lib );;</span>
#I  newO8+(3).(2^2)_{111}: 2 equivalence classes
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( poss );</span>
64
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= RepresentativesCharacterTables( poss );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( reps );</span>
2
</pre></div>

<p>The two candidate tables differ only in four irreducible characters involving irrationalities on the classes of element order <span class="SimpleMath">28</span>. All three subgroups <span class="SimpleMath">G.2_i</span> contain elements of order <span class="SimpleMath">28</span> that do not lie in the simple group <span class="SimpleMath">G</span>; these classes are roots of the same (unique) class of element order <span class="SimpleMath">7</span>. The centralizer <span class="SimpleMath">C</span> of an order <span class="SimpleMath">7</span> element in <span class="SimpleMath">G.2^2</span> has order <span class="SimpleMath">112 = 2^4 ⋅ 7</span>, the intersection of <span class="SimpleMath">C</span> with <span class="SimpleMath">G</span> has the structure <span class="SimpleMath">2^2 × 7</span> since <span class="SimpleMath">G</span> contains three classes of cyclic subgroups of the order <span class="SimpleMath">14</span>, and each of the intersections of <span class="SimpleMath">C</span> with one of the subgroups <span class="SimpleMath">G.2_i</span> has the structure <span class="SimpleMath">2 × 4 × 7</span>, so the structure of <span class="SimpleMath">C</span> is <span class="SimpleMath">4^2 × 7 ≅ 4 × 28</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= reps[1].table;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord7:= Filtered( [ 1 .. NrConjugacyClasses( t ) ],                        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              i -&gt; OrdersClassRepresentatives( t )[i] = 7 );</span>
[ 37 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesCentralizers( t ){ ord7 };</span>
[ 112 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord28:= Filtered( [ 1 .. NrConjugacyClasses( t ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              i -&gt; OrdersClassRepresentatives( t )[i] = 28 );</span>
[ 112, 113, 114, 115, 161, 162, 163, 164, 210, 211, 212, 213 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( reps[1].G2fusGV4, x -&gt; Intersection( ord28, x ) );</span>
[ [ 112, 113, 114, 115 ], [ 161, 162, 163, 164 ], 
  [ 210, 211, 212, 213 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sub:= CharacterTable( "Cyclic", 28 ) * CharacterTable( "Cyclic", 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( reps, x -&gt; Length( PossibleClassFusions( sub, x.table ) ) );</span>
[ 0, 96 ]
</pre></div>

<p>It turns out that only one of the two candidate tables admits a class fusion from the character table of <span class="SimpleMath">C</span>, thus we have determined the ordinary character table of <span class="SimpleMath">O_8^+(3).2^2_111</span>. It coincides with the table from the library.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">trans:= TransformingPermutationsCharacterTables( reps[2].table, lib );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( trans );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( reps[2].G2fusGV4, x -&gt; OnTuples( x, trans.columns ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> = List( tblsG2, x -&gt; GetFusionMap( x, lib ) );</span>
true
</pre></div>

<p>(If we do not believe the statement about the structure of <span class="SimpleMath">C</span> then we can check all <span class="SimpleMath">14</span> groups of order <span class="SimpleMath">112</span> that contain a central subgroup of order <span class="SimpleMath">7</span>. A unique such group admits a class fusion into at least one of the two candidate tables.)</p>

<p>The wrong candidate for the ordinary table cannot be excluded via conditions that are forced by the construction of the <span class="SimpleMath">p</span>-modular tables of <span class="SimpleMath">O_8^+(3).2^2_111</span>. Thus we restrict the ordinary tables used for this construction to those candidates that are equivalent to the correct table.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= Filtered( poss,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     r -&gt; TransformingPermutationsCharacterTables( r.table, lib )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          &lt;&gt; fail );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstructModularGV4Tables( tblG, tblsG2, poss, lib );;</span>
#I  not all input tables for O8+(3).(2^2)_{111} mod 3 available
</pre></div>

<p>So also the <span class="SimpleMath">p</span>-modular tables of <span class="SimpleMath">O_8^+(3).2^2_111</span> can be computed this way, provided that the <span class="SimpleMath">p</span>-modular tables of the index <span class="SimpleMath">2</span> subgroups are available.</p>

<p><a id="X845BAA2A7FD768B0" name="X845BAA2A7FD768B0"></a></p>

<h4>2.7 <span class="Heading">Examples for the Type <span class="SimpleMath">2^2.G</span></span></h4>

<p>We compute the character table of a group of the type <span class="SimpleMath">2^2.G</span> from the character tables of the three factor groups of the type <span class="SimpleMath">2.G</span>, using the function <code class="func">PossibleCharacterTablesOfTypeV4G</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7E7043A5857B9240"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeV4G</span></a>), see Section <a href="chap2.html#X81464C4B8178C85A"><span class="RefLink">2.3-4</span></a>.</p>

<p><a id="X87EEBDB987249117" name="X87EEBDB987249117"></a></p>

<h5>2.7-1 <span class="Heading">The Character Table of <span class="SimpleMath">2^2.Sz(8)</span></span></h5>

<p>The three central involutions in <span class="SimpleMath">2^2.Sz(8)</span> are permuted cyclicly by an outer automorphism <span class="SimpleMath">α</span> of order three. In order to apply <code class="func">PossibleCharacterTablesOfTypeV4G</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7E7043A5857B9240"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeV4G</span></a>), we need the character table of the group <span class="SimpleMath">2.Sz(8)</span> and the action on the classes of <span class="SimpleMath">Sz(8)</span> that is induced by <span class="SimpleMath">α</span>.</p>

<p>The ordinary character table of <span class="SimpleMath">G = Sz(8)</span> admits exactly five table automorphisms of order dividing <span class="SimpleMath">3</span>. Each of these possibilities leads to exactly one possible character table of <span class="SimpleMath">2^2.G</span>, and the five tables are permutation equivalent. From this point of view, we need not know which of the table automorphisms are induced by outer <em>group</em> automorphisms of <span class="SimpleMath">G</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t:= CharacterTable( "Sz(8)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2t:= CharacterTable( "2.Sz(8)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut:= AutomorphismsOfTable( t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= Set( Filtered( aut, x -&gt; Order( x ) in [ 1, 3 ] ),           </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               SmallestGeneratorPerm );</span>
[ (), (9,10,11), (6,7,8), (6,7,8)(9,10,11), (6,7,8)(9,11,10) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= List( elms,                                         </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      pi -&gt; PossibleCharacterTablesOfTypeV4G( t, 2t, pi, "2^2.Sz(8)" ) );</span>
[ [ CharacterTable( "2^2.Sz(8)" ) ], [ CharacterTable( "2^2.Sz(8)" ) ]
    , [ CharacterTable( "2^2.Sz(8)" ) ], 
  [ CharacterTable( "2^2.Sz(8)" ) ], 
  [ CharacterTable( "2^2.Sz(8)" ) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= RepresentativesCharacterTables( Concatenation( poss ) );</span>
[ CharacterTable( "2^2.Sz(8)" ) ]
</pre></div>

<p>The tables coincide with the one that is stored in the <strong class="pkg">GAP</strong> library.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( reps[1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "2^2.Sz(8)" ) ) );</span>
true
</pre></div>

<p>The computation of the <span class="SimpleMath">p</span>-modular character table of <span class="SimpleMath">2^2.G</span> from the <span class="SimpleMath">p</span>-modular character table of <span class="SimpleMath">2.G</span> and the three factor fusions from <span class="SimpleMath">2^2.G</span> to <span class="SimpleMath">2.G</span> is straightforward, as is stated in Section <a href="chap2.html#X81464C4B8178C85A"><span class="RefLink">2.3-4</span></a>. The three fusions are stored on the tables returned by <code class="func">PossibleCharacterTablesOfTypeV4G</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7E7043A5857B9240"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeV4G</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetFusionMap( poss[1][1], 2t, "1" );</span>
[ 1, 1, 2, 2, 3, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 
  12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetFusionMap( poss[1][1], 2t, "2" );</span>
[ 1, 2, 1, 2, 3, 4, 5, 6, 7, 6, 7, 8, 9, 8, 9, 10, 11, 10, 11, 12, 
  13, 12, 13, 14, 15, 14, 15, 16, 17, 16, 17, 18, 19, 18, 19 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GetFusionMap( poss[1][1], 2t, "3" );</span>
[ 1, 2, 2, 1, 3, 4, 5, 6, 7, 7, 6, 8, 9, 9, 8, 10, 11, 11, 10, 12, 
  13, 13, 12, 14, 15, 15, 14, 16, 17, 17, 16, 18, 19, 19, 18 ]
</pre></div>

<p>The <strong class="pkg">GAP</strong> library function <code class="func">BrauerTableOfTypeV4G</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X8536F9027F097C79"><span class="RefLink">CTblLib: BrauerTableOfTypeV4G</span></a>) can be used to derive Brauer tables of <span class="SimpleMath">2^2.G</span>. We have to compute the <span class="SimpleMath">p</span>-modular tables for prime divisors <span class="SimpleMath">p</span> of <span class="SimpleMath">|G|</span>, that is, for <span class="SimpleMath">p ∈ { 2, 5, 7, 13 }</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrimeDivisors( Size( t ) );</span>
[ 2, 5, 7, 13 ]
</pre></div>

<p>Clearly <span class="SimpleMath">p = 2</span> is uninteresting from this point of view because the <span class="SimpleMath">2</span>-modular table of <span class="SimpleMath">2^2.G</span> can be identified with the <span class="SimpleMath">2</span>-modular table of <span class="SimpleMath">G</span>.</p>

<p>For each of the five ordinary tables (corresponding to the five possible table automorphisms of <span class="SimpleMath">G</span>) constructed above, we get one candidate of a <span class="SimpleMath">5</span>-modular table. However, these tables are <em>not</em> all equivalent. There are two equivalence classes, and one of the two possibilities is inconsistent in the sense that not all tensor products of irreducibles decompose into irreducibles.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= List( poss, l -&gt; BrauerTableOfTypeV4G( l[1], 2t mod 5,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ConstructionInfoCharacterTable( l[1] )[3] ) );</span>
[ BrauerTable( "2^2.Sz(8)", 5 ), BrauerTable( "2^2.Sz(8)", 5 ), 
  BrauerTable( "2^2.Sz(8)", 5 ), BrauerTable( "2^2.Sz(8)", 5 ), 
  BrauerTable( "2^2.Sz(8)", 5 ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesCharacterTables( cand ) );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( cand, CTblLib.Test.TensorDecomposition );</span>
[ false, true, false, true, true ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesCharacterTables( cand{ [ 2, 4, 5 ] } ) );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( cand[2],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "2^2.Sz(8)" ) mod 5 ) );</span>
true
</pre></div>

<p>This implies that only those table automorphisms of <span class="SimpleMath">G</span> can be induced by an outer group automorphism that move the classes of element order <span class="SimpleMath">13</span>.</p>

<p>The <span class="SimpleMath">7</span>-modular table of <span class="SimpleMath">2^2.G</span> is uniquely determined, independent of the choice of the table automorphism of <span class="SimpleMath">G</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= List( poss, l -&gt; BrauerTableOfTypeV4G( l[1], 2t mod 7,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ConstructionInfoCharacterTable( l[1] )[3] ) );</span>
[ BrauerTable( "2^2.Sz(8)", 7 ), BrauerTable( "2^2.Sz(8)", 7 ), 
  BrauerTable( "2^2.Sz(8)", 7 ), BrauerTable( "2^2.Sz(8)", 7 ), 
  BrauerTable( "2^2.Sz(8)", 7 ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesCharacterTables( cand ) );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( cand[1],      </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "2^2.Sz(8)" ) mod 7 ) );</span>
true
</pre></div>

<p>We get two candidates for the <span class="SimpleMath">13</span>-modular table of <span class="SimpleMath">2^2.G</span>, also if we consider only the three admissible table automorphisms.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elms:= elms{ [ 2, 4, 5 ] };</span>
[ (9,10,11), (6,7,8)(9,10,11), (6,7,8)(9,11,10) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= poss{ [ 2, 4, 5 ] };;                                     </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cand:= List( poss, l -&gt; BrauerTableOfTypeV4G( l[1], 2t mod 13,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ConstructionInfoCharacterTable( l[1] )[3] ) );</span>
[ BrauerTable( "2^2.Sz(8)", 13 ), BrauerTable( "2^2.Sz(8)", 13 ), 
  BrauerTable( "2^2.Sz(8)", 13 ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesCharacterTables( cand ) );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( cand, CTblLib.Test.TensorDecomposition );                      </span>
[ true, true, true ]
</pre></div>

<p>The action of the outer automorphism of order three of <span class="SimpleMath">G</span> can be read off from the <span class="SimpleMath">2</span>-modular table of <span class="SimpleMath">G</span>. Note that the ordinary and the <span class="SimpleMath">5</span>-modular character table of <span class="SimpleMath">G</span> possess two independent table automorphisms of order three, whereas the group of table automorphisms of the <span class="SimpleMath">2</span>-modular table has order three. (The reason is that the irrational values on the classes of the element orders <span class="SimpleMath">7</span> and <span class="SimpleMath">13</span> appear in the same irreducible <span class="SimpleMath">2</span>-modular Brauer characters.)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mod2:= CharacterTable( "Sz(8)" ) mod 2;</span>
BrauerTable( "Sz(8)", 2 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutomorphismsOfTable( mod2 );</span>
Group([ (3,4,5)(6,7,8) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OrdersClassRepresentatives( mod2 );</span>
[ 1, 5, 7, 7, 7, 13, 13, 13 ]
</pre></div>

<p>This means that the first candidate is ruled out; this determines the <span class="SimpleMath">13</span>-modular character table of <span class="SimpleMath">2^2.G</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesCharacterTables( cand{ [ 2, 3 ] } ) );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( cand[2],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       CharacterTable( "2^2.Sz(8)" ) mod 13 ) );</span>
true
</pre></div>

<p><a id="X83652A0282A64D14" name="X83652A0282A64D14"></a></p>

<h5>2.7-2 <span class="Heading"><strong class="pkg">Atlas</strong> Tables of the Type <span class="SimpleMath">2^2.G</span> (September 2005)</span></h5>

<p>Besides <span class="SimpleMath">2^2.Sz(8)</span> (cf. Section <a href="chap2.html#X87EEBDB987249117"><span class="RefLink">2.7-1</span></a>), <span class="SimpleMath">2^2.O_8^+(3)</span> (cf. Section <a href="chap2.html#X7F63DDF77870F967"><span class="RefLink">2.7-3</span></a>), and certain central extensions of <span class="SimpleMath">L_3(4)</span> (cf. Section <a href="chap2.html#X86A1607787DE6BB9"><span class="RefLink">2.7-4</span></a>), the following examples of central extensions of nearly simple <strong class="pkg">Atlas</strong> groups <span class="SimpleMath">G</span> by a Klein four group occur.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">listV4G:= [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ "2^2.L3(4)",         "2.L3(4)",     "L3(4)"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ "2^2.L3(4).2_1",     "2.L3(4).2_1", "L3(4).2_1"   ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ "(2^2x3).L3(4)",     "6.L3(4)",     "3.L3(4)"     ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ "(2^2x3).L3(4).2_1", "6.L3(4).2_1", "3.L3(4).2_1" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ "2^2.O8+(2)",        "2.O8+(2)",    "O8+(2)"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ "2^2.U6(2)",         "2.U6(2)",     "U6(2)"       ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ "(2^2x3).U6(2)",     "6.U6(2)",     "3.U6(2)"     ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ "2^2.2E6(2)",        "2.2E6(2)",    "2E6(2)"      ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     [ "(2^2x3).2E6(2)",    "6.2E6(2)",    "3.2E6(2)"    ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">];;</span>
</pre></div>

<p>(For the tables of <span class="SimpleMath">(2^2 × 3).G</span>, with <span class="SimpleMath">G</span> one of <span class="SimpleMath">L_3(4)</span>, <span class="SimpleMath">U_6(2)</span>, or <span class="SimpleMath">^2E_6(2)</span>, we could alternatively use the tables of <span class="SimpleMath">2^2.G</span> and <span class="SimpleMath">3.G</span>, and the construction described in Chapter <a href="chap3.html#X7A80D5ED7D6E57B7"><span class="RefLink">3</span></a>.)</p>

<p>The function for computing the candidates for the ordinary character tables is similar to the one from Section <a href="chap2.html#X7FEC3AB081487AF2"><span class="RefLink">2.6-2</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstructOrdinaryV4GTable:= function( tblG, tbl2G, name, lib )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     local ord3, nam, poss, reps, trans;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     # Compute the possible actions for the ordinary tables.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ord3:= Set( Filtered( AutomorphismsOfTable( tblG ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                           x -&gt; Order( x ) = 3 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 SmallestGeneratorPerm );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if 1 &lt; Length( ord3 ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  ", name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              ": the action of the automorphism is not unique" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     # Compute the possible ordinary tables for the given actions.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     nam:= Concatenation( "new", name );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss:= Concatenation( List( ord3, pi -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            PossibleCharacterTablesOfTypeV4G( tblG, tbl2G, pi, nam ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     # Test the possibilities for permutation equivalence.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     reps:= RepresentativesCharacterTables( poss );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if 1 &lt; Length( reps ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  ", name, ": ", Length( reps ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              " equivalence classes\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     elif Length( reps ) = 0 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#E  ", name, ": no solution\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       # Compare the computed table with the library table.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if not IsCharacterTable( lib ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#I  no library table for ", name, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         PrintToLib( name, poss[1].table );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         trans:= TransformingPermutationsCharacterTables( reps[1], lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if not IsRecord( trans ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed table and library table for ", name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     return poss;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end;;</span>
</pre></div>

<p>Concerning the Brauer tables, the same ambiguity problem may occur as in Section <a href="chap2.html#X7FEC3AB081487AF2"><span class="RefLink">2.6-2</span></a>: Some candidates for the ordinary table may be excluded due to information provided by some <span class="SimpleMath">p</span>-modular table, see Section <a href="chap2.html#X87EEBDB987249117"><span class="RefLink">2.7-1</span></a> for an easy example. Our strategy is analogous to the one used in Section <a href="chap2.html#X7FEC3AB081487AF2"><span class="RefLink">2.6-2</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstructModularV4GTables:= function( tblG, tbl2G, ordposs,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                         ordlibtblV4G )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     local name, modposs, primes, checkordinary, i, p, tmodp, 2tmodp, aut,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           poss, modlib, trans, reps;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if not IsCharacterTable( ordlibtblV4G ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#I  no ordinary library table ...\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       return [];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     name:= Identifier( ordlibtblV4G );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modposs:= [];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     primes:= ShallowCopy( PrimeDivisors( Size( tblG ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ordposs:= ShallowCopy( ordposs );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     checkordinary:= false;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     for i in [ 1 .. Length( ordposs ) ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modposs[i]:= [];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       for p in primes do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         tmodp := tblG  mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         2tmodp:= tbl2G mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if IsCharacterTable( tmodp ) and IsCharacterTable( 2tmodp ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           aut:= ConstructionInfoCharacterTable( ordposs[i] )[3];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           poss:= BrauerTableOfTypeV4G( ordposs[i], 2tmodp, aut );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           if CTblLib.Test.TensorDecomposition( poss, false ) = false then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Print( "#I  excluded cand. ", i, " (out of ",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    Length( ordposs ), ") for ", name, " by ", p,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    "-mod. table\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Unbind( ordposs[i] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Unbind( modposs[i] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             checkordinary:= true;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             break;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Add( modposs[i], poss );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#I  not all input tables for ", name, " mod ", p,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " available\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           primes:= Difference( primes, [ p ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if IsBound( modposs[i] ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         # Compare the computed Brauer tables with the library tables.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         for poss in modposs[i] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           p:= UnderlyingCharacteristic( poss );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           modlib:= ordlibtblV4G mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           if IsCharacterTable( modlib ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             trans:= TransformingPermutationsCharacterTables(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         poss, modlib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             if not IsRecord( trans ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               Print( "#E  computed table and library table for ",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                      name, " mod ", p, " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             Print( "#I  no library table for ",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    name, " mod ", p, "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             PrintToLib( name, poss );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if checkordinary then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       # Test whether the ordinary table is admissible.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       ordposs:= Compacted( ordposs );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modposs:= Compacted( modposs );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       reps:= RepresentativesCharacterTables( ordposs );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if 1 &lt; Length( reps ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#I  ", name, ": ", Length( reps ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                " equivalence classes (ord. table)\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       elif Length( reps ) = 0 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#E  ", name, ": no solution (ord. table)\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       else</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         # Compare the computed table with the library table.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         trans:= TransformingPermutationsCharacterTables( reps[1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     ordlibtblV4G );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if not IsRecord( trans ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed table and library table for ", name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     # Test the uniqueness of the Brauer tables.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     for poss in TransposedMat( modposs ) do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       reps:= RepresentativesCharacterTables( poss );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if Length( reps ) &lt;&gt; 1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#I  ", name, ": ", Length( reps ), " candidates for the ",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                UnderlyingCharacteristic( reps[1] ), "-modular table\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     return rec( ordinary:= ordposs, modular:= modposs );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end;;</span>
</pre></div>

<p>In our examples, the action of the outer automorphism of order three on the classes of <span class="SimpleMath">G</span> turns out to be uniquely determined by the table automorphisms of the character table of <span class="SimpleMath">G</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for input in listV4G do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tblG  := CharacterTable( input[3] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     tbl2G := CharacterTable( input[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     lib   := CharacterTable( input[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     poss  := ConstructOrdinaryV4GTable( tblG, tbl2G, input[1], lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ConstructModularV4GTables( tblG, tbl2G, poss, lib );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
#I  excluded cand. 1 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
#I  excluded cand. 2 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
#I  excluded cand. 7 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
#I  excluded cand. 10 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
#I  excluded cand. 15 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
#I  excluded cand. 16 (out of 16) for 2^2.L3(4).2_1 by 7-mod. table
#I  excluded cand. 1 (out of 16) for (2^2x3).L3(4).2_1 by 7-mod. table
#I  excluded cand. 2 (out of 16) for (2^2x3).L3(4).2_1 by 7-mod. table
#I  excluded cand. 7 (out of 16) for (2^2x3).L3(4).2_1 by 7-mod. table
#I  excluded cand. 10 (out of 16) for (2^2x3).L3(4).2_1 by 
7-mod. table
#I  excluded cand. 15 (out of 16) for (2^2x3).L3(4).2_1 by 
7-mod. table
#I  excluded cand. 16 (out of 16) for (2^2x3).L3(4).2_1 by 
7-mod. table
#I  not all input tables for 2^2.2E6(2) mod 2 available
#I  not all input tables for 2^2.2E6(2) mod 3 available
#I  not all input tables for 2^2.2E6(2) mod 5 available
#I  not all input tables for 2^2.2E6(2) mod 7 available
#I  not all input tables for (2^2x3).2E6(2) mod 2 available
#I  not all input tables for (2^2x3).2E6(2) mod 3 available
#I  not all input tables for (2^2x3).2E6(2) mod 5 available
#I  not all input tables for (2^2x3).2E6(2) mod 7 available
#I  not all input tables for (2^2x3).2E6(2) mod 11 available
#I  not all input tables for (2^2x3).2E6(2) mod 13 available
#I  not all input tables for (2^2x3).2E6(2) mod 17 available
#I  not all input tables for (2^2x3).2E6(2) mod 19 available
</pre></div>

<p><a id="X7F63DDF77870F967" name="X7F63DDF77870F967"></a></p>

<h5>2.7-3 <span class="Heading">The Character Table of <span class="SimpleMath">2^2.O_8^+(3)</span> (March 2009)</span></h5>

<p>When one tries to construct the character table of the central extensions of <span class="SimpleMath">G = O_8^+(3)</span> by a Klein four group, in the same way as in Section <a href="chap2.html#X83652A0282A64D14"><span class="RefLink">2.7-2</span></a>, one notices that the order three automorphism that relates the three central extensions of <span class="SimpleMath">G</span> by an involution is <em>not</em> uniquely determined.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">entry:= [ "2^2.O8+(3)", "2.O8+(3)", "O8+(3)" ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( entry[3] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut:= AutomorphismsOfTable( tblG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord3:= Set( Filtered( aut, x -&gt; Order( x ) = 3 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               SmallestGeneratorPerm );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( ord3 );</span>
4
</pre></div>

<p>However, the table candidates one gets from the four possible automorphisms turn out to be all equivalent, hence the character table of <span class="SimpleMath">2^2.O_8^+(3)</span> can be constructed as follows.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= [];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl2G:= CharacterTable( entry[2] );</span>
CharacterTable( "2.O8+(3)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for pi in ord3 do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  Append( poss,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          PossibleCharacterTablesOfTypeV4G( tblG, tbl2G, pi, entry[1] ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( poss );</span>
32
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= RepresentativesCharacterTables( poss );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( poss );</span>
1
</pre></div>

<p>The computed table coincides with the library table.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib:= CharacterTable( entry[1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">if TransformingPermutationsCharacterTables( poss[1], lib ) = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Print( "#E  differences for ", entry[1], "\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   fi;</span>
</pre></div>

<p><a id="X86A1607787DE6BB9" name="X86A1607787DE6BB9"></a></p>

<h5>2.7-4 <span class="Heading">The Character Table of the Schur Cover of <span class="SimpleMath">L_3(4)</span>
(September 2005)</span></h5>

<p>The Schur cover of <span class="SimpleMath">G = L_3(4)</span> has the structure <span class="SimpleMath">(4^2 × 3).L_3(4)</span>. Following <a href="chapBib.html#biBCCN85">[CCN+85, p. 23]</a>, we regard the multiplier of <span class="SimpleMath">G</span> as</p>

<p class="pcenter">M = ⟨ a, b, c, d ∣ [a,b] = [a,c] = [a,d] = [b,c] = [b,d] = [c,d] = a^4 = b^4 = c^4 = d^3 = abc ⟩ ,</p>

<p>and we will consider the automorphism <span class="SimpleMath">α</span> of <span class="SimpleMath">M.G</span> that acts as <span class="SimpleMath">(a,b,c)(d)</span> on <span class="SimpleMath">M</span>.</p>

<p>The subgroup lattice of the subgroup <span class="SimpleMath">⟨ a, b, c ⟩ = ⟨ a, b ⟩ ≅ 4^2</span> of <span class="SimpleMath">M</span> looks as follows. (The subgroup in the centre of the picture is the Klein four group <span class="SimpleMath">⟨ a^2, b^2, c^2 ⟩ = ⟨ a^2, b^2 ⟩</span>.)</p>

<p><center> <img src="ctblcons19.png" alt="Schur cover of L3(4)"/> </center></p>

<p>(The symmetry w.r.t. <span class="SimpleMath">α</span> would be reflected better in a three dimensional model, with <span class="SimpleMath">⟨ a, b ⟩</span>, <span class="SimpleMath">⟨ a^2, b^2 ⟩</span>, and the trivial subgroup on a vertical symmetry axis, and with the remaining subgroups on three circles such that <span class="SimpleMath">α</span> induces a rotation.)</p>

<p>The following is a 3D variant of the picture, which shows the symmetry of order three of the group <span class="SimpleMath">4 × 4</span>. <center> <img src="ctblcons20.png" alt="Schur cover of L3(4), emphasizing a symmetry of order three "/> </center></p>

<p>We have <span class="SimpleMath">(M / ⟨ a ⟩).G ≅ (M / ⟨ b ⟩).G ≅ (M / ⟨ c ⟩).G ≅ 12_2.G</span> and <span class="SimpleMath">(M / ⟨ a b^2 ⟩).G ≅ (M / ⟨ b c^2 ⟩).G ≅ (M / ⟨ c a^2 ⟩).G ≅ 12_1.G</span>. This is because the action of <span class="SimpleMath">G.2_2</span> fixes <span class="SimpleMath">a</span>, and swaps <span class="SimpleMath">b</span> and <span class="SimpleMath">c</span>; so <span class="SimpleMath">b</span> is inverted modulo <span class="SimpleMath">⟨ a ⟩</span> but fixed modulo <span class="SimpleMath">⟨ a b^2 ⟩</span>, and the normal subgroup of order four in <span class="SimpleMath">4_2.G.2_2</span> is central but that in <span class="SimpleMath">4_1.G.2_2</span> is not central.</p>

<p>The constructions of the character tables of <span class="SimpleMath">4^2.G</span> and <span class="SimpleMath">(4^2 × 3).G</span> are essentially the same. We start with the table of <span class="SimpleMath">4^2.G</span>. It can be regarded as a central extension <span class="SimpleMath">H = V.2^2.G</span> of <span class="SimpleMath">2^2.G</span> by a Klein four group <span class="SimpleMath">V</span>. The three subgroups of order two in <span class="SimpleMath">V</span> are cyclicly permuted by the automorphism of <span class="SimpleMath">M / ⟨ d ⟩</span> induced by <span class="SimpleMath">α</span>, so the three factors by these subgroups are isomorphic groups <span class="SimpleMath">F</span>, say, with the structure <span class="SimpleMath">(2 × 4).G</span>.</p>

<p>The group <span class="SimpleMath">F</span> itself is a central extension of <span class="SimpleMath">2.G</span> by a Klein four group, but in this case the three factor groups by the order two subgroups of the Klein four group are nonisomorphic groups, of the types <span class="SimpleMath">4_1.G</span>, <span class="SimpleMath">4_2.G</span>, and <span class="SimpleMath">2^2.G</span>, respectively. The <strong class="pkg">GAP</strong> function <code class="func">PossibleCharacterTablesOfTypeV4G</code> (<a href="../../../pkg/ctbllib-1.3.4/doc/chap5.html#X7E7043A5857B9240"><span class="RefLink">CTblLib: PossibleCharacterTablesOfTypeV4G</span></a>) can be used to construct the character table of <span class="SimpleMath">F</span> from the three factors. Note that in this case, no information about table automorphisms is required.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "2.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls2G:= List( [ "4_1.L3(4)", "4_2.L3(4)", "2^2.L3(4)"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  CharacterTable );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= PossibleCharacterTablesOfTypeV4G( tblG, tbls2G, "(2x4).L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( poss );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= RepresentativesCharacterTables( poss );</span>
[ CharacterTable( "(2x4).L3(4)" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib:= CharacterTable( "(2x4).L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( reps[1], lib ) );</span>
true
</pre></div>

<p>In the second step, we construct the table of <span class="SimpleMath">4^2.G</span> from that of <span class="SimpleMath">(2 × 4).G</span> and the table automorphism of <span class="SimpleMath">2^2.G</span> that is induced by <span class="SimpleMath">α</span>; it turns out that the group of table automorphisms of <span class="SimpleMath">2^2.G</span> contains a unique subgroup of order three.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= tbls2G[3];</span>
CharacterTable( "2^2.L3(4)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl2G:= lib;       </span>
CharacterTable( "(2x4).L3(4)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut:= AutomorphismsOfTable( tblG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord3:= Set( Filtered( aut, x -&gt; Order( x ) = 3 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               SmallestGeneratorPerm );</span>
[ (2,3,4)(6,7,8)(10,11,12)(13,15,17)(14,16,18)(20,21,22)(24,25,26)(28,
    29,30)(32,33,34) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= ord3[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= PossibleCharacterTablesOfTypeV4G( tblG, tbl2G, pi, "4^2.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( poss );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= RepresentativesCharacterTables( poss );        </span>
[ CharacterTable( "4^2.L3(4)" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib:= CharacterTable( "4^2.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( reps[1], lib ) );</span>
true
</pre></div>

<p>With the same approach, we compute the table of <span class="SimpleMath">(2 × 12).G = 2^2.6.G</span> from the tables of the three nonisomorphic factor groups <span class="SimpleMath">12_1.G</span>, <span class="SimpleMath">12_2.G</span>, and <span class="SimpleMath">(2^2 × 3).G</span>, and we compute the table of <span class="SimpleMath">(4^2 × 3).G = 2^2.(2^2 × 3).G</span> from the three tables of the factor groups <span class="SimpleMath">(2 × 12).G</span> and the action induced by <span class="SimpleMath">α</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "6.L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbls2G:= List( [ "12_1.L3(4)", "12_2.L3(4)", "(2^2x3).L3(4)"],            </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  CharacterTable );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= PossibleCharacterTablesOfTypeV4G( tblG, tbls2G, "(2x12).L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( poss );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= RepresentativesCharacterTables( poss );</span>
[ CharacterTable( "(2x12).L3(4)" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib:= CharacterTable( "(2x12).L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( reps[1], lib ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblG:= CharacterTable( "(2^2x3).L3(4)" ); </span>
CharacterTable( "(2^2x3).L3(4)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tbl2G:= CharacterTable( "(2x12).L3(4)" );</span>
CharacterTable( "(2x12).L3(4)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aut:= AutomorphismsOfTable( tblG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ord3:= Set( Filtered( aut, x -&gt; Order( x ) = 3 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               SmallestGeneratorPerm );</span>
[ (2,7,8)(3,4,10)(6,11,12)(14,19,20)(15,16,22)(18,23,24)(26,27,28)(29,
    35,41)(30,37,43)(31,39,45)(32,36,42)(33,38,44)(34,40,46)(48,53,
    54)(49,50,56)(52,57,58)(60,65,66)(61,62,68)(64,69,70)(72,77,
    78)(73,74,80)(76,81,82)(84,89,90)(85,86,92)(88,93,94) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi:= ord3[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= PossibleCharacterTablesOfTypeV4G( tblG, tbl2G, pi,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                            "(4^2x3).L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( poss );</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">reps:= RepresentativesCharacterTables( poss );</span>
[ CharacterTable( "(4^2x3).L3(4)" ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lib:= CharacterTable( "(4^2x3).L3(4)" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( reps[1], lib ) );</span>
true
</pre></div>

<p><a id="X8711DBB083655A25" name="X8711DBB083655A25"></a></p>

<h4>2.8 <span class="Heading">Examples of Extensions by <span class="SimpleMath">p</span>-singular Automorphisms</span></h4>

<p><a id="X81C08739850E4AAE" name="X81C08739850E4AAE"></a></p>

<h5>2.8-1 <span class="Heading">Some <span class="SimpleMath">p</span>-Modular Tables of Groups of the Type <span class="SimpleMath">M.G.A</span></span></h5>

<p>We show an alternative construction of <span class="SimpleMath">p</span>-modular tables of certain groups that have been met in Section <a href="chap2.html#X7ED45AB379093A70"><span class="RefLink">2.4-3</span></a>. Each entry in the <strong class="pkg">GAP</strong> list <code class="code">listMGA</code> contains the <code class="func">Identifier</code> (<a href="../../../doc/ref/chap70.html#X810E53597B5BB4F8"><span class="RefLink">Reference: Identifier for tables of marks</span></a>) values of character tables of groups of the types <span class="SimpleMath">M.G</span>, <span class="SimpleMath">G</span>, <span class="SimpleMath">G.A</span>, and <span class="SimpleMath">M.G.A</span>. For each entry with <span class="SimpleMath">|A| = p</span>, a prime integer, we fetch the <span class="SimpleMath">p</span>-modular table of <span class="SimpleMath">G</span> and the ordinary table of <span class="SimpleMath">G.A</span>, compute the action of <span class="SimpleMath">G.A</span> on the <span class="SimpleMath">p</span>-regular classes of <span class="SimpleMath">G</span>, and then compute the <span class="SimpleMath">p</span>-modular table of <span class="SimpleMath">G.A</span>. Analogously, we compute the <span class="SimpleMath">p</span>-modular table of <span class="SimpleMath">M.G.A</span> from the <span class="SimpleMath">p</span>-modular table of <span class="SimpleMath">M.G</span> and the ordinary table of <span class="SimpleMath">M.G.A</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for input in listMGA do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ordtblMG  := CharacterTable( input[1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ordtblG   := CharacterTable( input[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ordtblGA  := CharacterTable( input[3] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     ordtblMGA := CharacterTable( input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     p:= Size( ordtblGA ) / Size( ordtblG );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if IsPrimeInt( p ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modtblG:= ordtblG mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if modtblG &lt;&gt; fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         modtblGA := CharacterTableRegular( ordtblGA, p );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         SetIrr( modtblGA, IBrOfExtensionBySingularAutomorphism( modtblG,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                               ordtblGA ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         modlibtblGA:= ordtblGA mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if modlibtblGA = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  ", p, "-modular table of '", Identifier( ordtblGA ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  "' is missing\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         elif TransformingPermutationsCharacterTables( modtblGA,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  modlibtblGA ) = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed table and library table for ", input[3],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " mod ", p, " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modtblMG:= ordtblMG mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if modtblMG &lt;&gt; fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         modtblMGA := CharacterTableRegular( ordtblMGA, p );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         SetIrr( modtblMGA, IBrOfExtensionBySingularAutomorphism( modtblMG,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                ordtblMGA ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         modlibtblMGA:= ordtblMGA mod p;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if modlibtblMGA = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  ", p, "-modular table of '", Identifier( ordtblMGA ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  "' is missing\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         elif TransformingPermutationsCharacterTables( modtblMGA,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  modlibtblMGA ) = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed table and library table for ", input[4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " mod ", p, " differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
</pre></div>

<p><a id="X7FED618F83ACB7C2" name="X7FED618F83ACB7C2"></a></p>

<h5>2.8-2 <span class="Heading">Some <span class="SimpleMath">p</span>-Modular Tables of Groups of the Type <span class="SimpleMath">G.S_3</span></span></h5>

<p>We show an alternative construction of <span class="SimpleMath">2</span>- and <span class="SimpleMath">3</span>-modular tables of certain groups that have been met in Section <a href="chap2.html#X80F9BC057980A9E9"><span class="RefLink">2.5-2</span></a>. Each entry in the <strong class="pkg">GAP</strong> list <code class="code">listGS3</code> contains the <code class="func">Identifier</code> (<a href="../../../doc/ref/chap70.html#X810E53597B5BB4F8"><span class="RefLink">Reference: Identifier for tables of marks</span></a>) values of character tables of groups of the types <span class="SimpleMath">G</span>, <span class="SimpleMath">G.2</span>, <span class="SimpleMath">G.3</span>, and <span class="SimpleMath">G.S_3</span>. For each entry, we fetch the <span class="SimpleMath">2</span>-modular table of <span class="SimpleMath">G</span> and the ordinary table of <span class="SimpleMath">G.2</span>, compute the action of <span class="SimpleMath">G.2</span> on the <span class="SimpleMath">2</span>-regular classes of <span class="SimpleMath">G</span>, and then compute the <span class="SimpleMath">2</span>-modular table of <span class="SimpleMath">G.2</span>. Analogously, we compute the <span class="SimpleMath">3</span>-modular table of <span class="SimpleMath">G.3</span> from the <span class="SimpleMath">3</span>-modular table of <span class="SimpleMath">G</span> and the ordinary table of <span class="SimpleMath">G.3</span>, and we compute the <span class="SimpleMath">2</span>-modular table of <span class="SimpleMath">G.S_3</span> from the <span class="SimpleMath">2</span>-modular table of <span class="SimpleMath">G.3</span> and the ordinary table of <span class="SimpleMath">G.S_3</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for input in listGS3 do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modtblG:= CharacterTable( input[1] ) mod 2;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if modtblG &lt;&gt; fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       ordtblG2 := CharacterTable( input[2] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modtblG2 := CharacterTableRegular( ordtblG2, 2 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       SetIrr( modtblG2, IBrOfExtensionBySingularAutomorphism( modtblG,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                             ordtblG2 ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modlibtblG2:= ordtblG2 mod 2;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if modlibtblG2 = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#E  2-modular table of '", Identifier( ordtblG2 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                "' is missing\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       elif TransformingPermutationsCharacterTables( modtblG2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                modlibtblG2 ) = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#E  computed table and library table for ", input[2],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                " mod 2 differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modtblG:= CharacterTable( input[1] ) mod 3;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if modtblG &lt;&gt; fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       ordtblG3 := CharacterTable( input[3] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modtblG3 := CharacterTableRegular( ordtblG3, 3 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       SetIrr( modtblG3, IBrOfExtensionBySingularAutomorphism( modtblG,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                             ordtblG3 ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modlibtblG3:= ordtblG3 mod 3;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if modlibtblG3 = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#E  3-modular table of '", Identifier( ordtblG3 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                "' is missing\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       elif TransformingPermutationsCharacterTables( modtblG3,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                modlibtblG3 ) = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#E  computed table and library table for ", input[3],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                " mod 3 differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modtblG3:= CharacterTable( input[3] ) mod 2;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if modtblG3 &lt;&gt; fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       ordtblGS3 := CharacterTable( input[4] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modtblGS3 := CharacterTableRegular( ordtblGS3, 2 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       SetIrr( modtblGS3, IBrOfExtensionBySingularAutomorphism( modtblG3,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                              ordtblGS3 ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       modlibtblGS3:= ordtblGS3 mod 2;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       if modlibtblGS3 = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#E  2-modular table of '", Identifier( ordtblGS3 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                "' is missing\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       elif TransformingPermutationsCharacterTables( modtblGS3,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                modlibtblGS3 ) = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         Print( "#E  computed table and library table for ", input[4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                " mod 2 differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
</pre></div>

<p><a id="X7EEF6A7F8683177A" name="X7EEF6A7F8683177A"></a></p>

<h5>2.8-3 <span class="Heading"><span class="SimpleMath">2</span>-Modular Tables of Groups of the Type <span class="SimpleMath">G.2^2</span></span></h5>

<p>We show an alternative construction of <span class="SimpleMath">2</span>-modular tables of certain groups that have been met in Section <a href="chap2.html#X7FEC3AB081487AF2"><span class="RefLink">2.6-2</span></a>. Each entry in the <strong class="pkg">GAP</strong> list <code class="code">listGV4</code> contains the <code class="func">Identifier</code> (<a href="../../../doc/ref/chap70.html#X810E53597B5BB4F8"><span class="RefLink">Reference: Identifier for tables of marks</span></a>) values of character tables of groups of the types <span class="SimpleMath">G</span>, <span class="SimpleMath">G.2_1</span>, <span class="SimpleMath">G.2_2</span>, <span class="SimpleMath">G.2_3</span>, and <span class="SimpleMath">G.2^2</span>. For each entry, we fetch the <span class="SimpleMath">2</span>-modular table of <span class="SimpleMath">G</span> and the ordinary tables of the groups <span class="SimpleMath">G.2_i</span>, and compute the <span class="SimpleMath">2</span>-modular tables of <span class="SimpleMath">G.2_i</span>; Then we compute from this modular table and the ordinary table of <span class="SimpleMath">G.2^2</span> the <span class="SimpleMath">2</span>-modular table of <span class="SimpleMath">G.2^2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for input in listGV4 do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modtblG:= CharacterTable( input[1] ) mod 2;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if modtblG &lt;&gt; fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       ordtblsG2:= List( input{ [ 2 .. 4 ] }, CharacterTable );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       ordtblGV4:= CharacterTable( input[5] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       for tblG2 in ordtblsG2 do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         modtblG2:= CharacterTableRegular( tblG2, 2 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         SetIrr( modtblG2, IBrOfExtensionBySingularAutomorphism( modtblG,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                               tblG2 ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         modlibtblG2:= tblG2 mod 2;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if modlibtblG2 = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  2-modular table of '", Identifier( tblG2 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  "' is missing\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         elif TransformingPermutationsCharacterTables( modtblG2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  modlibtblG2 ) = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed table and library table for ",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  Identifier( tblG2 ), " mod 2 differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         modtblGV4:= CharacterTableRegular( ordtblGV4, 2 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         SetIrr( modtblGV4, IBrOfExtensionBySingularAutomorphism( modtblG2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                               ordtblGV4 ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         modlibtblGV4:= ordtblGV4 mod 2;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         if modlibtblGV4 = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  2-modular table of '", Identifier( ordtblGV4 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  "' is missing\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         elif TransformingPermutationsCharacterTables( modtblGV4,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                ordtblGV4 mod 2 ) = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">           Print( "#E  computed table and library table for ", input[5],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  " mod 2 differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">         fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       od;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
</pre></div>

<p><a id="X875F8DD77C0997FA" name="X875F8DD77C0997FA"></a></p>

<h5>2.8-4 <span class="Heading">The <span class="SimpleMath">3</span>-Modular Table of <span class="SimpleMath">U_3(8).3^2</span></span></h5>

<p>The only example of an <strong class="pkg">Atlas</strong> group of the structure <span class="SimpleMath">G.3^3</span> is <span class="SimpleMath">U_3(8).3^2</span>. Its <span class="SimpleMath">3</span>-modular character table can be constructed from the known <span class="SimpleMath">3</span>-modular character table of any of its index <span class="SimpleMath">3</span> subgroups, plus the action of <span class="SimpleMath">U_3(8).3^2</span> on the classes of this subgroup.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ordtblG3:= CharacterTable( "U3(8).3^2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">modlibtblG3:= ordtblG3 mod 3;</span>
BrauerTable( "U3(8).3^2", 3 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for nam in [ "U3(8).3_1", "U3(8).3_2", "U3(8).3_3" ] do</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modtblG:= CharacterTable( nam ) mod 3;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if modtblG = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Error( "no 3-modular table of ", nam );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     modtblG3:= CharacterTableRegular( ordtblG3, 3 );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     SetIrr( modtblG3, IBrOfExtensionBySingularAutomorphism( modtblG,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                           ordtblG3 ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     if TransformingPermutationsCharacterTables( modtblG3,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            modlibtblG3 ) = fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       Print( "#E  computed table and library table for ",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              Identifier( ordtblG3 ), " mod 3 differ\n" );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   od;</span>
</pre></div>

<p>As expected, we get the same <span class="SimpleMath">3</span>-modular table for any choice of the index <span class="SimpleMath">3</span> subgroup.</p>

<p>Note that all <span class="SimpleMath">3</span>-modular Brauer characters of <span class="SimpleMath">U_3(8).3^2</span> lift to characteristic zero.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rest:= RestrictedClassFunctions( Irr( ordtblG3 ), modlibtblG3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubset( rest, Irr( modlibtblG3 ) );</span>
true
</pre></div>

<p><a id="X7A4D6044865E516B" name="X7A4D6044865E516B"></a></p>

<h4>2.9 <span class="Heading">Examples of Subdirect Products of Index Two</span></h4>

<p>Typical examples of this construction are those maximal subgroups of alternating groups <span class="SimpleMath">A_n</span> that extend in the corresponding symmetric groups <span class="SimpleMath">S_n</span> to direct products of the structures <span class="SimpleMath">S_m × S_n-m</span>, for <span class="SimpleMath">2 &lt; m &lt; n/2</span>. Also certain subgroups of these maximal subgroups that have this structure can be interesting, see Section <a href="chap2.html#X7925DBFA7C5986B5"><span class="RefLink">2.4-2</span></a>.</p>

<p><a id="X850FF694801700CF" name="X850FF694801700CF"></a></p>

<h5>2.9-1 <span class="Heading">Certain Dihedral Groups as Subdirect Products of Index Two</span></h5>

<p>Also dihedral groups of order <span class="SimpleMath">2 n</span> with <span class="SimpleMath">n</span> divisible by at least two different primes have the required structure: Let <span class="SimpleMath">n = n_1 n_2</span> with coprime <span class="SimpleMath">n_1</span>, <span class="SimpleMath">n_2</span>, and let the normal subgroups <span class="SimpleMath">H_1</span>, <span class="SimpleMath">H_2</span> be cyclic subgroups of order <span class="SimpleMath">n_1</span> and <span class="SimpleMath">n_2</span>, respectively, inside the cyclic subgroup of index two. Then the factors <span class="SimpleMath">G/N_1</span>, <span class="SimpleMath">G/N_2</span> are themselves dihedral groups.</p>

<p>So an example (with <span class="SimpleMath">n_1 = 3</span> and <span class="SimpleMath">n_2 = 5</span>) is the construction of the dihedral group <span class="SimpleMath">D_30</span> as a subdirect product of index two in the direct product <span class="SimpleMath">D_6 × D_10</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblh1:= CharacterTable( "C3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblg1:= CharacterTable( "S3" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblh1, PossibleClassFusions( tblh1, tblg1 )[1], tblg1 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblh2:= CharacterTable( "C5" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblg2:= CharacterTable( "D10" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( tblh2, PossibleClassFusions( tblh2, tblg2 )[1], tblg2 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">subdir:= CharacterTableOfIndexTwoSubdirectProduct( tblh1, tblg1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                tblh2, tblg2, "D30" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( subdir.table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( "Dihedral", 30 ) ) );</span>
true
</pre></div>

<p><a id="X80C5D6FA83D7E2CF" name="X80C5D6FA83D7E2CF"></a></p>

<h5>2.9-2 <span class="Heading">The Character Table of <span class="SimpleMath">(D_10 × HN).2 &lt; M</span> (June 2008)</span></h5>

<p>The sporadic simple Monster group contains maximal subgroups with the structure <span class="SimpleMath">(D_10 × HN).2</span> (see <a href="chapBib.html#biBCCN85">[CCN+85, p. 234]</a>), the factor group modulo <span class="SimpleMath">D_10</span> is the automorphism group <span class="SimpleMath">HN.2</span> of <span class="SimpleMath">HN</span>, and the factor group modulo <span class="SimpleMath">HN</span> is the Frobenius group <span class="SimpleMath">5:4</span> of order <span class="SimpleMath">20</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblh1:= CharacterTable( "D10" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblg1:= CharacterTable( "5:4" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblh2:= CharacterTable( "HN" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tblg2:= CharacterTable( "HN.2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">subdir:= CharacterTableOfIndexTwoSubdirectProduct( tblh1, tblg1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                tblh2, tblg2, "(D10xHN).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( subdir.table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( "(D10xHN).2" ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m:= CharacterTable( "M" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fus:= PossibleClassFusions( subdir.table, m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( fus );</span>
16
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( RepresentativesFusions( subdir.table, fus, m ) );</span>
1
</pre></div>

<p>An alternative construction is the one described in Section <a href="chap2.html#X82E75B6880EC9E6C"><span class="RefLink">2.3-1</span></a>, as <span class="SimpleMath">(D_10 × HN).2 = M.G.A</span> with <span class="SimpleMath">G = 2 × HN</span>, <span class="SimpleMath">M.G = D_10 × HN</span>, and <span class="SimpleMath">G.A</span> the subdirect product of <span class="SimpleMath">HN.2</span> and a cyclic group of order four (which can be constructed as the isoclinic variant of <span class="SimpleMath">2 × HN.2</span>, see Section <a href="chap2.html#X80C37276851D5E39"><span class="RefLink">2.2-4</span></a>).</p>

<p>Here is this construction:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2:= CharacterTable( "C2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hn:= CharacterTable( "HN" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= c2 * hn;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d10:= CharacterTable( "D10" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mg:= d10 * hn;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nsg:= ClassPositionsOfNormalSubgroups( mg );</span>
[ [ 1 ], [ 1, 55 .. 109 ], [ 1, 55 .. 163 ], [ 1 .. 54 ], 
  [ 1 .. 162 ], [ 1 .. 216 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SizesConjugacyClasses( mg ){ nsg[2] };</span>
[ 1, 2, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= mg / nsg[2];</span>
CharacterTable( "D10xHN/[ 1, 55, 109 ]" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">help:= c2 * CharacterTable( "HN.2" );</span>
CharacterTable( "C2xHN.2" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ga:= CharacterTableIsoclinic( help ); </span>
CharacterTable( "Isoclinic(C2xHN.2)" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gfusga:= PossibleClassFusions( g, ga ); </span>
[ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 15, 16, 17, 
      18, 19, 20, 21, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 
      32, 32, 33, 33, 34, 35, 36, 37, 37, 38, 39, 40, 40, 41, 42, 42, 
      43, 43, 44, 44, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 89, 
      90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 101, 102, 
      103, 103, 104, 105, 106, 107, 108, 109, 110, 110, 111, 111, 
      112, 113, 114, 115, 115, 116, 117, 118, 118, 119, 120, 120, 
      121, 121, 122, 122 ], 
  [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 15, 16, 17, 
      18, 19, 20, 21, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 
      32, 32, 33, 33, 35, 34, 36, 37, 37, 38, 39, 40, 40, 41, 42, 42, 
      43, 43, 44, 44, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 89, 
      90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 101, 102, 
      103, 103, 104, 105, 106, 107, 108, 109, 110, 110, 111, 111, 
      113, 112, 114, 115, 115, 116, 117, 118, 118, 119, 120, 120, 
      121, 121, 122, 122 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StoreFusion( g, gfusga[1], ga );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">acts:= PossibleActionsForTypeMGA( mg, g, ga );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( acts );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">poss:= PossibleCharacterTablesOfTypeMGA( mg, g, ga, acts[1],       </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              "(D10xHN).2" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( poss );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRecord( TransformingPermutationsCharacterTables( poss[1].table,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 CharacterTable( "(D10xHN).2" ) ) );</span>
true
</pre></div>

<p><a id="X85EECFD47EC252A2" name="X85EECFD47EC252A2"></a></p>

<h5>2.9-3 <span class="Heading">A Counterexample (August 2015)</span></h5>

<p>A group <span class="SimpleMath">G</span> is called <em>real</em> if each of its elements is conjugate in <span class="SimpleMath">G</span> to its inverse. Equivalently, a group is real if and only if all its character values are real. One might ask whether the Sylow <span class="SimpleMath">2</span>-subgroup of a real group is itself real. Counterexamples can be found by a search through <strong class="pkg">GAP</strong>'s library of small groups. Using the facts we have collected about index two subdirect products in Section <a href="chap2.html#X788591D78451C024"><span class="RefLink">2.3-6</span></a>, we can demonstrate such a counterexample without using <strong class="pkg">GAP</strong>.</p>

<p>Let <span class="SimpleMath">H_1 = A_4</span>, <span class="SimpleMath">G_1 = S_4</span>, <span class="SimpleMath">H_2 = C_4</span>, and <span class="SimpleMath">G_2</span> a nonabelian group of order <span class="SimpleMath">8</span>, and consider the unique index two subgroup <span class="SimpleMath">G</span> of <span class="SimpleMath">G_1 × G_2</span> that is different from <span class="SimpleMath">H_1 × G_2</span> and <span class="SimpleMath">G_1 × H_2</span>.</p>

<p>Each irreducible character of <span class="SimpleMath">G</span> either extends to <span class="SimpleMath">G_1 × G_2</span> or it is induced from an irreducible character of <span class="SimpleMath">H_1 × H_2</span>. In the former case, the character is integer valued. Irrational values in the latter case arise as follows.</p>

<p>Let <span class="SimpleMath">χ</span> be an irreducible character of <span class="SimpleMath">H_1 × H_2</span>; then it is the product of irreducible characters <span class="SimpleMath">χ_1</span> and <span class="SimpleMath">χ_2</span> of <span class="SimpleMath">H_1</span> and <span class="SimpleMath">H_2</span>, respectively. If <span class="SimpleMath">χ</span> has irrational values then <span class="SimpleMath">χ_1</span> takes primitive third roots of unity <span class="SimpleMath">ω, ω^2</span> on elements of order three in <span class="SimpleMath">H_1</span>, or <span class="SimpleMath">χ_2</span> takes primitive fourth roots of unity <span class="SimpleMath">± i</span> on elements of order four in <span class="SimpleMath">H_2</span>, or both. In the first two cases, inducing <span class="SimpleMath">χ</span> to <span class="SimpleMath">G</span> yields an integer valued character, because each pair of Galois conjugate classes fuses in <span class="SimpleMath">G</span> on which <span class="SimpleMath">χ</span> takes irrational values. In the last case, <span class="SimpleMath">χ</span> takes primitive <span class="SimpleMath">12</span>-th roots of unity <span class="SimpleMath">± i ω</span> and <span class="SimpleMath">± i ω^2</span> on elements of order <span class="SimpleMath">12</span>; since <span class="SimpleMath">G</span> fuses the classes with the character values <span class="SimpleMath">i ω</span> and <span class="SimpleMath">-i ω^2</span>, we get the character value <span class="SimpleMath">i ω -i ω^2 = -sqrt{3}</span> in the induced character <span class="SimpleMath">χ^G</span>. This means that this character is real valued. Hence <span class="SimpleMath">G</span> is real.</p>

<p>Now we consider a Sylow <span class="SimpleMath">2</span>-subgroup of <span class="SimpleMath">G</span>. It has also the structure of a subdirect product, as follows. Let <span class="SimpleMath">H_1 = V_4</span>, <span class="SimpleMath">G_1 = D_8</span>, and <span class="SimpleMath">H_2</span> and <span class="SimpleMath">G_2</span> as above, and consider the unique index two subgroup <span class="SimpleMath">G</span> of <span class="SimpleMath">G_1 × G_2</span> that is different from <span class="SimpleMath">H_1 × G_2</span> and <span class="SimpleMath">G_1 × H_2</span>.</p>

<p>As above, irrational values in an irreducible character of <span class="SimpleMath">G</span> arise only if this character is induced from a character <span class="SimpleMath">χ</span>, say, that is the product of irreducible characters <span class="SimpleMath">χ_1</span> and <span class="SimpleMath">χ_2</span> of <span class="SimpleMath">H_1</span> and <span class="SimpleMath">H_2</span>, respectively. In this case, <span class="SimpleMath">χ_2</span> takes primitive fourth roots of unity <span class="SimpleMath">± i</span> on elements of order four in <span class="SimpleMath">H_2</span>. Moreover, <span class="SimpleMath">χ_1</span> takes different values <span class="SimpleMath">± 1</span> on the two classes of <span class="SimpleMath">H_1</span> that are fused in <span class="SimpleMath">G</span> if the induced character has irrational values, and these values are <span class="SimpleMath">± 2i</span>. Hence the group <span class="SimpleMath">G</span> is <em>not</em> real.</p>

<p>(In fact the above two groups of order <span class="SimpleMath">96</span> are the smallest real groups with non-real Sylow <span class="SimpleMath">2</span>-subgroup, and there are no other such groups of this order.)</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap3.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
