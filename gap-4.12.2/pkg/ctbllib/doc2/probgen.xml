
<!-- remarks/questions:
     - PositionsProperty is meanwhile available in GAP, can be omitted
     - is the file tst/probgen.g up to date?
-->

<!-- %W  probgen.xml     GAP 4 package CTblLib              Thomas Breuer -->
<!-- %Y  Copyright 2006, Lehrstuhl D fÃ¼r Mathematik, RWTH Aachen, Germany -->

<Chapter Label="chap:probgen">
<Heading>&GAP; Computations Concerning Probabilistic Generation of Finite
Simple Groups</Heading>

Date: March 28th, 2012

<P/>

This is a collection of examples showing how
the &GAP; system&nbsp;<Cite Key="GAP"/>
can be used to compute information about the probabilistic generation of
finite almost simple groups.
It includes all examples that were needed for the computational results
in&nbsp;<Cite Key="BGK"/>.

<P/>

The purpose of this writeup is twofold.
On the one hand, the computations are documented this way.
On the other hand, the &GAP; code shown for the examples can be used as
test input for automatic checking of the data and the functions used.

<P/>

A first version of this document, which was based on &GAP;&nbsp;4.4.10,
had been accessible in the web since April&nbsp;2006
and is available in the arXiv (no. 0710.3267) since October&nbsp;2007.
<!-- cite as http://arxiv.org/abs/0710.3267v1 -->
The differences between that document and the current version are as follows.

<List>
<Item>
  The format of the &GAP; output was adjusted to the changed behaviour
  of &GAP; until version&nbsp;4.10.
  This affects mainly the way how &GAP; records are printed.
</Item>
<Item>
  Several computations are now easier because more character tables of
  almost simple groups and maximal subgroups of such groups are available
  in the &GAP; Character Table Library.
  (The more involved computations from the original version have been kept
  in the file.)
</Item>
<Item>
  The computation of all conjugacy classes of a subgroup of
  <M>&POmega;^+(12,3)</M>
  has been replaced by the computation of the conjugacy classes of elements
  of prime order in this subgroup.
</Item>
<Item>
  The irreducible element chosen in the simple group <M>&POmega;^-(10,3)</M> has
  order <M>61</M> not <M>122</M>.
</Item>
</List>

<!-- can I insert a table of contents here? -->

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:probgen_overview">
<Heading>Overview</Heading>

The main purpose of this note is to document the &GAP; computations
that were carried out in order to obtain the computational results
in&nbsp;<Cite Key="BGK"/>.
Table&nbsp;I lists the simple groups among these examples.
The first column gives the group names,
the second and third columns contain a plus sign <M>+</M> or a minus sign
<M>-</M>, depending on whether the quantities
<M>&total;(G,s)</M> and <M>&prop;(G,s)</M>, respectively,
are less than <M>1/3</M>.
The fourth column lists the orders of elements <M>s</M> which either prove
the <M>+</M> signs or cover most of the cases for proving these signs.
The fifth column lists the sections in this note where the example is
treated.
The rows of the table are ordered alphabetically w.r.t.&nbsp;the group names.

<P/>

In order to keep this note self-contained,
we first describe the theory needed,
in Section&nbsp;<Ref Sect="sect:probgen-background"/>.
The translation of the relevant formulae into &GAP; functions
can be found in Section&nbsp;<Ref Sect="sect:probgen-functions"/>.
Then Section&nbsp;<Ref Sect="sect:chartheor"/> describes the computations
that only require (ordinary) character tables in the
&GAP; Character Table Library&nbsp;<Cite Key="CTblLib"/>.
Computations using also the groups are shown in
Section&nbsp;<Ref Sect="sect:hard"/>.
In each of the last two sections, the examples are ordered alphabetically
w.r.t.&nbsp;the names of the simple groups.

<P/>

<Table Align="|l|c|c|r|r|">
<Caption>Table I: Computations needed in&nbsp;<Cite Key="BGK"/></Caption>
<HorLine/>
<Row>
   <Item><M>G</M></Item>
   <Item><M>&total; &lt; \frac{1}{3}</M></Item>
   <Item><M>&prop; &lt; \frac{1}{3}</M></Item>
   <Item><M>|s|</M></Item>
   <Item>see</Item>
</Row>
<HorLine/>
<HorLine/>
<Row>
   <Item><M>A_5</M></Item>
   <Item><M>-</M></Item>
   <Item><M>-</M></Item>
   <Item><M>5</M></Item>
   <Item><Ref Subsect="A5"/></Item>
</Row>
<Row>
   <Item><M>A_6</M></Item>
   <Item><M>-</M></Item>
   <Item><M>-</M></Item>
   <Item><M>4</M></Item>
   <Item><Ref Subsect="A6"/></Item>
</Row>
<Row>
   <Item><M>A_7</M></Item>
   <Item><M>-</M></Item>
   <Item><M>-</M></Item>
   <Item><M>7</M></Item>
   <Item><Ref Subsect="A7"/></Item>
</Row>
<Row>
   <Item><M>A_8</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>15</M></Item>
   <Item><Ref Subsect="easyloop"/>, <Ref Subsect="SL"/></Item>
</Row>
<Row>
   <Item><M>A_9</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>9</M></Item>
   <Item><Ref Subsect="easyloop"/>, <Ref Subsect="Aodd"/></Item>
</Row>
<Row>
   <Item><M>A_{11}</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>11</M></Item>
   <Item><Ref Subsect="easyloop"/>, <Ref Subsect="Aodd"/></Item>
</Row>
<Row>
   <Item><M>A_{13}</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>13</M></Item>
   <Item><Ref Subsect="easyloop"/>, <Ref Subsect="Aodd"/></Item>
</Row>
<Row>
   <Item><M>A_{15}</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>15</M></Item>
   <Item><Ref Subsect="Aodd"/></Item>
</Row>
<Row>
   <Item><M>A_{17}</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>17</M></Item>
   <Item><Ref Subsect="Aodd"/></Item>
</Row>
<Row>
   <Item><M>A_{19}</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>19</M></Item>
   <Item><Ref Subsect="Aodd"/></Item>
</Row>
<Row>
   <Item><M>A_{21}</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>21</M></Item>
   <Item><Ref Subsect="Aodd"/></Item>
</Row>
<Row>
   <Item><M>A_{23}</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>23</M></Item>
   <Item><Ref Subsect="Aodd"/></Item>
</Row>
<Row>
   <Item><M>L_3(2)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>7</M></Item>
   <Item><Ref Subsect="easyloop"/>, <Ref Subsect="easyloopaut"/>,</Item>
</Row>
<Row>
   <Item>&nbsp;</Item>
   <Item>&nbsp;</Item>
   <Item>&nbsp;</Item>
   <Item>&nbsp;</Item>
   <Item><Ref Subsect="SL"/>, <Ref Subsect="L32"/></Item>
</Row>
<Row>
   <Item><M>L_3(3)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>13</M></Item>
   <Item><Ref Subsect="easyloop"/>, <Ref Subsect="easyloopaut"/>,</Item>
</Row>
<Row>
   <Item>&nbsp;</Item>
   <Item>&nbsp;</Item>
   <Item>&nbsp;</Item>
   <Item>&nbsp;</Item>
   <Item><Ref Subsect="SL"/></Item>
</Row>
<Row>
   <Item><M>L_3(4)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>7</M></Item>
   <Item><Ref Subsect="easyloop"/>, <Ref Subsect="easyloopaut"/></Item>
</Row>
<Row>
   <Item><M>L_4(3)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>20</M></Item>
   <Item><Ref Subsect="easyloop"/>, <Ref Subsect="SL"/></Item>
</Row>
<Row>
   <Item><M>L_4(4)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>85</M></Item>
   <Item><Ref Subsect="SL"/></Item>
</Row>
<Row>
   <Item><M>L_6(2)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>63</M></Item>
   <Item><Ref Subsect="SL"/></Item>
</Row>
<Row>
   <Item><M>L_6(3)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>182</M></Item>
   <Item><Ref Subsect="SL"/></Item>
</Row>
<Row>
   <Item><M>L_6(4)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>455</M></Item>
   <Item><Ref Subsect="SL"/></Item>
</Row>
<Row>
   <Item><M>L_6(5)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>1953</M></Item>
   <Item><Ref Subsect="SL"/></Item>
</Row>
<Row>
   <Item><M>L_8(2)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>255</M></Item>
   <Item><Ref Subsect="SL"/></Item>
</Row>
<Row>
   <Item><M>L_{10}(2)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>1023</M></Item>
   <Item><Ref Subsect="SL"/></Item>
</Row>
<HorLine/>
<Row>
   <Item><M>M_{11}</M></Item>
   <Item><M>-</M></Item>
   <Item><M>-</M></Item>
   <Item><M>11</M></Item>
   <Item><Ref Subsect="spreadM11"/></Item>
</Row>
<Row>
   <Item><M>M_{12}</M></Item>
   <Item><M>-</M></Item>
   <Item><M>+</M></Item>
   <Item><M>10</M></Item>
   <Item><Ref Subsect="probgen:sporaut"/>, <Ref Subsect="spreadM12"/></Item>
</Row>
<HorLine/>
<Row>
   <Item><M>O^+_8(2)</M></Item>
   <Item><M>-</M></Item>
   <Item><M>-</M></Item>
   <Item><M>15</M></Item>
   <Item><Ref Subsect="O8p2"/></Item>
</Row>
<Row>
   <Item><M>O^+_8(3)</M></Item>
   <Item><M>-</M></Item>
   <Item><M>-</M></Item>
   <Item><M>20</M></Item>
   <Item><Ref Subsect="O8p3"/></Item>
</Row>
<Row>
   <Item><M>O^+_8(4)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>65</M></Item>
   <Item><Ref Subsect="O8p4"/></Item>
</Row>
<Row>
   <Item><M>O^+_{10}(2)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>45</M></Item>
   <Item><Ref Subsect="O10p2"/></Item>
</Row>
<Row>
   <Item><M>O^+_{12}(2)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>85</M></Item>
   <Item><Ref Subsect="O12p2"/></Item>
</Row>
<Row>
   <Item><M>O^+_{12}(3)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>205</M></Item>
   <Item><Ref Subsect="O12p3"/></Item>
</Row>
<Row>
   <Item><M>O^-_8(2)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>17</M></Item>
   <Item><Ref Subsect="easyloop"/></Item>
</Row>
<Row>
   <Item><M>O^-_8(3)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>41</M></Item>
   <Item><Ref Subsect="O8m3"/></Item>
</Row>
<Row>
   <Item><M>O^-_{10}(2)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>33</M></Item>
   <Item><Ref Subsect="O10m2"/></Item>
</Row>
<Row>
   <Item><M>O^-_{10}(3)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>122</M></Item>
   <Item><Ref Subsect="O10m3"/></Item>
</Row>
<Row>
   <Item><M>O^-_{12}(2)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>65</M></Item>
   <Item><Ref Subsect="O12m2"/></Item>
</Row>
<Row>
   <Item><M>O^-_{14}(2)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>129</M></Item>
   <Item><Ref Subsect="O14m2"/></Item>
</Row>
<Row>
   <Item><M>O_7(3)</M></Item>
   <Item><M>-</M></Item>
   <Item><M>-</M></Item>
   <Item><M>14</M></Item>
   <Item><Ref Subsect="O73"/></Item>
</Row>
<HorLine/>
<Row>
   <Item><M>S_4(4)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>17</M></Item>
   <Item><Ref Subsect="easyloop"/>, <Ref Subsect="easyloopaut"/></Item>
</Row>
<Row>
   <Item><M>S_6(2)</M></Item>
   <Item><M>-</M></Item>
   <Item><M>-</M></Item>
   <Item><M>9</M></Item>
   <Item><Ref Subsect="S62"/></Item>
</Row>
<Row>
   <Item><M>S_6(3)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>14</M></Item>
   <Item><Ref Subsect="easyloop"/>, <Ref Subsect="easyloopaut"/></Item>
</Row>
<Row>
   <Item><M>S_6(4)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>65</M></Item>
   <Item><Ref Subsect="S64"/></Item>
</Row>
<Row>
   <Item><M>S_8(2)</M></Item>
   <Item><M>-</M></Item>
   <Item><M>-</M></Item>
   <Item><M>17</M></Item>
   <Item><Ref Subsect="S82"/></Item>
</Row>
<Row>
   <Item><M>S_8(3)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>41</M></Item>
   <Item><Ref Subsect="S83"/></Item>
</Row>
<HorLine/>
<Row>
   <Item><M>U_3(3)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>6</M></Item>
   <Item><Ref Subsect="easyloop"/>, <Ref Subsect="easyloopaut"/></Item>
</Row>
<Row>
   <Item><M>U_3(5)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>10</M></Item>
   <Item><Ref Subsect="easyloop"/>, <Ref Subsect="easyloopaut"/></Item>
</Row>
<Row>
   <Item><M>U_4(2)</M></Item>
   <Item><M>-</M></Item>
   <Item><M>-</M></Item>
   <Item><M>9</M></Item>
   <Item><Ref Subsect="U42"/></Item>
</Row>
<Row>
   <Item><M>U_4(3)</M></Item>
   <Item><M>-</M></Item>
   <Item><M>+</M></Item>
   <Item><M>7</M></Item>
   <Item><Ref Subsect="U43"/></Item>
</Row>
<Row>
   <Item><M>U_4(4)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>65</M></Item>
   <Item><Ref Subsect="U44"/></Item>
</Row>
<Row>
   <Item><M>U_5(2)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>11</M></Item>
   <Item><Ref Subsect="easyloop"/></Item>
</Row>
<Row>
   <Item><M>U_6(2)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>11</M></Item>
   <Item><Ref Subsect="U62"/></Item>
</Row>
<Row>
   <Item><M>U_6(3)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>122</M></Item>
   <Item><Ref Subsect="U63"/></Item>
</Row>
<Row>
   <Item><M>U_8(2)</M></Item>
   <Item><M>+</M></Item>
   <Item>&nbsp;</Item>
   <Item><M>129</M></Item>
   <Item><Ref Subsect="U82"/></Item>
</Row>
<HorLine/>
</Table>

<P/>

Contrary to&nbsp;<Cite Key="BGK"/>,
&ATLAS; notation is used throughout this note,
because the identifiers used for character tables in the
&GAP; Character Table Library follow mainly the
&ATLAS;&nbsp;<Cite Key="CCN85"/>.
For example, we write
<M>L_d(q)</M> for <M>&PSL;(d,q)</M>,
<M>S_d(q)</M> for <M>&PSp;(d,q)</M>,
<M>U_d(q)</M> for <M>&PSU;(d,q)</M>, and
<M>O^+_{2d}(q)</M>, <M>O^-_{2d}(q)</M>, <M>O_{2d+1}(q)</M> for
<M>&POmega;^+(2d,q)</M>, <M>&POmega;^-(2d,q)</M>, <M>&POmega;(2d+1,q)</M>,
respectively.

<P/>

Furthermore, in the case of classical groups,
the character tables of the (almost) <E>simple</E> groups
are considered
not the tables of the matrix groups (which are in fact often not available
in the &GAP; Character Table Library).
Consequently, also element orders and the description of maximal subgroups
refer to the (almost) simple groups not to the matrix groups.

<P/>

This note contains also several examples that are not needed for the proofs
in&nbsp;<Cite Key="BGK"/>.
Besides several small simple groups <M>G</M> whose character table
is contained in the &GAP; Character Table Library
and for which enough information is available for computing <M>&total;(G)</M>,
in Section&nbsp;<Ref Subsect="easyloop"/>,
a few such examples appear in individual sections.
In the table of contents, the section headers of the latter kind of examples
are marked with an asterisk <M>(\ast)</M>.

<P/>

The examples use the &GAP; Character Table Library,
the &GAP; Library of Tables of Marks,
<!-- %T TODO: cite the package! -->
and the &GAP; interface&nbsp;<Cite Key="AtlasRep"/> to the
&ATLAS; of Group Representations&nbsp;<Cite Key="AGRv3"/>,
so we first load these three packages in the required versions.
The &GAP; output was adjusted to the versions shown below;
in older versions, features necessary for the computations may be missing,
and it may happen that with newer versions, the behaviour is different.

<P/>

<Example><![CDATA[
gap> CompareVersionNumbers( GAPInfo.Version, "4.5.0" );
true
gap> LoadPackage( "ctbllib", "1.2", false );
true
gap> LoadPackage( "tomlib", "1.2", false );
true
gap> LoadPackage( "atlasrep", "1.5", false );
true
]]></Example>

<P/>

Some of the computations in Section&nbsp;<Ref Sect="sect:hard"/>
require about <M>800</M> MB of space (on <M>32</M> bit machines).
Therefore we check whether &GAP; was started with sufficient maximal
memory; the command line option for this is <C>-o 800m</C>.

<P/>

<Example><![CDATA[
gap> max:= GAPInfo.CommandLineOptions.o;;
gap> if not ( ( IsSubset( max, "m" ) and
>               Int( Filtered( max, IsDigitChar ) ) >= 800 ) or
>             ( IsSubset( max, "g" ) and
>               Int( Filtered( max, IsDigitChar ) ) >= 1 ) ) then
>      Print( "the maximal allowed memory might be too small\n" );
>    fi;
]]></Example>

<P/>

Several computations involve calls to the &GAP; function
<Ref Func="Random" BookName="ref"/>.
In order to make the results of individual examples reproducible,
independent of the rest of the computations,
we reset the relevant random number generators
whenever this is appropriate.
For that, we store the initial states in the variable <C>staterandom</C>,
and provide a function for resetting the random number generators.
(The <Ref Func="Random" BookName="ref"/> calls in the &GAP; library
use the two random number generators
<Ref Var="GlobalRandomSource" BookName="ref"/> and
<Ref Var="GlobalMersenneTwister" BookName="ref"/>.)

<P/>

<Example><![CDATA[
gap> staterandom:= [ State( GlobalRandomSource ),
>                    State( GlobalMersenneTwister ) ];;
gap> ResetGlobalRandomNumberGenerators:= function()
>     Reset( GlobalRandomSource, staterandom[1] );
>     Reset( GlobalMersenneTwister, staterandom[2] );
> end;;
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:probgen-background">
<Heading>Prerequisites</Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="sect:Theoretical Background">
<Heading>Theoretical Background</Heading>

Let <M>G</M> be a finite group, <M>S</M> the socle of <M>G</M>,
and denote by <M>G^{\times}</M> the set of nonidentity elements in <M>G</M>.
For <M>s, g \in G^{\times}</M>, let
<M>&prop;( g, s ):=
   |\{ h \in G; S \nsubseteq \langle s^h, g \rangle \}| / |G|</M>,
the proportion of elements in the class <M>s^G</M> which fail to generate
at least <M>S</M> with <M>g</M>;
we set <M>&prop;( G, s ):= \max\{ &prop;( g, s ); g \in G^{\times} \}</M>.
We are interested in finding a class <M>s^G</M> of elements in <M>S</M>
such that <M>&prop;( G, s ) &lt; 1/3</M> holds.
<P/>
First consider <M>g \in S</M>,
and let <M>&M;(S,s)</M> denote the set of those maximal subgroups of <M>S</M>
that contain <M>s</M>.
We have

<Display Mode="M">
   |\{ h \in S; S \nsubseteq \langle s^h, g \rangle \}|
       =  |\{ h \in S; \langle s, h g h^{-1} \rangle &noteq; S \}| \\
       \leq  \sum_{M \in &M;(S,s)} |\{ h \in S; h g h^{-1} \in M \}|
</Display>

Since <M>h g h^{-1} \in M</M> holds if and only if the coset <M>M h</M>
is fixed by <M>g</M> under the permutation action of <M>S</M>
on the right cosets of <M>M</M> in <M>S</M>,
we get that
<M>|\{ h \in S; h g h^{-1} \in M \}| = |C_S(g)| \cdot |g^S \cap M|
 = |M| \cdot 1_M^S(g)</M>,
where <M>1_M^S</M> is the permutation character of this action,
of degree <M>|S|/|M|</M>.
Thus

<Display Mode="M">
   |\{ h \in S; \langle s, h g h^{-1} \rangle &noteq; S \}| / |S|
       \leq  \sum_{M \in &M;(S,s)} 1_M^S(g) / 1_M^S(1) .
</Display>

We abbreviate the right hand side of this inequality by <M>&total;( g, s )</M>,
set <M>&total;( S, s ):= \max\{ &total;( g, s ); g \in S^{\times} \}</M>,
and choose a transversal <M>T</M> of <M>S</M> in <M>G</M>.
Then <M>&prop;( g, s ) \leq |T|^{-1} \cdot \sum_{t \in T} &total;( g^t, s )</M>
and thus <M>&prop;( G, s ) \leq &total;( S, s )</M> holds.

<P/>

If <M>S = G</M> and if <M>&M;(G,s)</M> consists of a single maximal subgroup
<M>M</M> of <M>G</M> then equality holds,
i.e., <M>&prop;( g, s ) = &total;( g, s ) = 1_M^S(g) / 1_M^S(1)</M>.

<P/>

The quantity <M>1_M^S(g) / 1_M^S(1) = |g^S \cap M| / |g^S|</M>
is the proportion of fixed points of <M>g</M> in the permutation action
of <M>S</M> on the right cosets of its subgroup <M>M</M>.
This is called the <E>fixed point ratio</E> of <M>g</M>
w.&nbsp;r.&nbsp;t.&nbsp;<M>S/M</M>, and is denoted as <M>&fpr;(g,S/M)</M>.

<P/>

For a subgroup <M>M</M> of <M>S</M>,
the number <M>n</M> of <M>S</M>-conjugates of <M>M</M>
containing <M>s</M> is equal to <M>|M^S| \cdot |s^S \cap M| / |s^S|</M>.
To see this, consider the set <M>\{ (s^h, M^k); h, k \in S, s^h \in M^k \}</M>,
the cardinality of which can be counted either as
<M>|M^S| \cdot |s^S \cap M|</M> or as <M>|s^S| \cdot n</M>.
So we get <M>n = |M| \cdot 1_M^S(s) / |N_S(M)|</M>.

<P/>

If <M>S</M> is a finite <E>nonabelian simple</E> group
then each maximal subgroup in <M>S</M> is self-normalizing,
and we have <M>n = 1_M^S(s)</M> if <M>M</M> is maximal.
So we can replace the summation over <M>&M;(S,s)</M> by one over a set
<M>&MM;(S,s)</M> of representatives of conjugacy classes
of maximal subgroups of <M>S</M>,
and get that

<Display Mode="M">
   &total;( g, s ) = \sum_{M \in &MM;(S,s)}
     \frac{1_M^S(s) \cdot 1_M^S(g)}{1_M^S(1)}.
</Display>

Furthermore, we have <M>|&M;(S,s)| = \sum_{M \in &MM;(S,s)} 1_M^S(s)</M>.

<P/>

In the following, we will often deal with the quantities
<M>&total;(S):= \min\{ &total;( S, s ); s \in S^{\times} \}</M> and
<M>&sprtotal;(S):= \lceil 1 / &total;(S) - 1 \rceil</M>.
These values can be computed easily from the primitive
permutation characters of <M>S</M>.

<P/>

Analogously, we set
<M>&prop;(S):= \min \{ &prop;( S, s ); s \in S^{\times} \}</M> and
<M>&sprbound;(S):= \lceil 1 / &prop;(S) - 1 \rceil</M>.
Clearly we have <M>&prop;(S) \leq &total;(S)</M> and
<M>&sprbound;(S) \geq &sprtotal;(S)</M>.

<P/>

One interpretation of <M>&sprbound;(S)</M> is that if this value is
at least <M>k</M>
then it follows that for any <M>g_1, g_2, \ldots, g_k \in S^{\times}</M>,
there is some <M>s \in S</M> such that <M>S = \langle g_i, s \rangle</M>,
for <M>1 \leq i \leq k</M>.
In this case, <M>S</M> is said to have <E>spread</E> at least <M>k</M>.
(Note that the lower bound <M>&sprtotal;(S)</M> for <M>&sprbound;(S)</M>
can be computed from the list of primitive permutation characters of <M>S</M>.)

<P/>

Moreover, <M>&sprbound;(S) \geq k</M> implies that the element <M>s</M>
can be chosen uniformly from a fixed conjugacy class of <M>S</M>.
This is called <E>uniform spread</E> at least <M>k</M>
in&nbsp;<Cite Key="BGK"/>.

<P/>

It is proved in&nbsp;<Cite Key="GK"/> that all finite simple groups
have uniform spread at least <M>1</M>,
that is, for any element <M>x \in S^{\times}</M>,
there is an element <M>y</M> in a prescribed class of <M>S</M>
such that <M>G = \langle x, y \rangle</M> holds.
In&nbsp;<Cite Key="BGK" Where="Corollary&nbsp;1.3"/>,
it is shown that all finite simple groups have uniform spread at least <M>2</M>,
and the finite simple groups with (uniform) spread exactly <M>2</M> are listed.

<P/>

Concerning the spread, it should be mentioned that the methods used here and
in&nbsp;<Cite Key="BGK"/> are nonconstructive in the sense that they cannot
be used for finding an element <M>s</M> that generates <M>G</M> together
with each of the <M>k</M> prescribed elements <M>g_1, g_2, \ldots, g_k</M>.

<P/>

Now consider <M>g \in G \setminus S</M>.
Since <M>&prop;( g^k, s ) \geq &prop;( g, s )</M> for any positive integer
<M>k</M>,
we can assume that <M>g</M> has prime order <M>p</M>, say.
We set <M>H = \langle S, g \rangle \leq G</M>, with <M>[H:S] = p</M>,
choose a transversal <M>T</M> of <M>H</M> in <M>G</M>,
let <M>&M;^{\prime}(H,s):= &M;(H,s) \setminus \{ S \}</M>,
and let <M>&MM;^{\prime}(H,s)</M> denote a set of representatives of
<M>H</M>-conjugacy classes of these groups.
As above,

<!--
<Display Mode="M">
   |\{ h \in H; S \nsubseteq \langle s^h, g \rangle \}| / |H|
     =  |\{ h \in H; \langle s^h, g \rangle &noteq; H \}| / |H| \\
     \leq  \sum_{M \in &M;^{\prime}(H,s)}
                     |\{ h \in H; h g h^{-1} \in M \}| / |H| \\
     =  \sum_{M \in &M;^{\prime}(H,s)} 1_M^H(g) / 1_M^H(1) \\
     =  \sum_{M \in &MM;^{\prime}(H,s)} 1_M^H(g) \cdot 1_M^H(s) / 1_M^H(1)
</Display>
-->
<Table Align="rcl">
<Row>
   <Item><M>|\{ h \in H; S \nsubseteq \langle s^h, g \rangle \}| / |H|</M></Item>
   <Item><M>=</M></Item>
   <Item><M>|\{ h \in H; \langle s^h, g \rangle &noteq; H \}| / |H|</M></Item>
</Row>
<Row>
   <Item>&nbsp;</Item>
   <Item><M>\leq</M></Item>
   <Item><M>\sum_{M \in &M;^{\prime}(H,s)}
                     |\{ h \in H; h g h^{-1} \in M \}| / |H|</M></Item>
</Row>
<Row>
   <Item>&nbsp;</Item>
   <Item><M>=</M></Item>
   <Item><M>\sum_{M \in &M;^{\prime}(H,s)} 1_M^H(g) / 1_M^H(1)</M></Item>
</Row>
<Row>
   <Item>&nbsp;</Item>
   <Item><M>=</M></Item>
   <Item><M>\sum_{M \in &MM;^{\prime}(H,s)} 1_M^H(g) \cdot 1_M^H(s) / 1_M^H(1)</M></Item>
</Row>
</Table>

(Note that no summand for <M>M = S</M> occurs,
so each group in <M>&MM;^{\prime}(H,s)</M> is self-normalizing.)
We abbreviate the right hand side by <M>&total;(H,g,s)</M>,
and set <M>&total;^{\prime}( H, s ) =
  \max\{ &total;(H,g,s); g \in H \setminus S, |g| = [H:S] \}</M>.
Then we get
<M>&prop;( g, s ) \leq |T|^{-1} \cdot \sum_{t \in T} &total;(H^t,g^t,s)</M>
and thus

<Display Mode="M">
   &prop;( G, s ) \leq \max\{ &prop;( S, s ),
     \max\{ &total;^{\prime}( H, s );
               S \leq H \leq G, [H:S] \textrm{\ prime} \} \} .
</Display>

For convenience, we set
<M>&prop;^{\prime}(G,s) = \max\{ &prop;(g,s); g \in G \setminus S \}</M>.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="sect:probgen-criteria">
<Heading>Computational Criteria</Heading>

The following criteria will be used when we have to show
the existence or nonexistence of <M>x_1, x_2, \ldots, x_k</M>,
and <M>s \in G</M> with the property
<M>\langle x_i, s \rangle = G</M> for <M>1 \leq i \leq k</M>.
Note that manipulating lists of integers (representing fixed or moved points)
is much more efficient than testing whether certain permutations generate
a given group.

<P/>

Lemma:

<P/>

Let <M>G</M> be a finite group, <M>s \in G^{\times}</M>,
and <M>X = \bigcup_{M \in &M;(G,s)} G/M</M>.
For <M>x_1, x_2, \ldots, x_k \in G</M>,
the conjugate <M>s^{\prime}</M> of <M>s</M> satisfies
<M>\langle x_i, s^{\prime} \rangle = G</M> for <M>1 \leq i \leq k</M>
if and only if
<M>&Fix;_{X}(s^{\prime}) \cap \bigcup_{i=1}^k &Fix;_{X}(x_i) = \emptyset</M>
holds.

<P/>

<E>Proof.</E>
If <M>s^g \in U \leq G</M> for some <M>g \in G</M> then
<M>&Fix;_{X}(U) = \emptyset</M> if and only if <M>U = G</M> holds;
note that <M>&Fix;_{X}(G) = \emptyset</M>,
and <M>&Fix;_{X}(U) = \emptyset</M> implies that <M>U \nsubseteq h^{-1} M h</M>
holds for all <M>h \in G</M> and <M>M \in &M;(G,s)</M>, thus <M>U = G</M>.
Applied to <M>U = \langle x_i, s^{\prime} \rangle</M>,
we get <M>\langle x_i, s^{\prime} \rangle = G</M> if and only if
<M>&Fix;_{X}(s^{\prime}) \cap &Fix;_{X}(x_i) = &Fix;_{X}(U) = \emptyset</M>.

<!-- % weaken this? -->
<!-- % one direction without X being the union of all perm. repr. including s? -->

<P/>

Corollary&nbsp;1:

<P/>

If <M>&M;(G,s) = \{ M \}</M> in the situation of the above Lemma
then there is a conjugate <M>s^{\prime}</M> of <M>s</M> that satisfies
<M>\langle x_i, s^{\prime} \rangle = G</M> for <M>1 \leq i \leq k</M>
if and only if
<M>\bigcup_{i=1}^k &Fix;_{X}(x_i) &noteq; X</M>.

<P/>

Corollary&nbsp;2:

<P/>

Let <M>G</M> be a finite simple group
and let <M>X</M>  be a <M>G</M>-set such that each <M>g \in G</M> fixes at least one
point in <M>X</M> but that <M>&Fix;_{X}(G) = \emptyset</M> holds.
If <M>x_1, x_2, \ldots x_k</M> are elements in <M>G</M> such that
<M>\bigcup_{i=1}^k &Fix;_{X}(x_i) = X</M> holds
then for each <M>s \in G</M> there is at least one <M>i</M> with
<M>\langle x_i, s \rangle &noteq; G</M>.

</Subsection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:probgen-functions">
<Heading>&GAP; Functions for the Computations</Heading> 

After the introduction of general utilities in
Section&nbsp;<Ref Subsect="subsect:utils"/>,
we distinguish two different tasks.
Section&nbsp;<Ref Subsect="subsect:probgen-ctfun"/> introduces functions
that will be used
in the following to compute <M>&total;(g,s)</M> with character-theoretic methods.
Functions for computing <M>&prop;(g,s)</M> or an upper bound for this value
will be introduced in Section&nbsp;<Ref Subsect="subsect:groups"/>.
<P/>
The &GAP; functions shown in this section
are collected in the file <F>tst/probgen.g</F> that is
distributed with the &GAP; Character Table Library,
see&nbsp;<URL>http://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib</URL>.

<P/>

The functions have been designed for the examples in the later sections,
they could be generalized and optimized for other examples.
It is not our aim to provide a package for this functionality.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:utils">
<Heading>General Utilities</Heading>

Let <C>list</C> be a dense list and <C>prop</C> be a unary function that returns
<K>true</K> or <K>false</K> when applied to the entries of <C>list</C>.
<C>PositionsProperty</C> returns the set of positions in <C>list</C> for which
<K>true</K> is returned.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#A  PositionsProperty( <list>, <prop> )
##
##  Let <list> be a dense list and <prop> be a unary function that returns
##  `true' or `false' when applied to the entries of <list>.
##  `PositionsProperty' returns the set of positions in <list> for which
##  `true' is returned.
##
]]></Ignore>
<Example><![CDATA[
gap> if not IsBound( PositionsProperty ) then
>      PositionsProperty:= function( list, prop )
>        return Filtered( [ 1 .. Length( list ) ], i -> prop( list[i] ) );
>      end;
>    fi;
]]></Example>

<P/>

<!--
Let <C>list</C> be a dense list and <C>k</C> be a nonnegative integer.
<C>UnorderedTuplesNoSort</C> returns a list of all unordered <C>k</C>-tuples
with repetitions of elements in <C>list</C>.
The only difference to the &GAP; library function <C>UnorderedTuples</C> is
that the entries in the result of <C>UnorderedTuplesNoSort</C> need not be
sorted.
This is advantageous when the comparison of elements in <C>list</C> is
expensive, e.&nbsp;g., when these elements are conjugacy classes in a group.

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#A  UnorderedTuplesNoSort( <list>, <k> )
##
##  Let <list> be a dense list and <k> be a nonnegative integer.
##  `UnorderedTuplesNoSort' returns a list of all unordered <k>-tuples with
##  repetitions of elements in <list>.
##  The only difference to the GAP library function `UnorderedTuples' is
##  that the entries in the result of `UnorderedTuplesNoSort' need not be
##  sorted.
##  This is advantageous when the comparison of elements in <list> is
##  expensive, e.~g., when these elements are conjugacy classes in a group.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "UnorderedTuplesNoSort", function( list, k )
>     return List( UnorderedTuples( [ 1 .. Length( list ) ], k ),
>                  tuple -> list{ tuple } );
> end );
]]></Example>
-->

The following two functions implement loops over ordered triples
(and quadruples, respectively) in a Cartesian product.
A prescribed function <C>prop</C> is subsequently applied to the triples
(quadruples),
and if the result of this call is <K>true</K> then this triple (quadruple)
is returned immediately;
if none of the calls to <C>prop</C> yields <K>true</K> then <K>fail</K>
is returned.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  TripleWithProperty( <threelists>, <prop> )
#F  QuadrupleWithProperty( <fourlists>, <prop> )
##
##  Let <threelists> be a list of three lists $l_1, l_2, l_3$,
##  and <prop> be a unary function that takes a triple $[ x_1, x_2, x_3 ]$
##  with $x_i \in l_i$ as its argument and returns either `true' or `false'.
##  `TripleWithProperty' returns a triple for which `prop' returns `true'
##  if such a triple exists, and `fail' otherwise.
##
##  Analogously, the first argument of `QuadrupleWithProperty' is a list
##  <fourlists> of four lists, and the second argument <prop> takes a
##  quadruple as its argument.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "TripleWithProperty", function( threelists, prop )
>     local i, j, k, test;
> 
>     for i in threelists[1] do
>       for j in threelists[2] do
>         for k in threelists[3] do
>           test:= [ i, j, k ];
>           if prop( test ) then
>               return test;
>           fi;
>         od;
>       od;
>     od;
> 
>     return fail;
> end );
gap> BindGlobal( "QuadrupleWithProperty", function( fourlists, prop )
>     local i, j, k, l, test;
> 
>     for i in fourlists[1] do
>       for j in fourlists[2] do
>         for k in fourlists[3] do
>           for l in fourlists[4] do
>             test:= [ i, j, k, l ];
>             if prop( test ) then
>               return test;
>             fi;
>           od;
>         od;
>       od;
>     od;
> 
>     return fail;
> end );
]]></Example>

<P/>

Of course one could do better by considering <E>un</E>ordered <M>n</M>-tuples
when several of the argument lists are equal,
and in practice, backtrack searches would often allow one to prune parts
of the search tree in early stages.
However, the above loops are not time critical in the examples presented
here, so the possible improvements are not worth the effort for our
purposes.

<P/>

The function <C>PrintFormattedArray</C> prints the matrix <C>array</C>
in a columnwise formatted way.
(The only diference to the &GAP; library function
<Ref Func="PrintArray" BookName="ref"/> is that
<C>PrintFormattedArray</C> chooses each column width according to the entries
only in this column not w.r.t.&nbsp;the whole matrix.)

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  PrintFormattedArray( <array> )
##
##  Let <array> be a rectangular table.
##  `PrintFormattedArray' prints <array> such that each column is right
##  aligned.
##  The only difference to the GAP library function `PrintArray'
##  is that the latter prints all columns at the same width.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "PrintFormattedArray", function( array )
>      local colwidths, n, row;
>      array:= List( array, row -> List( row, String ) );
>      colwidths:= List( TransposedMat( array ),
>                        col -> Maximum( List( col, Length ) ) );
>      n:= Length( array[1] );
>      for row in List( array, row -> List( [ 1 .. n ],
>                   i -> String( row[i], colwidths[i] ) ) ) do
>        Print( "  ", JoinStringsWithSeparator( row, " " ), "\n" );
>      od;
> end );
]]></Example>

<P/>

Finally, <C>CleanWorkspace</C> is a utility for reducing the space needed.
This is achieved by unbinding those user variables
that are not write protected and are not mentioned in the list
<C>NeededVariables</C> of variable names that are bound now,
and by flushing the caches of tables of marks and character tables.

<!-- %T In a forthcoming version, flushing these caches should become easier. -->

<P/>

<Example><![CDATA[
gap> BindGlobal( "NeededVariables", NamesUserGVars() );
gap> BindGlobal( "CleanWorkspace", function()
>       local name, record;
> 
>       for name in Difference( NamesUserGVars(), NeededVariables ) do
>        if not IsReadOnlyGlobal( name ) then
>          UnbindGlobal( name );
>        fi;
>      od;
>      for record in [ LIBTOMKNOWN, LIBTABLE ] do
>        for name in RecNames( record.LOADSTATUS ) do
>          Unbind( record.LOADSTATUS.( name ) );
>          Unbind( record.( name ) );
>        od;
>      od;
> end );
]]></Example>

<P/>

The function <C>PossiblePermutationCharacters</C> takes two ordinary character
tables <C>sub</C> and <C>tbl</C>,
computes the possible class fusions from <C>sub</C> to <C>tbl</C>,
then induces the trivial character of <C>sub</C> to <C>tbl</C>, w.r.t.&nbsp;these fusions,
and returns the set of these class functions.
(So if <C>sub</C> and <C>tbl</C> are the character tables of groups <M>H</M> and <M>G</M>,
respectively, where <M>H</M> is a subgroup of <M>G</M>,
then the result contains the permutation character <M>1_H^G</M>.)
<P/>
Note that the columns of the character tables
in the &GAP; Character Table Library
are not explicitly associated with particular conjugacy classes of the
corresponding groups,
so from the character tables,
we can compute only <E>possible</E> class fusions,
i.e., maps between the columns of two tables that satisfy certain
necessary conditions, see the section about the function
<C>PossibleClassFusions</C> in the &GAP; Reference Manual for details.
There is no problem if the permutation character is uniquely determined
by the character tables, in all other cases we give ad hoc arguments
for resolving the ambiguities.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  PossiblePermutationCharacters( <sub>, <tbl> )
##
##  For two ordinary character tables <sub> and <tbl>,
##  `PossiblePermutationCharacters' returns the set of all induced class
##  functions of the trivial character of <sub> to <tbl>,
##  w.r.t.~the possible class fusions from <sub> to <tbl>.
##
]]></Ignore>
<Example><![CDATA[
gap> if not IsBound( PossiblePermutationCharacters ) then
>      BindGlobal( "PossiblePermutationCharacters", function( sub, tbl )
>        local fus, triv;
> 
>        fus:= PossibleClassFusions( sub, tbl );
>        if fus = fail then
>          return fail;
>        fi;
>        triv:= [ TrivialCharacter( sub ) ];
> 
>        return Set(
>            List( fus, map -> Induced( sub, tbl, triv, map )[1] ) );
>      end );
>    fi;
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:probgen-ctfun">
<Heading>Character-Theoretic Computations</Heading>

We want to use the &GAP; libraries of character tables
and of tables of marks, and proceed in three steps.

<P/>

First we extract the primitive permutation characters from the library
information if this is available;
for that, we write the function <C>PrimitivePermutationCharacters</C>.
Then the result can be used as the input for the function <C>ApproxP</C>,
which computes the values <M>&total;( g, s )</M>.
Finally,
the functions <C>ProbGenInfoSimple</C> and <C>ProbGenInfoAlmostSimple</C>
compute <M>&sprtotal;( G )</M>.

<P/>

For a group <M>G</M> whose character table <M>T</M> is contained in the &GAP;
character table library, the complete set of primitive permutation
characters can be easily computed if the character tables of all maximal
subgroups and their class fusions into <M>T</M> are known
(in this case, we check whether the attribute
<Ref Attr="Maxes" BookName="ctbllib"/> of <M>T</M> is bound)
or if the table of marks of <M>G</M> and the class fusion from <M>T</M> into this
table of marks are known
(in this case, we check whether the attribute
<Ref Attr="FusionToTom" BookName="ctbllib"/> of <M>T</M> is bound).
If the attribute <Ref Attr="UnderlyingGroup" BookName="ref"/> of <M>T</M>
is bound then this group
can be used to compute the primitive permutation characters.
The latter happens if <M>T</M> was computed from the group object in &GAP;;
for tables in the &GAP; character table library,
this is not the case by default.

<P/>

The &GAP; function <C>PrimitivePermutationCharacters</C> tries to compute
the primitive permutation characters of a group using this information;
it returns the required list of characters if this can be computed this way,
otherwise <K>fail</K> is returned.
(For convenience, we use the &GAP; mechanism of <E>attributes</E>
in order to store the permutation characters in the character table object
once they have been computed.)

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#A  PrimitivePermutationCharacters( <tbl> )
##
##  For an ordinary character table <tbl> for which either the value of one
##  of the attributes `Maxes' or `UnderlyingGroup' is stored or the table of
##  marks is contained in the GAP library of tables of marks,
##  `PrimitivePermutationCharacters' returns the list of all primitive
##  permutation characters of <tbl>.
##  Otherwise `fail' is returned.
##
##  We use 'InstallOtherMethod' not 'InstallMethod' because another test file
##  declares the same attribute and installs the same method.
##
]]></Ignore>
<Example><![CDATA[
gap> DeclareAttribute( "PrimitivePermutationCharacters", IsCharacterTable );
gap> InstallOtherMethod( PrimitivePermutationCharacters,
>     [ IsCharacterTable ],
>     function( tbl )
>     local maxes, tom, G;
> 
>     if HasMaxes( tbl ) then
>       maxes:= List( Maxes( tbl ), CharacterTable );
>       if ForAll( maxes, s -> GetFusionMap( s, tbl ) <> fail ) then
>         return List( maxes, subtbl -> TrivialCharacter( subtbl )^tbl );
>       fi;
>     elif HasFusionToTom( tbl ) then
>       tom:= TableOfMarks( tbl );
>       maxes:= MaximalSubgroupsTom( tom );
>       return PermCharsTom( tbl, tom ){ maxes[1] };
>     elif HasUnderlyingGroup( tbl ) then
>       G:= UnderlyingGroup( tbl );
>       return List( MaximalSubgroupClassReps( G ),
>                    M -> TrivialCharacter( M )^tbl );
>     fi;
> 
>     return fail;
> end );
]]></Example>

<P/>

The function <C>ApproxP</C> takes a list <C>primitives</C>
of primitive permutation characters of a group <M>G</M>, say,
and the position <C>spos</C> of the class <M>s^G</M> in the character table
of <M>G</M>.

<P/>

Assume that the elements in <C>primitives</C> have the form <M>1_M^G</M>,
for suitable maximal subgroups <M>M</M> of <M>G</M>,
and let <M>&MM;</M> be the set of these groups <M>M</M>.
<C>ApproxP</C> returns the class function <M>\psi</M> of <M>G</M>
that is defined by <M>\psi(1) = 0</M> and

<Display Mode="M">
   \psi(g) = \sum_{M \in &MM;}
                 \frac{1_M^G(s) \cdot 1_M^G(g)}{1_M^G(1)}
</Display>

otherwise.

<P/>

If <C>primitives</C> contains all those primitive permutation characters <M>1_M^G</M>
of <M>G</M> (with multiplicity according to the number of conjugacy classes
of these maximal subgroups) that do not vanish at <M>s</M>,
and if all these <M>M</M> are self-normalizing in <M>G</M>
&ndash;this holds for example if <M>G</M> is a finite simple group&ndash;
then <M>\psi(g) = &total;( g, s )</M> holds.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  ApproxP( <primitives>, <spos> )
##
##  Let <primitives> be a list of primitive permutation characters of a group
##  $G$, say, and <spos> the position of the conjugacy class of the element
##  $s \in G$.
##  Assume that the elements in <primitives> have the form $1_M^G$,
##  for suitable maximal subgroups $M$ of $G$,
##  and let $\MM$ be the set of these groups $M$.
##  `ApproxP' returns the class function $\psi$ of $G$ that is defined by
##  $\psi(1) = 0$ and
##  \[
##     \psi(g) = \sum_{M \in \MM}
##                   \frac{1_M^G(s) \cdot 1_M^G(g)}{1_M^G(1)}
##  \]
##  otherwise.
##
##  If <primitives> contains all those primitive permutation characters
##  $1_M^G$ of $G$ (with multiplicity according to the number of conjugacy
##  classes of these maximal subgroups) that do not vanish at $s$,
##  and if all these $M$ are self-normalizing in $G$
##  --this holds for example if $G$ is a finite simple group--
##  then $\psi(g) = &total;( g, s )$ holds.
##
##  The latter is an upper bound for the proportion
##  $&prop;( g, s )$ of elements in the conjugacy class of $s$ that generate
##  together with $g$ a proper subgroup of $G$.
##
##  Note that if $&prop;( g, s )$ is less than $1/k$ for all
##  $g \in G^{\times}$ then $G$ has spread at least $k$.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "ApproxP", function( primitives, spos )
>     local sum;
> 
>     sum:= ShallowCopy( Sum( List( primitives,
>                                   pi -> pi[ spos ] * pi / pi[1] ) ) );
>     sum[1]:= 0;
> 
>     return sum;
> end );
]]></Example>

<P/>

Note that for computations with permutation characters,
it would make the functions more complicated (and not more efficient)
if we would consider only elements <M>g</M> of prime order,
and only one representative of Galois conjugate classes.
<P/>
The next functions needed in this context compute <M>&total;(S)</M> and
<M>&sprtotal;( S )</M>, for a simple group <M>S</M>,
and <M>&total;^{\prime}(G,s)</M> for an almost simple group <M>G</M>
with socle <M>S</M>, respectively.

<P/>

<C>ProbGenInfoSimple</C> takes the character table <C>tbl</C> of <M>S</M>
as its argument.
If the full list of primitive permutation characters of <M>S</M> cannot be
computed with <C>PrimitivePermutationCharacters</C> then the function returns
<K>fail</K>.
Otherwise <C>ProbGenInfoSimple</C> returns a list containing
the identifier of the table,
the value <M>&total;(S)</M>,
the integer <M>&sprtotal;( S )</M>,
a list of &ATLAS; names of representatives of Galois families of those
classes of elements <M>s</M> for which <M>&total;(S) = &total;( S, s )</M> holds,
and the list of the corresponding cardinalities <M>|&M;(S,s)|</M>.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  ProbGenInfoSimple( <tbl> )
##
##  Let <tbl> be the ordinary character table of a finite simple group $S$.
##  If the full list of primitive permutation characters of <tbl> cannot be
##  computed with `PrimitivePermutationCharacters' then `fail' is returned.
##  Otherwise `ProbGenInfoSimple' returns a list of length $5$, containing
##  the identifier of <tbl>,
##  the value $&total;(S)$,
##  the value $\sprtotal( S )$,
##  a list of {\ATLAS} names of the classes of elements $s$ for which
##  $&total;(S) = &total;( S, s )$ holds,
##  and the list of the corresponding cardinalities $|&M;(S,s)|$.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "ProbGenInfoSimple", function( tbl )
>     local prim, max, min, bound, s;
>     prim:= PrimitivePermutationCharacters( tbl );
>     if prim = fail then
>       return fail;
>     fi;
>     max:= List( [ 1 .. NrConjugacyClasses( tbl ) ],
>                 i -> Maximum( ApproxP( prim, i ) ) );
>     min:= Minimum( max );
>     bound:= Inverse( min );
>     if IsInt( bound ) then
>       bound:= bound - 1;
>     else
>       bound:= Int( bound );
>     fi;
>     s:= PositionsProperty( max, x -> x = min );
>     s:= List( Set( s, i -> ClassOrbit( tbl, i ) ), i -> i[1] );
>     return [ Identifier( tbl ),
>              min,
>              bound,
>              AtlasClassNames( tbl ){ s },
>              Sum( List( prim, pi -> pi{ s } ) ) ];
> end );
]]></Example>

<P/>

<C>ProbGenInfoAlmostSimple</C> takes the character tables <C>tblS</C> and
<C>tblG</C> of <M>S</M> and <M>G</M>,
and a list <C>sposS</C> of class positions (w.r.t.&nbsp;<C>tblS</C>)
as its arguments.
It is assumed that <M>S</M> is simple and has prime index in <M>G</M>.
If <C>PrimitivePermutationCharacters</C> can compute the full list
of primitive permutation characters of <M>G</M> then the function returns
a list containing
the identifier of <C>tblG</C>,
the maximum <M>m</M> of <M>&total;^{\prime}( G, s )</M>,
for <M>s</M> in the classes described by <C>sposS</C>,
a list of &ATLAS; names (in <M>G</M>) of the classes of elements <M>s</M>
for which this maximum is attained,
and the list of the corresponding cardinalities <M>|&M;^{\prime}(G,s)|</M>.
When <C>PrimitivePermutationCharacters</C> returns <K>fail</K>,
also <C>ProbGenInfoAlmostSimple</C> returns <K>fail</K>.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  ProbGenInfoAlmostSimple( <tblS>, <tblG>, <sposS> )
##
##  Let <tblS> be the ordinary character table of a finite simple group $S$,
##  <tblG> be the character table of an automorphic extension $G$ of $S$
##  in which $S$ has prime index,
##  and <sposS> a list of class positions in <tblS>.
##
##  If the full list of primitive permutation characters of <tblG> cannot be
##  computed with `PrimitivePermutationCharacters' then `fail' is returned.
##  Otherwise `ProbGenInfoAlmostSimple' returns a list of length five,
##  containing
##  the identifier of <tblG>,
##  the maximum $m$ of $&total;^{\prime}( G, s )$,
##  for $s$ in the classes described by <sposS>,
##  a list of {\ATLAS} names (w.r.t. $G$) of the classes of elements $s$
##  for which this maximum is attained,
##  and the list of the corresponding cardinalities $|\M^{\prime}(G,s)|$.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "ProbGenInfoAlmostSimple", function( tblS, tblG, sposS )
>     local p, fus, inv, prim, sposG, outer, approx, l, max, min,
>           s, cards, i, names;
> 
>     p:= Size( tblG ) / Size( tblS );
>     if not IsPrimeInt( p )
>        or Length( ClassPositionsOfNormalSubgroups( tblG ) ) <> 3 then
>       return fail;
>     fi;
>     fus:= GetFusionMap( tblS, tblG );
>     if fus = fail then
>       return fail;
>     fi;
>     inv:= InverseMap( fus );
>     prim:= PrimitivePermutationCharacters( tblG );
>     if prim = fail then
>       return fail;
>     fi;
>     sposG:= Set( fus{ sposS } );
>     outer:= Difference( PositionsProperty(
>                 OrdersClassRepresentatives( tblG ), IsPrimeInt ), fus );
>     approx:= List( sposG, i -> ApproxP( prim, i ){ outer } );
>     if IsEmpty( outer ) then
>       max:= List( approx, x -> 0 );
>     else
>       max:= List( approx, Maximum );
>     fi;
>     min:= Minimum( max);
>     s:= sposG{ PositionsProperty( max, x -> x = min ) };
>     cards:= List( prim, pi -> pi{ s } );
>     for i in [ 1 .. Length( prim ) ] do
>       # Omit the character that is induced from the simple group.
>       if ForAll( prim[i], x -> x = 0 or x = prim[i][1] ) then
>         cards[i]:= 0;
>       fi;
>     od;
>     names:= AtlasClassNames( tblG ){ s };
>     Perform( names, ConvertToStringRep );
> 
>     return [ Identifier( tblG ),
>              min,
>              names,
>              Sum( cards ) ];
> end );
]]></Example>
<P/>
The next function computes <M>&total;(G,s)</M> from
the character table <C>tbl</C> of a simple or almost simple group <M>G</M>,
the name <C>sname</C> of the class of <M>s</M> in this table,
the list <C>maxes</C> of the character tables of all subgroups <M>M</M>
with <M>M \in &M;(G,s)</M>,
and the list <C>numpermchars</C> of the numbers of possible permutation characters
induced from <C>maxes</C>.
If the string <C>"outer"</C> is given as an optional argument then <M>G</M> is assumed
to be an automorphic extension of a simple group <M>S</M>, with <M>[G:S]</M> a prime,
and <M>&total;^{\prime}(G,s)</M> is returned.
In both situations,
the result is <K>fail</K> if the numbers of possible permutation characters
induced from <C>maxes</C> do not coincide with the numbers prescribed in
<C>numpermchars</C>.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  SigmaFromMaxes( <tbl>, <sname>, <maxes>, <numpermchars> )
#F  SigmaFromMaxes( <tbl>, <sname>, <maxes>, <numpermchars>, <choice> )
##
##  Let <tbl> be the ordinary character table of a finite almost simple group
##  $G$ with socle $S$,
##  <sname> be the name of a class in <tbl>,
##  <maxes> be a list of character tables of all those maximal subgroups
##  of $G$ which contain elements $s$ in the class with the name <sname>.
##  Further let <numpermchars> be a list of integers such that the $i$-th
##  entry in <maxes> induces `<numpermchars>[i]' different permutation
##  characters.
##  (So if several classes of maximal subgroups in $G$ induce the same
##  permutation character then the table of this subgroup must occur with
##  this multiplicity in <maxes>, and the corresponding entries in
##  <numpermchars> must be $1$.
##  Conversely, if there are $n$ classes of isomorphic maximal subgroups
##  which induce $n$ different permutation characters then the table must
##  occur only once in <maxes>, and the corresponding multiplicity in
##  <numpermchars> must be $n$.)
##
##  The return value is `fail' if there is an entry `<maxes>[i]' such that
##  `PossiblePermutationCharacters' does not return a list of length
##  `<numpermchars>[i]' when its arguments are `<maxes>[i]' and <tbl>.
##
##  If the string `"outer"' is entered as the optional argument <choice> then
##  $G$ is assumed to be an automorphic extension of $S$,
##  with $[G:S]$ a prime,
##  and $&total;^{\prime}(G,s)$ is returned.
##
##  Otherwise `SigmaFromMaxes' returns $&total;(G,s)$.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "SigmaFromMaxes", function( arg )
>     local t, sname, maxes, numpermchars, prim, spos, outer;
> 
>     t:= arg[1];
>     sname:= arg[2];
>     maxes:= arg[3];
>     numpermchars:= arg[4];
>     prim:= List( maxes, s -> PossiblePermutationCharacters( s, t ) );
>     spos:= Position( AtlasClassNames( t ), sname );
>     if ForAny( [ 1 .. Length( maxes ) ],
>                i -> Length( prim[i] ) <> numpermchars[i] ) then
>       return fail;
>     elif Length( arg ) = 5 and arg[5] = "outer" then
>       outer:= Difference(
>           PositionsProperty( OrdersClassRepresentatives( t ), IsPrimeInt ),
>           ClassPositionsOfDerivedSubgroup( t ) );
>       return Maximum( ApproxP( Concatenation( prim ), spos ){ outer } );
>     else
>       return Maximum( ApproxP( Concatenation( prim ), spos ) );
>     fi;
> end );
]]></Example>

<P/>

The following function allows us to extract information about <M>&M;(G,s)</M>
from the character table <C>tbl</C> of <M>G</M> and a list <C>snames</C>
of class positions of <M>s</M>.
If <C>Maxes( tbl )</C> is stored then the names of the character tables of the
subgroups in <M>&M;(G,s)</M> and the number of conjugates are printed,
otherwise <K>fail</K> is printed.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  DisplayProbGenMaxesInfo( <tbl>, <snames> )
##
##  For a character table <tbl> with known `Maxes' value and a list <snames>
##  of class names in <tbl>,
##  `DisplayProbGenMaxesInfo' prints a description of the maximal subgroups
##  of <tbl> that contain an element $s$ in the classes with names in the
##  list <snames>.
##  Printed are the `Identifier' values of the tables of the maximal
##  subgroups and the number of conjugate subgroups in this class
##  that contain $s$.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "DisplayProbGenMaxesInfo", function( tbl, snames )
>     local mx, prim, i, spos, nonz, indent, j;
> 
>     if not HasMaxes( tbl ) then
>       Print( Identifier( tbl ), ": fail\n" );
>       return;
>     fi;
> 
>     mx:= List( Maxes( tbl ), CharacterTable );
>     prim:= List( mx, s -> TrivialCharacter( s )^tbl );
>     Assert( 1, SortedList( prim ) =
>                SortedList( PrimitivePermutationCharacters( tbl ) ) );
>     for i in [ 1 .. Length( prim ) ] do
>       # Deal with the case that the subgroup is normal.
>       if ForAll( prim[i], x -> x = 0 or x = prim[i][1] ) then
>         prim[i]:= prim[i] / prim[i][1];
>       fi;
>     od;
> 
>     spos:= List( snames,
>                  nam -> Position( AtlasClassNames( tbl ), nam ) );
>     nonz:= List( spos, x -> PositionsProperty( prim, pi -> pi[x] <> 0 ) );
>     for i in [ 1 .. Length( spos ) ] do
>       Print( Identifier( tbl ), ", ", snames[i], ": " );
>       indent:= ListWithIdenticalEntries(
>           Length( Identifier( tbl ) ) + Length( snames[i] ) + 4, ' ' );
>       if not IsEmpty( nonz[i] ) then
>         Print( Identifier( mx[ nonz[i][1] ] ), "  (",
>                prim[ nonz[i][1] ][ spos[i] ], ")\n" );
>         for j in [ 2 .. Length( nonz[i] ) ] do
>           Print( indent, Identifier( mx[ nonz[i][j] ] ), "  (",
>                prim[ nonz[i][j] ][ spos[i] ], ")\n" );
>         od;
>       else
>         Print( "\n" );
>       fi;
>     od;
> end );
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:groups">
<Heading>Computations with Groups</Heading>

Here, the task is to compute <M>&prop;(g,s)</M> or <M>&prop;(G,s)</M>
using explicit computations with <M>G</M>,
where the character-theoretic bounds are not sufficient.

<P/>

We start with small utilities that make the examples shorter.

<P/>

For a finite solvable group <C>G</C>,
the function <C>PcConjugacyClassReps</C> returns a list of representatives of
the conjugacy classes of <C>G</C>,
which are computed using a polycyclic presentation for <C>G</C>.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  PcConjugacyClassReps( <G> )
##
##  Let <G> be a finite solvable group.
##  `PcConjugacyClassReps' returns a list of representatives of
##  the conjugacy classes of <G>,
##  which are computed using a polycyclic presentation for <G>.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "PcConjugacyClassReps", function( G )
>      local iso;
> 
>      iso:= IsomorphismPcGroup( G );
>      return List( ConjugacyClasses( Image( iso ) ),
>               c -> PreImagesRepresentative( iso, Representative( c ) ) );
> end );
]]></Example>

<P/>

For a finite group <C>G</C>, a list <C>primes</C> of prime integers,
and a normal subgroup <C>N</C> of <C>G</C>,
the function <C>ClassesOfPrimeOrder</C> returns a list of those
conjugacy classes of <C>G</C>
that are not contained in <C>N</C> and whose elements' orders occur
in <C>primes</C>.

<P/>

For each prime <M>p</M> in <C>primes</C>,
first class representatives of order <M>p</M>
in a Sylow <M>p</M> subgroup of <C>G</C> are computed,
then the representatives in <C>N</C> are discarded,
and then representatives w.&nbsp;r.&nbsp;t.&nbsp;conjugacy in <C>G</C>
are computed.

<P/>

<!--
% Note that we do not call 'IsConjugate' but create the conjugacy classes
% of the two elements in question, and then ask for equality,
% since the latter is much faster --don't ask why.
% Also, we do  not first create the list of conjugacy classes
% of all elements in question, and then compare the classes in this list
% (using the very elegant 'DuplicateFreeList'),
% because then the required memory would be too large:
% There are cases where more than 1000 elements must be processed,
% and the comparison causes the centralizer of the representative
% to be stored in the class object.
-->

(Note that this approach may be inappropriate
for example if a large elementary abelian Sylow <M>p</M> subgroup occurs,
and if the conjugacy tests in <C>G</C> are expensive,
see Section&nbsp;<Ref Subsect="O8p4"/>.)

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  ClassesOfPrimeOrder( <G>, <primes>, <N> )
##
##  Let <G> be a finite group, <primes> be a list of primes,
##  and <N> be a normal subgroup of <G>.
##  `ClassesOfPrimeOrder' returns a list of those conjugacy classes of <G>
##  that are not contained in <N>
##  and whose elements' orders occur in <primes>.
##
##  For each prime $p$ in <primes>, first class representatives of order $p$
##  in a Sylow $p$ subgroup of <G> are computed,
##  then the representatives in <N> are discarded,
##  and then representatives w. r. t. conjugacy in <G> are computed.
##
##  (Note that this approach may be inappropriate if an elementary abelian
##  Sylow $p$ subgroup for a large prime $p$ occurs, and if the conjugacy
##  tests in <G> are expensive.)
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "ClassesOfPrimeOrder", function( G, primes, N )
>      local ccl, p, syl, Greps, reps, r, cr;
> 
>      ccl:= [];
>      for p in primes do
>        syl:= SylowSubgroup( G, p );
>        Greps:= [];
>        reps:= Filtered( PcConjugacyClassReps( syl ),
>                   r -> Order( r ) = p and not r in N );
>        for r in reps do
>          cr:= ConjugacyClass( G, r );
>          if ForAll( Greps, c -> c <> cr ) then
>            Add( Greps, cr );
>          fi;
>        od;
>        Append( ccl, Greps );
>      od;
> 
>      return ccl;
> end );
]]></Example>

<P/>

The function <C>IsGeneratorsOfTransPermGroup</C> takes a
<E>transitive</E> permutation group <C>G</C> and a list <C>list</C>
of elements in <C>G</C>,
and returns <K>true</K> if the elements in <C>list</C> generate <C>G</C>,
and <K>false</K> otherwise.
The main point is that the return value <K>true</K> requires the group
generated by <C>list</C> to be transitive, and the check for transitivity
is much cheaper than the test whether this group is equal to <C>G</C>.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  IsGeneratorsOfTransPermGroup( <G>, <list> )
##
##  Let <G> be a finite group that acts *transitively* on its moved points,
##  and <list> a list of elements in <G>.
##
##  `IsGeneratorsOfTransPermGroup' returns `true' if the elements in <list>
##  generate <G>, and `false' otherwise.
##  The main point is that the return value `true' requires the group
##  generated by `list' to be transitive, and the check for transitivity
##  is much cheaper than the test whether this group is equal to `G'.
##
]]></Ignore>
<Example><![CDATA[
gap> if not IsBound( IsGeneratorsOfTransPermGroup) then
>      BindGlobal( "IsGeneratorsOfTransPermGroup", function( G, list )
>        local S;
> 
>        if not IsTransitive( G ) then
>          Error( "<G> must be transitive on its moved points" );
>        fi;
>        S:= SubgroupNC( G, list );
> 
>        return IsTransitive( S, MovedPoints( G ) ) and
>               Size( S ) = Size( G );
>      end );
>    fi;
]]></Example>

<P/>

<C>RatioOfNongenerationTransPermGroup</C> takes a <E>transitive</E> permutation
group <C>G</C> and two elements <C>g</C> and <C>s</C> of <C>G</C>,
and returns the proportion <M>&prop;(g,s)</M>.
(The function tests the (non)generation only for representatives of
<M>C_G(g)</M>-<M>C_G(s)</M>-double cosets.
Note that for <M>c_1 \in C_G(g)</M>, <M>c_2 \in C_G(s)</M>,
and a representative <M>r \in G</M>,
we have <M>\langle g^{c_1 r c_2}, s \rangle = \langle g^r, s \rangle^{c_2}</M>.)

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  RatioOfNongenerationTransPermGroup( <G>, <g>, <s> )
##
##  Let <G> be a finite group that acts *transitively* on its moved points,
##  and <g> and <s> be two elements in <G>.
##
##  `RatioOfNongenerationTransPermGroup' returns the proportion
##  $&prop;(g,s)$.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "RatioOfNongenerationTransPermGroup", function( G, g, s )
>     local nongen, pair;
> 
>     if not IsTransitive( G ) then
>       Error( "<G> must be transitive on its moved points" );
>     fi;
>     nongen:= 0;
>     for pair in DoubleCosetRepsAndSizes( G, Centralizer( G, g ),
>                     Centralizer( G, s ) ) do
>       if not IsGeneratorsOfTransPermGroup( G, [ s, g^pair[1] ] ) then
>         nongen:= nongen + pair[2];
>       fi;
>     od;
> 
>     return nongen / Size( G );
> end );
]]></Example>

<P/>

Let <M>G</M> be a group,
and let <C>groups</C> be a list <M>[ G_1, G_2, \ldots, G_n ]</M>
of permutation groups such that <M>G_i</M> describes the action of <M>G</M>
on a set <M>\Omega_i</M>, say.
Moreover, we require that for <M>1 \leq i, j \leq n</M>,
mapping the <C>GeneratorsOfGroup</C> list of <M>G_i</M> to that of <M>G_j</M>
defines an isomorphism.
<C>DiagonalProductOfPermGroups</C> takes <C>groups</C> as its argument,
and returns the action of <M>G</M> on the disjoint union of
<M>\Omega_1, \Omega_2, \ldots, \Omega_n</M>.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  DiagonalProductOfPermGroups( <groups> )
##
##  Let $G$ be a group, and let <groups> be a list
##  $[ G_1, G_2, \ldots, G_n ]$ of permutation groups such that $G_i$
##  describes the action of $G$ on a set $\Omega_i$, say.
##  Moreover, we require that for $1 \leq i, j \leq n$,
##  mapping the `GeneratorsOfGroup' list of $G_i$ to that of $G_j$
##  defines an isomorphism.
##
##  `DiagonalProductOfPermGroups' takes `groups' as its argument,
##  and returns the action of $G$ on the disjoint union of
##  $\Omega_1, \Omega_2, \ldots \Omega_n$.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "DiagonalProductOfPermGroups", function( groups )
>     local prodgens, deg, i, gens, D, pi;
> 
>     prodgens:= GeneratorsOfGroup( groups[1] );
>     deg:= NrMovedPoints( prodgens );
>     for i in [ 2 .. Length( groups ) ] do
>       gens:= GeneratorsOfGroup( groups[i] );
>       D:= MovedPoints( gens );
>       pi:= MappingPermListList( D, [ deg+1 .. deg+Length( D ) ] );
>       deg:= deg + Length( D );
>       prodgens:= List( [ 1 .. Length( prodgens ) ],
>                        i -> prodgens[i] * gens[i]^pi );
>     od;
> 
>     return Group( prodgens );
> end );
]]></Example>

<P/>

<!-- %T Add the above function to the AtlasRep package? -->

The following two functions are used to reduce checks of generation
to class representatives of maximal order.
Note that if <M>\langle s, g \rangle</M> is a proper subgroup of <M>G</M> then
also <M>\langle s^k, g \rangle</M> is a proper subgroup of <M>G</M>,
so we need not check powers <M>s^k</M> different from <M>s</M>
in this situation.

<P/>

For an ordinary character table <C>tbl</C>,
the function <C>RepresentativesMaximallyCyclicSubgroups</C>
returns a list of class positions, containing one class of generators
for each class of maximally cyclic subgroups.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  RepresentativesMaximallyCyclicSubgroups( <tbl> )
##
##  For an ordinary character table <tbl>,
##  `RepresentativesMaximallyCyclicSubgroups' returns a list of class
##  positions containing exactly one class of generators for each class of
##  maximally cyclic subgroups.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "RepresentativesMaximallyCyclicSubgroups", function( tbl )
>     local n, result, orders, p, pmap, i, j;
> 
>     # Initialize.
>     n:= NrConjugacyClasses( tbl );
>     result:= BlistList( [ 1 .. n ], [ 1 .. n ] );
> 
>     # Omit powers of smaller order.
>     orders:= OrdersClassRepresentatives( tbl );
>     for p in PrimeDivisors( Size( tbl ) ) do
>       pmap:= PowerMap( tbl, p );
>       for i in [ 1 .. n ] do
>         if orders[ pmap[i] ] < orders[i] then
>           result[ pmap[i] ]:= false;
>         fi;
>       od;
>     od;
> 
>     # Omit Galois conjugates.
>     for i in [ 1 .. n ] do
>       if result[i] then
>         for j in ClassOrbit( tbl, i ) do
>           if i <> j then
>             result[j]:= false;
>           fi;
>         od;
>       fi;
>     od;
> 
>     # Return the result.
>     return ListBlist( [ 1 .. n ], result );
> end );
]]></Example>

<P/>

Let <C>G</C> be a finite group,
<C>tbl</C> be the ordinary character table of <C>G</C>,
and <C>cols</C> be a list of class positions in <C>tbl</C>,
for example the list returned by <C>RepresentativesMaximallyCyclicSubgroups</C>.
The function <C>ClassesPerhapsCorrespondingToTableColumns</C> returns
the sublist of those conjugacy classes of <C>G</C>
for which the corresponding column in <C>tbl</C>
can be contained in <C>cols</C>, according to element order and class size.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  ClassesPerhapsCorrespondingToTableColumns( <G>, <tbl>, <cols> )
##
##  For a group <G>, its ordinary character table <tbl>, and a list <cols>
##  of class positions in <tbl>,
##  `ClassesPerhapsCorrespondingToTableColumns' returns the sublist
##  of those conjugacy classes of `G' for which the corresponding column
##  in `tbl' can be contained in `cols',
##  according to element order and class length.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "ClassesPerhapsCorrespondingToTableColumns",
>    function( G, tbl, cols )
>     local orders, classes, invariants;
> 
>     orders:= OrdersClassRepresentatives( tbl );
>     classes:= SizesConjugacyClasses( tbl );
>     invariants:= List( cols, i -> [ orders[i], classes[i] ] );
> 
>     return Filtered( ConjugacyClasses( G ),
>         c -> [ Order( Representative( c ) ), Size(c) ] in invariants );
> end );
]]></Example>

<P/>

The next function computes,
for a finite group <M>G</M> and subgroups <M>M_1, M_2, \ldots, M_n</M>
of <M>G</M>,
an upper bound for
<M>\max \{ \sum_{i=1}^n &fpr;(g,G/M_i); g \in G \setminus Z(G) \}</M>.
So if the <M>M_i</M> are the groups in <M>&M;(G,s)</M>,
for some <M>s \in G^{\times}</M>,
then we get an upper bound for <M>&total;(G,s)</M>.

<P/>

The idea is that for <M>M \leq G</M> and <M>g \in G</M> of order <M>p</M>,
we have

<Display Mode="M">
   &fpr;(g,G/M) = |g^G \cap M| / |g^G|
               \leq \sum_{h \in C} |h^M| / |g^G|
               =    \sum_{h \in C} |h^M| \cdot |C_G(g)| / |G| ,
</Display>

where <M>C</M> is a set of class representatives <M>h \in M</M> of all those
classes that satisfy <M>|h| = p</M> and <M>|C_G(h)| = |C_G(g)|</M>,
and in the case that <M>G</M> is a permutation group additionally that
<M>h</M> and <M>g</M> move the same number of points.
(Note that it is enough to consider elements of <E>prime</E> order.)

<P/>

For computing the maximum of the rightmost term in this inequality,
for <M>g \in G \setminus Z(G)</M>,
we need not determine the <M>G</M>-conjugacy of class representatives
in <M>M</M>.
Of course we pay the price that the result may be larger than the
leftmost term.
However,
if the maximal sum is in fact taken only over a single class representative,
we are sure that equality holds.
Thus we return a list of length two, containing the maximum of the
right hand side of the above inequality and a Boolean value indicating
whether this is equal to <M>\max \{ &fpr;(g,G/M); g \in G \setminus Z(G) \}</M>
or just an upper bound.

<P/>

The arguments for <C>UpperBoundFixedPointRatios</C> are the group <C>G</C>,
a list <C>maxesclasses</C> such that the <M>i</M>-th entry
is a list of conjugacy classes of <M>M_i</M>,
which covers all classes of prime element order in <M>M_i</M>,
and either <K>true</K> or <K>false</K>,
where <K>true</K> means that the <E>exact</E> value
of <M>&total;(G,s)</M> is computed, not just an upper bound;
this can be much more expensive because of the conjugacy tests in <M>G</M>
that may be necessary.
(We try to reduce the number of conjugacy tests in this case,
the second half of the code is not completely straightforward.
The special treatment of conjugacy checks for elements with the same sets
of fixed points is essential in the computation of <M>&total;^{\prime}(G,s)</M>
for <M>G = &PGL;(6,4)</M>;
the critical input line is <C>ApproxPForOuterClassesInGL( 6, 4 )</C>,
see Section&nbsp;<Ref Subsect="SLaut"/>.
Currently the standard &GAP; conjugacy test for
an element of order three and its inverse in <M>G \setminus G^{\prime}</M>
requires hours of CPU time, whereas the check for existence of a conjugating
element in the stabilizer of the common set of fixed points of the two
elements is almost free of charge.)

<P/>

<C>UpperBoundFixedPointRatios</C> can be used to compute
<M>&total;^{\prime}(G,s)</M>
in the case that <M>G</M> is an automorphic extension of a simple group
<M>S</M>,
with <M>[G:S] = p</M> a prime;
if <M>&M;^{\prime}(G,s) = \{ M_1, M_2, \ldots, M_n \}</M> then
the <M>i</M>-th entry of <C>maxesclasses</C> must contain only
the classes of element order <M>p</M> in <M>M_i \setminus (M_i \cap S)</M>.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  UpperBoundFixedPointRatios( <G>, <maxesclasses>, <truetest> )
##
##  Let <G> be a finite group, and <maxesclasses> be a list
##  $[ l_1, l_2, ..., l_n ]$ such that each $l_i$ is a list of conjugacy
##  classes of maximal subgroups $M_i$ of <G>, such that all classes of
##  prime element order in $M_i$ are contained in $l_i$,
##  and such that the $M_i$ are all those maximal subgroups of <G>
##  (in particular, \emph{not} only conjugacy class representatives of
##  subgroups) that contain a fixed element $s \in G$.
##
##  `UpperBoundFixedPointRatios' returns a list $[ x, y ]$, where
##  \[
##     x = \max_{1 \not= p \mid |G|} \max_{g \in G \setminus Z(G), |g|=p}
##            \sum_{i=1}^n \sum_{h \in S(i,p,g)} |h^{M_i}| / |g^G|,
##  \]
##  and $S(i,p,g)$ is a set of representatives $h$ of all those classes in
##  $l_i$ that satisfy $|h| = p$ and $|C_G(h)| = |C_G(g)|$,
##  and in the case that $G$ is a permutation group additionally that
##  $h$ and $g$ move the same number of points.
##  Since $S(i,p,g) \supseteq g^G \cap M_i$ holds,
##  $x$ is an upper bound for $&total;(G,s)$.
##
##  The second entry is `true' if the first value is in fact equal to
##  $\max_{g \in G \setminus Z(G)} &fpr;(g,G/M}$, and `false' otherwise.
##
##  The third argument <truetest> must be `true' or `false',
##  where `true' means that the exact value of $&total;(G,s)$ is computed
##  not just an upper bound; this can be much more expensive.
##  (We try to reduce the number of conjugacy tests in this case,
##  the second half of the code is not completely straightforward.)
##
##  If $G$ is an automorphic extension of a simple group $S$,
##  with $[G:S] = p$ a prime, then `UpperBoundFixedPointRatios' can be used
##  to compute $&total;^{\prime}(G,s)$,
##  by choosing $M_i$ the maximal subgroups of $G$ containing $s$,
##  except $S$, such that $l_i$ contains only the classes of element order
##  $p$ in $M_i \setminus (M_i \cap S)$.
##
##  Note that in the case $n = 1$, we have $&total;(G,s) = &prop;(G,s)$,
##  so in this case the second entry `true' means that the first entry is
##  equal to $\max_{g \in G \setminus Z(G)} &fpr;(g,G/M_1}$.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "UpperBoundFixedPointRatios",
>    function( G, maxesclasses, truetest )
>     local myIsConjugate, invs, info, c, r, o, inv, pos, sums, max, maxpos,
>           maxlen, reps, split, i, found, j;
> 
>     myIsConjugate:= function( G, x, y )
>       local movx, movy;
> 
>       movx:= MovedPoints( x );
>       movy:= MovedPoints( y );
>       if movx = movy then
>         G:= Stabilizer( G, movx, OnSets );
>       fi;
>       return IsConjugate( G, x, y );
>     end;
> 
>     invs:= [];
>     info:= [];
> 
>     # First distribute the classes according to invariants.
>     for c in Concatenation( maxesclasses ) do
>       r:= Representative( c );
>       o:= Order( r );
>       # Take only prime order representatives.
>       if IsPrimeInt( o ) then
>         inv:= [ o, Size( Centralizer( G, r ) ) ];
>         # Omit classes that are central in `G'.
>         if inv[2] <> Size( G ) then
>           if IsPerm( r ) then
>             Add( inv, NrMovedPoints( r ) );
>           fi;
>           pos:= First( [ 1 .. Length( invs ) ], i -> inv = invs[i] );
>           if pos = fail then
>             # This class is not `G'-conjugate to any of the previous ones.
>             Add( invs, inv );
>             Add( info, [ [ r, Size( c ) * inv[2] ] ] );
>           else
>             # This class may be conjugate to an earlier one.
>             Add( info[ pos ], [ r, Size( c ) * inv[2] ] );
>           fi;
>         fi;
>       fi;
>     od;
> 
>     if info = [] then
>       return [ 0, true ];
>     fi;
> 
>     repeat
>       # Compute the contributions of the classes with the same invariants.
>       sums:= List( info, x -> Sum( List( x, y -> y[2] ) ) );
>       max:= Maximum( sums );
>       maxpos:= Filtered( [ 1 .. Length( info ) ], i -> sums[i] = max );
>       maxlen:= List( maxpos, i -> Length( info[i] ) );
> 
>       # Split the sets with the same invariants if necessary
>       # and if we want to compute the exact value.
>       if truetest and not 1 in maxlen then
>         # Make one conjugacy test.
>         pos:= Position( maxlen, Minimum( maxlen ) );
>         reps:= info[ maxpos[ pos ] ];
>         if myIsConjugate( G, reps[1][1], reps[2][1] ) then
>           # Fuse the two classes.
>           reps[1][2]:= reps[1][2] + reps[2][2];
>           reps[2]:= reps[ Length( reps ) ];
>           Unbind( reps[ Length( reps ) ] );
>         else
>           # Split the list. This may require additional conjugacy tests.
>           Unbind( info[ maxpos[ pos ] ] );
>           split:= [ reps[1], reps[2] ];
>           for i in [ 3 .. Length( reps ) ] do
>             found:= false;
>             for j in split do
>               if myIsConjugate( G, reps[i][1], j[1] ) then
>                 j[2]:= reps[i][2] + j[2];
>                 found:= true;
>                 break;
>               fi;
>             od;
>             if not found then
>               Add( split, reps[i] );
>             fi;
>           od;
> 
>           info:= Compacted( Concatenation( info,
>                                            List( split, x -> [ x ] ) ) );
>         fi;
>       fi;
>     until 1 in maxlen or not truetest;
> 
>     return [ max / Size( G ), 1 in maxlen ];
> end );
]]></Example>

<P/>

<!-- % possible improvement: -->
<!-- % in the case of a permutation group, -->
<!-- % consider the number of moved points distributed to the orbits of the group -->

Suppose that <M>C_1, C_2, C_3</M> are conjugacy classes in <M>G</M>,
and that we have to prove,
for each <M>(x_1, x_2, x_3) \in C_1 \times C_2 \times C_3</M>,
the existence of an element <M>s</M> in a prescribed class <M>C</M>
of <M>G</M> such that
<M>\langle x_1, s \rangle = \langle x_2, s \rangle = \langle x_2, s \rangle = G</M>
holds.

<P/>

We have to check only representatives under the conjugation action of <M>G</M>
on <M>C_1 \times C_2 \times C_3</M>.
For each representative,
we try a prescribed number of random elements in <M>C</M>.
If this is successful then we are done.
The following two functions implement this idea.

<P/>

For a group <M>G</M> and a list <M>[ g_1, g_2, \ldots, g_n ]</M>
of elements in <M>G</M>,
<C>OrbitRepresentativesProductOfClasses</C> returns a list
<M>R(G, g_1, g_2, \ldots, g_n)</M> of representatives of <M>G</M>-orbits
on the Cartesian product <M>g_1^G \times g_2^G \times \cdots \times g_n^G</M>.

<P/>

The idea behind this function is to choose <M>R(G, g_1) = \{ ( g_1 ) \}</M>
in the case <M>n = 1</M>,
and, for <M>n > 1</M>,

<Display Mode="M">
   R(G, g_1, g_2, \ldots, g_n)  =  \{ (h_1, h_2, \ldots, h_n) \mid
          (h_1, h_2, \ldots, h_{n-1}) \in R(G, g_1, g_2, \ldots, g_{n-1}), \\
            h_n = g_n^d, \textrm{\ for\ } d \in D \} ,
</Display>

where <M>D</M> is a set of representatives of double cosets
<M>C_G(g_n) \setminus G / \cap_{i=1}^{n-1} C_G(h_i)</M>.

<P/>

<!-- % For a proof, show inductively that two such representatives lie in -->
<!-- % different <M>G</M>-orbits, -->
<!-- % and that each element in the product of classes lies in the <M>G</M>-orbit -->
<!-- % of one representative. -->

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  OrbitRepresentativesProductOfClasses( <G>, <classreps> )
##
##  For a finite group <G> and a list
##  $<classreps> = [ g_1, g_2, \ldots, g_n ]$ of elements in <G>,
##  `OrbitRepresentativesProductOfClasses' returns a list of representatives
##  of <G>-orbits on the Cartesian product
##  $g_1^{<G>} \times g_2^{<G>} \times \cdots \times g_n^{<G>}$.
##
##  The idea behind this function is to choose $R(<G>, g_1) = \{ ( g_1 ) \}$
##  in the case $n = 1$,
##  and, for $n > 1$,
##  \[
##     R(<G>, g_1, g_2, \ldots, g_n) = \{ (h_1, h_2, \ldots, h_n);
##        (h_1, h_2, \ldots, h_{n-1}) \in R(<G>, g_1, g_2, \ldots, g_{n-1}),
##        k_n = g_n^d, \textrm{\ for\ } d \in D \} ,
##  \]
##  where $D$ is a set of representatives of double cosets
##  $C_{<G>}(g_n) \setminus <G> / \cap_{i=1}^{n-1} C_{<G>}(h_i)$.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "OrbitRepresentativesProductOfClasses",
>    function( G, classreps )
>     local cents, n, orbreps;
> 
>     cents:= List( classreps, x -> Centralizer( G, x ) );
>     n:= Length( classreps );
> 
>     orbreps:= function( reps, intersect, pos )
>       if pos > n then
>         return [ reps ];
>       fi;
>       return Concatenation( List(
>           DoubleCosetRepsAndSizes( G, cents[ pos ], intersect ),
>             r -> orbreps( Concatenation( reps, [ classreps[ pos ]^r[1] ] ),
>                  Intersection( intersect, cents[ pos ]^r[1] ), pos+1 ) ) );
>     end;
> 
>     return orbreps( [ classreps[1] ], cents[1], 2 );
> end );
]]></Example>

<P/>

<!-- %T implement an iterator for orbit representatives on a direct product!! -->

The function <C>RandomCheckUniformSpread</C> takes
a transitive permutation group <M>G</M>,
a list of class representatives <M>g_i \in G</M>, an element <M>s \in G</M>,
and a positive integer <M>N</M>.
The return value is <K>true</K> if for each representative of <M>G</M>-orbits
on the product of the classes <M>g_i^G</M>,
a good conjugate of <M>s</M> is found in at most <M>N</M> random tests.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  RandomCheckUniformSpread( <G>, <classreps>, <s>, <N> )
##
##  Let <G> be a finite permutation group that is transitive on its moved
##  points,
##  <classreps> be a list of elements in <G>,
##  <s> be an element in <G>,
##  and <N> be a positive integer.
##
##  `RandomCheckUniformSpread' computes representatives $X$ of <G>-orbits
##  on the Cartesian product of the conjugacy classes of <classreps>;
##  for each of them, up to <N> random conjugates $s^{\prime}$ of <s> are
##  checked whether $s^{\prime}$ generates <G> with each element in the
##  $n$-tuple of elements in $X$.
##  If such an element $s^{\prime}$ is found this way, for all $X$,
##  the function returns `true',
##  otherwise a representative $X$ is returned for which no good conjugate
##  of <s> is found.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "RandomCheckUniformSpread", function( G, classreps, s, try )
>     local elms, found, i, conj;
> 
>     if not IsTransitive( G, MovedPoints( G ) ) then
>       Error( "<G> must be transitive on its moved points" );
>     fi;
> 
>     # Compute orbit representatives of G on the direct product,
>     # and try to find a good conjugate of s for each representative.
>     for elms in OrbitRepresentativesProductOfClasses( G, classreps ) do
>       found:= false;
>       for i in [ 1 .. try ] do
>         conj:= s^Random( G );
>         if ForAll( elms,
>               x -> IsGeneratorsOfTransPermGroup( G, [ x, conj ] ) ) then
>           found:= true;
>           break;
>         fi;
>       od;
>       if not found then
>         return elms;
>       fi;
>     od;
> 
>     return true;
> end );
]]></Example>

<P/>

Of course this approach is not suitable for <E>dis</E>proving the existence
of <M>s</M>,
but it is much cheaper than an exhaustive search in the class <M>C</M>.
(Typically, <M>|C|</M> is large whereas the <M>|C_i|</M> are small.)

<P/>

<!-- % (Note that for the case <M>C_1 = C_2</M>, in general fewer orbit representatives -->
<!-- % would suffice, since we need to consider only representatives under the -->
<!-- % <M>G</M>-action on <E>un</E>ordered pairs of elements in <M>C_1 \times C_1</M>.) -->
<P/>
<!-- % deterministic approach under special conditions: -->
<!-- %  -->
<!-- % # G must be defined on the diagonal product of prim. reps. on the -->
<!-- % # cosets of maxes cont. s -->
<!-- % # -->
<!-- % # improve: compute in small perm. rep., -->
<!-- % # form intersections in big repres. -->
<!-- % CheckUniformSpread3:= function( G, C1, C2, C3, sorb ) -->
<!-- %     local x1, fix1, Cx1, n, x2, Cx2, fix2, x3, fix3, set; -->
<!-- %     # Compute orbit representatives of <M>G</M> on <M>C_1 \times C_2 \times C_3</M>. -->
<!-- %     x1:= Representative( C1 ); -->
<!-- %     fix1:= Difference( MovedPoints( G ), MovedPoints( x1 ) ); -->
<!-- %     Cx1:= Centralizer( G, x1 ); -->
<!-- %     n:= Size( G ); -->
<!-- %     # Try to find a conjugate of <M>s</M> for each representative. -->
<!-- %     for x2 in List( OrbitsDomain( Cx1, Elements( C2 ) ), -->
<!-- %                     Representative ) do -->
<!-- %       Cx2:= Centralizer( Cx1, x2 ); -->
<!-- %       fix2:= Difference( MovedPoints( G ), MovedPoints( x2 ) ); -->
<!-- %       for x3 in List( OrbitsDomain( Cx2, Elements( C3 ) ), -->
<!-- %                       Representative ) do -->
<!-- %         # ... -->
<!-- %         fix3:= Difference( MovedPoints( G ), MovedPoints( x3 ) ); -->
<!-- %         set:= Union( fix1, fix2, fix3 ); -->
<!-- %         if ForAll( sorb, x -> not IsEmpty( Intersection( x, set ) ) ) then -->
<!-- %           return [ x1, x2, x3 ]; -->
<!-- %         fi; -->
<!-- %       od; -->
<!-- %     od; -->
<!-- %     return true; -->
<!-- % end;; -->

<P/>

The following function can be used to verify that a given <M>n</M>-tuple
<M>(x_1, x_2, \ldots, x_n)</M> of elements in a group <M>G</M> has the property
that for all elements <M>g \in G</M>, at least one <M>x_i</M> satisfies
<M>\langle x_i, g \rangle</M>.
The arguments are a transitive permutation group <M>G</M>,
a list of class representatives in <M>G</M>, and the <M>n</M>-tuple in question.
The return value is a conjugate <M>g</M> of the given representatives
that has the property if such an element exists,
and <K>fail</K> otherwise.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  CommonGeneratorWithGivenElements( <G>, <classreps>, <tuple> )
##
##  Let <G> be a finite group,
##  and <classreps> and <tuple> be lists of elements in <G>.
##  `CommonGeneratorWithGivenElements' returns an element $g$ in the
##  <G>-conjugacy class of one of the elements in <classreps> with the
##  property that each element in <tuple> together with $g$ generates <G>,
##  if such an element $g$ exists.
##  Otherwise `fail' is returned.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "CommonGeneratorWithGivenElements",
>    function( G, classreps, tuple )
>     local inter, rep, repcen, pair;
> 
>     if not IsTransitive( G, MovedPoints( G ) ) then
>       Error( "<G> must be transitive on its moved points" );
>     fi;
> 
>     inter:= Intersection( List( tuple, x -> Centralizer( G, x ) ) );
>     for rep in classreps do
>       repcen:= Centralizer( G, rep );
>       for pair in DoubleCosetRepsAndSizes( G, repcen, inter ) do
>         if ForAll( tuple,
>            x -> IsGeneratorsOfTransPermGroup( G, [ x, rep^pair[1] ] ) ) then
>           return rep;
>         fi;
>       od;
>     od;
> 
>     return fail;
> end );
]]></Example>

</Subsection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:chartheor">
<Heading>Character-Theoretic Computations</Heading>

In this section, we apply the functions introduced in
Section&nbsp;<Ref Subsect="subsect:probgen-ctfun"/>
to the character tables of simple groups
that are available in the &GAP; Character Table Library.

<P/>

Our first examples are the sporadic simple groups,
in Section&nbsp;<Ref Subsect="subsect:spor"/>,
then their automorphism groups are considered
in Section&nbsp;<Ref Subsect="probgen:sporaut"/>.

<P/>

Then we consider those other simple groups for which &GAP; provides
enough information for automatically computing an upper bound on
<M>&total;(G,s)</M> &ndash;see Section&nbsp;<Ref Subsect="easyloop"/>&ndash;
and their automorphic extensions
&ndash;see Section&nbsp;<Ref Subsect="easyloopaut"/>.

<P/>

After that, individual groups are considered.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:spor">
<Heading>Sporadic Simple Groups</Heading>

The &GAP; Character Table Library contains the tables of maximal subgroups
of all sporadic simple groups except <M>B</M> and <M>M</M>,
so all primitive permutation characters can be computed via the function
<C>PrimitivePermutationCharacters</C> for <M>24</M> of the <M>26</M>
sporadic simple groups.

<P/>

<Example><![CDATA[
gap> sporinfo:= [];;
gap> spornames:= AllCharacterTableNames( IsSporadicSimple, true,
>                                        IsDuplicateTable, false );;
gap> for tbl in List( spornames, CharacterTable ) do
>      info:= ProbGenInfoSimple( tbl );
>      if info <> fail then
>        Add( sporinfo, info );
>      fi;
>    od;
]]></Example>

<P/>

We show the result as a formatted table.

<P/>

<Example><![CDATA[
gap> PrintFormattedArray( sporinfo );
   Co1    421/1545600         3671        [ "35A" ]    [ 4 ]
   Co2          1/270          269        [ "23A" ]    [ 1 ]
   Co3        64/6325           98        [ "21A" ]    [ 4 ]
   F3+ 1/269631216855 269631216854        [ "29A" ]    [ 1 ]
  Fi22         43/585           13        [ "16A" ]    [ 7 ]
  Fi23   2651/2416635          911        [ "23A" ]    [ 2 ]
    HN        4/34375         8593        [ "19A" ]    [ 1 ]
    HS        64/1155           18        [ "15A" ]    [ 2 ]
    He          3/595          198        [ "14C" ]    [ 3 ]
    J1           1/77           76        [ "19A" ]    [ 1 ]
    J2           5/28            5        [ "10C" ]    [ 3 ]
    J3          2/153           76        [ "19A" ]    [ 2 ]
    J4   1/1647124116   1647124115        [ "29A" ]    [ 1 ]
    Ly     1/35049375     35049374        [ "37A" ]    [ 1 ]
   M11            1/3            2        [ "11A" ]    [ 1 ]
   M12            1/3            2        [ "10A" ]    [ 3 ]
   M22           1/21           20        [ "11A" ]    [ 1 ]
   M23         1/8064         8063        [ "23A" ]    [ 1 ]
   M24       108/1265           11        [ "21A" ]    [ 2 ]
   McL      317/22275           70 [ "15A", "30A" ] [ 3, 3 ]
    ON       10/30723         3072        [ "31A" ]    [ 2 ]
    Ru         1/2880         2879        [ "29A" ]    [ 1 ]
   Suz       141/5720           40        [ "14A" ]    [ 3 ]
    Th       2/267995       133997 [ "27A", "27B" ] [ 2, 2 ]
]]></Example>

<P/>

We see that in all these cases, <M>&total;(G) &lt; 1/2</M> and thus
<M>&sprbound;( G ) \geq 2</M>,
and all sporadic simple groups <M>G</M> except <M>G = M_{11}</M> and <M>G = M_{12}</M>
satisfy <M>&total;(G) &lt; 1/3</M>.
See&nbsp;<Ref Subsect="spreadM11"/> and&nbsp;<Ref Subsect="spreadM12"/> for a proof that also these
two groups have uniform spread at least three.

<P/>

The structures and multiplicities of the maximal subgroups containing <M>s</M>
are as follows.

<P/>

<Example><![CDATA[
gap> for entry in sporinfo do
>      DisplayProbGenMaxesInfo( CharacterTable( entry[1] ), entry[4] );
> od;
Co1, 35A: (A5xJ2):2  (1)
          (A6xU3(3)):2  (2)
          (A7xL2(7)):2  (1)
Co2, 23A: M23  (1)
Co3, 21A: U3(5).3.2  (2)
          L3(4).D12  (1)
          s3xpsl(2,8).3  (1)
F3+, 29A: 29:14  (1)
Fi22, 16A: 2^10:m22  (1)
           (2x2^(1+8)):U4(2):2  (1)
           2F4(2)'  (4)
           2^(5+8):(S3xA6)  (1)
Fi23, 23A: 2..11.m23  (1)
           L2(23)  (1)
HN, 19A: U3(8).3_1  (1)
HS, 15A: A8.2  (1)
         5:4xa5  (1)
He, 14C: 2^1+6.psl(3,2)  (1)
         7^2:2psl(2,7)  (1)
         7^(1+2):(S3x3)  (1)
J1, 19A: 19:6  (1)
J2, 10C: 2^1+4b:a5  (1)
         a5xd10  (1)
         5^2:D12  (1)
J3, 19A: L2(19)  (1)
         J3M3  (1)
J4, 29A: frob  (1)
Ly, 37A: 37:18  (1)
M11, 11A: L2(11)  (1)
M12, 10A: A6.2^2  (1)
          M12M4  (1)
          2xS5  (1)
M22, 11A: L2(11)  (1)
M23, 23A: 23:11  (1)
M24, 21A: L3(4).3.2_2  (1)
          2^6:(psl(3,2)xs3)  (1)
McL, 15A: 3^(1+4):2S5  (1)
          2.A8  (1)
          5^(1+2):3:8  (1)
McL, 30A: 3^(1+4):2S5  (1)
          2.A8  (1)
          5^(1+2):3:8  (1)
ON, 31A: L2(31)  (1)
         ONM8  (1)
Ru, 29A: L2(29)  (1)
Suz, 14A: J2.2  (2)
          (a4xpsl(3,4)):2  (1)
Th, 27A: ThN3B  (1)
         ThM7  (1)
Th, 27B: ThN3B  (1)
         ThM7  (1)
]]></Example>

<P/>

For the remaining two sporadic simple groups, <M>B</M> and <M>M</M>,
we choose suitable elements <M>s</M>.
If <M>G = B</M> and <M>s \in G</M> is of order <M>47</M> then,
by&nbsp;<Cite Key="Wil99"/>,
<M>&M;(G,s) = \{ 47:23 \}</M>.

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "B" ), "47A",
>        [ CharacterTable( "47:23" ) ], [ 1 ] );
1/174702778623598780219392000000
]]></Example>

<P/>

If <M>G = M</M> and <M>s \in G</M> is of order <M>59</M> then, by&nbsp;<Cite Key="HW04"/>,
<M>&M;(G,s) = \{ L_2(59) \}</M>.
In this case, the permutation character is not uniquely determined by the
character tables, but all possibilities lead to the same value for
<M>&total;(G)</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "M" );;
gap> s:= CharacterTable( "L2(59)" );;
gap> pi:= PossiblePermutationCharacters( s, t );;
gap> Length( pi );
5
gap> spos:= Position( OrdersClassRepresentatives( t ), 59 );
152
gap> Set( pi, x -> Maximum( ApproxP( [ x ], spos ) ) );
[ 1/3385007637938037777290625 ]
]]></Example>

<P/>

Essentially the same approach is taken in&nbsp;<Cite Key="GM01"/>.
However, there <M>s</M> is restricted to classes of prime order.
Thus the results in the above table are better for <M>J_2</M>, <M>HS</M>, <M>M_{24}</M>,
<M>McL</M>, <M>He</M>, <M>Suz</M>, <M>Co_3</M>, <M>Fi_{22}</M>, <M>Ly</M>, <M>Th</M>, <M>Co_1</M>, and <M>J_4</M>.
Besides that, the value <M>10\,999</M> claimed in&nbsp;<Cite Key="GM01"/>
for <M>&sprtotal;( HN )</M> is not correct.

<P/>

<!-- % And they do not write how they obtain their results, -->
<!-- % presumably they also rely on the character table data plus the fusions. -->
<!-- % In fact, this information is the largest part of the result, -->
<!-- % since a few lines of &GAP; code suffice for the computations. -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="probgen:sporaut">
<Heading>Automorphism Groups of Sporadic Simple Groups</Heading>

Next we consider the automorphism groups of the sporadic simple groups.
There are exactly <M>12</M> cases where nontrivial outer automorphisms exist,
and then the simple group <M>S</M> has index <M>2</M>
in its automorphism group <M>G</M>.

<P/>

<Example><![CDATA[
gap> sporautnames:= AllCharacterTableNames( IsSporadicSimple, true,
>                       IsDuplicateTable, false,
>                       OfThose, AutomorphismGroup );;
gap> sporautnames:= Difference( sporautnames, spornames );
[ "F3+.2", "Fi22.2", "HN.2", "HS.2", "He.2", "J2.2", "J3.2", "M12.2", 
  "M22.2", "McL.2", "ON.2", "Suz.2" ]
]]></Example>

<P/>

First we compute the values <M>&total;^{\prime}(G,s)</M>,
for the same <M>s \in S</M> that were chosen for the simple group <M>S</M>
in Section&nbsp;<Ref Subsect="subsect:spor"/>.

<P/>

For six of the groups <M>G</M> in question,
the character tables of all maximal subgroups are available in the &GAP;
Character Table Library.
In these cases, the values <M>&total;^{\prime}( G, s )</M>
can be computed using <C>ProbGenInfoAlmostSimple</C>.

<P/>

<E>(The above statement can meanwhile be replaced by the statement that
the character tables of all maximal subgroups are available for all twelve
groups.
We show the table results for all these groups but keep the individual
computations from the original computations.)</E>

<P/>

<Example><![CDATA[
gap> sporautinfo:= [];;
gap> fails:= [];;
gap> for name in sporautnames do
>      tbl:= CharacterTable( name{ [ 1 .. Position( name, '.' ) - 1 ] } );
>      tblG:= CharacterTable( name );
>      info:= ProbGenInfoSimple( tbl );
>      info:= ProbGenInfoAlmostSimple( tbl, tblG,
>          List( info[4], x -> Position( AtlasClassNames( tbl ), x ) ) );
>      if info = fail then
>        Add( fails, name );
>      else
>        Add( sporautinfo, info );
>      fi;
>    od;
gap> PrintFormattedArray( sporautinfo );
   F3+.2         0         [ "29AB" ]    [ 1 ]
  Fi22.2  251/3861         [ "16AB" ]    [ 7 ]
    HN.2    1/6875         [ "19AB" ]    [ 1 ]
    HS.2    36/275          [ "15A" ]    [ 2 ]
    He.2   37/9520         [ "14CD" ]    [ 3 ]
    J2.2      1/15         [ "10CD" ]    [ 3 ]
    J3.2    1/1080         [ "19AB" ]    [ 1 ]
   M12.2      4/99          [ "10A" ]    [ 1 ]
   M22.2      1/21         [ "11AB" ]    [ 1 ]
   McL.2      1/63 [ "15AB", "30AB" ] [ 3, 3 ]
    ON.2   1/84672         [ "31AB" ]    [ 1 ]
   Suz.2 661/46332          [ "14A" ]    [ 3 ]
]]></Example>

<P/>

Note that for <M>S = McL</M>,
the bound <M>&total;^{\prime}(G,s)</M> for <M>G = S.2</M>
(in the second column) is worse than the bound for the simple group <M>S</M>.

<P/>

The structures and multiplicities of the maximal subgroups containing <M>s</M>
are as follows.

<P/>

<Example><![CDATA[
gap> for entry in sporautinfo do
>      DisplayProbGenMaxesInfo( CharacterTable( entry[1] ), entry[3] );
> od;
F3+.2, 29AB: F3+  (1)
             frob  (1)
Fi22.2, 16AB: Fi22  (1)
              Fi22.2M4  (1)
              (2x2^(1+8)):(U4(2):2x2)  (1)
              2F4(2)'.2  (4)
              2^(5+8):(S3xS6)  (1)
HN.2, 19AB: HN  (1)
            U3(8).6  (1)
HS.2, 15A: HS  (1)
           S8x2  (1)
           5:4xS5  (1)
He.2, 14CD: He  (1)
            2^(1+6)_+.L3(2).2  (1)
            7^2:2.L2(7).2  (1)
            7^(1+2):(S3x6)  (1)
J2.2, 10CD: J2  (1)
            2^(1+4).S5  (1)
            (A5xD10).2  (1)
            5^2:(4xS3)  (1)
J3.2, 19AB: J3  (1)
            19:18  (1)
M12.2, 10A: M12  (1)
            (2^2xA5):2  (1)
M22.2, 11AB: M22  (1)
             L2(11).2  (1)
McL.2, 15AB: McL  (1)
             3^(1+4):4S5  (1)
             Isoclinic(2.A8.2)  (1)
             5^(1+2):(24:2)  (1)
McL.2, 30AB: McL  (1)
             3^(1+4):4S5  (1)
             Isoclinic(2.A8.2)  (1)
             5^(1+2):(24:2)  (1)
ON.2, 31AB: ON  (1)
            31:30  (1)
Suz.2, 14A: Suz  (1)
            J2.2x2  (2)
            (A4xL3(4):2_3):2  (1)
]]></Example>

<P/>

Note that the maximal subgroups <M>L_2(19)</M> of <M>J_3</M> do not extend
to <M>J_3.2</M> and that a class of maximal subgroups of the type
<M>19:18</M> appears in <M>J_3.2</M>
whose intersection with <M>J_3</M> is not maximal in <M>J_3</M>.
Similarly, the maximal subgroups <M>A_6.2^2</M> of <M>M_{12}</M> do not extend
to <M>M_{12}.2</M>.

<P/>

For the other six groups, we use individual computations.

<P/>

In the case <M>S = Fi_{24}^{\prime}</M>,
the unique maximal subgroup <M>29:14</M> that contains an element <M>s</M>
of order <M>29</M> extends to a group of the type
<M>29:28</M> in <M>Fi_{24}</M>,
which is a nonsplit extension of <M>29:14</M>.

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "Fi24'.2" ), "29AB",
>        [ CharacterTable( "29:28" ) ], [ 1 ], "outer" );
0
]]></Example>

<P/>

In the case <M>S = Fi_{22}</M>, there are four classes of maximal subgroups
that contain <M>s</M> of order <M>16</M>.
They extend to <M>G = Fi_{22}.2</M>,
and none of the <E>novelties</E> in <M>G</M> (i.&nbsp;e., subgroups of <M>G</M> that are
maximal in <M>G</M> but whose intersections with <M>S</M> are not maximal in <M>S</M>)
contains <M>s</M>, cf.&nbsp;<Cite Key="CCN85" Where="p.&nbsp;163"/>.

<P/>

<Example><![CDATA[
gap> 16 in OrdersClassRepresentatives( CharacterTable( "U4(2).2" ) );
false
gap> 16 in OrdersClassRepresentatives( CharacterTable( "G2(3).2" ) );
false
]]></Example>

<P/>

The character tables of three of the four extensions are available in the
&GAP; Character Table Library.
The permutation character on the cosets of the fourth extension can be
obtained as the extension of the permutation character of <M>S</M> on the
cosets of its maximal subgroup of the type <M>2^{5+8}:(S_3 \times A_6)</M>.

<P/>

<Example><![CDATA[
gap> t2:= CharacterTable( "Fi22.2" );;
gap> prim:= List( [ "Fi22.2M4", "(2x2^(1+8)):(U4(2):2x2)", "2F4(2)" ],
>        n -> PossiblePermutationCharacters( CharacterTable( n ), t2 ) );;
gap> t:= CharacterTable( "Fi22" );;
gap> pi:= PossiblePermutationCharacters(
>             CharacterTable( "2^(5+8):(S3xA6)" ), t );
[ Character( CharacterTable( "Fi22" ),
  [ 3648645, 56133, 10629, 2245, 567, 729, 405, 81, 549, 165, 133, 
      37, 69, 20, 27, 81, 9, 39, 81, 19, 1, 13, 33, 13, 1, 0, 13, 13, 
      5, 1, 0, 0, 0, 8, 4, 0, 0, 9, 3, 15, 3, 1, 1, 1, 1, 3, 3, 1, 0, 
      0, 0, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2 ] ) ]
gap> torso:= CompositionMaps( pi[1], InverseMap( GetFusionMap( t, t2 ) ) );
[ 3648645, 56133, 10629, 2245, 567, 729, 405, 81, 549, 165, 133, 37, 
  69, 20, 27, 81, 9, 39, 81, 19, 1, 13, 33, 13, 1, 0, 13, 13, 5, 1, 
  0, 0, 0, 8, 4, 0, 9, 3, 15, 3, 1, 1, 1, 3, 3, 1, 0, 0, 2, 1, 0, 0, 
  0, 0, 0, 0, 1, 1, 2 ]
gap> ext:= PermChars( t2, rec( torso:= torso ) );;
gap> Add( prim, ext );
gap> prim:= Concatenation( prim );;  Length( prim );
4
gap> spos:= Position( OrdersClassRepresentatives( t2 ), 16 );;
gap> List( prim, x -> x[ spos ] );
[ 1, 1, 4, 1 ]
gap> sigma:= ApproxP( prim, spos );;
gap> Maximum( sigma{ Difference( PositionsProperty(
>                        OrdersClassRepresentatives( t2 ), IsPrimeInt ),
>                        ClassPositionsOfDerivedSubgroup( t2 ) ) } );
251/3861
]]></Example>

<P/>

In the case <M>S = HN</M>, the unique maximal subgroup <M>U_3(8).3</M>
that contains the fixed element <M>s</M> of order <M>19</M>
extends to a group of the type <M>U_3(8).6</M> in <M>HN.2</M>.

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "HN.2" ), "19AB",
>        [ CharacterTable( "U3(8).6" ) ], [ 1 ], "outer" );
1/6875
]]></Example>

<P/>

In the case <M>S = HS</M>, there are two classes of maximal subgroups
that contain <M>s</M> of order <M>15</M>.
They extend to <M>G = HS.2</M>,
and none of the novelties in <M>G</M> contains <M>s</M>
(cf.&nbsp;<Cite Key="CCN85" Where="p.&nbsp;80"/>).

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "HS.2" ), "15A",
>      [ CharacterTable( "S8x2" ),
>        CharacterTable( "5:4" ) * CharacterTable( "A5.2" ) ], [ 1, 1 ],
>      "outer" );
36/275
]]></Example>

<P/>

In the case <M>S = He</M>, there are three classes of maximal subgroups
that contain <M>s</M> in the class <C>14C</C>.
They extend to <M>G = He.2</M>,
and none of the novelties in <M>G</M> contains <M>s</M>
(cf.&nbsp;<Cite Key="CCN85" Where="p.&nbsp;104"/>).
We compute the extensions of the corresponding primitive permutation
characters of <M>S</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "He" );;
gap> t2:= CharacterTable( "He.2" );;
gap> prim:= PrimitivePermutationCharacters( t );;
gap> spos:= Position( AtlasClassNames( t ), "14C" );;
gap> prim:= Filtered( prim, x -> x[ spos ] <> 0 );;
gap> map:= InverseMap( GetFusionMap( t, t2 ) );;
gap> torso:= List( prim, pi -> CompositionMaps( pi, map ) );
[ [ 187425, 945, 449, 0, 21, 21, 25, 25, 0, 0, 5, 0, 0, 7, 1, 0, 0, 
      1, 0, 1, 0, 0, 0, 0, 0, 0 ], 
  [ 244800, 0, 64, 0, 84, 0, 0, 16, 0, 0, 4, 24, 45, 3, 4, 0, 0, 0, 
      0, 1, 0, 0, 0, 0, 0, 0 ], 
  [ 652800, 0, 512, 120, 72, 0, 0, 0, 0, 0, 8, 8, 22, 1, 0, 0, 0, 0, 
      0, 1, 0, 0, 1, 1, 2, 0 ] ]
gap> ext:= List( torso, x -> PermChars( t2, rec( torso:= x ) ) );
[ [ Character( CharacterTable( "He.2" ),
      [ 187425, 945, 449, 0, 21, 21, 25, 25, 0, 0, 5, 0, 0, 7, 1, 0, 
          0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 315, 15, 0, 0, 3, 7, 7, 3, 0, 
          0, 0, 1, 1, 0, 1, 1, 0, 0, 0 ] ) ], 
  [ Character( CharacterTable( "He.2" ),
      [ 244800, 0, 64, 0, 84, 0, 0, 16, 0, 0, 4, 24, 45, 3, 4, 0, 0, 
          0, 0, 1, 0, 0, 0, 0, 0, 0, 360, 0, 0, 0, 6, 0, 0, 0, 0, 0, 
          3, 2, 2, 0, 0, 0, 0, 0, 0 ] ) ], 
  [ Character( CharacterTable( "He.2" ),
      [ 652800, 0, 512, 120, 72, 0, 0, 0, 0, 0, 8, 8, 22, 1, 0, 0, 0, 
          0, 0, 1, 0, 0, 1, 1, 2, 0, 480, 0, 120, 0, 12, 0, 0, 0, 0, 
          0, 4, 0, 0, 0, 0, 0, 0, 1, 1 ] ) ] ]
gap> spos:= Position( AtlasClassNames( t2 ), "14CD" );;
gap> sigma:= ApproxP( Concatenation( ext ), spos );;
gap> Maximum( sigma{ Difference( PositionsProperty(
>                        OrdersClassRepresentatives( t2 ), IsPrimeInt ),
>                        ClassPositionsOfDerivedSubgroup( t2 ) ) } );
37/9520
]]></Example>

<P/>

In the case <M>S = O'N</M>, the two classes of maximal subgroups of the type
<M>L_2(31)</M> do not extend to <M>G = O'N.2</M>, and a class of novelties of the
structure <M>31:30</M> appears (see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;132"/>).

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "ON.2" ), "31AB",
>        [ CharacterTable( "P:Q", [ 31, 30 ] ) ], [ 1 ], "outer" );
1/84672
]]></Example>

<P/>

Now we consider also <M>&total;(G,\hat{s})</M>,
for suitable <M>\hat{s} \in G \setminus S</M>;
this yields lower bounds for the spread of the nonsimple groups <M>G</M>.
(These results are shown in the last two columns of&nbsp;<Cite Key="BGK" Where="Table&nbsp;9"/>.)

<P/>

As above, we use the known character tables of the maximal subgroups
in order to compute the optimal choice for <M>\hat{s} \in G \setminus S</M>.
(We may use the function <C>ProbGenInfoSimple</C> although the groups are not
simple; all we need is that the relevant maximal subgroups are
self-normalizing.)

<P/>

<Example><![CDATA[
gap> sporautinfo2:= [];;
gap> for name in List( sporautinfo, x -> x[1] ) do
>      Add( sporautinfo2, ProbGenInfoSimple( CharacterTable( name ) ) );
>    od;
gap> PrintFormattedArray( sporautinfo2 );
   F3+.2    19/5684  299        [ "42E" ]   [ 10 ]
  Fi22.2 1165/20592   17        [ "24G" ]    [ 3 ]
    HN.2     1/1425 1424        [ "24B" ]    [ 4 ]
    HS.2     21/550   26        [ "20C" ]    [ 4 ]
    He.2    33/4165  126        [ "24A" ]    [ 2 ]
    J2.2       1/15   14        [ "14A" ]    [ 1 ]
    J3.2   77/10260  133        [ "34A" ]    [ 1 ]
   M12.2    113/495    4        [ "12B" ]    [ 3 ]
   M22.2       8/33    4        [ "10A" ]    [ 4 ]
   McL.2      1/135  134        [ "22A" ]    [ 1 ]
    ON.2  61/109368 1792 [ "22A", "38A" ] [ 1, 1 ]
   Suz.2      1/351  350        [ "28A" ]    [ 1 ]
gap> for entry in sporautinfo2 do
>      DisplayProbGenMaxesInfo( CharacterTable( entry[1] ), entry[4] );
> od;
F3+.2, 42E: 2^12.M24  (2)
            2^2.U6(2):S3x2  (1)
            2^(3+12).(L3(2)xS6)  (2)
            (S3xS3xG2(3)):2  (1)
            S6xL2(8):3  (1)
            7:6xS7  (1)
            7^(1+2)_+:(6xS3).2  (2)
Fi22.2, 24G: Fi22.2M4  (1)
             2^(5+8):(S3xS6)  (1)
             3^5:(2xU4(2).2)  (1)
HN.2, 24B: 2^(1+8)_+.(A5xA5).2^2  (1)
           5^2.5.5^2.4S5  (2)
           HN.2M13  (1)
HS.2, 20C: (2xA6.2^2).2  (1)
           HS.2N5  (2)
           5:4xS5  (1)
He.2, 24A: 2^(1+6)_+.L3(2).2  (1)
           S4xL3(2).2  (1)
J2.2, 14A: L3(2).2x2  (1)
J3.2, 34A: L2(17)x2  (1)
M12.2, 12B: L2(11).2  (1)
            D8.(S4x2)  (1)
            3^(1+2):D8  (1)
M22.2, 10A: M22.2M4  (1)
            A6.2^2  (1)
            L2(11).2  (2)
McL.2, 22A: 2xM11  (1)
ON.2, 22A: J1x2  (1)
ON.2, 38A: J1x2  (1)
Suz.2, 28A: (A4xL3(4):2_3):2  (1)
]]></Example>

<P/>

In the other six cases,
we do not have the complete lists of primitive permutation characters,
so we choose a suitable element <M>\hat{s}</M> for each group.
It is sufficient to prescribe <M>|\hat{s}|</M>, as follows.

<P/>

<Example><![CDATA[
gap> sporautchoices:= [
>        [ "Fi22",  "Fi22.2",  42 ],
>        [ "Fi24'", "Fi24'.2", 46 ],
>        [ "He",    "He.2",    42 ],
>        [ "HN",    "HN.2",    44 ],
>        [ "HS",    "HS.2",    30 ],
>        [ "ON",    "ON.2",    38 ], ];;
]]></Example>

<P/>

First we list the maximal subgroups of the corresponding simple groups
that contain the square of <M>\hat{s}</M>.

<P/>

<Example><![CDATA[
gap> for triple in sporautchoices do
>      tbl:= CharacterTable( triple[1] );
>      tbl2:= CharacterTable( triple[2] );
>      spos2:= PowerMap( tbl2, 2,
>          Position( OrdersClassRepresentatives( tbl2 ), triple[3] ) );
>      spos:= Position( GetFusionMap( tbl, tbl2 ), spos2 );
>      DisplayProbGenMaxesInfo( tbl, AtlasClassNames( tbl ){ [ spos ] } );
>    od;
Fi22, 21A: O8+(2).3.2  (1)
           S3xU4(3).2_2  (1)
           A10.2  (1)
           A10.2  (1)
F3+, 23A: Fi23  (1)
          F3+M7  (1)
He, 21B: 3.A7.2  (1)
         7^(1+2):(S3x3)  (1)
         7:3xpsl(3,2)  (2)
HN, 22A: 2.HS.2  (1)
HS, 15A: A8.2  (1)
         5:4xa5  (1)
ON, 19B: L3(7).2  (1)
         ONM2  (1)
         J1  (1)
]]></Example>

<P/>

According to&nbsp;<Cite Key="CCN85"/>, exactly
the following maximal subgroups of the simple group <M>S</M> in the above list
do <E>not</E> extend to <M>&Aut;(S)</M>:
The two <M>S_{10}</M> type subgroups of <M>Fi_{22}</M>
and the two <M>L_3(7).2</M> type subgroups of <M>O'N</M>.

<P/>

Furthermore, the following maximal subgroups of <M>&Aut;(S)</M> with the property
that the intersection with <M>S</M> is not maximal in <M>S</M> have to be considered
whether they contain <M>s^{\prime}</M>:
<M>G_2(3).2</M> and <M>3^5:(2 \times U_4(2).2)</M> in <M>Fi_{22}.2</M>.
(Note that the order of the <M>7^{1+2}_+:(3 \times D_{16})</M> type subgroup in
<M>O'N.2</M> is obviously not divisible by <M>19</M>.)

<P/>

<Example><![CDATA[
gap> 42 in OrdersClassRepresentatives( CharacterTable( "G2(3).2" ) );
false
gap> Size( CharacterTable( "U4(2)" ) ) mod 7 = 0;
false
]]></Example>

<P/>

So we take the extensions of the above maximal subgroups,
as described in&nbsp;<Cite Key="CCN85"/>.

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "Fi22.2" ), "42A",
>     [ CharacterTable( "O8+(2).3.2" ) * CharacterTable( "Cyclic", 2 ),
>       CharacterTable( "S3" ) * CharacterTable( "U4(3).(2^2)_{122}" ) ],
>     [ 1, 1 ] );
163/1170
gap> SigmaFromMaxes( CharacterTable( "Fi24'.2" ), "46A",
>      [ CharacterTable( "Fi23" ) * CharacterTable( "Cyclic", 2 ),
>        CharacterTable( "2^12.M24" ) ],
>      [ 1, 1 ] );
566/5481
gap> SigmaFromMaxes( CharacterTable( "He.2" ), "42A",
>      [ CharacterTable( "3.A7.2" ) * CharacterTable( "Cyclic", 2 ),
>        CharacterTable( "7^(1+2):(S3x6)" ),
>        CharacterTable( "7:6" ) * CharacterTable( "L3(2)" ) ],
>      [ 1, 1, 1 ] );
1/119
gap> SigmaFromMaxes( CharacterTable( "HN.2" ), "44A",
>      [ CharacterTable( "4.HS.2" ) ],
>      [ 1 ] );
997/192375
gap> SigmaFromMaxes( CharacterTable( "HS.2" ), "30A",
>      [ CharacterTable( "S8" ) * CharacterTable( "C2" ),
>        CharacterTable( "5:4" ) * CharacterTable( "S5" ) ],
>      [ 1, 1 ] );
36/275
gap> SigmaFromMaxes( CharacterTable( "ON.2" ), "38A",
>      [ CharacterTable( "J1" ) * CharacterTable( "C2" ) ],
>      [ 1 ] );
61/109368
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="easyloop">
<Heading>Other Simple Groups &ndash; Easy Cases</Heading>

We are interested in simple groups <M>G</M> for which <C>ProbGenInfoSimple</C>
does not guarantee <M>&sprtotal;(G) \geq 3</M>.
So we examine the remaining tables of simple groups in the &GAP;
Character Table Library,
and distinguish the following three cases:
Either <C>ProbGenInfoSimple</C> yields the lower bound at least three,
or a smaller bound,
or the computation of a lower bound fails because not enough information
is available to compute the primitive permutation characters.

<P/>

<Example><![CDATA[
gap> names:= AllCharacterTableNames( IsSimple, true, IsAbelian, false,
>                                    IsDuplicateTable, false );;
gap> names:= Difference( names, spornames );;
gap> fails:= [];;
gap> lessthan3:= [];;
gap> atleast3:= [];;
gap> for name in names do
>      tbl:= CharacterTable( name );
>      info:= ProbGenInfoSimple( tbl );
>      if info = fail then
>        Add( fails, name );
>      elif info[3] < 3 then
>        Add( lessthan3, info );
>      else
>        Add( atleast3, info );
>      fi;
>    od;
]]></Example>

<P/>

For the following simple groups,
(currently) not enough information is available
in the &GAP; Character Table Library and in the &GAP; Library of Tables
of Marks,
for computing a lower bound for <M>&total;(G)</M>.
Some of these groups will be dealt with in later sections,
and for the other groups, the bounds derived with theoretical arguments
in&nbsp;<Cite Key="BGK"/> are sufficient,
so we need no &GAP; computations for them.

<P/>

<Example><![CDATA[
gap> fails;
[ "2E6(2)", "2F4(8)", "3D4(3)", "3D4(4)", "A14", "A15", "A16", "A17", 
  "A18", "A19", "E6(2)", "L4(4)", "L4(5)", "L4(9)", "L5(3)", "L8(2)", 
  "O10+(2)", "O10+(3)", "O10-(2)", "O10-(3)", "O12+(2)", "O12+(3)", 
  "O12-(2)", "O12-(3)", "O7(5)", "O8+(7)", "O8-(3)", "O9(3)", 
  "R(27)", "S10(2)", "S12(2)", "S4(7)", "S4(8)", "S4(9)", "S6(4)", 
  "S6(5)", "S8(3)", "U4(4)", "U4(5)", "U5(3)", "U5(4)", "U6(4)", 
  "U7(2)" ]
]]></Example>

<P/>

The following simple groups appear in&nbsp;<Cite Key="BGK" Where="Table&nbsp;1&ndash;6"/>.
More detailed computations can be found in the sections&nbsp;<Ref Subsect="A5"/>,
<Ref Subsect="A6"/>, <Ref Subsect="A7"/>, <Ref Subsect="O8p2"/>, <Ref Subsect="O8p3"/>, <Ref Subsect="S62"/>, <Ref Subsect="U42"/>, <Ref Subsect="U43"/>.

<P/>

<Example><![CDATA[
gap> PrintFormattedArray( lessthan3 );
      A5      1/3 2                [ "5A" ]       [ 1 ]
      A6      2/3 1                [ "5A" ]       [ 2 ]
      A7      2/5 2                [ "7A" ]       [ 2 ]
   O7(3)  199/351 1               [ "14A" ]       [ 3 ]
  O8+(2)  334/315 0 [ "15A", "15B", "15C" ] [ 7, 7, 7 ]
  O8+(3) 863/1820 2 [ "20A", "20B", "20C" ] [ 8, 8, 8 ]
   S6(2)      4/7 1                [ "9A" ]       [ 4 ]
   S8(2)     8/15 1               [ "17A" ]       [ 3 ]
   U4(2)    21/40 1               [ "12A" ]       [ 2 ]
   U4(3)   53/135 2                [ "7A" ]       [ 7 ]
]]></Example>

<P/>

For the following simple groups <M>G</M>,
the inequality <M>&total;(G) &lt; 1/3</M> follows from the loop above.
The columns show the name of <M>G</M>, the values <M>&total;(G)</M> and <M>&sprtotal;(G)</M>,
the class names of <M>s</M> for which these values are attained,
and <M>|&M;(G,s)|</M>.

<P/>

(We increase the line length for this table.
Even with this width,
the entry for the group <M>L_7(2)</M> would not fit on one screen line,
we show it separately below.)

<P/>

<Example><![CDATA[
gap> oldsize:= SizeScreen();;
gap> SizeScreen( [ 80 ] );;
gap> PrintFormattedArray( Filtered( atleast3, l -> l[1] <> "L7(2)" ) );
  2F4(2)'  118/1755   14                           [ "16A" ]             [ 2 ]
   3D4(2)    1/5292 5291                           [ "13A" ]             [ 1 ]
      A10      3/10    3                           [ "21A" ]             [ 1 ]
      A11     2/105   52                           [ "11A" ]             [ 2 ]
      A12       2/9    4                           [ "35A" ]             [ 1 ]
      A13    4/1155  288                           [ "13A" ]             [ 5 ]
       A8      3/14    4                           [ "15A" ]             [ 1 ]
       A9      9/35    3                      [ "9A", "9B" ]          [ 4, 4 ]
    F4(2)     9/595   66                           [ "13A" ]             [ 5 ]
    G2(3)       1/7    6                           [ "13A" ]             [ 3 ]
    G2(4)      1/21   20                           [ "13A" ]             [ 2 ]
    G2(5)      1/31   30                     [ "7A", "21A" ]         [ 10, 1 ]
  L2(101)     1/101  100                    [ "51A", "17A" ]          [ 1, 1 ]
  L2(103)   53/5253   99             [ "52A", "26A", "13A" ]       [ 1, 1, 1 ]
  L2(107)   55/5671  103 [ "54A", "27A", "18A", "9A", "6A" ] [ 1, 1, 1, 1, 1 ]
  L2(109)     1/109  108                    [ "55A", "11A" ]          [ 1, 1 ]
   L2(11)      7/55    7                            [ "6A" ]             [ 1 ]
  L2(113)     1/113  112                    [ "57A", "19A" ]          [ 1, 1 ]
  L2(121)     1/121  120                           [ "61A" ]             [ 1 ]
  L2(125)     1/125  124        [ "63A", "21A", "9A", "7A" ]    [ 1, 1, 1, 1 ]
   L2(13)      1/13   12                            [ "7A" ]             [ 1 ]
   L2(16)      1/15   14                           [ "17A" ]             [ 1 ]
   L2(17)      1/17   16                            [ "9A" ]             [ 1 ]
   L2(19)    11/171   15                           [ "10A" ]             [ 1 ]
   L2(23)    13/253   19                     [ "6A", "12A" ]          [ 1, 1 ]
   L2(25)      1/25   24                           [ "13A" ]             [ 1 ]
   L2(27)     5/117   23                     [ "7A", "14A" ]          [ 1, 1 ]
   L2(29)      1/29   28                           [ "15A" ]             [ 1 ]
   L2(31)    17/465   27                     [ "8A", "16A" ]          [ 1, 1 ]
   L2(32)      1/31   30              [ "3A", "11A", "33A" ]       [ 1, 1, 1 ]
   L2(37)      1/37   36                           [ "19A" ]             [ 1 ]
   L2(41)      1/41   40                     [ "21A", "7A" ]          [ 1, 1 ]
   L2(43)    23/903   39                    [ "22A", "11A" ]          [ 1, 1 ]
   L2(47)   25/1081   43        [ "24A", "12A", "8A", "6A" ]    [ 1, 1, 1, 1 ]
   L2(49)      1/49   48                           [ "25A" ]             [ 1 ]
   L2(53)      1/53   52                     [ "27A", "9A" ]          [ 1, 1 ]
   L2(59)   31/1711   55       [ "30A", "15A", "10A", "6A" ]    [ 1, 1, 1, 1 ]
   L2(61)      1/61   60                           [ "31A" ]             [ 1 ]
   L2(64)      1/63   62                    [ "65A", "13A" ]          [ 1, 1 ]
   L2(67)   35/2211   63                    [ "34A", "17A" ]          [ 1, 1 ]
   L2(71)   37/2485   67 [ "36A", "18A", "12A", "9A", "6A" ] [ 1, 1, 1, 1, 1 ]
   L2(73)      1/73   72                           [ "37A" ]             [ 1 ]
   L2(79)   41/3081   75       [ "40A", "20A", "10A", "8A" ]    [ 1, 1, 1, 1 ]
    L2(8)       1/7    6                      [ "3A", "9A" ]          [ 1, 1 ]
   L2(81)      1/81   80                           [ "41A" ]             [ 1 ]
   L2(83)   43/3403   79 [ "42A", "21A", "14A", "7A", "6A" ] [ 1, 1, 1, 1, 1 ]
   L2(89)      1/89   88              [ "45A", "15A", "9A" ]       [ 1, 1, 1 ]
   L2(97)      1/97   96                     [ "49A", "7A" ]          [ 1, 1 ]
   L3(11)    1/6655 6654                   [ "19A", "133A" ]          [ 1, 1 ]
    L3(2)       1/4    3                            [ "7A" ]             [ 1 ]
    L3(3)      1/24   23                           [ "13A" ]             [ 1 ]
    L3(4)       1/5    4                            [ "7A" ]             [ 3 ]
    L3(5)     1/250  249                           [ "31A" ]             [ 1 ]
    L3(7)    1/1372 1371                           [ "19A" ]             [ 1 ]
    L3(8)    1/1792 1791                           [ "73A" ]             [ 1 ]
    L3(9)    1/2880 2879                           [ "91A" ]             [ 1 ]
    L4(3)   53/1053   19                           [ "20A" ]             [ 1 ]
    L5(2)    1/5376 5375                           [ "31A" ]             [ 1 ]
    L6(2) 365/55552  152                    [ "21A", "63A" ]          [ 2, 2 ]
   O8-(2)      1/63   62                           [ "17A" ]             [ 1 ]
    S4(4)      4/15    3                           [ "17A" ]             [ 2 ]
    S4(5)       1/5    4                           [ "13A" ]             [ 1 ]
    S6(3)     1/117  116                           [ "14A" ]             [ 2 ]
   Sz(32)    1/1271 1270                     [ "5A", "25A" ]          [ 1, 1 ]
    Sz(8)      1/91   90                            [ "5A" ]             [ 1 ]
   U3(11)    1/6655 6654                           [ "37A" ]             [ 1 ]
    U3(3)     16/63    3                     [ "6A", "12A" ]          [ 2, 2 ]
    U3(4)     1/160  159                           [ "13A" ]             [ 1 ]
    U3(5)    46/525   11                           [ "10A" ]             [ 2 ]
    U3(7)    1/1372 1371                           [ "43A" ]             [ 1 ]
    U3(8)    1/1792 1791                           [ "19A" ]             [ 1 ]
    U3(9)    1/3600 3599                           [ "73A" ]             [ 1 ]
    U5(2)      1/54   53                           [ "11A" ]             [ 1 ]
    U6(2)      5/21    4                           [ "11A" ]             [ 4 ]
gap> SizeScreen( oldsize );;
gap> First( atleast3, l -> l[1] = "L7(2)" );
[ "L7(2)", 1/4388290560, 4388290559, [ "127A" ], [ 1 ] ]
]]></Example>

<P/>

It should be mentioned that&nbsp;<Cite Key="BW1"/> states the following
lower bounds for the uniform spread of the groups <M>L_2(q)</M>.

<P/>

<Table Align="|l|l|">
  <Row>
    <Item><M>q-2</M></Item>
    <Item>if <M>4 \leq q</M> is even,</Item>
  </Row>
  <Row>
    <Item><M>q-1</M></Item>
    <Item>if <M>11 \leq q \equiv 1 \pmod{4}</M>,</Item>
  </Row>
  <Row>
    <Item><M>q-4</M></Item>
    <Item>if <M>11 \leq q \equiv -1 \pmod{4}</M>.</Item>
  </Row>
</Table>

<P/>

These bounds appear in the third column of the above table.
Furthermore, <Cite Key="BW1"/> states that the (uniform) spread
of alternating groups of even degree at least <M>8</M> is exactly <M>4</M>.

<P/>

For the sake of completeness,
Table&nbsp;II gives an overview of the
sets <M>&M;(G,s)</M> for those cases in the above list
that are needed in&nbsp;<Cite Key="BGK"/>
but that do not require a further discussion here.
The structure of the maximal subgroups and the order of <M>s</M> in the table
refer to the matrix groups not to the simple groups.
The number of the subgroups has been shown above,
the structure follows from&nbsp;<Cite Key="CCN85"/>.

<P/>

<Table Align="|l|l|r|r|">
<Caption>Table II: Maximal subgroups/></Caption>
<HorLine/>
<Row>
   <Item><M>G</M></Item>
   <Item><M>&M;(G,s)</M></Item>
   <Item><M>|s|</M></Item>
   <Item>see&nbsp;<Cite Key="CCN85"/></Item>
</Row>
<HorLine/>
<HorLine/>
<Row>
   <Item><M>&SL;(3,4) = 3.L_3(4)</M></Item>
   <Item><M>3 \times L_3(2), 3 \times L_3(2), 3 \times L_3(2)</M></Item>
   <Item><M>21</M></Item>
   <Item>p.&nbsp;23</Item>
</Row>
<HorLine/>
<Row>
   <Item><M>\Omega^-(8,2) = O^-_8(2)</M></Item>
   <Item><M>\Omega^-(4,4).2 = L_2(16).2</M></Item>
   <Item><M>17</M></Item>
   <Item>p.&nbsp;89</Item>
</Row>
<HorLine/>
<Row>
   <Item><M>&Sp;(4,4) = S_4(4)</M></Item>
   <Item><M>\Omega^-(4,4).2 = L_2(16).2, &Sp;(2,16).2 = L_2(16).2</M></Item>
   <Item><M>17</M></Item>
   <Item>p.&nbsp;44</Item>
</Row>
<Row>
   <Item><M>&Sp;(6,3) = 2.S_6(3)</M></Item>
   <Item><M>(4 \times U_3(3)).2, &Sp;(2,17).3 = 2.L_2(27).3</M></Item>
   <Item><M>28</M></Item>
   <Item>p.&nbsp;113</Item>
</Row>
<HorLine/>
<Row>
   <Item><M>&SU;(3,3) = U_3(3)</M></Item>
   <Item><M>3^{1+2}_+:8, &GU;(2,3) = 4.S_4</M></Item>
   <Item><M>6</M></Item>
   <Item>p.&nbsp;14</Item>
</Row>
<Row>
   <Item><M>&SU;(3,5) = 3.U_3(5)</M></Item>
   <Item><M>3 \times 5^{1+2}_+:8, &GU;(2,5) = 3 \times 2S_5</M></Item>
   <Item><M>30</M></Item>
   <Item>p.&nbsp;34</Item>
</Row>
<Row>
   <Item><M>&SU;(5,2) = U_5(2)</M></Item>
   <Item><M>L_2(11)</M></Item>
   <Item><M>11</M></Item>
   <Item>p.&nbsp;73</Item>
</Row>
<HorLine/>
</Table>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="easyloopaut">
<Heading>Automorphism Groups of other Simple Groups &ndash; Easy Cases</Heading>

We deal with automorphic extensions of those simple groups that are
listed in Table&nbsp;I and that have been treated
successfully in Section&nbsp;<Ref Subsect="easyloop"/>.

<P/>

For the following groups, <C>ProbGenInfoAlmostSimple</C> can be used
because &GAP; can compute their primitive permutation characters.

<P/>

<Example><![CDATA[
gap> list:= [
>   [ "A5", "A5.2" ],
>   [ "A6", "A6.2_1" ],
>   [ "A6", "A6.2_2" ],
>   [ "A6", "A6.2_3" ],
>   [ "A7", "A7.2" ],
>   [ "A8", "A8.2" ],
>   [ "A9", "A9.2" ],
>   [ "A11", "A11.2" ],
>   [ "L3(2)", "L3(2).2" ],
>   [ "L3(3)", "L3(3).2" ],
>   [ "L3(4)", "L3(4).2_1" ],
>   [ "L3(4)", "L3(4).2_2" ],
>   [ "L3(4)", "L3(4).2_3" ],
>   [ "L3(4)", "L3(4).3" ],
>   [ "S4(4)", "S4(4).2" ],
>   [ "U3(3)", "U3(3).2" ],
>   [ "U3(5)", "U3(5).2" ],
>   [ "U3(5)", "U3(5).3" ],
>   [ "U4(2)", "U4(2).2" ],
>   [ "U4(3)", "U4(3).2_1" ],
>   [ "U4(3)", "U4(3).2_3" ],
> ];;
gap> autinfo:= [];;
gap> fails:= [];;
gap> for pair in list do
>      tbl:= CharacterTable( pair[1] );
>      tblG:= CharacterTable( pair[2] );
>      info:= ProbGenInfoSimple( tbl );
>      spos:= List( info[4], x -> Position( AtlasClassNames( tbl ), x ) );
>      Add( autinfo, ProbGenInfoAlmostSimple( tbl, tblG, spos ) );
>    od;
gap> PrintFormattedArray( autinfo );
       A5.2      0        [ "5AB" ]    [ 1 ]
     A6.2_1    2/3        [ "5AB" ]    [ 2 ]
     A6.2_2    1/6         [ "5A" ]    [ 1 ]
     A6.2_3      0        [ "5AB" ]    [ 1 ]
       A7.2   1/15        [ "7AB" ]    [ 1 ]
       A8.2  13/28       [ "15AB" ]    [ 1 ]
       A9.2    1/4        [ "9AB" ]    [ 1 ]
      A11.2  1/945       [ "11AB" ]    [ 1 ]
    L3(2).2    1/4        [ "7AB" ]    [ 1 ]
    L3(3).2   1/18       [ "13AB" ]    [ 1 ]
  L3(4).2_1   3/10        [ "7AB" ]    [ 3 ]
  L3(4).2_2  11/60         [ "7A" ]    [ 1 ]
  L3(4).2_3   1/12        [ "7AB" ]    [ 1 ]
    L3(4).3   1/64         [ "7A" ]    [ 1 ]
    S4(4).2      0       [ "17AB" ]    [ 2 ]
    U3(3).2    2/7 [ "6A", "12AB" ] [ 2, 2 ]
    U3(5).2   2/21        [ "10A" ]    [ 2 ]
    U3(5).3 46/525        [ "10A" ]    [ 2 ]
    U4(2).2  16/45       [ "12AB" ]    [ 2 ]
  U4(3).2_1 76/135         [ "7A" ]    [ 3 ]
  U4(3).2_3 31/162        [ "7AB" ]    [ 3 ]
]]></Example>
<P/>
We see that from this list,
the two groups <M>A_6.2_1 = S_6</M> and <M>U_4(3).2_1</M> require further computations
(see Sections&nbsp;<Ref Subsect="A6"/> and&nbsp;<Ref Subsect="U43"/>, respectively)
because the bound in the second column is larger than <M>1/2</M>.
<P/>
Also <M>U_4(2)</M> is not done by the above,
because in&nbsp;<Cite Key="BGK" Where="Table&nbsp;4"/>,
an element <M>s</M> of order <M>9</M> is chosen
for the simple group, see Section&nbsp;<Ref Subsect="U42"/>.

<P/>

Finally, we deal with automorphic extensions of the groups <M>L_4(3)</M>,
<M>O_8^-(2)</M>, <M>S_6(3)</M>, and <M>U_5(2)</M>.
<P/>
For <M>S = L_4(3)</M> and <M>s \in S</M> of order <M>20</M>,
we have <M>&M;(S,s) = \{ (4 \times A_6):2 \}</M>,
the subgroup has index <M>2\,106</M>, see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;69"/>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "L4(3)" );;
gap> prim:= PrimitivePermutationCharacters( t );;
gap> spos:= Position( AtlasClassNames( t ), "20A" );;
gap> prim:= Filtered( prim, x -> x[ spos ] <> 0 );
[ Character( CharacterTable( "L4(3)" ),
  [ 2106, 106, 42, 0, 27, 27, 0, 46, 6, 6, 1, 7, 7, 0, 3, 3, 0, 0, 0, 
      1, 1, 1, 0, 0, 0, 0, 0, 1, 1 ] ) ]
]]></Example>
<P/>
For the three automorphic extensions of the structure <M>G = S.2</M>,
we compute the extensions of the permutation character,
and the bounds <M>&total;^{\prime}(G,s)</M>.
<P/>
<Example><![CDATA[
gap> for name in [ "L4(3).2_1", "L4(3).2_2", "L4(3).2_3" ] do
>      t2:= CharacterTable( name );
>      map:= InverseMap( GetFusionMap( t, t2 ) );
>      torso:= List( prim, pi -> CompositionMaps( pi, map ) );
>      ext:= Concatenation( List( torso,
>                              x -> PermChars( t2, rec( torso:= x ) ) ) );
>      sigma:= ApproxP( ext, Position( OrdersClassRepresentatives( t2 ), 20 ) );
>      max:= Maximum( sigma{ Difference( PositionsProperty(
>                           OrdersClassRepresentatives( t2 ), IsPrimeInt ),
>                           ClassPositionsOfDerivedSubgroup( t2 ) ) } );
>      Print( name, ":\n", ext, "\n", max, "\n" );
> od;
L4(3).2_1:
[ Character( CharacterTable( "L4(3).2_1" ), 
    [ 2106, 106, 42, 0, 27, 0, 46, 6, 6, 1, 7, 0, 3, 0, 0, 1, 1, 0, 
      0, 0, 0, 0, 1, 1, 0, 4, 0, 0, 6, 6, 6, 6, 2, 0, 0, 0, 0, 0, 0, 
      1, 1, 1, 1 ] ) ]
0
L4(3).2_2:
[ Character( CharacterTable( "L4(3).2_2" ), 
    [ 2106, 106, 42, 0, 27, 27, 0, 46, 6, 6, 1, 7, 7, 0, 3, 3, 0, 0, 
      0, 1, 1, 1, 0, 0, 0, 1, 306, 306, 42, 6, 10, 10, 0, 0, 15, 15, 
      3, 3, 3, 3, 0, 0, 1, 1, 0, 1, 1, 0, 0 ] ) ]
17/117
L4(3).2_3:
[ Character( CharacterTable( "L4(3).2_3" ), 
    [ 2106, 106, 42, 0, 27, 0, 46, 6, 6, 1, 7, 0, 3, 0, 0, 1, 1, 0, 
      0, 0, 1, 36, 0, 0, 6, 6, 2, 2, 2, 1, 1, 0, 0, 0 ] ) ]
2/117
]]></Example>
<P/>
For <M>S = O_8^-(2)</M> and <M>s \in S</M> of order <M>17</M>,
we have <M>&M;(S,s) = \{ L_2(16).2 \}</M>,
the subgroup extends to <M>L_2(16).4</M> in <M>S.2</M>, see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;89"/>.
This is a non-split extension, so <M>&total;^{\prime}(S.2,s) = 0</M> holds.
<P/>
<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "O8-(2).2" ), "17AB",
>        [ CharacterTable( "L2(16).4" ) ], [ 1 ], "outer" );
0
]]></Example>
<P/>
For <M>S = S_6(3)</M> and <M>s \in S</M> irreducible of order <M>14</M>,
we have <M>&M;(S,s) = \{ (2 \times U_3(3)).2, L_2(27).3 \}</M>.
In <M>G = S.2</M>, the subgroups extend to <M>(4 \times U_3(3)).2</M> and <M>L_2(27).6</M>,
respectively, see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;113"/>.
In order to show that <M>&total;^{\prime}(G,s) = 7/3240</M> holds,
we compute the primitive permutation characters of <M>S</M>
(cf.&nbsp;Section&nbsp;<Ref Subsect="easyloop"/>) and the unique extensions to <M>G</M>
of those which are nonzero on <M>s</M>.
<P/>
<Example><![CDATA[
gap> t:= CharacterTable( "S6(3)" );;
gap> t2:= CharacterTable( "S6(3).2" );;
gap> prim:= PrimitivePermutationCharacters( t );;
gap> spos:= Position( AtlasClassNames( t ), "14A" );;
gap> prim:= Filtered( prim, x -> x[ spos ] <> 0 );;
gap> map:= InverseMap( GetFusionMap( t, t2 ) );;
gap> torso:= List( prim, pi -> CompositionMaps( pi, map ) );;
gap> ext:= List( torso, pi -> PermChars( t2, rec( torso:= pi ) ) );
[ [ Character( CharacterTable( "S6(3).2" ),
      [ 155520, 0, 288, 0, 0, 0, 216, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
          0, 0, 0, 0, 6, 1, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 
          0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 144, 288, 0, 0, 0, 
          6, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 
          0 ] ) ], 
  [ Character( CharacterTable( "S6(3).2" ),
      [ 189540, 1620, 568, 0, 486, 0, 0, 27, 540, 84, 24, 0, 0, 0, 0, 
          0, 54, 0, 0, 10, 0, 7, 1, 6, 6, 0, 0, 0, 0, 0, 0, 18, 0, 0, 
          0, 6, 12, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 234, 64, 
          30, 8, 0, 3, 90, 6, 0, 4, 10, 6, 0, 2, 1, 0, 0, 0, 0, 0, 0, 
          0, 1, 1, 0, 0 ] ) ] ]
gap> spos:= Position( AtlasClassNames( t2 ), "14A" );;
gap> sigma:= ApproxP( Concatenation( ext ), spos );;
gap> Maximum( sigma{ Difference(
>      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
>      ClassPositionsOfDerivedSubgroup( t2 ) ) } );
7/3240
]]></Example>

<P/>

For <M>S = U_5(2)</M> and <M>s \in S</M> of order <M>11</M>,
we have <M>&M;(S,s) = \{ L_2(11) \}</M>,
the subgroup extends to <M>L_2(11).2</M> in <M>S.2</M>,
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;73"/>.

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "U5(2).2" ), "11AB",
>        [ CharacterTable( "L2(11).2" ) ], [ 1 ], "outer" );
1/288
]]></Example>
<P/>
Here we clean the workspace for the first time.
This may save more than <M>100</M> megabytes, due to the fact that the caches
for tables of marks and character tables are flushed.

<P/>

<Example><![CDATA[
gap> CleanWorkspace();
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="O8m3">
<Heading><M>O_8^-(3)</M></Heading>

We show that <M>S = O_8^-(3) = \Omega^-(8,3)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> of order <M>41</M>,
    <M>&M;(S,s)</M> consists of one group of the type
    <M>L_2(81).2_1 = \Omega^-(4,9).2</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 1/567</M>.
</Item>
</List>

<P/>

The only maximal subgroups of <M>S</M> containing elements of order <M>41</M>
have the type <M>L_2(81).2_1</M>,
and there is one class of these subgroups,
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;141"/>.

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "O8-(3)" ), "41A",
>    [ CharacterTable( "L2(81).2_1" ) ], [ 1 ] );
1/567
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="O10p2">
<Heading><M>O_{10}^+(2)</M></Heading>

We show that <M>S = O_{10}^+(2) = \Omega^+(10,2)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    Ford<M>s \in S</M> of order <M>45</M>,
    <M>&M;(S,s)</M> consists of one group of the type
    <M>(A_5 \times U_4(2)).2 = (\Omega^-(4,2) \times \Omega^-(6,2)).2</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 43/4\,216</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    For <M>s</M> as in (a),
    the maximal subgroup in (a) extends to <M>S_5 \times U_4(2).2</M>
    in <M>G = &Aut;(S) = S.2</M>,
    and <M>&total;^{\prime}(G,s) = 23/248</M>.
</Item>
</List>

<P/>

The only maximal subgroups of <M>S</M> containing elements of order <M>45</M>
are one class of groups
<M>H = (A_5 \times U_4(2)):2</M>,
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;146"/>.
(Note that none of the groups <M>S_8(2)</M>, <M>O_8^+(2)</M>, <M>L_5(2)</M>,
<M>O_8^-(2)</M>, and <M>A_8</M> contains elements of order <M>45</M>.)
<M>H</M> extends to subgroups of the type <M>H.2 = S_5 \times U_4(2):2</M>
in <M>G</M>,
so we can compute <M>1_H^S = (1_{H.2}^G)_S</M>.

<P/>

<Example><![CDATA[
gap> ForAny( [ "S8(2)", "O8+(2)", "L5(2)", "O8-(2)", "A8" ],
>            x -> 45 in OrdersClassRepresentatives( CharacterTable( x ) ) );
false
gap> t:= CharacterTable( "O10+(2)" );;
gap> t2:= CharacterTable( "O10+(2).2" );;
gap> s2:= CharacterTable( "A5.2" ) * CharacterTable( "U4(2).2" );
CharacterTable( "A5.2xU4(2).2" )
gap> pi:= PossiblePermutationCharacters( s2, t2 );;
gap> spos:= Position( OrdersClassRepresentatives( t2 ), 45 );;
gap> approx:= ApproxP( pi, spos );;
gap> Maximum( approx{ ClassPositionsOfDerivedSubgroup( t2 ) } );
43/4216
]]></Example>

<P/>

Statement&nbsp;(c) follows from considering the outer classes
of prime element order.

<P/>

<Example><![CDATA[
gap> Maximum( approx{ Difference(
>      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
>      ClassPositionsOfDerivedSubgroup( t2 ) ) } );
23/248
]]></Example>

<P/>

Alternatively, we can use <C>SigmaFromMaxes</C>.

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( t2, "45AB", [ s2 ], [ 1 ], "outer" );
23/248
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="O10m2">
<Heading><M>O_{10}^-(2)</M></Heading>

We show that <M>S = O_{10}^-(2) = \Omega^-(10,2)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> of order <M>33</M>,
    <M>&M;(S,s)</M> consists of one group of the type
    <M>3 \times U_5(2) = &GU;(5,2)</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 1/119</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    For <M>s</M> as in (a),
    the maximal subgroup in (a) extends to <M>(3 \times U_5(2)).2</M>
    in <M>G</M>,
    and <M>&total;^{\prime}(G,s) = 1/595</M>.
</Item>
</List>

<P/>

The only maximal subgroups of <M>S</M> containing elements of order <M>11</M>
have the types <M>A_{12}</M> and <M>3 \times U_5(2)</M>,
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;147"/>.
So <M>3 \times U_5(2)</M> is the unique class of subgroups containing elements
of order <M>33</M>.
This shows statement&nbsp;(a),
and statement&nbsp;(b) follows using <C>SigmaFromMaxes</C>.

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "O10-(2)" ), "33A",
>    [ CharacterTable( "Cyclic", 3 ) * CharacterTable( "U5(2)" ) ], [ 1 ] );
1/119
]]></Example>

<P/>

The structure of the maximal subgroup of <M>G</M> follows
from&nbsp;<Cite Key="CCN85" Where="p.&nbsp;147"/>.
We create its character table with a generic construction
that is based on the fact that the outer automorphism acts nontrivially on
the two direct factors; this determines the character table uniquely.
(See&nbsp;<Cite Key="Auto"/> for details.)

<P/>

<Example><![CDATA[
gap> tblG:= CharacterTable( "U5(2)" );;
gap> tblMG:= CharacterTable( "Cyclic", 3 ) * tblG;;
gap> tblGA:= CharacterTable( "U5(2).2" );;
gap> acts:= PossibleActionsForTypeMGA( tblMG, tblG, tblGA );;
gap> poss:= Concatenation( List( acts, pi ->
>            PossibleCharacterTablesOfTypeMGA( tblMG, tblG, tblGA, pi,
>                "(3xU5(2)).2" ) ) );
[ rec( 
      MGfusMGA := [ 1, 2, 3, 4, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 12, 
          13, 13, 14, 14, 15, 15, 16, 17, 17, 18, 18, 19, 20, 21, 21, 
          22, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28, 28, 29, 29, 
          30, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 
          44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 
          59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 
          74, 75, 76, 77, 31, 32, 33, 35, 34, 37, 36, 38, 39, 40, 41, 
          42, 43, 45, 44, 47, 46, 49, 48, 51, 50, 52, 54, 53, 56, 55, 
          57, 58, 60, 59, 62, 61, 64, 63, 66, 65, 68, 67, 69, 71, 70, 
          73, 72, 75, 74, 77, 76 ], 
      table := CharacterTable( "(3xU5(2)).2" ) ) ]
]]></Example>

<P/>

Now statement&nbsp;(c) follows using <C>SigmaFromMaxes</C>.

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "O10-(2).2" ), "33AB",
>        [ poss[1].table ], [ 1 ], "outer" );
1/595
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="O12p2">
<Heading><M>O_{12}^+(2)</M></Heading>

We show that <M>S = O_{12}^+(2) = \Omega^+(12,2)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> of the type <M>4^- \perp 8^-</M>
    (i.&nbsp;e., <M>s</M> decomposes the natural <M>12</M>-dimensional module
    for <M>&GO;^+_{12}(2) = S.2</M> into an orthogonal sum of two irreducible
    modules of the dimensions <M>4</M> and <M>8</M>, respectively)
    and of order <M>85</M>,
    <M>&M;(S,s)</M> consists of one group of the type
    <M>G_8 = (\Omega^-(4,2) \times \Omega^-(8,2)).2</M> and
    two groups of the type <M>L_4(4).2^2 = \Omega^+(6,4).2^2</M>
    that are conjugate in <M>G = &Aut;(S) = S.2 = &SO;^+(12,2)</M>
    but <E>not</E> conjugate in <M>S</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 7\,675/1\,031\,184</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&total;^{\prime}(G,s) = 73/1\,008</M>.
</Item>
</List>

<P/>

The element <M>s</M> is a ppd<M>(12,2;8)</M>-element in the sense of&nbsp;<Cite Key="GPPS"/>,
so the maximal subgroups of <M>S</M> that contain <M>s</M> are among the nine
cases (2.1)&ndash;(2.9) listed in this paper;
in the notation of this paper,
we have <M>q = 2</M>, <M>d = 12</M>, <M>e = 8</M>, and <M>r = 17</M>.
Case&nbsp;(2.1) does not occur for orthogonal groups and <M>q = 2</M>,
according to&nbsp;<Cite Key="KlL90"/>;
case&nbsp;(2.2) contributes a unique maximal subgroup,
the stabilizer <M>G_8</M> of the orthogonal decomposition;
the cases&nbsp;(2.3), (2.4)&nbsp;(a), (2.5), and (2.6)&nbsp;(a) do not occur
because <M>r &noteq; e+1</M> in our situation;
case&nbsp;(2.4)&nbsp;(b) describes extension field type subgroups that are contained
in <M>&GammaL;(6,4)</M>,
which yields the candidates <M>&GU;(6,2).2 \cong 3.U_6(2).S_3</M>
&ndash;but <M>3.U_6(2).3</M> does not contain elements of order <M>85</M>&ndash;
and <M>\Omega^+(6,4).2^2 \cong L_4(4).2^2</M>
(two classes by&nbsp;<Cite Key="KlL90" Where="Prop.&nbsp;4.3.14"/>);
the cases&nbsp;(2.6)&nbsp;(b)&ndash;(c) and&nbsp;(2.8) do not occur
because they require <M>d \leq 8</M>;
case&nbsp;(2.7) does not occur
because&nbsp;<Cite Key="GPPS" Where="Table&nbsp;5"/> contains no entry for
<M>r = 2e+1 = 17</M>;
finally, case&nbsp;(2.9) does not occur
because it requires <M>e \in \{ d-1, d \}</M>
in the case <M>r = 2e+1</M>.

<P/>

So we need the permutation characters of the actions on the cosets of
<M>L_4(4).2^2</M> (two classes) and <M>G_8</M>.
According to&nbsp;<Cite Key="KlL90" Where="Prop.&nbsp;4.1.6"/>,
<M>G_8</M> has the structure <M>(\Omega^-(4,2) \times \Omega^-(8,2)).2</M>.

<P/>

Newer versions of the &GAP; Character Table Library contain the
character table of <M>S</M>,
but it is still easier to work with the table of <M>G</M>,
which was already available at the times when the first version
of these examples was created.

<P/>

The two classes of <M>L_4(4).2^2</M> type subgroups in <M>S</M> are fused in <M>G</M>.
This can be seen from the fact that inducing the trivial character of
a subgroup <M>H_1 = L_4(4).2^2</M> of <M>S</M> to <M>G</M> yields a character <M>\psi</M>
whose values are not all even;
note that if <M>H_1</M> would extend in <M>G</M> to a subgroup of twice the size
of <M>H_1</M> then <M>\psi</M> would be induced from a degree two character
of this subgroup whose values are all even,
and induction preserves this property.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "O12+(2).2" );;
gap> h1:= CharacterTable( "L4(4).2^2" );;
gap> psi:= PossiblePermutationCharacters( h1, t );;
gap> Length( psi );
1
gap> ForAny( psi[1], IsOddInt );
true
]]></Example>

<P/>

The fixed element <M>s</M> of order <M>85</M> is contained in a member of each
of the two conjugacy classes of the type <M>L_4(4).2^2</M> in <M>S</M>,
since <M>S</M> contains only one class of subgroups of the order <M>85</M>;
note that the order of the Sylow <M>17</M> centralizer (in both <M>S</M> and <M>G</M>)
is not divisible by <M>25</M>.

<P/>

<Example><![CDATA[
gap> SizesCentralizers( t ){ PositionsProperty(
>        OrdersClassRepresentatives( t ), x -> x = 17 ) } / 25;
[ 408/5, 408/5 ]
]]></Example>

<P/>

This implies that the restriction of <M>\psi</M> to <M>S</M>
is the sum <M>\psi_S = \pi_1 + \pi_2</M>, say,
of the first two interesting permutation characters of <M>S</M>.

<P/>

The subgroup <M>G_8</M> of <M>S</M> extends to a group of the structure
<M>H_2 = \Omega^-(4,2).2 \times \Omega^-(8,2).2</M> in <M>G</M>,
inducing the trivial characters of <M>H_2</M> to <M>G</M> yields
a permutation character <M>\varphi</M> of <M>G</M> whose restriction to <M>S</M>
is the third permutation character <M>\varphi_S = \pi_3</M>, say.

<P/>

<Example><![CDATA[
gap> h2:= CharacterTable( "S5" ) * CharacterTable( "O8-(2).2" );;
gap> phi:= PossiblePermutationCharacters( h2, t );;
gap> Length( phi );
1
]]></Example>

<P/>

We have <M>\pi_1(1) = \pi_2(1)</M> and <M>\pi_1(s) = \pi_2(s)</M>,
the latter again because <M>S</M> contains only one class of subgroups
of order <M>85</M>.

<P/>

Now statement&nbsp;(a) follows from the fact that <M>\pi_i(s) = 1</M> holds
for <M>1 \leq i \leq 3</M>.

<P/>

<Example><![CDATA[
gap> prim:= Concatenation( psi, phi );;
gap> spos:= Position( OrdersClassRepresentatives( t ), 85 );
213
gap> List( prim, x -> x[ spos ] );
[ 2, 1 ]
]]></Example>

<P/>

For statement&nbsp;(b), we compute <M>&total;(S,s)</M>.
Note that we have to consider only classes inside <M>S = G^{\prime}</M>,
and that

<Display Mode="M">
   &total;( g, s )
     = \sum_{i=1}^3 \frac{\pi_i(s) \cdot \pi_i(g)}{\pi_i(1)}
     = \frac{\psi(s) \cdot \psi(g)}{\psi(1)}
       + \frac{\varphi(s) \cdot \varphi(g)}{\varphi(1)}
</Display>

holds for <M>g \in S^{\times}</M>,
so the characters <M>\psi</M> and <M>\varphi</M> are sufficient.

<P/>

<Example><![CDATA[
gap> approx:= ApproxP( prim, spos );;
gap> Maximum( approx{ ClassPositionsOfDerivedSubgroup( t ) } );
7675/1031184
]]></Example>

<P/>

Statement&nbsp;(c) follows from considering the outer involution classes.
Note that by&nbsp;<Cite Key="BGK" Where="Remark after Proposition&nbsp;5.14"/>,
only the subgroup <M>H_2</M> need to be considered,
no novelties appear.

<P/>

<Example><![CDATA[
gap> Maximum( approx{ Difference(
>      PositionsProperty( OrdersClassRepresentatives( t ), IsPrimeInt ),
>      ClassPositionsOfDerivedSubgroup( t ) ) } );
73/1008
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="O12m2">
<Heading><M>O_{12}^-(2)</M></Heading>

We show that <M>S = O_{12}^-(2) = \Omega^-(12,2)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> irreducible of order <M>2^6+1 = 65</M>,
    <!-- For <M>q = 2</M>, <M>m = 6</M>, we have <M>S = \Omega^-(2m,q)</M>
         and <M>|s| = (q^m+1)/\gcd(2,q-1)</M>. -->
    <M>&M;(S,s)</M> consists of two groups of the types
    <M>U_4(4).2 = \Omega^-(6,4).2</M> and <M>L_2(64).3 = \Omega^-(4,8).3</M>,
    respectively.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 1/1\,023</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&total;^{\prime}(&Aut;(S),s) = 1/347\,820</M>.
</Item>
</List>

<P/>

By&nbsp;<Cite Key="Be00"/>,
<M>&M;(S,s)</M> consists of extension field subgroups,
which have the structures <M>U_4(4).2</M> and <M>L_2(64).3</M>, respectively,
and by&nbsp;<Cite Key="KlL90" Where="Prop.&nbsp;4.3.16"/>,
there is just one class of each of these types.

<P/>

Newer versions of the &GAP; Character Table Library contain the
character table of <M>S</M>,
but using this table for the computations is not easier than
using the table of <M>G = &Aut;(S) = O_{12}^-(2).2</M>,
which was already available at the times when the first version
of these examples was created.
So we compute the permutation characters <M>\pi_1, \pi_2</M> of the extensions
of the groups in <M>&M;(S,s)</M> to <M>G</M>
&ndash;these maximal subgroups have the structures <M>U_4(4).4</M> and
<M>L_2(64).6</M>, respectively&ndash;
and compute the fixed point ratios of the restrictions to <M>S</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "O12-(2).2" );;
gap> s1:= CharacterTable( "U4(4).4" );;
gap> pi1:= PossiblePermutationCharacters( s1, t );;
gap> s2:= CharacterTable( "L2(64).6" );;
gap> pi2:= PossiblePermutationCharacters( s2, t );;
gap> prim:= Concatenation( pi1, pi2 );;  Length( prim );
2
]]></Example>

<P/>

Now statement&nbsp;(a) follows from the fact
that <M>\pi_1(s) = \pi_2(s) = 1</M> holds.

<P/>

<Example><![CDATA[
gap> spos:= Position( OrdersClassRepresentatives( t ), 65 );;
gap> List( prim, x -> x[ spos ] );
[ 1, 1 ]
]]></Example>

<P/>

For statement&nbsp;(b), we compute <M>&total;(S,s)</M>;
note that we have to consider only classes inside <M>S = G^{\prime}</M>.

<P/>

<Example><![CDATA[
gap> approx:= ApproxP( prim, spos );;
gap> Maximum( approx{ ClassPositionsOfDerivedSubgroup( t ) } );
1/1023
]]></Example>

<P/>

Statement&nbsp;(c) follows from the values on the outer involution classes.

<P/>

<Example><![CDATA[
gap> Maximum( approx{ Difference(
>      PositionsProperty( OrdersClassRepresentatives( t ), IsPrimeInt ),
>      ClassPositionsOfDerivedSubgroup( t ) ) } );
1/347820
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="S64">
<Heading><M>S_6(4)</M></Heading>

We show that <M>S = S_6(4) = &Sp;(6,4)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> irreducible of order <M>65</M>,
    <M>&M;(S,s)</M> consists of two groups of the types
    <M>U_4(4).2 = \Omega^-(6,4).2</M> and <M>L_2(64).3 = &Sp;(2,64).3</M>,
    respectively.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 16/63</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&total;^{\prime}(&Aut;(S),s) = 0</M>.
</Item>
</List>

<P/>

By&nbsp;<Cite Key="Be00"/>, the element <M>s</M> is contained in maximal
subgroups of the given types,
and by&nbsp;<Cite Key="KlL90" Where="Prop.&nbsp;4.3.10, 4.8.6"/>,
there is exactly one class of these subgroups.

<P/>

The character tables of these two subgroups are currently not contained
in the &GAP; Character Table Library.
We compute the permutation character induced from the first subgroup
as the  unique character of the right degree that is combinatorially
possible (cf.&nbsp;<Cite Key="BP98copy"/>).

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "S6(4)" );;
gap> degree:= Size( t ) / ( 2 * Size( CharacterTable( "U4(4)" ) ) );;
gap> pi1:= PermChars( t, rec( torso:= [ degree ] ) );;
gap> Length( pi1 );
1
]]></Example>

<P/>

The index of the second subgroup is too large for this simpleminded
approach;
therefore, we first restrict the set of possible irreducible constituents
of the permutation character to those of <M>1_H^G</M>,
where <M>H</M> is the derived subgroup of <M>L_2(64).3</M>,
for which the character table is available.

<P/>

<Example><![CDATA[
gap> CharacterTable( "L2(64).3" );  CharacterTable( "U4(4).2" );
fail
fail
gap> s:= CharacterTable( "L2(64)" );;
gap> subpi:= PossiblePermutationCharacters( s, t );;
gap> Length( subpi );
1
gap> scp:= MatScalarProducts( t, Irr( t ), subpi );;
gap> nonzero:= PositionsProperty( scp[1], x -> x <> 0 );
[ 1, 11, 13, 14, 17, 18, 32, 33, 56, 58, 59, 73, 74, 77, 78, 79, 80, 
  93, 95, 96, 103, 116, 117, 119, 120 ]
gap> const:= RationalizedMat( Irr( t ){ nonzero } );;
gap> degree:= Size( t ) / ( 3 * Size( s ) );
5222400
gap> pi2:= PermChars( t, rec( torso:= [ degree ], chars:= const ) );;
gap> Length( pi2 );
1
gap> prim:= Concatenation( pi1, pi2 );;
]]></Example>

<P/>

Now statement&nbsp;(a) follows from the fact
that <M>\pi_1(s) = \pi_2(s) = 1</M> holds.

<P/>

<Example><![CDATA[
gap> spos:= Position( OrdersClassRepresentatives( t ), 65 );;
gap> List( prim, x -> x[ spos ] );
[ 1, 1 ]
]]></Example>

<P/>

For statement&nbsp;(b), we compute <M>&total;(G,s)</M>.

<P/>

<Example><![CDATA[
gap> Maximum( ApproxP( prim, spos ) );
16/63
]]></Example>

<P/>

In order to prove statement&nbsp;(c), we have to consider only the extensions
of the above permutation characters of <M>S</M> to <M>&Aut;(S) \cong S.2</M>
(cf.&nbsp;<Cite Key="BGK" Where="Section&nbsp;2.2"/>).

<P/>

<Example><![CDATA[
gap> t2:= CharacterTable( "S6(4).2" );;
gap> tfust2:= GetFusionMap( t, t2 );;
gap> cand:= List( prim, x -> CompositionMaps( x, InverseMap( tfust2 ) ) );;
gap> ext:= List( cand, pi -> PermChars( t2, rec( torso:= pi ) ) );
[ [ Character( CharacterTable( "S6(4).2" ),
      [ 2016, 512, 96, 128, 32, 120, 0, 6, 16, 40, 24, 0, 8, 136, 1, 
          6, 6, 1, 32, 0, 8, 6, 2, 0, 2, 0, 0, 4, 0, 16, 32, 1, 8, 2, 
          6, 2, 1, 2, 4, 0, 0, 1, 6, 0, 1, 10, 0, 1, 1, 0, 10, 10, 4, 
          0, 1, 0, 2, 0, 2, 1, 2, 2, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 
          0, 0, 0, 32, 0, 0, 8, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 8, 0, 
          0, 0, 2, 2, 0, 2, 2, 0, 2, 2, 2, 0, 0 ] ) ], 
  [ Character( CharacterTable( "S6(4).2" ),
      [ 5222400, 0, 0, 0, 1280, 0, 960, 120, 0, 0, 0, 0, 0, 0, 1600, 
          0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1, 0, 0, 15, 0, 0, 0, 0, 0, 
          0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 
          0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 
          0, 0, 960, 0, 0, 0, 16, 0, 24, 12, 0, 0, 0, 0, 0, 0, 0, 0, 
          0, 0, 0, 0, 4, 1, 0, 0, 3, 0, 0, 0, 0, 0 ] ) ] ]
gap> spos2:= Position( OrdersClassRepresentatives( t2 ), 65 );;
gap> sigma:= ApproxP( Concatenation( ext ), spos2 );;
gap> Maximum( approx{ Difference(
>      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
>      ClassPositionsOfDerivedSubgroup( t2 ) ) } );
0
]]></Example>

<P/>

For the simple group, we can <E>alternatively</E> consider a reducible
element <M>s: 2 \perp 4</M> of order <M>85</M>,
which is a multiple of the primitive prime divisor <M>r = 17</M> of <M>4^4-1</M>.
So we have <M>e = 4</M>, <M>d = 6</M>, and <M>q = 4</M>, in the terminology of&nbsp;<Cite Key="GPPS"/>.
Then <M>&M;(S,s)</M> consists of two groups, of the types
<M>\Omega^+(6,4).2 \cong L_4(4).2_2</M> and <M>&Sp;(2,4) \times &Sp;(4,4)</M>.
This can be shown by
checking&nbsp;<Cite Key="GPPS" Where="Ex.&nbsp;2.1&ndash;2.9"/>.
Ex.&nbsp;2.1 yields the candidates <M>\Omega^{\pm}(6,4).2</M>,
but only <M>\Omega^+(6,4).2</M> contains elements of order <M>85</M>.
<!-- % Note that <M>S_6(2)</M> does not occur! -->
Ex.&nbsp;2.2 yields the stabilizer of a two-dimensional subspace,
which has the structure <M>&Sp;(2,4) \times &Sp;(4,4)</M>, by&nbsp;<Cite Key="KlL90"/>.
All other cases except Ex.&nbsp;2.4&nbsp;(b) are excluded by the fact that <M>r = 4e+1</M>,
and Ex.&nbsp;2.4&nbsp;(b) does not apply because <M>d/\gcd(d,e)</M> is odd.

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "S6(4)" ), "85A",
>    [ CharacterTable( "L4(4).2_2" ),
>      CharacterTable( "A5" ) * CharacterTable( "S4(4)" ) ], [ 1, 1 ] );
142/455
]]></Example>

<P/>

This bound is not as good as the one obtained from the irreducible
element of order <M>65</M> used above.

<P/>

<Example><![CDATA[
gap> 16/63 < 142/455;
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="S65">
<Heading><M>\ast</M>&nbsp;<M>S_6(5)</M></Heading>

We show that <M>S = S_6(5) = &PSp;(6,5)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> of the type <M>2 \perp 4</M>
    (i.&nbsp;e., the preimage of <M>s</M> in <M>&Sp;(6,5) = 2.G</M> decomposes
    the natural <M>6</M>-dimensional module for
    <M>&Sp;(6,5)</M> into an orthogonal sum of two irreducible modules
    of the dimensions <M>2</M> and <M>4</M>, respectively)
    and of order <M>78</M>,
    <M>&M;(S,s)</M> consists of one group of the type
    <M>G_2 = 2.(&PSp;(2,5) \times &PSp;(4,5))</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 9/217</M>.
</Item>
</List>

<P/>

The order of <M>s</M> is a multiple of the primitive prime divisor <M>r = 13</M>
of <M>5^4-1</M>,
so we have <M>e = 4</M>, <M>d = 6</M>, and <M>q = 5</M>, in the terminology of&nbsp;<Cite Key="GPPS"/>.
We check&nbsp;<Cite Key="GPPS" Where="Ex.&nbsp;2.1&ndash;2.9"/>.
Ex.&nbsp;2.1 does not apply because the classes <M>C_5</M> and <M>C_8</M>
are empty by&nbsp;<Cite Key="KlL90" Where="Table&nbsp;3.5.C"/>,
Ex.&nbsp;2.2 yields exactly the stabilizer <M>G_2</M> of a <M>2</M>-dimensional subspace,
Ex.&nbsp;2.4&nbsp;(b) does not apply because <M>d/\gcd(d,e)</M> is odd,
and all other cases are excluded by the fact that <M>r = 3e+1</M>.

<P/>

The group <M>G_2</M> has the structure <M>2.(&PSp;(2,5) \times &PSp;(4,5))</M>,
which is a central product of <M>&Sp;(2,5) \cong 2.A_5</M> and <M>&Sp;(4,5) = 2.S_4(5)</M>
(see&nbsp;<Cite Key="KlL90" Where="Prop.&nbsp;4.1.3"/>).
The character table of <M>G_2</M> can be derived from that of the direct product
of <M>2.A_5</M> and <M>2.S_4(5)</M>,
by factoring out the diagonal central subgroup of order two.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "S6(5)" );;
gap> s1:= CharacterTable( "2.A5" );;
gap> s2:= CharacterTable( "2.S4(5)" );;
gap> dp:= s1 * s2;
CharacterTable( "2.A5x2.S4(5)" )
gap> c:= Difference( ClassPositionsOfCentre( dp ), Union(
>                        GetFusionMap( s1, dp ), GetFusionMap( s2, dp ) ) );
[ 62 ]
gap> s:= dp / c;
CharacterTable( "2.A5x2.S4(5)/[ 1, 62 ]" )
]]></Example>

<P/>

Now we compute <M>&total;(S,s)</M>.

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( t, "78A", [ s ], [ 1 ] );
9/217
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="S83">
<Heading><M>S_8(3)</M></Heading>

We show that <M>S = S_8(3) = &PSp;(8,3)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> irreducible of order <M>41</M>,
    <M>&M;(S,s)</M> consists of one group <M>M</M> of the type
    <M>S_4(9).2 = &PSp;(4,9).2</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 1/546</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    The preimage of <M>s</M> in the matrix group <M>2.S_8(3) = &Sp;(8,3)</M>
    can be chosen of order <M>82</M>,
    and the preimage of <M>M</M> is <M>2.S_4(9).2 = &Sp;(4,9).2</M>.
</Item>
</List>

<P/>

By&nbsp;<Cite Key="Be00"/>,
the only maximal subgroups of <M>S</M> that contain irreducible
elements of order <M>(3^4+1)/2 = 41</M> are of extension field type,
and by&nbsp;<Cite Key="KlL90" Where="Prop.&nbsp;4.3.10"/>,
these groups have the structure <M>S_4(9).2</M>
and there is exactly one class of these groups.

<P/>

The group <M>U = S_4(9)</M> has three nontrivial outer automorphisms,
the character table of the subgroup <M>U.2</M> in question has the identifier
<C>"S4(9).2_1"</C>,
which follows from the fact that the extensions of <M>U</M> by the other two
outer automorphisms do not admit a class fusion into <M>S</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "S8(3)" );;
gap> pi:= List( [ "S4(9).2_1", "S4(9).2_2", "S4(9).2_3" ],
>               name -> PossiblePermutationCharacters(
>                           CharacterTable( name ), t ) );;
gap> List( pi, Length );
[ 1, 0, 0 ]
]]></Example>

<P/>

Now statement&nbsp;(a) follows from the fact
that <M>(1_{U.2})^S(s) = 1</M> holds.

<P/>

<Example><![CDATA[
gap> spos:= Position( OrdersClassRepresentatives( t ), 41 );;
gap> pi[1][1][ spos ];
1
]]></Example>

<P/>

Now we compute <M>&total;(S,s)</M> in order to show statement&nbsp;(b).

<P/>

<Example><![CDATA[
gap> Maximum( ApproxP( pi[1], spos ) );
1/546
]]></Example>

<P/>

Statement&nbsp;(c) is clear from the description of extension field type
subgroups in&nbsp;<Cite Key="KlL90"/>.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="U44">
<Heading><M>U_4(4)</M></Heading>

We show that <M>S = U_4(4) = &SU;(4,4)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> of the type <M>1 \perp 3</M>
    (i.&nbsp;e., <M>s</M> decomposes the natural <M>4</M>-dimensional module
    for <M>&SU;(4,4)</M> into an orthogonal sum of two irreducible modules
    of the dimensions <M>1</M> and <M>3</M>, respectively)
    and of order <M>4^3+1 = 65</M>,
    <M>&M;(S,s)</M> consists of one group of the type
    <M>G_1 = 5 \times U_3(4) = &GU;(3,4)</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 209/3\,264</M>.
</Item>
</List>

<P/>

By&nbsp;<Cite Key="MSW94"/>,
the only maximal subgroups of <M>S</M> that contain <M>s</M>
are one class of stabilizers <M>H \cong 5 \times U_3(4)</M>
of this decomposition,
and clearly there is only one such group containing <M>s</M>.

<P/>

Note that <M>H</M> has index <M>3\,264</M> in <M>S</M>,
since <M>S</M> has two orbits on the <M>1</M>-dimensional subspaces,
of lengths <M>1\,105</M> and <M>3\,264</M>, respectively,
and elements of order <M>13 = 65/5</M> lie in the stabilizers of points
in the latter orbit.

<P/>

<Example><![CDATA[
gap> g:= SU(4,4);;
gap> orbs:= OrbitsDomain( g, NormedRowVectors( GF(16)^4 ), OnLines );;
gap> orblen:= List( orbs, Length );
[ 1105, 3264 ]
gap> List( orblen, x -> x mod 13 );
[ 0, 1 ]
]]></Example>

<P/>

We compute the permutation character <M>1_{G_1}^S</M>;
there is exactly one combinatorially possible permutation character
of degree <M>3\,264</M> (cf.&nbsp;<Cite Key="BP98copy"/>).

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "U4(4)" );;
gap> pi:= PermChars( t, rec( torso:= [ orblen[2] ] ) );;
gap> Length( pi );
1
]]></Example>

<P/>

Now we compute <M>&total;(S,s)</M>.

<P/>

<Example><![CDATA[
gap> spos:= Position( OrdersClassRepresentatives( t ), 65 );;
gap> Maximum( ApproxP( pi, spos ) );
209/3264
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="U62">
<Heading><M>U_6(2)</M></Heading>

We show that <M>S = U_6(2) = &PSU;(6,2)</M> satisfies the following.

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> of order <M>11</M>,
    <M>&M;(S,s)</M> consists of one group of the type <M>U_5(2) = &SU;(5,2)</M>
    and three groups of the type <M>M_{22}</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 5/21</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    The preimage of <M>s</M> in the matrix group <M>&SU;(6,2) = 3.U_6(2)</M>
    can be chosen of order <M>33</M>,
    and the preimages of the groups in <M>&M;(S,s)</M> have the structures
    <M>3 \times U_5(2) \cong &GU;(5,2)</M> and <M>3.M_{22}</M>, respectively.
</Item>
<Mark>(d)</Mark>
<Item>
    With <M>s</M> as in&nbsp;(a),
    the automorphic extensions <M>S.2</M>, <M>S.3</M> of <M>S</M>
    satisfy <M>&total;^{\prime}(S.2,s) = 5/96</M> and
    <M>&total;^{\prime}(S.3,s) = 59/224</M>.
</Item>
</List>

<P/>

According to the list of maximal subgroups of <M>S</M>
in&nbsp;<Cite Key="CCN85" Where="p.&nbsp;115"/>,
<M>s</M> is contained exactly in maximal subgroups of the types <M>U_5(2)</M>
(one class) and <M>M_{22}</M> (three classes).

<P/>

The permutation character of the action on the cosets of <M>U_5(2)</M> type
subgroups is uniquely determined by the character tables.
We get three possibilities for the permutation character on the cosets of
<M>M_{22}</M> type subgroups; they correspond to the three classes of such
subgroups, because each of these classes contains elements in exactly one
of the conjugacy classes <C>4C</C>, <C>4D</C>, and <C>4E</C> of elements in
<M>S</M>, and these classes are fused under the outer automorphism of <M>S</M>
of order three.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "U6(2)" );;
gap> s1:= CharacterTable( "U5(2)" );;
gap> pi1:= PossiblePermutationCharacters( s1, t );;
gap> Length( pi1 );
1
gap> s2:= CharacterTable( "M22" );;
gap> pi2:= PossiblePermutationCharacters( s2, t );
[ Character( CharacterTable( "U6(2)" ),
  [ 20736, 0, 384, 0, 0, 0, 54, 0, 0, 0, 0, 48, 0, 16, 6, 0, 0, 0, 0, 
      0, 0, 6, 0, 2, 0, 0, 0, 4, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 0, 0, 0 ] ), Character( CharacterTable( "U6(2)" ),
  [ 20736, 0, 384, 0, 0, 0, 54, 0, 0, 0, 48, 0, 0, 16, 6, 0, 0, 0, 0, 
      0, 0, 6, 0, 2, 0, 0, 4, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 0, 0, 0 ] ), Character( CharacterTable( "U6(2)" ),
  [ 20736, 0, 384, 0, 0, 0, 54, 0, 0, 48, 0, 0, 0, 16, 6, 0, 0, 0, 0, 
      0, 0, 6, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 0, 0, 0 ] ) ]
gap> imgs:= Set( pi2, x -> Position( x, 48 ) );
[ 10, 11, 12 ]
gap> AtlasClassNames( t ){ imgs };
[ "4C", "4D", "4E" ]
gap> GetFusionMap( t, CharacterTable( "U6(2).3" ) ){ imgs };
[ 10, 10, 10 ]
gap> prim:= Concatenation( pi1, pi2 );;
]]></Example>

<P/>

Now statement&nbsp;(a) follows from the fact that the permutation characters
have the value <M>1</M> on <M>s</M>.

<P/>

<Example><![CDATA[
gap> spos:= Position( OrdersClassRepresentatives( t ), 11 );;
gap> List( prim, x -> x[ spos ] );
[ 1, 1, 1, 1 ]
]]></Example>

<P/>

For statement&nbsp;(b), we compute <M>&total;(S,s)</M>.

<P/>

<Example><![CDATA[
gap> Maximum( ApproxP( prim, spos ) );
5/21
]]></Example>

<P/>

Statement&nbsp;(c) follows from&nbsp;<Cite Key="CCN85"/>,
plus the information that <M>3.U_6(2)</M> does not contain groups of the structure
<M>3 \times M_{22}</M>.

<P/>

<Example><![CDATA[
gap> PossibleClassFusions(
>        CharacterTable( "Cyclic", 3 ) * CharacterTable( "M22" ),
>        CharacterTable( "3.U6(2)" ) );
[  ]
]]></Example>

<P/>

For statement&nbsp;(d), we need that the relevant maximal subgroups of
<M>S.2</M> are <M>U_5(2).2</M> and one subgroup <M>M_{22}.2</M>,
and that the relevant maximal subgroup of <M>S.3</M> is <M>U_5(2) \times 3</M>,
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;115"/>.

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "U6(2).2" ), "11AB",
>        [ CharacterTable( "U5(2).2" ), CharacterTable( "M22.2" ) ],
>        [ 1, 1 ], "outer" );
5/96
gap> SigmaFromMaxes( CharacterTable( "U6(2).3" ), "11A",
>        [ CharacterTable( "U5(2)" ) * CharacterTable( "Cyclic", 3 ) ],
>        [ 1 ], "outer" );
59/224
]]></Example>

</Subsection>
</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:hard">
<Heading>Computations using Groups</Heading>

Before we start the computations using groups, we clean the workspace.

<P/>

<Example><![CDATA[
gap> CleanWorkspace();
]]></Example>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="Aodd">
<Heading><M>A_{2m+1}</M>, <M>2 \leq m \leq 11</M></Heading>

For alternating groups of odd degree <M>n = 2m+1</M>,
we choose <M>s</M> to be an <M>n</M>-cycle.
The interesting cases
in&nbsp;<Cite Key="BGK" Where="Proposition&nbsp;6.7"/> are
<M>5 \leq n \leq 23</M>.

<P/>

In each case, we compute representatives of the maximal subgroups of <M>A_n</M>,
consider only those that contain an <M>n</M>-cycle, and then compute the
permutation characters.
Additionally, we show also the names that are used for the subgroups in
the &GAP; Library of Transitive Groups,
see&nbsp;<Cite Key="HulpkeTG"/>
and the documentation of this library in the &GAP; Reference Manual.

<P/>

<Example><![CDATA[
gap> PrimitivesInfoForOddDegreeAlternatingGroup:= function( n )
>     local G, max, cycle, spos, prim, nonz;
> 
>     G:= AlternatingGroup( n );
> 
>     # Compute representatives of the classes of maximal subgroups.
>     max:= MaximalSubgroupClassReps( G );
> 
>     # Omit subgroups that cannot contain an `n'-cycle.
>     max:= Filtered( max, m -> IsTransitive( m, [ 1 .. n ] ) );
> 
>     # Compute the permutation characters.
>     cycle:= [];
>     cycle[ n-1 ]:= 1;
>     spos:= PositionProperty( ConjugacyClasses( CharacterTable( G ) ),
>                c -> CycleStructurePerm( Representative( c ) ) = cycle );
>     prim:= List( max, m -> TrivialCharacter( m )^G );
>     nonz:= PositionsProperty( prim, x -> x[ spos ] <> 0 );
> 
>     # Compute the subgroup names and the multiplicities.
>     return rec( spos := spos,
>                 prim := prim{ nonz },
>                 grps := List( max{ nonz },
>                               m -> TransitiveGroup( n,
>                                        TransitiveIdentification( m ) ) ),
>                 mult := List( prim{ nonz }, x -> x[ spos ] ) );
> end;;
]]></Example>

<P/>

The sets <M>&MM;(s)</M> and the values <M>&total;(A_n,s)</M> are as follows.
For each degree in question, the first list shows names for representatives
of the conjugacy classes of maximal subgroups containing a fixed <M>n</M>-cycle,
and the second list shows the number of conjugates in each class.

<P/>

<Example><![CDATA[
gap> for n in [ 5, 7 .. 23 ] do
>      prim:= PrimitivesInfoForOddDegreeAlternatingGroup( n );
>      bound:= Maximum( ApproxP( prim.prim, prim.spos ) );
>      Print( n, ": ", prim.grps, ", ", prim.mult, ", ", bound, "\n" );
> od;
5: [ D(5) = 5:2 ], [ 1 ], 1/3
7: [ L(7) = L(3,2), L(7) = L(3,2) ], [ 1, 1 ], 2/5
9: [ 1/2[S(3)^3]S(3), L(9):3=P|L(2,8) ], [ 1, 3 ], 9/35
11: [ M(11), M(11) ], [ 1, 1 ], 2/105
13: [ F_78(13)=13:6, L(13)=PSL(3,3), L(13)=PSL(3,3) ], [ 1, 2, 2 ], 4/
1155
15: [ 1/2[S(3)^5]S(5), 1/2[S(5)^3]S(3), L(15)=A_8(15)=PSL(4,2), 
  L(15)=A_8(15)=PSL(4,2) ], [ 1, 1, 1, 1 ], 29/273
17: [ L(17):4=PYL(2,16), L(17):4=PYL(2,16) ], [ 1, 1 ], 2/135135
19: [ F_171(19)=19:9 ], [ 1 ], 1/6098892800
21: [ t21n150, t21n161, t21n91 ], [ 1, 1, 2 ], 29/285
23: [ M(23), M(23) ], [ 1, 1 ], 2/130945815
]]></Example>

<P/>

In the above output, a subgroup printed as
<C>1/2[S(</C><M>n_1</M><C>)^</C><M>n_2</M><C>]S(</C><M>n_2</M><C>)</C>,
<C>1/2[S(</C><M>n_1</M><C>)^</C><M>n_2</M><C>]S(</C><M>n_2</M><C>)</C>,
where <M>n = n_1 n_2</M> holds, denotes the intersection of <M>A_n</M> with the
wreath product
<M>S_{n_1} \wr S_{n_2} \leq S_n</M>.
(Note that the &ATLAS; denotes the subgroup <C>1/2[S(3)^3]S(3)</C>
of <M>A_9</M> as <M>3^3:S_4</M>.)
The groups printed as <C>P|L(2,8)</C> and <C>PYL(2,16)</C> denote
<M>&PGammaL;(2,8)</M> and <M>&PGammaL;(2,16)</M>, respectively.
And the three subgroups of <M>A_{21}</M> have the structures
<M>(S_3 \wr S_7) \cap A_{21}</M>, <M>(S_7 \wr S_3) \cap A_{21}</M>,
and <M>&PGL;(3,4)</M>, respectively.

<P/>

Note that <M>A_9</M> contains two conjugacy classes of maximal subgroups of
the type <M>&PGammaL;(2,8) \cong L_2(8):3</M>, and that each <M>9</M>-cycle in <M>A_9</M>
is contained in exactly three <E>conjugate</E> subgroups of this type.
For <M>n \in \{ 13, 15, 17 \}</M>, <M>A_n</M> contains two conjugacy classes of
isomorphic maximal subgroups of linear type, and each <M>n</M>-cycle is contained
in subgroups from each class.
Finally, <M>A_{21}</M> contains only one class of maximal subgroups of linear type.

<P/>

For the two groups <M>A_5</M> and <M>A_7</M>,
the values computed above are not sufficient.
See Section&nbsp;<Ref Subsect="A5"/> and&nbsp;<Ref Subsect="A7"/> for a further treatment.

<P/>

The above computations look like a brute-force approach,
but note that the computation of the maximal subgroups of alternating
and symmetric groups in &GAP; uses the classification of these
subgroups, and also the conjugacy classes of elements in alternating and
symmetric groups can be computed cheaply.

<P/>

Alternative (character-theoretic) computations
for <M>n \in \{ 5, 7, 9, 11, 13 \}</M> were shown in Section&nbsp;<Ref Subsect="easyloop"/>.
(A hand calculation for the case <M>n = 19</M> can be found in&nbsp;<Cite Key="BW1"/>.)

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="A5">
<Heading><M>A_5</M></Heading>

We show that <M>S = A_5</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    <M>&total;(S) = 1/3</M>,
    and this value is attained exactly for <M>&total;(S,s)</M>
    with <M>s</M> of order <M>5</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s \in S</M> of order <M>5</M>,
    <M>&M;(S,s)</M> consists of one group of the type <M>D_{10}</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&prop;(S) = 1/3</M>,
    and this value is attained exactly for <M>&prop;(S,s)</M>
    with <M>s</M> of order <M>5</M>.
</Item>
<Mark>(d)</Mark>
<Item>
    Each element in <M>S</M> together with one of
    <M>(1,2)(3,4)</M>, <M>(1,3)(2,4)</M>, <M>(1,4)(2,3)</M>
    generates a proper subgroup of <M>S</M>.
</Item>
<Mark>(e)</Mark>
<Item>
    Both the spread and the uniform spread of <M>S</M> is exactly two
    (see&nbsp;<Cite Key="BW1"/>),
    with <M>s</M> of order <M>5</M>.
</Item>
</List>

<P/>

Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<Ref Subsect="easyloop"/>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "A5" );;
gap> ProbGenInfoSimple( t );
[ "A5", 1/3, 2, [ "5A" ], [ 1 ] ]
]]></Example>

<P/>

Statement&nbsp;(b) can be read off from the primitive permutation characters,
and the fact that the unique class of maximal subgroups that contain
elements of order <M>5</M> consists of groups of the structure <M>D_{10}</M>,
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;2"/>.

<P/>

<Example><![CDATA[
gap> OrdersClassRepresentatives( t );
[ 1, 2, 3, 5, 5 ]
gap> PrimitivePermutationCharacters( t );
[ Character( CharacterTable( "A5" ), [ 5, 1, 2, 0, 0 ] ), 
  Character( CharacterTable( "A5" ), [ 6, 2, 0, 1, 1 ] ), 
  Character( CharacterTable( "A5" ), [ 10, 2, 1, 0, 0 ] ) ]
]]></Example>

<P/>

For statement&nbsp;(c),
we compute that for all nonidentity elements <M>s \in S</M>
and involutions <M>g \in S</M>,
<M>&prop;(g,s) \geq 1/3</M> holds,
with equality if and only if <M>s</M> has order <M>5</M>.
We actually compute, for class representatives <M>s</M>,
the proportion of involutions <M>g</M> such that
<M>\langle g, s \rangle &noteq; S</M> holds.

<P/>

<Example><![CDATA[
gap> g:= AlternatingGroup( 5 );;
gap> inv:= g.1^2 * g.2;
(1,4)(2,5)
gap> cclreps:= List( ConjugacyClasses( g ), Representative );;
gap> SortParallel( List( cclreps, Order ), cclreps );
gap> List( cclreps, Order );
[ 1, 2, 3, 5, 5 ]
gap> Size( ConjugacyClass( g, inv ) );
15
gap> prop:= List( cclreps,
>                 r -> RatioOfNongenerationTransPermGroup( g, inv, r ) );
[ 1, 1, 3/5, 1/3, 1/3 ]
gap> Minimum( prop );
1/3
]]></Example>

<P/>

Statement&nbsp;(d) follows by explicit computations.

<P/>

<Example><![CDATA[
gap> triple:= [ (1,2)(3,4), (1,3)(2,4), (1,4)(2,3) ];;
gap> CommonGeneratorWithGivenElements( g, cclreps, triple );
fail
]]></Example>

<P/>

As for statement&nbsp;(e),
we know from&nbsp;(a) that the uniform spread of <M>S</M>
is at least two, and from&nbsp;(d) that the spread is less than three.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="A6">
<Heading><M>A_6</M></Heading>

We show that <M>S = A_6</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    <M>&total;(S) = 2/3</M>,
    and this value is attained exactly for <M>&total;(S,s)</M>
    with <M>s</M> of order <M>5</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s</M> of order <M>5</M>,
    <M>&M;(S,s)</M> consists of two nonconjugate groups of the type <M>A_5</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&prop;(S) = 5/9</M>,
    and this value is attained exactly for <M>&prop;(S,s)</M>
    with <M>s</M> of order <M>5</M>.
</Item>
<Mark>(d)</Mark>
<Item>
    Each element in <M>S</M> together with one of
    <M>(1,2)(3,4)</M>, <M>(1,3)(2,4)</M>, <M>(1,4)(2,3)</M>
    generates a proper subgroup of <M>S</M>.
</Item>
<Mark>(e)</Mark>
<Item>
    Both the spread and the uniform spread of <M>S</M> is exactly two
    (see&nbsp;<Cite Key="BW1"/>),
    with <M>s</M> of order <M>4</M>.
</Item>
<Mark>(f)</Mark>
<Item>
    For <M>x</M>, <M>y \in S_6^{\times}</M>, there is <M>s \in S_6</M>
    such that <M>S \subseteq \langle x, s \rangle \cap \langle y, s \rangle</M>.
    It is <E>not</E> possible to find <M>s \in S</M> with this property,
    or <M>s</M> in a prescribed conjugacy class of <M>S_6</M>.
</Item>
<Mark>(g)</Mark>
<Item>
    <M>&total;( &PGL;(2,9) ) = 1/6</M> and <M>&total;( M_{10} ) = 1/9</M>,
    with <M>s</M> of order <M>10</M> and <M>8</M>, respectively.
</Item>
</List>

<P/>

(Note that in this example, the optimal choice of <M>s</M> for <M>&prop;(S)</M> cannot be
used to obtain the result on the exact spread.)

<P/>

Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<Ref Subsect="easyloop"/>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "A6" );;
gap> ProbGenInfoSimple( t );
[ "A6", 2/3, 1, [ "5A" ], [ 2 ] ]
]]></Example>

<P/>

Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the two classes of maximal subgroups that contain
elements of order <M>5</M> consist of groups of the structure <M>A_5</M>,
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;4"/>.

<P/>

<Example><![CDATA[
gap> OrdersClassRepresentatives( t );
[ 1, 2, 3, 3, 4, 5, 5 ]
gap> prim:= PrimitivePermutationCharacters( t );
[ Character( CharacterTable( "A6" ), [ 6, 2, 3, 0, 0, 1, 1 ] ), 
  Character( CharacterTable( "A6" ), [ 6, 2, 0, 3, 0, 1, 1 ] ), 
  Character( CharacterTable( "A6" ), [ 10, 2, 1, 1, 2, 0, 0 ] ), 
  Character( CharacterTable( "A6" ), [ 15, 3, 3, 0, 1, 0, 0 ] ), 
  Character( CharacterTable( "A6" ), [ 15, 3, 0, 3, 1, 0, 0 ] ) ]
]]></Example>

<P/>

For statement&nbsp;(c),
we first compute that for all nonidentity elements <M>s \in S</M>
and involutions <M>g \in S</M>,
<M>&prop;(g,s) \geq 5/9</M> holds,
with equality if and only if <M>s</M> has order <M>5</M>.
We actually compute, for class representatives <M>s</M>,
the proportion of involutions <M>g</M> such that
<M>\langle g, s \rangle &noteq; S</M> holds.

<P/>

<Example><![CDATA[
gap> S:= AlternatingGroup( 6 );;
gap> inv:= (S.1*S.2)^2;
(1,3)(2,5)
gap> cclreps:= List( ConjugacyClasses( S ), Representative );;
gap> SortParallel( List( cclreps, Order ), cclreps );
gap> List( cclreps, Order );
[ 1, 2, 3, 3, 4, 5, 5 ]
gap> C:= ConjugacyClass( S, inv );;
gap> Size( C );
45
gap> prop:= List( cclreps,
>                 r -> RatioOfNongenerationTransPermGroup( S, inv, r ) );
[ 1, 1, 1, 1, 29/45, 5/9, 5/9 ]
gap> Minimum( prop );
5/9
]]></Example>

<P/>

Now statement&nbsp;(c) follows from the fact that for <M>g \in S</M> of order larger
than two, <M>&total;(S,g) \leq 1/2 &lt; 5/9</M> holds.

<P/>

<Example><![CDATA[
gap> ApproxP( prim, 6 );
[ 0, 2/3, 1/2, 1/2, 0, 1/3, 1/3 ]
]]></Example>

<P/>

Statement&nbsp;(d) follows by explicit computations.

<P/>

<Example><![CDATA[
gap> triple:= [ (1,2)(3,4), (1,3)(2,4), (1,4)(2,3) ];;
gap> CommonGeneratorWithGivenElements( S, cclreps, triple );
fail
]]></Example>

<P/>

An alternative triple to that in statement&nbsp;(d) is the one given
in&nbsp;<Cite Key="BW1"/>.

<P/>

<Example><![CDATA[
gap> triple:= [ (1,3)(2,4), (1,5)(2,6), (3,6)(4,5) ];;
gap> CommonGeneratorWithGivenElements( S, cclreps, triple );
fail
]]></Example>

<P/>

Of course we can also construct such a triple, as follows.

<P/>

<Example><![CDATA[
gap> TripleWithProperty( [ [ inv ], C, C ],
>        l -> ForAll( S, elm ->
>   ForAny( l, x -> not IsGeneratorsOfTransPermGroup( S, [ elm, x ] ) ) ) );
[ (1,3)(2,5), (1,3)(2,6), (1,3)(2,4) ]
]]></Example>

<P/>

For statement&nbsp;(e), we use the random approach described in
Section&nbsp;<Ref Subsect="subsect:groups"/>.

<P/>

<Example><![CDATA[
gap> s:= (1,2,3,4)(5,6);;
gap> reps:= Filtered( cclreps, x -> Order( x ) > 1 );;
gap> ResetGlobalRandomNumberGenerators();
gap> for pair in UnorderedTuples( reps, 2 ) do
>      if RandomCheckUniformSpread( S, pair, s, 40 ) <> true then
>        Print( "#E  nongeneration!\n" );
>      fi;
>    od;
]]></Example>

<P/>

We get no output, so a suitable element of order <M>4</M> works in all cases.
Note that we cannot use an element of order <M>5</M>,
because it fixes a point in the natural permutation representation,
and we may take <M>x_1 = (1,2,3)</M> and <M>x_2 = (4,5,6)</M>.
With this argument, only elements of order <M>4</M> and double <M>3</M>-cycles
are possible choices for <M>s</M>, and the latter are excluded by the fact
that an outer automorphism maps the class of double <M>s</M>-cycles in <M>A_6</M>
to the class of <M>3</M>-cycles.
So no element in <M>A_6</M> of order different from <M>4</M> works.

<P/>

Next we show statement&nbsp;(f).
Already in <M>A_6.2_1 = S_6</M>, elements <M>s</M> of order <M>4</M> do in general not work
because they do not generate with transpositions.

<P/>

<Example><![CDATA[
gap> G:= SymmetricGroup( 6 );;
gap> RatioOfNongenerationTransPermGroup( G, s, (1,2) );
1
]]></Example>

<P/>

Also, choosing <M>s</M> from a prescribed conjugacy class of <M>S_6</M> (that is,
also <M>s</M> outside <M>A_6</M> is allowed) with the property that
<M>A_6 \subseteq \langle x, s \rangle \cap \langle y, s \rangle</M>
is not possible.
Note that only <M>6</M>-cycles are possible for <M>s</M> if <M>x</M> and <M>y</M> are commuting
transpositions, and &ndash;applying the outer automorphism&ndash;
no <M>6</M>-cycle works for two commuting fixed-point free involutions.
(The group is small enough for a brute force test.)

<P/>

<Example><![CDATA[
gap> goods:= Filtered( Elements( G ),
>      s -> IsGeneratorsOfTransPermGroup( G, [ s, (1,2) ] ) and
>           IsGeneratorsOfTransPermGroup( G, [ s, (3,4) ] ) );;
gap> Collected( List( goods, CycleStructurePerm ) );
[ [ [ ,,,, 1 ], 24 ] ]
gap> goods:= Filtered( Elements( G ),
>      s -> IsGeneratorsOfTransPermGroup( G, [ s, (1,2)(3,4)(5,6) ] ) and
>           IsGeneratorsOfTransPermGroup( G, [ s, (1,3)(2,4)(5,6) ] ) );;
gap> Collected( List( goods, CycleStructurePerm ) );
[ [ [ 1, 1 ], 24 ] ]
]]></Example>

<P/>

However, for each pair of nonidentity element <M>x</M>, <M>y \in S_6</M>,
there is <M>s \in S_6</M> such that
<M>\langle x, s \rangle</M> and <M>\langle y, s \rangle</M> both contain <M>A_6</M>.
(If <M>s</M> works for the pair <M>(x,y)</M> then <M>s^g</M> works for <M>(x^g,y^g)</M>,
so it is sufficient to consider only orbit representatives <M>(x,y)</M> under
the conjugation action of <M>G</M> on pairs.
Thus we check conjugacy class representatives <M>x</M> and, for fixed <M>x</M>,
representatives of orbits of <M>C_G(x)</M> on the classes <M>y^G</M>,
i.&nbsp;e., representatives of <M>C_G(y)</M>-<M>C_G(x)</M>-double cosets in <M>G</M>.
Moreover, clearly we can restrict the checks to elements <M>x</M>, <M>y</M> of
prime order.)

<P/>

<Example><![CDATA[
gap> Sgens:= GeneratorsOfGroup( S );;
gap> primord:= Filtered( List( ConjugacyClasses( G ), Representative ),
>                        x -> IsPrimeInt( Order( x ) ) );;
gap> for x in primord do
>      for y in primord do
>        for pair in DoubleCosetRepsAndSizes( G, Centralizer( G, y ),
>                        Centralizer( G, x ) ) do
>          if not ForAny( G, s -> IsSubset( Group( x,s ), S ) and 
>                                 IsSubset( Group( y^pair[1], s ), S ) ) then
>            Error( [ x, y ] );
>          fi;
>        od;
>      od;
>    od;
]]></Example>

<P/>

In other words, the spread of <M>S_6</M> is <M>2</M> but the uniform spread of <M>S_6</M>
is not <M>2</M> but only <M>1</M>.

<P/>

We cannot always find <M>s \in A_6</M> with the required property:
If <M>x</M> is a transposition then any <M>s</M> with <M>S \subseteq\langle x, s \rangle</M>
must be a <M>5</M>-cycle.

<P/>

<Example><![CDATA[
gap> filt:= Filtered( S, s -> IsSubset( Group( (1,2), s ), S ) );;
gap> Collected( List( filt, Order ) );
[ [ 5, 48 ] ]
]]></Example>

<P/>

Moreover, clearly such <M>s</M> fixes one of the moved points of <M>x</M>,
so we may prescribe a transposition <M>y &noteq; x</M>
that commutes with <M>x</M>,
it satisfies <M>S \nsubseteq\langle y, s \rangle</M>.

<P/>

For the other two automorphic extensions <M>A_6.2_2 = &PGL;(2,9)</M>
and <M>A_6.2_3 = M_{10}</M>,
we compute the character-theoretic bounds <M>&total;(A_6.2_2) = 1/6</M>
and <M>&total;(A_6.2_3) = 1/9</M>,
which shows statement&nbsp;(g).

<P/>

<Example><![CDATA[
gap> ProbGenInfoSimple( CharacterTable( "A6.2_2" ) );
[ "A6.2_2", 1/6, 5, [ "10A" ], [ 1 ] ]
gap> ProbGenInfoSimple( CharacterTable( "A6.2_3" ) );
[ "A6.2_3", 1/9, 8, [ "8C" ], [ 1 ] ]
]]></Example>

<P/>

Note that <M>&total;^{\prime}( &PGL;(2,9), s ) = 1/6</M>,
with <M>s</M> of order <M>5</M>,
and <M>&total;^{\prime}( M_{10}, s ) = 0</M> for any <M>s \in A_6</M>
since <M>M_{10}</M> is a non-split extension of <M>A_6</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "A6" );;
gap> t2:= CharacterTable( "A6.2_2" );;
gap> spos:= PositionsProperty( OrdersClassRepresentatives( t ), x -> x = 5 );;
gap> ProbGenInfoAlmostSimple( t, t2, spos );
[ "A6.2_2", 1/6, [ "5A", "5B" ], [ 1, 1 ] ]
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="A7">
<Heading><M>A_7</M></Heading>

We show that <M>S = A_7</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    <M>&total;(S) = 2/5</M>,
    and this value is attained exactly for <M>&total;(S,s)</M>
    with <M>s</M> of order <M>7</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s</M> of order <M>7</M>,
    <M>&M;(S,s)</M> consists of two nonconjugate subgroups of the type <M>L_2(7)</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&prop;(S) = 2/5</M>,
    and this value is attained exactly for <M>&prop;(S,s)</M>
    with <M>s</M> of order <M>7</M>.
</Item>
<Mark>(d)</Mark>
<Item>
    The uniform spread of <M>S</M> is exactly three,
    with <M>s</M> of order <M>7</M>.
</Item>
</List>

<P/>

Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<Ref Subsect="easyloop"/>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "A7" );;
gap> ProbGenInfoSimple( t );
[ "A7", 2/5, 2, [ "7A" ], [ 2 ] ]
]]></Example>

<P/>

Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the two classes of maximal subgroups that contain
elements of order <M>7</M> consist of groups of the structure <M>L_2(7)</M>,
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;10"/>.

<P/>

<Example><![CDATA[
gap> OrdersClassRepresentatives( t );
[ 1, 2, 3, 3, 4, 5, 6, 7, 7 ]
gap> prim:= PrimitivePermutationCharacters( t );
[ Character( CharacterTable( "A7" ), [ 7, 3, 4, 1, 1, 2, 0, 0, 0 ] ), 
  Character( CharacterTable( "A7" ), [ 15, 3, 0, 3, 1, 0, 0, 1, 1 ] ),
  Character( CharacterTable( "A7" ), [ 15, 3, 0, 3, 1, 0, 0, 1, 1 ] ),
  Character( CharacterTable( "A7" ), [ 21, 5, 6, 0, 1, 1, 2, 0, 0 ] ),
  Character( CharacterTable( "A7" ), [ 35, 7, 5, 2, 1, 0, 1, 0, 0 ] ) 
 ]
]]></Example>

<P/>

For statement&nbsp;(c), we compute that for all nonidentity elements <M>s \in S</M>
and involutions <M>g \in S</M>,
<M>&prop;(g,s) \geq 2/5</M> holds,
with equality if and only if <M>s</M> has order <M>7</M>.
We actually compute, for class representatives <M>s</M>,
the proportion of involutions <M>g</M> such that
<M>\langle g, s \rangle &noteq; S</M> holds.

<P/>

<Example><![CDATA[
gap> g:= AlternatingGroup( 7 );;
gap> inv:= (g.1^3*g.2)^3;
(2,6)(3,7)
gap> ccl:= List( ConjugacyClasses( g ), Representative );;
gap> SortParallel( List( ccl, Order ), ccl );
gap> List( ccl, Order );
[ 1, 2, 3, 3, 4, 5, 6, 7, 7 ]
gap> Size( ConjugacyClass( g, inv ) );
105
gap> prop:= List( ccl, r -> RatioOfNongenerationTransPermGroup( g, inv, r ) );
[ 1, 1, 1, 1, 89/105, 17/21, 19/35, 2/5, 2/5 ]
gap> Minimum( prop );
2/5
]]></Example>

<P/>

For statement&nbsp;(d),
we use the random approach described in
Section&nbsp;<Ref Subsect="subsect:groups"/>.
By the character-theoretic bounds, it suffices to consider triples
of elements in the classes <C>2A</C> or <C>3B</C>.

<P/>

<Example><![CDATA[
gap> OrdersClassRepresentatives( t );
[ 1, 2, 3, 3, 4, 5, 6, 7, 7 ]
gap> spos:= Position( OrdersClassRepresentatives( t ), 7 );;
gap> SizesCentralizers( t );
[ 2520, 24, 36, 9, 4, 5, 12, 7, 7 ]
gap> ApproxP( prim, spos );
[ 0, 2/5, 0, 2/5, 2/15, 0, 0, 2/15, 2/15 ]
gap> s:= (1,2,3,4,5,6,7);;
gap> 3B:= (1,2,3)(4,5,6);;
gap> C3B:= ConjugacyClass( g, 3B );;
gap> Size( C3B );
280
gap> ResetGlobalRandomNumberGenerators();
gap> for triple in UnorderedTuples( [ inv, 3B ], 3 ) do
>      if RandomCheckUniformSpread( g, triple, s, 80 ) <> true then
>        Print( "#E  nongeneration!\n" );
>      fi;
>    od;
]]></Example>

<P/>

We get no output, so the uniform spread of <M>S</M> is at least three.

<P/>

Alternatively,
we can use the lemma from Section&nbsp;<Ref Subsect="sect:probgen-criteria"/>;
this approach is technically more involved but faster.
We work with the diagonal product of the two degree <M>15</M> representations
of <M>S</M>,
which is constructed from the information stored in the &GAP; Library
of Tables of Marks.

<P/>

<Example><![CDATA[
gap> tom:= TableOfMarks( "A7" );;
gap> a7:= UnderlyingGroup( tom );;
gap> tommaxes:= MaximalSubgroupsTom( tom );
[ [ 39, 38, 37, 36, 35 ], [ 7, 15, 15, 21, 35 ] ]
gap> index15:= List( tommaxes[1]{ [ 2, 3 ] },
>                    i -> RepresentativeTom( tom, i ) );
[ Group([ (1,3)(2,7), (1,5,7)(3,4,6) ]), 
  Group([ (1,4)(2,3), (2,4,6)(3,5,7) ]) ]
gap> deg15:= List( index15, s -> RightTransversal( a7, s ) );;
gap> reps:= List( deg15, l -> Action( a7, l, OnRight ) );
[ Group([ (1,5,7)(2,9,10)(3,11,4)(6,12,8)(13,14,15), (1,8,15,5,12)
      (2,13,11,3,10)(4,14,9,7,6) ]), 
  Group([ (1,2,3)(4,6,5)(7,8,9)(10,12,11)(13,15,14), (1,12,3,13,10)
      (2,9,15,4,11)(5,6,14,7,8) ]) ]
gap> g:= DiagonalProductOfPermGroups( reps );;
gap> ResetGlobalRandomNumberGenerators();
gap> repeat s:= Random( g );
>    until Order( s ) = 7;
gap> NrMovedPoints( s );
28
gap> mpg:= MovedPoints( g );;
gap> fixs:= Difference( mpg, MovedPoints( s ) );;
gap> orb_s:= Orbit( g, fixs, OnSets );;
gap> Length( orb_s );
120
gap> SizesCentralizers( t );
[ 2520, 24, 36, 9, 4, 5, 12, 7, 7 ]
gap> repeat 2a:= Random( g ); until Order( 2a ) = 2;
gap> repeat 3b:= Random( g );
>    until Order( 3b ) = 3 and Size( Centralizer( g, 3b ) ) = 9;
gap> orb2a:= Orbit( g, Difference( mpg, MovedPoints( 2a ) ), OnSets );;
gap> orb3b:= Orbit( g, Difference( mpg, MovedPoints( 3b ) ), OnSets );;
gap> orb2aor3b:= Union( orb2a, orb3b );;
gap> TripleWithProperty( [ [ orb2a[1], orb3b[1] ], orb2aor3b, orb2aor3b ],
>        l -> ForAll( orb_s,
>                 f -> not IsEmpty( Intersection( Union( l ), f ) ) ) );
fail
]]></Example>

<P/>

It remains to show that for any choice of <M>s \in S</M>,
a quadruple of elements in <M>S^{\times}</M> exists such that <M>s</M> generates
a proper subgroup of <M>S</M> together with at least one of these elements.

<P/>

First we observe (without using &GAP;) that there is a pair of <M>3</M>-cycles
whose fixed points cover the seven points of the natural permutation
representation.
This implies the statement for all elements <M>s \in S</M>
that fix a point in this representation.
So it remains to consider elements <M>s</M> of the orders six and seven.

<P/>

For the order seven element, the above setup and
the lemma from Section&nbsp;<Ref Subsect="sect:probgen-criteria"/>
can be used.

<P/>

<Example><![CDATA[
gap> QuadrupleWithProperty( [ [ orb2a[1] ], orb2a, orb2a, orb2a ],
>        l -> ForAll( orb_s,
>                 f -> not IsEmpty( Intersection( Union( l ), f ) ) ) );
[ [ 2, 5, 12, 18, 19, 26 ], [ 7, 8, 9, 16, 21, 25 ], 
  [ 1, 6, 10, 17, 20, 27 ], [ 13, 14, 15, 28, 29, 30 ] ]
]]></Example>

<P/>

For the order six element, we use the diagonal product of the
primitive permutation representations of the degrees <M>21</M> and <M>35</M>.

<P/>

<Example><![CDATA[
gap> has6A:= List( tommaxes[1]{ [ 4, 5 ] },
>                  i -> RepresentativeTom( tom, i ) );
[ Group([ (1,2)(3,7), (2,6,5,4)(3,7) ]), 
  Group([ (2,3)(5,7), (1,2)(4,5,6,7), (2,3)(5,6) ]) ]
gap> trans:= List( has6A, s -> RightTransversal( a7, s ) );;
gap> reps:= List( trans, l -> Action( a7, l, OnRight ) );
[ Group([ (1,16,12)(2,17,13)(3,18,11)(4,19,14)(15,20,21), (1,4,7,9,10)
      (2,5,8,3,6)(11,12,15,14,13)(16,20,19,17,18) ]), 
  Group([ (2,16,6)(3,17,7)(4,18,8)(5,19,9)(10,20,26)(11,21,27)
      (12,22,28)(13,23,29)(14,24,30)(15,25,31), (1,2,3,4,5)
      (6,10,13,15,9)(7,11,14,8,12)(16,20,23,25,19)(17,21,24,18,22)
      (26,32,35,31,28)(27,33,29,34,30) ]) ]
gap> g:= DiagonalProductOfPermGroups( reps );;
gap> repeat s:= Random( g );
>    until Order( s ) = 6;
gap> NrMovedPoints( s );
53
gap> mpg:= MovedPoints( g );;
gap> fixs:= Difference( mpg, MovedPoints( s ) );;
gap> orb_s:= Orbit( g, fixs, OnSets );;
gap> Length( orb_s );
105
gap> repeat 3a:= Random( g );
>    until Order( 3a ) = 3 and Size( Centralizer( g, 3a ) ) = 36;
gap> orb3a:= Orbit( g, Difference( mpg, MovedPoints( 3a ) ), OnSets );;
gap> Length( orb3a );
35
gap> TripleWithProperty( [ [ orb3a[1] ], orb3a, orb3a ],
>        l -> ForAll( orb_s,
>                 f -> not IsEmpty( Intersection( Union( l ), f ) ) ) );
[ [ 1, 4, 6, 12, 14, 15, 34, 37, 40, 43, 49 ], 
  [ 1, 4, 6, 16, 19, 20, 27, 30, 33, 44, 49 ], 
  [ 2, 3, 4, 5, 7, 9, 26, 47, 48, 50, 53 ] ]
]]></Example>

<P/>

So we have found not only a quadruple but even a triple of <M>3</M>-cycles
that excludes candidates <M>s</M> of order six.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="SL">
<Heading><M>L_d(q)</M></Heading>

In the treatment of small dimensional linear groups <M>S = &SL;(d,q)</M>,
<Cite Key="BGK"/> uses a Singer element <M>s</M> of order <M>(q^d-1)/(q-1)</M>.
(So the order of the corresponding element in
<M>&PSL;(d,q) = (q^d-1)/[(q-1) \gcd(d,q-1)]</M>.)
By&nbsp;<Cite Key="Be00"/>, <M>&M;(S,s)</M> consists of extension field type subgroups,
except in the cases <M>d = 2</M>, <M>q \in \{ 2, 5, 7, 9 \}</M>, and <M>(d,q) = (3,4)</M>.
These subgroups have the structure <M>&GL;(d/p,q^p):\alpha_q \cap S</M>,
for prime divisors <M>p</M> of <M>d</M>,
where <M>\alpha_q</M> denotes the Frobenius automorphism that acts on
matrices by raising each entry to the <M>q</M>-th power.
(If <M>q</M> is a prime then we have <M>&GL;(d/p,q^p):\alpha_q = &GammaL;(d/p,q^p)</M>.)
Since <M>s</M> acts irreducibly,
it is contained in at most one conjugate of each class of
extension field type subgroups
(cf.&nbsp;<Cite Key="BGK" Where="Lemma&nbsp;2.12"/>).

<P/>

First we write a &GAP; function <C>RelativeSigmaL</C> that takes
a positive integer <M>d</M> and a basis <M>B</M> of the field
extension of degree <M>n</M> over the field with <M>q</M> elements,
and returns the group <M>&GL;(d,q^n):\alpha_q</M>,
as a subgroup of <M>&GL;(dn,q)</M>.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  RelativeSigmaL( <d>, <B> )
##
##  Let <d> be a positive integer and <B> a basis for a field extension
##  of degree $n$, say, over the field $F$ with $q$ elements.
##  `RelativeSigmaL' returns a group of $<d> n \times <d> n$ matrices
##  over $F$, which is the intersection of $&SL;(<d> n, q)$ and the split
##  extension of an extension field type subgroup isomorphic with
##  $&GL;(<d>, q^n)$ by the Frobenius automorphism that maps each matrix
##  entry to its $q$-th power.
##
##  (If $q$ is a prime then the return value is isomorphic with the
##  semilinear group $\SigmaL(<d>, q^n)$.)
##
]]></Ignore>
<Example><![CDATA[
gap> RelativeSigmaL:= function( d, B )
>     local n, F, q, glgens, diag, pi, frob, i;
> 
>     n:= Length( B );
>     F:= LeftActingDomain( UnderlyingLeftModule( B ) );
>     q:= Size( F );
> 
>     # Create the generating matrices inside the linear subgroup.
>     glgens:= List( GeneratorsOfGroup( SL( d, q^n ) ),
>                    m -> BlownUpMat( B, m ) );
> 
>     # Create the matrix of a diagonal part that maps to determinant 1.
>     diag:= IdentityMat( d*n, F );
>     diag{ [ 1 .. n ] }{ [ 1 .. n ] }:= BlownUpMat( B, [ [ Z(q^n)^(q-1) ] ] );
>     Add( glgens, diag );
> 
>     # Create the matrix that realizes the Frobenius action,
>     # and adjust the determinant.
>     pi:= List( B, b -> Coefficients( B, b^q ) );
>     frob:= NullMat( d*n, d*n, F );
>     for i in [ 0 .. d-1 ] do
>       frob{ [ 1 .. n ] + i*n }{ [ 1 .. n ] + i*n }:= pi;
>     od;
>     diag:= IdentityMat( d*n, F );
>     diag{ [ 1 .. n ] }{ [ 1 .. n ] }:= BlownUpMat( B, [ [ Z(q^n) ] ] );
>     diag:= diag^LogFFE( Inverse( Determinant( frob ) ), Determinant( diag ) );
> 
>     # Return the result.
>     return Group( Concatenation( glgens, [ diag * frob ] ) );
> end;;
]]></Example>

<P/>

The next function computes <M>&total;(&SL;(d,q),s)</M>,
by computing the sum of <M>&fpr;(g,S/(&GL;(d/p,q^p):\alpha_q \cap S))</M>,
for prime divisors <M>p</M> of <M>d</M>, and taking the maximum over
<M>g \in S^{\times}</M>.
The computations take place in a permutation representation of <M>&PSL;(d,q)</M>.

<P/>

<!-- % (Note that &GAP; knows special methods for computing class representatives -->
<!-- % of the matrix groups <M>&SL;(d,q)</M>, -->
<!-- % but currently there are no special methods for checking whether two elements -->
<!-- % in <M>&SL;(d,g)</M> are conjugate.) -->

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  ApproxPForSL( <d>, <q> )
##
##  For a positive integer <d> and a prime power <q>,
##  `ApproxPForSL' returns $[ &M;(G,s), &total;( G, s ) ]$,
##  where $G = &PSL;( <d>, <q> )$, $s \in G$ is the image of a Singer cycle
##  in $&SL;(d,q)$,
##  and $&M;(G,s)$ is the list of names of those maximal subgroups of $G$
##  that contain $s$.
##
]]></Ignore>
<Example><![CDATA[
gap> ApproxPForSL:= function( d, q )
>     local G, epi, PG, primes, maxes, names, ccl;
> 
>     # Check whether this is an admissible case (see [Be00]).
>     if ( d = 2 and q in [ 2, 5, 7, 9 ] ) or ( d = 3 and q = 4 ) then
>       return fail;
>     fi;
> 
>     # Create the group SL(d,q), and the map to PSL(d,q).
>     G:= SL( d, q );
>     epi:= ActionHomomorphism( G, NormedRowVectors( GF(q)^d ), OnLines );
>     PG:= ImagesSource( epi );
> 
>     # Create the subgroups corresponding to the prime divisors of `d'.
>     primes:= PrimeDivisors( d );
>     maxes:= List( primes, p -> RelativeSigmaL( d/p,
>                                  Basis( AsField( GF(q), GF(q^p) ) ) ) );
>     names:= List( primes, p -> Concatenation( "GL(", String( d/p ), ",",
>                                  String( q^p ), ").", String( p ) ) );
>     if 2 < q then
>       names:= List( names, name -> Concatenation( name, " cap G" ) );
>     fi;
> 
>     # Compute the conjugacy classes of prime order elements in the maxes.
>     # (In order to avoid computing all conjugacy classes of these subgroups,
>     # we work in Sylow subgroups.)
>     ccl:= List( List( maxes, x -> ImagesSet( epi, x ) ),
>             M -> ClassesOfPrimeOrder( M, PrimeDivisors( Size( M ) ),
>                                       TrivialSubgroup( M ) ) );
> 
>     return [ names, UpperBoundFixedPointRatios( PG, ccl, true )[1] ];
> end;;
]]></Example>

<P/>

<!-- % Improve this as soon as special conjugacy tests for SL are installed? -->

We apply this function to the cases that are interesting
in&nbsp;<Cite Key="BGK" Where="Section&nbsp;5.12"/>.

<P/>

<Example><![CDATA[
gap> pairs:= [ [ 3, 2 ], [ 3, 3 ], [ 4, 2 ], [ 4, 3 ], [ 4, 4 ],
>            [ 6, 2 ], [ 6, 3 ], [ 6, 4 ], [ 6, 5 ], [ 8, 2 ], [ 10, 2 ] ];;
gap> array:= [];;
gap> for pair in pairs do
>      d:= pair[1];  q:= pair[2];
>      approx:= ApproxPForSL( d, q );
>      Add( array, [ Concatenation( "SL(", String(d), ",", String(q), ")" ),
>                    (q^d-1)/(q-1),
>                    approx[1], approx[2] ] );
>    od;
gap> oldsize:= SizeScreen();;
gap> SizeScreen( [ 80 ] );;
gap> PrintFormattedArray( array );
   SL(3,2)    7                             [ "GL(1,8).3" ]             1/4
   SL(3,3)   13                      [ "GL(1,27).3 cap G" ]            1/24
   SL(4,2)   15                             [ "GL(2,4).2" ]            3/14
   SL(4,3)   40                       [ "GL(2,9).2 cap G" ]         53/1053
   SL(4,4)   85                      [ "GL(2,16).2 cap G" ]           1/108
   SL(6,2)   63                [ "GL(3,4).2", "GL(2,8).3" ]       365/55552
   SL(6,3)  364   [ "GL(3,9).2 cap G", "GL(2,27).3 cap G" ] 22843/123845436
   SL(6,4) 1365  [ "GL(3,16).2 cap G", "GL(2,64).3 cap G" ]         1/85932
   SL(6,5) 3906 [ "GL(3,25).2 cap G", "GL(2,125).3 cap G" ]        1/484220
   SL(8,2)  255                             [ "GL(4,4).2" ]          1/7874
  SL(10,2) 1023               [ "GL(5,4).2", "GL(2,32).5" ]        1/129794
gap> SizeScreen( oldsize );;
]]></Example>

<!-- %T the most expensive call is SL(6,5), -->
<!-- %T and conjugacy tests for elements of order 31 are hard there -->

<P/>

The only missing case for&nbsp;<Cite Key="BGK"/> is <M>S = L_3(4)</M>,
for which <M>&M;(S,s)</M> consists of three groups of the type <M>L_3(2)</M>
(see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;23"/>).
The group <M>L_3(4)</M> has been considered already in Section&nbsp;<Ref Subsect="easyloop"/>,
where <M>&total;(S,s) = 1/5</M> has been proved.
Also the cases <M>&SL;(3,3)</M>, <M>&SL;(4,2) \cong A_8</M>, and <M>&SL;(4,3)</M> have been
handled there.

<P/>

An alternative character-theoretic proof for <M>S = L_6(2)</M> looks as follows.
In this case, the subgroups in <M>&M;(S,s)</M> have the types
<M>&GammaL;(3,4) \cong &GL;(3,4).2 \cong 3.L_3(4).3.2_2</M>
and <M>&GammaL;(2,8) \cong &GL;(2,8).3 \cong (7 \times L_2(8)).3</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "L6(2)" );;
gap> s1:= CharacterTable( "3.L3(4).3.2_2" );;
gap> s2:= CharacterTable( "(7xL2(8)).3" );;
gap> SigmaFromMaxes( t, "63A", [ s1, s2 ], [ 1, 1 ] );
365/55552
]]></Example>

<!-- %T add L4(4):   GL(2,16).2 cap G is (15xL2(16)).2 cap G -->
<!-- %T L6(3):       GL(3,9).2 cap G is ... -->
<!-- %T              GL(2,27).3 cap G is ... -->
<!-- %T L8(2):       GL(4,4).2 is (3xL4(4)).2 -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Ldq-with-prime-d">
<Heading><M>\ast</M>&nbsp;<M>L_d(q)</M> with prime <M>d</M></Heading>

For <M>S = &SL;(d,q)</M> with <E>prime</E> dimension <M>d</M>,
and <M>s \in S</M> a Singer cycle,
we have <M>&M;(S,s) = \{ M \}</M>,
where <M>M = N_S(\langle s \rangle) \cong &GammaL;(1,q^d) \cap S</M>.
So

<Display Mode="M">
   &total;(g,s) = &fpr;(g,S/M) = |g^S \cap M|/|g^S|
               &lt; |M|/|g^S| \leq (q^d-1) \cdot d/|g^S|
</Display>

holds for any <M>g \in S \setminus Z(S)</M>,
which implies
<M>&total;( S, s ) &lt; \max\{ (q^d-1) \cdot d/|g^S|; g \in S \setminus Z(S) \}</M>.
The right hand side of this inequality is returned by the following function.
In&nbsp;<Cite Key="BGK" Where="Lemma&nbsp;3.8"/>,
the global upper bound <M>1/q^d</M> is derived for primes <M>d \geq 5</M>.

<P/>

<Example><![CDATA[
gap> UpperBoundForSL:= function( d, q )
>     local G, Msize, ccl;
> 
>     if not IsPrimeInt( d ) then
>       Error( "<d> must be a prime" );
>     fi;
> 
>     G:= SL( d, q );
>     Msize:= (q^d-1) * d;
>     ccl:= Filtered( ConjugacyClasses( G ),
>                     c ->     Msize mod Order( Representative( c ) ) = 0
>                          and Size( c ) <> 1 );
> 
>     return Msize / Minimum( List( ccl, Size ) );
> end;;
]]></Example>

<P/>

The interesting values are <M>(d,q)</M> with <M>d \in \{ 5, 7, 11 \}</M> and
<M>q \in \{ 2, 3, 4 \}</M>, and perhaps also <M>(d,q) \in \{ (3,2), (3,3) \}</M>.
(Here we exclude <M>&SL;(11,4)</M> because writing down the conjugacy classes
of this group would exceed the permitted memory.)

<!-- %T what would help here: for example a conjugacy classes iterator -->

<P/>

<Example><![CDATA[
gap> NrConjugacyClasses( SL(11,4) );
1397660
gap> pairs:= [ [ 3, 2 ], [ 3, 3 ], [ 5, 2 ], [ 5, 3 ], [ 5, 4 ],
>              [ 7, 2 ], [ 7, 3 ], [ 7, 4 ],
>              [ 11, 2 ], [ 11, 3 ] ];;
gap> array:= [];;
gap> for pair in pairs do
>      d:= pair[1];  q:= pair[2];
>      approx:= UpperBoundForSL( d, q );
>      Add( array, [ Concatenation( "SL(", String(d), ",", String(q), ")" ),
>                    (q^d-1)/(q-1),
>                    approx ] );
>    od;
gap> PrintFormattedArray( array );
   SL(3,2)     7                                   7/8
   SL(3,3)    13                                   3/4
   SL(5,2)    31                              31/64512
   SL(5,3)   121                                 10/81
   SL(5,4)   341                                15/256
   SL(7,2)   127                             7/9142272
   SL(7,3)  1093                                14/729
   SL(7,4)  5461                               21/4096
  SL(11,2)  2047 2047/34112245508649716682268134604800
  SL(11,3) 88573                              22/59049
]]></Example>

<P/>

The exact values are clearly better than the above bounds.
We compute them for <M>L_5(2)</M> and <M>L_7(2)</M>.
In the latter case, the class fusion of the <M>127:7</M> type subgroup <M>M</M>
is not uniquely determined by the character tables;
here we use the additional information that the elements of order <M>7</M> in <M>M</M>
have centralizer order <M>49</M> in <M>L_7(2)</M>.
<!-- %T show this!! -->
(See Section&nbsp;<Ref Subsect="easyloop"/> for the examples with <M>d = 3</M>.)

<P/>

<Example><![CDATA[
gap> SigmaFromMaxes( CharacterTable( "L5(2)" ), "31A",
>        [ CharacterTable( "31:5" ) ], [ 1 ] );
1/5376
gap> t:= CharacterTable( "L7(2)" );;
gap> s:= CharacterTable( "P:Q", [ 127, 7 ] );;
gap> pi:= PossiblePermutationCharacters( s, t );;
gap> Length( pi );
2
gap> ord7:= PositionsProperty( OrdersClassRepresentatives( t ), x -> x = 7 );
[ 38, 45, 76, 77, 83 ]
gap> sizes:= SizesCentralizers( t ){ ord7 };
[ 141120, 141120, 3528, 3528, 49 ]
gap> List( pi, x -> x[83] );
[ 42, 0 ]
gap> spos:= Position( OrdersClassRepresentatives( t ), 127 );;
gap> Maximum( ApproxP( pi{ [ 1 ] }, spos ) );
1/4388290560
]]></Example>

<!-- %T add also L5(3); currently 121:5 causes problems!! -->
<!-- %T handle the others with ApproxPForSL? -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="SLaut">
<Heading>Automorphic Extensions of <M>L_d(q)</M></Heading>

For the following values of <M>d</M> and <M>q</M>,
automorphic extensions <M>G</M> of <M>L_d(q)</M> had to be checked
for&nbsp;<Cite Key="BGK" Where="Section&nbsp;5.12"/>.

<Display Mode="M">
   (d,q) \in \{ (3,4), (6,2), (6,3), (6,4), (6,5), (10,2) \}
</Display>

The first case has been treated in Section&nbsp;<Ref Subsect="easyloopaut"/>.
For the other cases, we compute <M>&total;^{\prime}(G,s)</M> below.
<P/>
In any case, the extension by a <E>graph</E> automorphism occurs,
which can be described by mapping each matrix in <M>&SL;(d,q)</M> to its inverse
transpose.
If <M>q > 2</M>, also extensions by <E>diagonal</E> automorphisms occur,
which are induced by conjugation with elements in <M>&GL;(d,q)</M>.
If <M>q</M> is nonprime then also extensions by <E>field</E> automorphisms occur,
which can be described by powering the matrix entries by roots of <M>q</M>.
Finally, products (of prime order) of these three kinds of automorphisms
have to be considered.
<P/>
We start with the extension <M>G</M> of <M>S = &SL;(d,q)</M> by a graph automorphism.
<M>G</M> can be embedded into <M>&GL;(2d,q)</M> by representing the matrix <M>A \in S</M>
as a block diagonal matrix with diagonal blocks equal to <M>A</M> and <M>A^{-tr}</M>,
and representing the graph automorphism by a permutation matrix that
interchanges the two blocks.
In order to construct the field extension type subgroups of <M>G</M>,
we have to choose the basis of the field extension in such a way that the
subgroup is normalized by the permutation matrix;
a sufficient condition is that the matrices of the <M>&F;_q</M>-linear mappings
induced by the basis elements are symmetric.
<P/>
(We do not give a function that computes a basis with this property from
the parameters <M>d</M> and <M>q</M>.
Instead, we only write down the bases that we will need.)

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  SymmetricBasis( <q>, <n> )
##
##  For a positive integer <n> and a prime power <q>,
##  `SymmetricBasis' returns a basis $B$ for the `GF(<q>)'-vector space
##  `GF(<q>^<n>)' with the property that $`BlownUpMat'( B, x )$
##  is symmetric for each element $x$ in `GF(<q>^<n>)'.
##
]]></Ignore>
<Example><![CDATA[
gap> SymmetricBasis:= function( q, n )
>     local vectors, B, issymmetric;
> 
>     if   q = 2 and n = 2 then
>       vectors:= [ Z(2)^0, Z(2^2) ];
>     elif q = 2 and n = 3 then
>       vectors:= [ Z(2)^0, Z(2^3), Z(2^3)^5 ];
>     elif q = 2 and n = 5 then
>       vectors:= [ Z(2)^0, Z(2^5), Z(2^5)^4, Z(2^5)^25, Z(2^5)^26 ];
>     elif q = 3 and n = 2 then
>       vectors:= [ Z(3)^0, Z(3^2) ];
>     elif q = 3 and n = 3 then
>       vectors:= [ Z(3)^0, Z(3^3)^2, Z(3^3)^7 ];
>     elif q = 4 and n = 2 then
>       vectors:= [ Z(2)^0, Z(2^4)^3 ];
>     elif q = 4 and n = 3 then
>       vectors:= [ Z(2)^0, Z(2^3), Z(2^3)^5 ];
>     elif q = 5 and n = 2 then
>       vectors:= [ Z(5)^0, Z(5^2)^2 ];
>     elif q = 5 and n = 3 then
>       vectors:= [ Z(5)^0, Z(5^3)^9, Z(5^3)^27 ];
>     else
>       Error( "sorry, no basis for <q> and <n> stored" );
>     fi;
> 
>     B:= Basis( AsField( GF(q), GF(q^n) ), vectors );
> 
>     # Check that the basis really has the required property.
>     issymmetric:= M -> M = TransposedMat( M );
>     if not ForAll( B, b -> issymmetric( BlownUpMat( B, [ [ b ] ] ) ) ) then
>       Error( "wrong basis!" );
>     fi;
> 
>     # Return the result.
>     return B;
> end;;
]]></Example>

<P/>

<!--
SymmetricBasis:= function( F )
    local B, subfield, elms, choices, index, issymmetric, pos, i;

    subfield:= Elements( LeftActingDomain( F ) );
    elms:= ShallowCopy( Elements( F ) );
    RemoveSet( elms, Zero( F ) );
    choices:= [];
    while not IsEmpty( elms ) do
      Add( choices, elms[1] );
      SubtractSet( elms, subfield * elms[1] );
    od;
    index:= Reversed( [ 1 .. Dimension( F ) ] );
    index[1]:= index[2];
    issymmetric:= ( M -> M = List( TransposedMat( M ) ) );
    repeat
      pos:= 1;
      while index[ pos ] = Length( choices ) - pos + 1 do
        pos:= pos + 1;
      od;
      for i in [ 1 .. pos ] do
        index[i]:= index[ pos ] + pos + 1 - i;
      od;
      B:= Basis( F, choices{ Reversed( index ) } );
    until B <> fail
          and ForAll( B, b -> issymmetric( BlownUpMat( B, [[b]] ) ) );

    return B;
end;
-->

In later examples, we will need similar embeddings of matrices.
Therefore, we provide a more general function <C>EmbeddedMatrix</C>
that takes a field <C>F</C>, a matrix <C>mat</C>, and a function <C>func</C>,
and returns a block diagonal matrix over <C>F</C> whose diagonal blocks are
<C>mat</C> and <C>func( mat )</C>.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  EmbeddedMatrix( <F>, <mat>, <func> )
##
##  For a field <F>, a matrix <mat> and a function <func> that takes a matrix
##  and returns a matrix of the same shape,
##  `EmbeddedMatrix' returns a block diagonal matrix over the field <F>
##  whose diagonal blocks are <mat> and `<func>( <mat> )'.
##
]]></Ignore>
<Example><![CDATA[
gap> BindGlobal( "EmbeddedMatrix", function( F, mat, func )
>   local d, result;
> 
>   d:= Length( mat );
>   result:= NullMat( 2*d, 2*d, F );
>   result{ [ 1 .. d ] }{ [ 1 .. d ] }:= mat;
>   result{ [ d+1 .. 2*d ] }{ [ d+1 .. 2*d ] }:= func( mat );
> 
>   return result;
> end );
]]></Example>

<P/>

The following function is similar to <C>ApproxPForSL</C>,
the differences are that the group <M>G</M> in question is not <M>&SL;(d,q)</M> but
the extension of this group by a graph automorphism,
and that <M>&total;^{\prime}(G,s)</M> is computed not <M>&total;(G,s)</M>.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  ApproxPForOuterClassesInExtensionOfSLByGraphAut( <d>, <q> )
##
##  For a positive integer <d> and a prime power <q>,
##  `ApproxPForOuterClassesInExtensionOfSLByGraphAut' returns
##  $[ &M;(G,s), &total;^{\prime}( G, s ) ]$,
##  where $G$ is $&PSL;( <d>, <q> )$ extended by a graph automorphism,
##  $s \in G$ is the image of a Singer cycle in $&SL;(d,q)$,
##  and $&M;(G,s)$ is the list of names of those maximal subgroups of
##  $&PGL;( <d>, <q> )$ that contain $s$.
##
]]></Ignore>
<Example><![CDATA[
gap> ApproxPForOuterClassesInExtensionOfSLByGraphAut:= function( d, q )
>     local embedG, swap, G, orb, epi, PG, Gprime, primes, maxes, ccl, names;
> 
>     # Check whether this is an admissible case (see [Be00],
>     # note that a graph automorphism exists only for `d > 2').
>     if d = 2 or ( d = 3 and q = 4 ) then
>       return fail;
>     fi;
> 
>     # Provide a function that constructs a block diagonal matrix.
>     embedG:= mat -> EmbeddedMatrix( GF( q ), mat,
>                                     M -> TransposedMat( M^-1 ) );
> 
>     # Create the matrix that exchanges the two blocks.
>     swap:= NullMat( 2*d, 2*d, GF(q) );
>     swap{ [ 1 .. d ] }{ [ d+1 .. 2*d ] }:= IdentityMat( d, GF(q) );
>     swap{ [ d+1 .. 2*d ] }{ [ 1 .. d ] }:= IdentityMat( d, GF(q) );
> 
>     # Create the group SL(d,q).2, and the map to the projective group.
>     G:= ClosureGroupDefault( Group( List( GeneratorsOfGroup( SL( d, q ) ),
>                                           embedG ) ),
>                       swap );
>     orb:= Orbit( G, One( G )[1], OnLines );
>     epi:= ActionHomomorphism( G, orb, OnLines );
>     PG:= ImagesSource( epi );
>     Gprime:= DerivedSubgroup( PG );
> 
>     # Create the subgroups corresponding to the prime divisors of `d'.
>     primes:= PrimeDivisors( d );
>     maxes:= List( primes,
>               p -> ClosureGroupDefault( Group( List( GeneratorsOfGroup(
>                          RelativeSigmaL( d/p, SymmetricBasis( q, p ) ) ),
>                          embedG ) ),
>                      swap ) );
> 
>     # Compute conjugacy classes of outer involutions in the maxes.
>     # (In order to avoid computing all conjugacy classes of these subgroups,
>     # we work in the Sylow $2$ subgroups.)
>     maxes:= List( maxes, M -> ImagesSet( epi, M ) );
>     ccl:= List( maxes, M -> ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );
>     names:= List( primes, p -> Concatenation( "GL(", String( d/p ), ",",
>                                    String( q^p ), ").", String( p ) ) );
> 
>     return [ names, UpperBoundFixedPointRatios( PG, ccl, true )[1] ];
> end;;
]]></Example>

<P/>

And these are the results for the groups we are interested in
(and others).
<P/>
<Example><![CDATA[
gap> ApproxPForOuterClassesInExtensionOfSLByGraphAut( 4, 3 );
[ [ "GL(2,9).2" ], 17/117 ]
gap> ApproxPForOuterClassesInExtensionOfSLByGraphAut( 4, 4 );
[ [ "GL(2,16).2" ], 73/1008 ]
gap> ApproxPForOuterClassesInExtensionOfSLByGraphAut( 6, 2 );
[ [ "GL(3,4).2", "GL(2,8).3" ], 41/1984 ]
gap> ApproxPForOuterClassesInExtensionOfSLByGraphAut( 6, 3 );
[ [ "GL(3,9).2", "GL(2,27).3" ], 541/352836 ]
gap> ApproxPForOuterClassesInExtensionOfSLByGraphAut( 6, 4 );
[ [ "GL(3,16).2", "GL(2,64).3" ], 3265/12570624 ]
gap> ApproxPForOuterClassesInExtensionOfSLByGraphAut( 6, 5 );
[ [ "GL(3,25).2", "GL(2,125).3" ], 13001/195250000 ]
gap> ApproxPForOuterClassesInExtensionOfSLByGraphAut( 8, 2 );
[ [ "GL(4,4).2" ], 367/1007872 ]
gap> ApproxPForOuterClassesInExtensionOfSLByGraphAut( 10, 2 );
[ [ "GL(5,4).2", "GL(2,32).5" ], 609281/476346056704 ]
]]></Example>
<P/>
Now we consider diagonal automorphisms.
We modify the approach for <M>&SL;(d,q)</M> by constructing the field extension
type subgroups of <M>&GL;(d,q) \ldots</M>

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  RelativeGammaL( <d>, <B> )
##
##  Let the arguments be as for `RelativeSigmaL'.
##  Then `RelativeGammaL' returns the extension field type subgroup of
##  $&GL;(d,q)$ that corresponds to the subgroup of $&SL;(d,q)$ returned by
##  `RelativeSigmaL'.
##
]]></Ignore>
<Example><![CDATA[
gap> RelativeGammaL:= function( d, B )
>     local n, F, q, diag;
> 
>     n:= Length( B );
>     F:= LeftActingDomain( UnderlyingLeftModule( B ) );
>     q:= Size( F );
>     diag:= IdentityMat( d * n, F );
>     diag{[ 1 .. n ]}{[ 1 .. n ]}:= BlownUpMat( B, [ [ Z(q^n) ] ] );
>     return ClosureGroup( RelativeSigmaL( d, B ),  diag );
> end;;
]]></Example>

<P/>

<M>\ldots</M>
and counting the elements of prime order outside the simple group.

<P/>

<Ignore Remark="gapfilecomments"><![CDATA[
#############################################################################
##
#F  ApproxPForOuterClassesInGL( <d>, <q> )
##
##  Let the arguments be as for `ApproxPForSL'.
##  Then `ApproxPForOuterClassesInGL' returns the list of names of the
##  extension field type subgroups of $&GL;(<d>,<q>)$,
##  and $&total;^{\prime}(&GL;(<d>,<q>),s)$,
##  for a Singer cycle $s \in &SL;(d,q)$.
##
]]></Ignore>
<Example><![CDATA[
gap> ApproxPForOuterClassesInGL:= function( d, q )
>     local G, epi, PG, Gprime, primes, maxes, names;
> 
>     # Check whether this is an admissible case (see [Be00]).
>     if ( d = 2 and q in [ 2, 5, 7, 9 ] ) or ( d = 3 and q = 4 ) then
>       return fail;
>     fi;
> 
>     # Create the group GL(d,q), and the map to PGL(d,q).
>     G:= GL( d, q );
>     epi:= ActionHomomorphism( G, NormedRowVectors( GF(q)^d ), OnLines );
>     PG:= ImagesSource( epi );
>     Gprime:= ImagesSet( epi, SL( d, q ) );
> 
>     # Create the subgroups corresponding to the prime divisors of `d'.
>     primes:= PrimeDivisors( d );
>     maxes:= List( primes, p -> RelativeGammaL( d/p,
>                                    Basis( AsField( GF(q), GF(q^p) ) ) ) );
>     maxes:= List( maxes, M -> ImagesSet( epi, M ) );
>     names:= List( primes, p -> Concatenation( "M(", String( d/p ), ",",
>                                    String( q^p ), ")" ) );
> 
>     return [ names,
>              UpperBoundFixedPointRatios( PG, List( maxes,
>                  M -> ClassesOfPrimeOrder( M,
>                           PrimeDivisors( Index( PG, Gprime ) ), Gprime ) ),
>                  true )[1] ];
> end;;
]]></Example>

<P/>

Here are the required results.

<P/>

<Example><![CDATA[
gap> ApproxPForOuterClassesInGL( 6, 3 );
[ [ "M(3,9)", "M(2,27)" ], 41/882090 ]
gap> ApproxPForOuterClassesInGL( 4, 3 );
[ [ "M(2,9)" ], 0 ]
gap> ApproxPForOuterClassesInGL( 6, 4 );
[ [ "M(3,16)", "M(2,64)" ], 1/87296 ]
gap> ApproxPForOuterClassesInGL( 6, 5 );
[ [ "M(3,25)", "M(2,125)" ], 821563/756593750000 ]
]]></Example>
<P/>
(Note that the extension field type subgroup in <M>&PGL;(4,3) = L_4(3).2_1</M>
is a <E>non-split</E> extension of its intersection with <M>L_4(3)</M>,
hence the zero value.)
<P/>
<!-- % Compared to an earlier version of <C>UpperBoundFixedPointRatios</C>, -->
<!-- % the following simpleminded function was faster. -->
<!-- % ApproxPForGroup:= function( G, Gccl, maxesclasses ) -->
<!-- %     local approx, list, c, r, img; -->
<!-- %  -->
<!-- %     approx:= List( Gccl, x -> 0 ); -->
<!-- %     for list in maxesclasses do -->
<!-- %       for c in list do -->
<!-- %         r:= Representative( c ); -->
<!-- %         if IsPrimeInt( Order( r ) ) then -->
<!-- %           img:= PositionProperty( Gccl, -->
<!-- %                     c -> Order( r ) = Order( Representative( c ) ) -->
<!-- %                          and r in c ); -->
<!-- %           approx[ img ]:= approx[ img ] + Size( c ); -->
<!-- %         fi; -->
<!-- %       od; -->
<!-- %     od; -->
<!-- %  -->
<!-- %     return List( [ 1 .. Length( Gccl ) ], i -> approx[i] / Size( Gccl[i] ) ); -->
<!-- % end;; -->
<P/>
Concerning extensions by Frobenius automorphisms,
only the case <M>(d,q) = (6,4)</M> is interesting in&nbsp;<Cite Key="BGK"/>.
In fact, we would not need to compute anything for the extension <M>G</M> of
<M>S = &SL;(6,4)</M> by the Frobenius map that squares each matrix entry.
This is because <M>&M;^{\prime}(G,s)</M> consists of the normalizers
of the two subgroups of the types <M>&SL;(3,16)</M> and <M>&SL;(2,64)</M>,
and the former maximal subgroup is a <E>non-split</E> extension of its
intersection with <M>S</M>,
<!-- % Note that <M>G</M> contains the extension of <M>&SL;(3,16)</M> by a Frobenius map -->
<!-- % of order four, and <M>S</M> contains the extension by the square of this map. -->
<!-- % (Note that we cannot find such an extension field type subgroup that is -->
<!-- % invariant under the involution that describes the Frobenius action, -->
<!-- % i.e., we cannot find a basis of <C>GF(16)/GF(4)</C> such that the blown up -->
<!-- % matrices have the property that their Frobenius images are also blown up -->
<!-- % matrices.) -->
so only one maximal subgroup can contribute to <M>&total;^{\prime}(G,s)</M>,
which is thus smaller than <M>1/2</M>,
by&nbsp;<Cite Key="BGK" Where="Prop.&nbsp;2.6"/>.

<P/>

However, it is easy enough to compute the exact value of
<M>&total;^{\prime}(G,s)</M>.
We work with the projective action of <M>S</M> on its natural module,
and compute the permutation induced by the Frobenius map as the
Frobenius action on the normed row vectors.

<P/>

<Example><![CDATA[
gap> matgrp:= SL(6,4);;
gap> dom:= NormedRowVectors( GF(4)^6 );;
gap> Gprime:= Action( matgrp, dom, OnLines );;
gap> pi:= PermList( List( dom, v -> Position( dom, List( v, x -> x^2 ) ) ) );;
gap> G:= ClosureGroup( Gprime, pi );;
]]></Example>

<P/>

Then we compute the maximal subgroups, the classes of outer involutions,
and the bound, similar to the situation with graph automorphisms.

<!-- % Note that each RelativeSigmaL is contained in Gprime!! -->

<P/>

<Example><![CDATA[
gap> maxes:= List( [ 2, 3 ], p -> Normalizer( G,
>              Action( RelativeSigmaL( 6/p,
>                Basis( AsField( GF(4), GF(4^p) ) ) ), dom, OnLines ) ) );;
gap> ccl:= List( maxes, M -> ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;
gap> List( ccl, Length );
[ 0, 1 ]
gap> UpperBoundFixedPointRatios( G, ccl, true );
[ 1/34467840, true ]
]]></Example>

<P/>

For <M>(d,q) = (6,4)</M>,
we have to consider also the extension <M>G</M> of <M>S = &SL;(6,4)</M>
by the product <M>\alpha</M> of the Frobenius map and the graph automorphism.
We use the same approach as for the graph automorphism,
i.&nbsp;e., we embed <M>&SL;(6,4)</M> into a <M>12</M>-dimensional group of <M>6 \times 6</M>
block matrices,
where the second block is the image of the first block under <M>\alpha</M>,
and describe <M>\alpha</M> by the transposition of the two blocks.

<P/>

First we construct the projective actions of <M>S</M> and <M>G</M> on an orbit of
<M>1</M>-spaces.

<P/>

<Example><![CDATA[
gap> embedFG:= function( F, mat )
>      return EmbeddedMatrix( F, mat,
>                 M -> List( TransposedMat( M^-1 ),
>                            row -> List( row, x -> x^2 ) ) );
>    end;;
gap> d:= 6;;  q:= 4;;
gap> alpha:= NullMat( 2*d, 2*d, GF(q) );;
gap> alpha{ [ 1 .. d ] }{ [ d+1 .. 2*d ] }:= IdentityMat( d, GF(q) );;
gap> alpha{ [ d+1 .. 2*d ] }{ [ 1 .. d ] }:= IdentityMat( d, GF(q) );;
gap> Gprime:= Group( List( GeneratorsOfGroup( SL(d,q) ),
>                          mat -> embedFG( GF(q), mat ) ) );;
gap> G:= ClosureGroupDefault( Gprime, alpha );;
gap> orb:= Orbit( G, One( G )[1], OnLines );;
gap> G:= Action( G, orb, OnLines );;
gap> Gprime:= Action( Gprime, orb, OnLines );;
]]></Example>

<P/>

Next we construct the maximal subgroups, the classes of outer involutions,
and the bound.

<P/>

<Example><![CDATA[
gap> maxes:= List( PrimeDivisors( d ), p -> Group( List( GeneratorsOfGroup(
>              RelativeSigmaL( d/p, Basis( AsField( GF(q), GF(q^p) ) ) ) ),
>                mat -> embedFG( GF(q), mat ) ) ) );;
gap> maxes:= List( maxes, x -> Action( x, orb, OnLines ) );;
gap> maxes:= List( maxes, x -> Normalizer( G, x ) );;
gap> ccl:= List( maxes, M -> ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;
gap> List( ccl, Length );
[ 0, 1 ]
gap> UpperBoundFixedPointRatios( G, ccl, true );
[ 1/10792960, true ]
]]></Example>

<P/>

The only missing cases are the extensions of <M>&SL;(6,3)</M> and <M>&SL;(6,5)</M>
by the involutory outer automorphism that acts as the product of a diagonal
and a graph automorphism.

<P/>

In the case <M>S = &SL;(6,3)</M>, we can directly write down the extension <M>G</M>.

<P/>

<Example><![CDATA[
gap> d:= 6;;  q:= 3;;
gap> diag:= IdentityMat( d, GF(q) );;
gap> diag[1][1]:= Z(q);;
gap> embedDG:= mat -> EmbeddedMatrix( GF(q), mat,
>                                     M -> TransposedMat( M^-1 )^diag );;
gap> Gprime:= Group( List( GeneratorsOfGroup( SL(d,q) ), embedDG ) );;
gap> alpha:= NullMat( 2*d, 2*d, GF(q) );;
gap> alpha{ [ 1 .. d ] }{ [ d+1 .. 2*d ] }:= IdentityMat( d, GF(q) );;
gap> alpha{ [ d+1 .. 2*d ] }{ [ 1 .. d ] }:= IdentityMat( d, GF(q) );;
gap> G:= ClosureGroupDefault( Gprime, alpha );;
]]></Example>

<P/>

The maximal subgroups are constructed as the normalizers in <M>G</M> of the
extension field type subgroups in <M>S</M>.
We work with a permutation representation of <M>G</M>.

<P/>

<Example><![CDATA[
gap> maxes:= List( PrimeDivisors( d ), p -> Group( List( GeneratorsOfGroup(
>              RelativeSigmaL( d/p, Basis( AsField( GF(q), GF(q^p) ) ) ) ),
>                embedDG ) ) );;
gap> orb:= Orbit( G, One( G )[1], OnLines );;
gap> G:= Action( G, orb, OnLines );;
gap> Gprime:= Action( Gprime, orb, OnLines );;
gap> maxes:= List( maxes, M -> Normalizer( G, Action( M, orb, OnLines ) ) );;
gap> ccl:= List( maxes, M -> ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;
gap> List( ccl, Length );
[ 1, 1 ]
gap> UpperBoundFixedPointRatios( G, ccl, true );
[ 25/352836, true ]
]]></Example>

<P/>

For <M>S = &SL;(6,5)</M>, this approach does not work because we cannot
realize the diagonal involution by an involutory matrix.
Instead, we consider the extension of <M>&GL;(6,5) \cong 2.(2 \times L_6(5)).2</M>
by the graph automorphism <M>\alpha</M>, which can be embedded into <M>&GL;(12,5)</M>.

<P/>

<Example><![CDATA[
gap> d:= 6;;  q:= 5;;
gap> embedG:= mat -> EmbeddedMatrix( GF(q),
>                                    mat, M -> TransposedMat( M^-1 ) );;
gap> Gprime:= Group( List( GeneratorsOfGroup( SL(d,q) ), embedG ) );;
gap> maxes:= List( PrimeDivisors( d ), p -> Group( List( GeneratorsOfGroup(
>              RelativeSigmaL( d/p, Basis( AsField( GF(q), GF(q^p) ) ) ) ),
>                embedG ) ) );;
gap> diag:= IdentityMat( d, GF(q) );;
gap> diag[1][1]:= Z(q);;
gap> diag:= embedG( diag );;
gap> alpha:= NullMat( 2*d, 2*d, GF(q) );;
gap> alpha{ [ 1 .. d ] }{ [ d+1 .. 2*d ] }:= IdentityMat( d, GF(q) );;
gap> alpha{ [ d+1 .. 2*d ] }{ [ 1 .. d ] }:= IdentityMat( d, GF(q) );;
gap> G:= ClosureGroupDefault( Gprime, alpha * diag );;
]]></Example>

<P/>

Now we switch to the permutation action of this group on the <M>1</M>-dimensional
subspaces, thus factoring out the cyclic normal subgroup of order four.
In this action, the involutory diagonal automorphism is represented by an
involution, and we can proceed as above.

<P/>

<Example><![CDATA[
gap> orb:= Orbit( G, One( G )[1], OnLines );;
gap> Gprime:= Action( Gprime, orb, OnLines );;
gap> G:= Action( G, orb, OnLines );;
gap> maxes:= List( maxes, M -> Action( M, orb, OnLines ) );;
gap> extmaxes:= List( maxes, M -> Normalizer( G, M ) );;
gap> ccl:= List( extmaxes, M -> ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;
gap> List( ccl, Length );
[ 2, 1 ]
gap> UpperBoundFixedPointRatios( G, ccl, true );
[ 3863/6052750000, true ]
]]></Example>

<P/>

In the same way,
we can recheck the values for the extensions of <M>&SL;(6,5)</M>
by the diagonal or by the graph automorphism.

<P/>

<Example><![CDATA[
gap> diag:= Permutation( diag, orb, OnLines );;
gap> G:= ClosureGroupDefault( Gprime, diag );;
gap> extmaxes:= List( maxes, M -> Normalizer( G, M ) );;
gap> ccl:= List( extmaxes, M -> ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;
gap> List( ccl, Length );
[ 3, 1 ]
gap> UpperBoundFixedPointRatios( G, ccl, true );
[ 821563/756593750000, true ]
gap> alpha:= Permutation( alpha, orb, OnLines );;
gap> G:= ClosureGroupDefault( Gprime, alpha );;
gap> extmaxes:= List( maxes, M -> Normalizer( G, M ) );;
gap> ccl:= List( extmaxes, M -> ClassesOfPrimeOrder( M, [ 2 ], Gprime ) );;
gap> List( ccl, Length );
[ 2, 2 ]
gap> UpperBoundFixedPointRatios( G, ccl, true );
[ 13001/195250000, true ]
]]></Example>

<!--
% alternatively:
% character-theoretic proof for the extension of <M>L_6(2)</M> by the graph
% automorphism
% 
% For <M>S = L_6(2)</M> and <M>s \in S</M> of order <M>63</M>,
% we have <M>&M;(S,s) = \{ &GammaL;(3,4), &GammaL;(2,8) \}</M>,
% these subgroups have the structures <M>&GL;(3,4).2 \cong 3.L_3(4).S_3</M>
% and <M>&GL;(2,8).3 \cong (7 \times L_2(8)).3</M>.

gap> t:= CharacterTable( "L6(2)" );;
gap> s1:= CharacterTable( "3.L3(4).3.2_2" );;
gap> s2:= CharacterTable( "(7xL2(8)).3" );;
gap> prim:= List( [ s1, s2 ], s -> PossiblePermutationCharacters( s, t ) );
[ [ Character( CharacterTable( "L6(2)" ), [ 55552, 0, 128, 256, 337, 112, 22, 
          0, 0, 16, 0, 16, 2, 17, 0, 0, 8, 2, 4, 28, 28, 0, 0, 0, 0, 4, 1, 0, 
          1, 0, 0, 4, 4, 0, 0, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 
          0, 0, 0, 0, 1, 1, 1, 1, 1, 1 ] ) ], 
  [ Character( CharacterTable( "L6(2)" ), [ 1904640, 0, 0, 512, 960, 0, 120, 
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 73, 73, 24, 24, 3, 0, 0, 15, 0, 
          0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 
          0, 0, 0, 0, 1, 1, 1, 1, 1, 1 ] ) ] ]

The permutation characters extend to <M>&Aut;(S) \cong S.2</M>. -->

gap> t2:= CharacterTable( "L6(2).2" );;
gap> map:= InverseMap( GetFusionMap( t, t2 ) );;
gap> torso:= List( Concatenation( prim ), pi -> CompositionMaps( pi, map ) );;
gap> ext:= List( torso, x -> PermChars( t2, rec( torso:= x ) ) );
[ [ Character( CharacterTable( "L6(2).2" ), [ 55552, 0, 128, 256, 337, 112, 
          22, 0, 0, 16, 0, 16, 2, 17, 0, 0, 8, 2, 4, 28, 0, 0, 0, 4, 1, 0, 1, 
          0, 0, 4, 0, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1120, 192, 32, 
          0, 0, 40, 13, 0, 4, 6, 0, 4, 4, 4, 0, 2, 8, 5, 0, 2, 0, 0, 0, 0, 1, 
          0, 1, 0 ] ) ], 
  [ Character( CharacterTable( "L6(2).2" ), [ 1904640, 0, 0, 512, 960, 0, 
          120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 73, 24, 3, 0, 0, 15, 0, 0, 
          0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 960, 960, 0, 0, 
          0, 0, 24, 0, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 
          0, 0, 0 ] ) ] ]
gap> sigma:= ApproxP( Concatenation( ext ),
>           Position( OrdersClassRepresentatives( t2 ), 63 ) );;
gap> Maximum( sigma{ Difference( PositionsProperty(
>                   OrdersClassRepresentatives( t2 ), IsPrimeInt ),
>                   ClassPositionsOfDerivedSubgroup( t2 ) ) } );
41/1984
-->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="L32">
<Heading><M>L_3(2)</M></Heading>

We show that <M>S = L_3(2) = &SL;(3,2)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    <M>&total;(S) = 1/4</M>,
    and this value is attained exactly for <M>&total;(S,s)</M>
    with <M>s</M> of order <M>7</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s</M> of order <M>7</M>,
    <M>&M;(S,s)</M> consists of one group of the type <M>7:3</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&prop;(S) = 1/4</M>,
    and this value is attained exactly for <M>&prop;(S,s)</M>
    with <M>s</M> of order <M>7</M>.
</Item>
<Mark>(d)</Mark>
<Item>
    The uniform spread of <M>S</M> is at exactly three,
    with <M>s</M> of order <M>7</M>,
    and the spread of <M>S</M> is exactly four.
    (This had been left open in&nbsp;<Cite Key="BW1"/>.)
</Item>
</List>

<P/>

(Note that in this example, the spread and the uniform spread differ.)

<P/>

Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<Ref Subsect="easyloop"/>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "L3(2)" );;
gap> ProbGenInfoSimple( t );
[ "L3(2)", 1/4, 3, [ "7A" ], [ 1 ] ]
]]></Example>

<P/>

Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the unique class of maximal subgroups that contain
elements of order <M>7</M> consists of groups of the structure <M>7:3</M>,
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;3"/>.

<P/>

<Example><![CDATA[
gap> OrdersClassRepresentatives( t );
[ 1, 2, 3, 4, 7, 7 ]
gap> PrimitivePermutationCharacters( t );
[ Character( CharacterTable( "L3(2)" ), [ 7, 3, 1, 1, 0, 0 ] ), 
  Character( CharacterTable( "L3(2)" ), [ 7, 3, 1, 1, 0, 0 ] ), 
  Character( CharacterTable( "L3(2)" ), [ 8, 0, 2, 0, 1, 1 ] ) ]
]]></Example>

<P/>

For the other statements, we will use the primitive permutation
representations on <M>7</M> and <M>8</M> points of <M>S</M>
(computed from the &GAP; Library of Tables of Marks),
and their diagonal products of the degrees <M>14</M> and <M>15</M>.

<P/>

<Example><![CDATA[
gap> tom:= TableOfMarks( "L3(2)" );;
gap> g:= UnderlyingGroup( tom );
Group([ (2,4)(5,7), (1,2,3)(4,5,6) ])
gap> mx:= MaximalSubgroupsTom( tom );
[ [ 14, 13, 12 ], [ 7, 7, 8 ] ]
gap> maxes:= List( mx[1], i -> RepresentativeTom( tom, i ) );;
gap> tr:= List( maxes, s -> RightTransversal( g, s ) );;
gap> acts:= List( tr, x -> Action( g, x, OnRight ) );;
gap> g7:= acts[1];
Group([ (3,4)(6,7), (1,3,2)(4,6,5) ])
gap> g8:= acts[3];
Group([ (1,6)(2,5)(3,8)(4,7), (1,7,3)(2,5,8) ])
gap> g14:= DiagonalProductOfPermGroups( acts{ [ 1, 2 ] } );
Group([ (3,4)(6,7)(11,13)(12,14), (1,3,2)(4,6,5)(8,11,9)(10,12,13) ])
gap> g15:= DiagonalProductOfPermGroups( acts{ [ 2, 3 ] } );
Group([ (4,6)(5,7)(8,13)(9,12)(10,15)(11,14), (1,4,2)(3,5,6)(8,14,10)
  (9,12,15) ])
]]></Example>

<P/>

First we compute that for all nonidentity elements <M>s \in S</M>
and order three elements <M>g \in S</M>,
<M>&prop;(g,s) \geq 1/4</M> holds,
with equality if and only if <M>s</M> has order <M>7</M>;
this implies statement&nbsp;(c).
We actually compute, for class representatives <M>s</M>,
the proportion of order three elements <M>g</M> such that
<M>\langle g, s \rangle &noteq; S</M> holds.

<P/>

<Example><![CDATA[
gap> ccl:= List( ConjugacyClasses( g7 ), Representative );;
gap> SortParallel( List( ccl, Order ), ccl );
gap> List( ccl, Order );
[ 1, 2, 3, 4, 7, 7 ]
gap> Size( ConjugacyClass( g7, ccl[3] ) );
56
gap> prop:= List( ccl,
>                 r -> RatioOfNongenerationTransPermGroup( g7, ccl[3], r ) );
[ 1, 5/7, 19/28, 2/7, 1/4, 1/4 ]
gap> Minimum( prop );
1/4
]]></Example>

<P/>

Now we show that the uniform spread of <M>S</M> is less than four.
In any of the primitive permutation representations of degree seven,
we find three involutions whose sets of fixed points cover the
seven points.
The elements <M>s</M> of order different from <M>7</M> in <M>S</M> fix a point in this
representation, so each such <M>s</M> generates a proper subgroup of <M>S</M>
together with one of the three involutions.

<P/>

<Example><![CDATA[
gap> x:= g7.1;
(3,4)(6,7)
gap> fix:= Difference( MovedPoints( g7 ), MovedPoints( x ) );
[ 1, 2, 5 ]
gap> orb:= Orbit( g7, fix, OnSets );
[ [ 1, 2, 5 ], [ 1, 3, 4 ], [ 2, 3, 6 ], [ 2, 4, 7 ], [ 1, 6, 7 ], 
  [ 3, 5, 7 ], [ 4, 5, 6 ] ]
gap> Union( orb{ [ 1, 2, 5 ] } ) = [ 1 .. 7 ];
true
]]></Example>

<P/>

So we still have to exclude elements <M>s</M> of order <M>7</M>.
In the primitive permutation representation of <M>S</M> on eight points,
we find four elements of order three whose sets of fixed points
cover the set of all points that are moved by <M>S</M>,
so with each element of order seven in <M>S</M>,
one of them generates an intransitive group.

<P/>

<Example><![CDATA[
gap> three:= g8.2;
(1,7,3)(2,5,8)
gap> fix:= Difference( MovedPoints( g8 ), MovedPoints( three ) );
[ 4, 6 ]
gap> orb:= Orbit( g8, fix, OnSets );;
gap> QuadrupleWithProperty( [ [ fix ], orb, orb, orb ],
>        list -> Union( list ) = [ 1 .. 8 ] );
[ [ 4, 6 ], [ 1, 7 ], [ 3, 8 ], [ 2, 5 ] ]
]]></Example>

<P/>

Together with statement&nbsp;(a), this proves that the uniform spread of <M>S</M>
is exactly three, with <M>s</M> of order seven.

<P/>

Each element of <M>S</M> fixes a point
in the permutation representation on <M>15</M> points.
So for proving that the spread of <M>S</M> is less than five,
it is sufficient to find a quintuple of elements whose sets of fixed points
cover all <M>15</M> points.
(From the permutation characters it is clear that four of these elements
must have order three, and the fifth must be an involution.)

<P/>

<Example><![CDATA[
gap> x:= g15.1;
(4,6)(5,7)(8,13)(9,12)(10,15)(11,14)
gap> fixx:= Difference( MovedPoints( g15 ), MovedPoints( x ) );
[ 1, 2, 3 ]
gap> orbx:= Orbit( g15, fixx, OnSets );
[ [ 1, 2, 3 ], [ 1, 4, 5 ], [ 1, 6, 7 ], [ 2, 4, 6 ], [ 3, 4, 7 ], 
  [ 3, 5, 6 ], [ 2, 5, 7 ] ]
gap> y:= g15.2;
(1,4,2)(3,5,6)(8,14,10)(9,12,15)
gap> fixy:= Difference( MovedPoints( g15 ), MovedPoints( y ) );
[ 7, 11, 13 ]
gap> orby:= Orbit( g15, fixy, OnSets );;
gap> QuadrupleWithProperty( [ [ fixy ], orby, orby, orby ],
>        l -> Difference( [ 1 .. 15 ], Union( l ) ) in orbx );
[ [ 7, 11, 13 ], [ 5, 8, 14 ], [ 1, 10, 15 ], [ 3, 9, 12 ] ]
]]></Example>

<P/>

It remains to show that the spread of <M>S</M> is (at least) four.
By the consideration of permutation characters,
we know that we can find a suitable order seven element
for all quadruples in question
except perhaps quadruples of order three elements.
We show that for each such case, we can choose <M>s</M> of order four.
Since <M>&M;(S,s)</M> consists of two subgroups of the type <M>S_4</M>,
we work with the representation on <M>14</M> points.)

<P/>

First we compute <M>s</M> and the <M>S</M>-orbit of its fixed points,
and the <M>S</M>-orbit of the fixed points of an element <M>x</M> of order three.
Then we prove that for each quadruple of conjugates of <M>x</M>,
the union of their fixed points intersects the fixed points of
at least one conjugate of <M>s</M> trivially.

<P/>

<Example><![CDATA[
gap> ResetGlobalRandomNumberGenerators();
gap> repeat s:= Random( g14 );
>    until Order( s ) = 4;
gap> s;
(1,3)(2,6,7,5)(9,11,10,12)(13,14)
gap> fixs:= Difference( MovedPoints( g14 ), MovedPoints( s ) );
[ 4, 8 ]
gap> orbs:= Orbit( g14, fixs, OnSets );;
gap> Length( orbs );
21
gap> three:= g14.2;
(1,3,2)(4,6,5)(8,11,9)(10,12,13)
gap> fix:= Difference( MovedPoints( g14 ), MovedPoints( three ) );
[ 7, 14 ]
gap> orb:= Orbit( g14, fix, OnSets );;
gap> Length( orb );
28
gap> QuadrupleWithProperty( [ [ fix ], orb, orb, orb ],
>        l -> ForAll( orbs, o -> not IsEmpty( Intersection( o,
>                        Union( l ) ) ) ) );
fail
]]></Example>

<P/>

By the lemma from Section&nbsp;<Ref Subsect="sect:probgen-criteria"/>,
we are done.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="spreadM11">
<Heading><M>M_{11}</M></Heading>

We show that <M>S = M_{11}</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    <M>&total;(S) = 1/3</M>,
    and this value is attained exactly for <M>&total;(S,s)</M>
    with <M>s</M> of order <M>11</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s</M> of order <M>11</M>,
    <M>&M;(S,s)</M> consists of one group of the type <M>L_2(11)</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&prop;(S) = 1/3</M>,
    and this value is attained exactly for <M>&prop;(S,s)</M>
    with <M>s</M> of order <M>11</M>.
</Item>
<Mark>(d)</Mark>
<Item>
    Both the uniform spread and the spread of <M>S</M> is exactly three,
    with <M>s</M> of order <M>11</M>.
</Item>
</List>

<P/>

Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<Ref Subsect="subsect:spor"/>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "M11" );;
gap> ProbGenInfoSimple( t );
[ "M11", 1/3, 2, [ "11A" ], [ 1 ] ]
]]></Example>

<P/>

Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the unique class of maximal subgroups that contain
elements of order <M>11</M> consists of groups of the structure <M>L_2(11)</M>,
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;18"/>.

<P/>

<Example><![CDATA[
gap> OrdersClassRepresentatives( t );
[ 1, 2, 3, 4, 5, 6, 8, 8, 11, 11 ]
gap> PrimitivePermutationCharacters( t );
[ Character( CharacterTable( "M11" ),
  [ 11, 3, 2, 3, 1, 0, 1, 1, 0, 0 ] ), 
  Character( CharacterTable( "M11" ),
  [ 12, 4, 3, 0, 2, 1, 0, 0, 1, 1 ] ), 
  Character( CharacterTable( "M11" ),
  [ 55, 7, 1, 3, 0, 1, 1, 1, 0, 0 ] ), 
  Character( CharacterTable( "M11" ),
  [ 66, 10, 3, 2, 1, 1, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "M11" ),
  [ 165, 13, 3, 1, 0, 1, 1, 1, 0, 0 ] ) ]
gap> Maxes( t );
[ "A6.2_3", "L2(11)", "3^2:Q8.2", "A5.2", "2.S4" ]
]]></Example>

<P/>

For the other statements, we will use the primitive permutation
representations of <M>S</M> on <M>11</M> and <M>12</M> points
(which are fetched from the &ATLAS; of Group Representations&nbsp;<Cite Key="AGRv3"/>),
and their diagonal product.

<P/>

<Example><![CDATA[
gap> gens11:= OneAtlasGeneratingSet( "M11", NrMovedPoints, 11 );
rec( charactername := "1a+10a", constituents := [ 1, 2 ], 
  contents := "core", 
  generators := [ (2,10)(4,11)(5,7)(8,9), (1,4,3,8)(2,5,6,9) ], 
  groupname := "M11", id := "", 
  identifier := [ "M11", [ "M11G1-p11B0.m1", "M11G1-p11B0.m2" ], 1, 
      11 ], isPrimitive := true, maxnr := 1, p := 11, rankAction := 2,
  repname := "M11G1-p11B0", repnr := 1, size := 7920, 
  stabilizer := "A6.2_3", standardization := 1, transitivity := 4, 
  type := "perm" )
gap> g11:= GroupWithGenerators( gens11.generators );;
gap> gens12:= OneAtlasGeneratingSet( "M11", NrMovedPoints, 12 );;
gap> g12:= GroupWithGenerators( gens12.generators );;
gap> g23:= DiagonalProductOfPermGroups( [ g11, g12 ] );
Group([ (2,10)(4,11)(5,7)(8,9)(12,17)(13,20)(16,18)(19,21), (1,4,3,8)
  (2,5,6,9)(12,17,18,15)(13,19)(14,20)(16,22,23,21) ])
]]></Example>

<P/>

First we compute that for all nonidentity elements <M>s \in S</M>
and involutions <M>g \in S</M>,
<M>&prop;(g,s) \geq 1/3</M> holds,
with equality if and only if <M>s</M> has order <M>11</M>;
this implies statement&nbsp;(c).
We actually compute, for class representatives <M>s</M>,
the proportion of involutions <M>g</M> such that
<M>\langle g, s \rangle &noteq; S</M> holds.

<P/>

<Example><![CDATA[
gap> inv:= g11.1;
(2,10)(4,11)(5,7)(8,9)
gap> ccl:= List( ConjugacyClasses( g11 ), Representative );;
gap> SortParallel( List( ccl, Order ), ccl );
gap> List( ccl, Order );
[ 1, 2, 3, 4, 5, 6, 8, 8, 11, 11 ]
gap> Size( ConjugacyClass( g11, inv ) );
165
gap> prop:= List( ccl,
>                 r -> RatioOfNongenerationTransPermGroup( g11, inv, r ) );
[ 1, 1, 1, 149/165, 25/33, 31/55, 23/55, 23/55, 1/3, 1/3 ]
gap> Minimum( prop );
1/3
]]></Example>

<P/>

For the first part of statement&nbsp;(d),
we have to deal only with the case of triples of involutions.

<P/>

The <M>11</M>-cycle <M>s</M> is contained in exactly one maximal subgroup
of <M>S</M>, of index <M>12</M>.
By Corollary&nbsp;1 in Section&nbsp;<Ref Subsect="sect:probgen-criteria"/>,
it is enough to show that in the primitive degree <M>12</M> representation
of <M>S</M>,
the fixed points of no triple <M>(x_1, x_2, x_3)</M> of involutions
in <M>S</M> can cover all twelve points;
equivalenly (considering complements),
we show that there is no triple such that
the intersection of the sets of <E>moved</E> points is empty.

<P/>

<Example><![CDATA[
gap> inv:= g12.1;
(1,6)(2,9)(5,7)(8,10)
gap> moved:= MovedPoints( inv );
[ 1, 2, 5, 6, 7, 8, 9, 10 ]
gap> orb12:= Orbit( g12, moved, OnSets );;
gap> Length( orb12 );
165
gap> TripleWithProperty( [ orb12{[1]}, orb12, orb12 ],
>        list -> IsEmpty( Intersection( list ) ) );
fail
]]></Example>

<P/>

This implies that the uniform spread of <M>S</M> is at least three.

<P/>

Now we show that there is a quadruple consisting of one
element of order three and three involutions whose fixed points cover
all points in the degree <M>23</M> representation constructed above;
since the permutation character of this representation is strictly positive,
this implies that <M>S</M> does not have spread four,
by Corollary&nbsp;2 in Section&nbsp;<Ref Subsect="sect:probgen-criteria"/>,
and we have proved statement&nbsp;(d).

<P/>

<Example><![CDATA[
gap> inv:= g23.1;
(2,10)(4,11)(5,7)(8,9)(12,17)(13,20)(16,18)(19,21)
gap> moved:= MovedPoints( inv );
[ 2, 4, 5, 7, 8, 9, 10, 11, 12, 13, 16, 17, 18, 19, 20, 21 ]
gap> orb23:= Orbit( g23, moved, OnSets );;
gap> three:= ( g23.1*g23.2^2 )^2;
(2,6,10)(4,8,7)(5,9,11)(12,17,23)(15,18,16)(19,21,22)
gap> movedthree:= MovedPoints( three );;
gap> QuadrupleWithProperty( [ [ movedthree ], orb23, orb23, orb23 ],
>        list -> IsEmpty( Intersection( list ) ) );
[ [ 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 21, 22, 23 ],
  [ 1, 3, 4, 5, 6, 8, 9, 10, 12, 13, 14, 16, 17, 18, 20, 21 ], 
  [ 1, 2, 3, 4, 5, 6, 7, 11, 12, 13, 14, 15, 18, 19, 20, 23 ], 
  [ 1, 2, 3, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 20, 22, 23 ] ]
]]></Example>

<!-- % Show the quadruple: -->
<!-- % RepresentativeAction? -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="spreadM12">
<Heading><M>M_{12}</M></Heading>

We show that <M>S = M_{12}</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    <M>&total;(S) = 1/3</M>,
    and this value is attained exactly for <M>&total;(S,s)</M>
    with <M>s</M> of order <M>10</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s \in S</M> of order <M>10</M>,
    <M>&M;(S,s)</M> consists of two nonconjugate subgroups
    of the type <M>A_6.2^2</M>,
    and one group of the type <M>2 \times S_5</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&prop;(S) = 31/99</M>,
    and this value is attained exactly for <M>&prop;(S,s)</M>
    with <M>s</M> of order <M>10</M>.
</Item>
<Mark>(d)</Mark>
<Item>
    The uniform spread of <M>S</M> is at least three,
    with <M>s</M> of order <M>10</M>.
</Item>
<Mark>(e)</Mark>
<Item>
    <M>&total;^{\prime}(&Aut;(S), s) = 4/99</M>.
</Item>
</List>

<P/>

Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<Ref Subsect="subsect:spor"/>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "M12" );;
gap> ProbGenInfoSimple( t );
[ "M12", 1/3, 2, [ "10A" ], [ 3 ] ]
]]></Example>

<P/>

Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the only classes of maximal subgroups that contain
elements of order <M>10</M> consist of groups of the structures
<M>A_6.2^2</M> (two classes) and <M>2 \times S_5</M> (one class),
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;33"/>.

<P/>

<Example><![CDATA[
gap> spos:= Position( OrdersClassRepresentatives( t ), 10 );
13
gap> prim:= PrimitivePermutationCharacters( t );;
gap> List( prim, x -> x{ [ 1, spos ] } );
[ [ 12, 0 ], [ 12, 0 ], [ 66, 1 ], [ 66, 1 ], [ 144, 0 ], [ 220, 0 ], 
  [ 220, 0 ], [ 396, 1 ], [ 495, 0 ], [ 495, 0 ], [ 1320, 0 ] ]
gap> Maxes( t );
[ "M11", "M12M2", "A6.2^2", "M12M4", "L2(11)", "3^2.2.S4", "M12M7", 
  "2xS5", "M8.S4", "4^2:D12", "A4xS3" ]
]]></Example>

<P/>

For statement&nbsp;(c) (which implies statement&nbsp;(d)),
we use the primitive permutation representation on <M>12</M> points.

<P/>

<Example><![CDATA[
gap> g:= MathieuGroup( 12 );
Group([ (1,2,3,4,5,6,7,8,9,10,11), (3,7,11,8)(4,10,5,6), (1,12)(2,11)
  (3,6)(4,8)(5,9)(7,10) ])
]]></Example>

<P/>

First we show that for <M>s</M> of order <M>10</M>,
<M>&prop;(S,s) = 31/99</M> holds.

<P/>

<Example><![CDATA[
gap> approx:= ApproxP( prim, spos );
[ 0, 3/11, 1/3, 1/11, 1/132, 13/99, 13/99, 13/396, 1/132, 1/33, 1/33, 
  1/33, 13/396, 0, 0 ]
gap> 2B:= g.2^2;
(3,11)(4,5)(6,10)(7,8)
gap> Size( ConjugacyClass( g, 2B ) );
495
gap> ResetGlobalRandomNumberGenerators();
gap> repeat s:= Random( g );
>    until Order( s ) = 10;
gap> prop:= RatioOfNongenerationTransPermGroup( g, 2B, s );
31/99
gap> Filtered( approx, x -> x >= prop );
[ 1/3 ]
]]></Example>

<P/>

Next we show that for <M>s</M> of order different from <M>10</M>,
<M>&prop;(g,s)</M> is larger than <M>31/99</M> for suitable <M>g \in S^{\times}</M>.
Except for <M>s</M> in the class <C>6A</C>
(which fixes no point in the degree <M>12</M>
representation), it suffices to consider <M>g</M> in the class <C>2B</C>
(with four fixed points).

<P/>

<Example><![CDATA[
gap> x:= g.2^2;
(3,11)(4,5)(6,10)(7,8)
gap> ccl:= List( ConjugacyClasses( g ), Representative );;
gap> SortParallel( List( ccl, Order ), ccl );
gap> prop:= List( ccl, r -> RatioOfNongenerationTransPermGroup( g, x, r ) );;
gap> SortedList( prop );
[ 7/55, 31/99, 5/9, 5/9, 39/55, 383/495, 383/495, 43/55, 29/33, 1, 1, 
  1, 1, 1, 1 ]
gap> bad:= Filtered( prop, x -> x < 31/99 );
[ 7/55 ]
gap> pos:= Position( prop, bad[1] );;
gap> [ Order( ccl[ pos ] ), NrMovedPoints( ccl[ pos ] ) ];
[ 6, 12 ]
]]></Example>

<P/>

In the remaining case, we choose <M>g</M> in the class <C>2A</C>
(which is fixed point free).

<P/>

<Example><![CDATA[
gap> x:= g.3;
(1,12)(2,11)(3,6)(4,8)(5,9)(7,10)
gap> s:= ccl[ pos ];;
gap> prop:= RatioOfNongenerationTransPermGroup( g, x, s );
17/33
gap> prop > 31/99;
true
]]></Example>

<P/>

Statement&nbsp;(e) has been shown already in
Section&nbsp;<Ref Subsect="probgen:sporaut"/>.

<!-- % Compute the exact (uniform) spread of <M>M_{12}</M>. -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="O73">
<Heading><M>O_7(3)</M></Heading>

We show that <M>S = O_7(3)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    <M>&total;(S) = 199/351</M>,
    and this value is attained exactly for <M>&total;(S,s)</M>
    with <M>s</M> of order <M>14</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s \in S</M> of order <M>14</M>,
    <M>&M;(S,s)</M> consists of one group of the type
    <M>2.U_4(3).2_2 = \Omega^-(6,3).2</M>
    and two nonconjugate groups of the type <M>S_9</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&prop;(S) = 155/351</M>,
    and this value is attained exactly for <M>&prop;(S,s)</M>
    with <M>s</M> of order <M>14</M>.
</Item>
<Mark>(d)</Mark>
<Item>
    The uniform spread of <M>S</M> is at least three,
    with <M>s</M> of order <M>14</M>.
</Item>
<Mark>(e)</Mark>
<Item>
    <M>&total;^{\prime}(&Aut;(S), s) = 1/3</M>.
</Item>
</List>

<P/>

Currently &GAP; provides neither the table of marks of <M>S</M> nor all
character tables of its maximal subgroups.
First we compute those primitive permutation characters of <M>S</M> that have
the degrees
<M>351</M> (point stabilizer <M>2.U_4(3).2_2</M>),
<M>364</M> (point stabilizer <M>3^5:U_4(2).2</M>),
<M>378</M> (point stabilizer <M>L_4(3).2_2</M>),
<M>1\,080</M> (point stabilizer <M>G_2(3)</M>, two classes),
<M>1\,120</M> (point stabilizer <M>3^{3+3}:L_3(3)</M>),
<M>3\,159</M> (point stabilizer <M>S_6(2)</M>, two classes),
<M>12\,636</M> (point stabilizer <M>S_9</M>, two classes),
<M>22\,113</M> (point stabilizer <M>(2^2 \times U_4(2)).2</M>,
which extends to <M>D_8 \times U_4(2).2</M> in <M>O_7(3).2</M>), and
<M>28\,431</M> (point stabilizer <M>2^6:A_7</M>).

<P/>

(So we ignore the primitive permutation characters of the degrees <M>3\,640</M>,
<M>265\,356</M>, and <M>331\,695</M>.
Note that the orders of the corresponding subgroups are not divisible by <M>7</M>.)

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "O7(3)" );;
gap> someprim:= [];;
gap> pi:= PossiblePermutationCharacters(
>             CharacterTable( "2.U4(3).2_2" ), t );;  Length( pi );
1
gap> Append( someprim, pi );
gap> pi:= PermChars( t, rec( torso:= [ 364 ] ) );;  Length( pi );
1
gap> Append( someprim, pi );
gap> pi:= PossiblePermutationCharacters(
>             CharacterTable( "L4(3).2_2" ), t );;  Length( pi );
1
gap> Append( someprim, pi );
gap> pi:= PossiblePermutationCharacters( CharacterTable( "G2(3)" ), t );
[ Character( CharacterTable( "O7(3)" ),
  [ 1080, 0, 0, 24, 108, 0, 0, 0, 27, 18, 9, 0, 12, 4, 0, 0, 0, 0, 0, 
      0, 0, 0, 12, 0, 0, 0, 0, 0, 3, 6, 0, 3, 2, 2, 2, 0, 0, 0, 3, 0, 
      0, 0, 0, 0, 0, 4, 0, 3, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "O7(3)" ),
  [ 1080, 0, 0, 24, 108, 0, 0, 27, 0, 18, 9, 0, 12, 4, 0, 0, 0, 0, 0, 
      0, 0, 0, 12, 0, 0, 0, 0, 3, 0, 0, 6, 3, 2, 2, 2, 0, 0, 3, 0, 0, 
      0, 0, 0, 0, 0, 4, 3, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0 ] ) ]
gap> Append( someprim, pi );
gap> pi:= PermChars( t, rec( torso:= [ 1120 ] ) );;  Length( pi );
1
gap> Append( someprim, pi );
gap> pi:= PossiblePermutationCharacters( CharacterTable( "S6(2)" ), t );
[ Character( CharacterTable( "O7(3)" ),
  [ 3159, 567, 135, 39, 0, 81, 0, 0, 27, 27, 0, 15, 3, 3, 7, 4, 0, 
      27, 0, 0, 0, 0, 0, 9, 3, 0, 9, 0, 3, 9, 3, 0, 2, 1, 1, 0, 0, 0, 
      3, 0, 2, 0, 0, 0, 3, 0, 0, 3, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "O7(3)" ),
  [ 3159, 567, 135, 39, 0, 81, 0, 27, 0, 27, 0, 15, 3, 3, 7, 4, 0, 
      27, 0, 0, 0, 0, 0, 9, 3, 0, 9, 3, 0, 3, 9, 0, 2, 1, 1, 0, 0, 3, 
      0, 0, 2, 0, 0, 0, 3, 0, 3, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 ] ) ]
gap> Append( someprim, pi );
gap> pi:= PossiblePermutationCharacters( CharacterTable( "S9" ), t );
[ Character( CharacterTable( "O7(3)" ),
  [ 12636, 1296, 216, 84, 0, 81, 0, 0, 108, 27, 0, 6, 0, 12, 10, 1, 
      0, 27, 0, 0, 0, 0, 0, 9, 3, 0, 9, 0, 12, 9, 3, 0, 1, 0, 2, 0, 
      0, 0, 3, 1, 1, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 
      1 ] ), Character( CharacterTable( "O7(3)" ),
  [ 12636, 1296, 216, 84, 0, 81, 0, 108, 0, 27, 0, 6, 0, 12, 10, 1, 
      0, 27, 0, 0, 0, 0, 0, 9, 3, 0, 9, 12, 0, 3, 9, 0, 1, 0, 2, 0, 
      0, 3, 0, 1, 1, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 
      1 ] ) ]
gap> Append( someprim, pi );
gap> t2:= CharacterTable( "O7(3).2" );;
gap> s2:= CharacterTable( "Dihedral", 8 ) * CharacterTable( "U4(2).2" );
CharacterTable( "Dihedral(8)xU4(2).2" )
gap> pi:= PossiblePermutationCharacters( s2, t2 );;  Length( pi );
1
gap> pi:= RestrictedClassFunctions( pi, t );;
gap> Append( someprim, pi );
gap> pi:= PossiblePermutationCharacters(
>             CharacterTable( "2^6:A7" ), t );;  Length( pi );
1
gap> Append( someprim, pi );
gap> List( someprim, x -> x[1] );
[ 351, 364, 378, 1080, 1080, 1120, 3159, 3159, 12636, 12636, 22113, 
  28431 ]
]]></Example>

<P/>

Note that in the three cases where two possible permutation characters
were found, there are in fact two classes of subgroups that induce
different permutation characters.
For the subgroups of the types <M>G_2(3)</M> and <M>S_6(2)</M>,
this is stated in&nbsp;<Cite Key="CCN85" Where="p.&nbsp;109"/>,
and for the subgroups of the type <M>S_9</M>,
this follows from the fact that each <M>S_9</M> type subgroup in <M>S</M> contains
elements in exactly one of the classes <C>3D</C> or <C>3E</C>,
and these two classes are fused by the outer automorphism of <M>S</M>.

<P/>

<Example><![CDATA[
gap> cl:= PositionsProperty( AtlasClassNames( t ),
>                            x -> x in [ "3D", "3E" ] );
[ 8, 9 ]
gap> List( Filtered( someprim, x -> x[1] = 12636 ), pi -> pi{ cl } );
[ [ 0, 108 ], [ 108, 0 ] ]
gap> GetFusionMap( t, t2 ){ cl };
[ 8, 8 ]
]]></Example>

<P/>

Now we compute the lower bounds for <M>&total;( S, s^{\prime} )</M> that are given
by the sublist <C>someprim</C> of the primitive permutation characters.

<P/>

<Example><![CDATA[
gap> spos:= Position( OrdersClassRepresentatives( t ), 14 );
52
gap> Maximum( ApproxP( someprim, spos ) );
199/351
]]></Example>

<P/>

This shows that <M>&total;( S, s ) = 199/351</M> holds.
For statement&nbsp;(a),
we have to show that choosing <M>s^{\prime}</M> from another class than
<C>14A</C> yields a larger value for <M>&total;( S, s^{\prime} )</M>.

<P/>

<Example><![CDATA[
gap> approx:= List( [ 1 .. NrConjugacyClasses( t ) ],
>       i -> Maximum( ApproxP( someprim, i ) ) );;
gap> PositionsProperty( approx, x -> x <= 199/351 );
[ 52 ]
]]></Example>

<P/>

Statement&nbsp;(b) can be read off from the permutation characters.

<P/>

<Example><![CDATA[
gap> pos:= PositionsProperty( someprim, x -> x[ spos ] <> 0 );
[ 1, 9, 10 ]
gap> List( someprim{ pos }, x -> x{ [ 1, spos ] } );
[ [ 351, 1 ], [ 12636, 1 ], [ 12636, 1 ] ]
]]></Example>

<P/>

For statement&nbsp;(c), we first compute <M>&prop;(g, s)</M> for <M>g</M> in the class
<C>2A</C>, via explicit computations with the group.
For dealing with this case, we first construct a faithful permutation
representation of <M>O_7(3)</M> from the natural matrix representation of
<M>&SO;(7,3)</M>.

<P/>

<!-- % In an earlier version, the result of <C>IsomorphismPermGroup</C> returned -->
<!-- % the action on the nonzero vectors, and I switched by hand to an action -->
<!-- % on the shortest orbit, of length 702. -->
<!-- % We need a transitive permutation representation, -->
<!-- % so we better prescribe the action on a particular orbit. -->

<Example><![CDATA[
gap> so73:= SpecialOrthogonalGroup( 7, 3 );;
gap> o73:= DerivedSubgroup( so73 );;
gap> orbs:= OrbitsDomain( o73, Elements( GF(3)^7 ) );;
gap> Set( orbs, Length );
[ 1, 702, 728, 756 ]
gap> g:= Action( o73, First( orbs, x -> Length( x ) = 702 ) );;
gap> Size( g ) = Size( t );
true
]]></Example>

<P/>

A <C>2A</C> element <M>g</M> can be found as the <M>7</M>-th power
of any element of order <M>14</M> in <M>S</M>.

<P/>

<Example><![CDATA[
gap> ResetGlobalRandomNumberGenerators();
gap> repeat s:= Random( g );
>    until Order( s ) = 14;
gap> 2A:= s^7;;
gap> bad:= RatioOfNongenerationTransPermGroup( g, 2A, s );
155/351
gap> bad > 1/3;
true
gap> approx:= ApproxP( someprim, spos );;
gap> PositionsProperty( approx, x -> x >= 1/3 );
[ 2 ]
]]></Example>

<P/>

This shows that <M>&prop;(g,s) = 155/351 > 1/3</M>.
Since <M>&total;( g, s ) &lt; 1/3</M> for all nonidentity <M>g</M>
not in the class <C>2A</C>, we have <M>&prop;( S, s ) = 155/351</M>.
For statement&nbsp;(c), it remains to show that <M>&prop;( S, s^{\prime} )</M> is larger
than <M>155/351</M> whenever <M>s^{\prime}</M> is not of order <M>14</M>.
First we compute <M>&prop;( g, s^{\prime} )</M>, for <M>g</M> in the class
<C>2A</C>.

<P/>

<Example><![CDATA[
gap> consider:= RepresentativesMaximallyCyclicSubgroups( t );
[ 18, 19, 25, 26, 27, 30, 31, 32, 34, 35, 38, 39, 41, 42, 43, 44, 45, 
  46, 47, 48, 49, 50, 52, 53, 54, 56, 57, 58 ]
gap> Length( consider );
28
gap> consider:= ClassesPerhapsCorrespondingToTableColumns( g, t, consider );;
gap> Length( consider );
31
gap> consider:= List( consider, Representative );;
gap> SortParallel( List( consider, Order ), consider );
gap> app2A:= List( consider, c ->
>       RatioOfNongenerationTransPermGroup( g, 2A, c ) );;
gap> SortedList( app2A );
[ 1/3, 1/3, 155/351, 191/351, 67/117, 23/39, 23/39, 85/117, 10/13, 
  10/13, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1 ]
gap> test:= PositionsProperty( app2A, x -> x <= 155/351 );;
gap> List( test, i -> Order( consider[i] ) );
[ 13, 13, 14 ]
]]></Example>

<P/>

We see that only for <M>s^{\prime}</M> in one of the two (algebraically
conjugate) classes of element order <M>13</M>,
<M>&prop;( S, s^{\prime} )</M> has a chance to be smaller than <M>155/351</M>.
This possibility is now excluded by counting elements in the class <C>3A</C>
that do not generate <M>S</M> together with <M>s^{\prime}</M> of order
<M>13</M>.

<P/>

<Example><![CDATA[
gap> C3A:= First( ConjugacyClasses( g ),
>               c -> Order( Representative( c ) ) = 3 and Size( c ) = 7280 );;
gap> repeat ss:= Random( g );
>    until Order( ss ) = 13;
gap> bad:= RatioOfNongenerationTransPermGroup( g, Representative( C3A ), ss );
17/35
gap> bad > 155/351;
true
]]></Example>

<P/>

Now we show statement&nbsp;(d):
For each triple <M>(x_1, x_2, x_3)</M> of nonidentity elements in <M>S</M>,
there is an element <M>s</M> in the class <C>14A</C> such that
<M>\langle x_i, s \rangle = S</M> holds for <M>1 \leq i \leq 3</M>.
We can read off from the character-theoretic data that
only those triples have to be checked for which at least two
elements are contained in the class <C>2A</C>,
and the third element lies in one of the classes
<C>2A</C>, <C>2B</C>, <C>3B</C>.

<P/>

<Example><![CDATA[
gap> approx:= ApproxP( someprim, spos );;
gap> max:= Maximum( approx{ [ 3 .. Length( approx ) ] } );
59/351
gap> 155 + 2*59 < 351;
true
gap> third:= PositionsProperty( approx, x -> 2 * 155/351 + x >= 1 );
[ 2, 3, 6 ]
gap> ClassNames( t ){ third };
[ "2a", "2b", "3b" ]
]]></Example>

<P/>

We can find elements in the classes <C>2B</C> and <C>3B</C> as powers
of arbitrary elements of the orders <M>20</M> and <M>15</M>, respectively.

<P/>

<Example><![CDATA[
gap> ord20:= PositionsProperty( OrdersClassRepresentatives( t ),
>                               x -> x = 20 );
[ 58 ]
gap> PowerMap( t, 10 ){ ord20 };
[ 3 ]
gap> repeat x:= Random( g );
>    until Order( x ) = 20;
gap> 2B:= x^10;;
gap> C2B:= ConjugacyClass( g, 2B );;
gap> ord15:= PositionsProperty( OrdersClassRepresentatives( t ),
>                               x -> x = 15 );
[ 53 ]
gap> PowerMap( t, 10 ){ ord15 };
[ 6 ]
gap> repeat x:= Random( g );
>    until Order( x ) = 15;
gap> 3B:= x^5;;
gap> C3B:= ConjugacyClass( g, 3B );;
]]></Example>

<P/>

The existence of <M>s</M> can be shown with the random approach
described in Section&nbsp;<Ref Subsect="subsect:groups"/>.

<P/>

<Example><![CDATA[
gap> repeat s:= Random( g );
>    until Order( s ) = 14;
gap> RandomCheckUniformSpread( g, [ 2A, 2A, 2A ], s, 50 );
true
gap> RandomCheckUniformSpread( g, [ 2B, 2A, 2A ], s, 50 );
true
gap> RandomCheckUniformSpread( g, [ 3B, 2A, 2A ], s, 50 );
true
]]></Example>

<P/>

Finally, we show statement&nbsp;(e).
Let <M>G = &Aut;(S) = S.2</M>.
By&nbsp;<Cite Key="CCN85" Where="p.&nbsp;109"/>,
<M>&M;^{\prime}(G,s)</M> consists of the extension
of the <M>2.U_4(3).2_1</M> type subgroup.
We compute the extension of the permutation character.

<P/>

<Example><![CDATA[
gap> prim:= someprim{ [ 1 ] };
[ Character( CharacterTable( "O7(3)" ),
  [ 351, 127, 47, 15, 27, 45, 36, 0, 0, 9, 0, 15, 3, 3, 7, 6, 19, 19, 
      10, 11, 12, 8, 3, 5, 3, 6, 1, 0, 0, 3, 3, 0, 1, 1, 1, 6, 3, 0, 
      0, 2, 2, 0, 3, 0, 3, 3, 0, 0, 1, 0, 0, 1, 0, 4, 4, 1, 2, 0 ] ) ]
gap> spos:= Position( AtlasClassNames( t ), "14A" );;
gap> t2:= CharacterTable( "O7(3).2" );;
gap> map:= InverseMap( GetFusionMap( t, t2 ) );;
gap> torso:= List( prim, pi -> CompositionMaps( pi, map ) );;
gap> ext:= List( torso, x -> PermChars( t2, rec( torso:= x ) ) );
[ [ Character( CharacterTable( "O7(3).2" ),
      [ 351, 127, 47, 15, 27, 45, 36, 0, 9, 0, 15, 3, 3, 7, 6, 19, 
          19, 10, 11, 12, 8, 3, 5, 3, 6, 1, 0, 3, 0, 1, 1, 1, 6, 3, 
          0, 2, 2, 0, 3, 0, 3, 3, 0, 1, 0, 0, 1, 0, 4, 1, 2, 0, 117, 
          37, 21, 45, 1, 13, 5, 1, 9, 9, 18, 15, 1, 7, 9, 6, 4, 0, 3, 
          0, 3, 3, 6, 2, 2, 9, 6, 1, 3, 1, 4, 1, 2, 1, 1, 0, 3, 1, 0, 
          0, 0, 0, 1, 1, 0, 0 ] ) ] ]
gap> approx:= ApproxP( Concatenation( ext ),
>        Position( AtlasClassNames( t2 ), "14A" ) );;
gap> Maximum( approx{ Difference(
>      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
>      ClassPositionsOfDerivedSubgroup( t2 ) ) } );
1/3
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="O8p2">
<Heading><M>O_8^+(2)</M></Heading>

We show that <M>S = O_8^+(2) = \Omega^+(8,2)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    <M>&total;(S) = 334/315</M>,
    and this value is attained exactly for <M>&total;(S,s)</M>
    with <M>s</M> of order <M>15</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s \in S</M> of order <M>15</M>,
    <M>&M;(S,s)</M> consists of one group of the type <M>S_6(2)</M>,
    two conjugate groups of the type <M>2^6:A_8</M>,
    two conjugate groups of the type <M>A_9</M>,
    and one group of each of the types
    <M>(3 \times U_4(2)):2 = (3 \times \Omega^-(6,2)):2</M> and
    <M>(A_5 \times A_5):2^2 = (\Omega^-(4,2) \times \Omega^-(4,2)):2^2</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&prop;(S) = 29/42</M>,
    and this value is attained exactly for <M>&prop;(S,s)</M>
    with <M>s</M> of order <M>15</M>.
</Item>
<Mark>(d)</Mark>
<Item>
    Let <M>x, y \in S</M> such that <M>x, y, x y</M> lie in the unique
    involution class of length <M>1\,575</M> of <M>S</M>.
    (This is the class <C>2A</C>.)
    Then each element in <M>S</M> together with one of
    <M>x</M>, <M>y</M>, <M>x y</M> generates a proper subgroup of <M>S</M>.
</Item>
<Mark>(e)</Mark>
<Item>
    Both the spread and the uniform spread of <M>S</M> is exactly two,
    with <M>s</M> of order <M>15</M>.
</Item>
<Mark>(f)</Mark>
<Item>
    For each choice of <M>s \in S</M>,
    there is an extension <M>S.2</M> such that
    for any element <M>g</M> in the (outer) class <C>2F</C>,
    <M>\langle s, g \rangle</M> does not contain <M>S</M>.
</Item>
<Mark>(g)</Mark>
<Item>
    For an element <M>s</M> of order <M>15</M> in <M>S</M>,
    either <M>S</M> is the only maximal subgroup of <M>S.2</M> that contains
    <M>s</M>,
    or the maximal subgroups of <M>S.2</M> that contain <M>s</M>
    are <M>S</M> and the extensions of the subgroups listed in
    statement&nbsp;(b);
    these groups have the structures <M>S_6(2) \times 2</M>,
    <M>2^6:S_8</M> (twice),
    <M>S_9</M> (twice), <M>S_3 \times U_4(2).2</M>, and <M>S_5 \wr 2</M>.
</Item>
<Mark>(h)</Mark>
<Item>
    For <M>s \in S</M> of order <M>15</M> and arbitrary
    <M>g \in S.3 \setminus S</M>,
    we have <M>\langle s, g \rangle = S.3</M>.
</Item>
<Mark>(i)</Mark>
<Item>
    If <M>x</M>, <M>y</M> are nonidentity elements in <M>&Aut;(S)</M> then
    there is an element <M>s</M> of order <M>15</M> in <M>S</M> such that
    <M>S \subseteq \langle x, s \rangle \cap \langle y, s \rangle</M>.
</Item>
</List>

<P/>

Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<Ref Subsect="easyloop"/>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "O8+(2)" );;
gap> ProbGenInfoSimple( t );
[ "O8+(2)", 334/315, 0, [ "15A", "15B", "15C" ], [ 7, 7, 7 ] ]
]]></Example>

<P/>

Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the only classes of maximal subgroups that contain
elements of order <M>15</M> consist of groups of the structures
as claimed, see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;85"/>.

<P/>

<Example><![CDATA[
gap> prim:= PrimitivePermutationCharacters( t );;
gap> spos:= Position( OrdersClassRepresentatives( t ), 15 );;
gap> List( Filtered( prim, x -> x[ spos ] <> 0 ), l -> l{ [ 1, spos ] } );
[ [ 120, 1 ], [ 135, 2 ], [ 960, 2 ], [ 1120, 1 ], [ 12096, 1 ] ]
]]></Example>

<P/>

For the remaining statements,
we take a primitive permutation representation on <M>120</M> points,
and assume that the permutation character is <C>1a+35a+84a</C>.
(See&nbsp;<Cite Key="CCN85" Where="p.&nbsp;85"/>,
note that the three classes of maximal subgroups
of index <M>120</M> in <M>S</M> are conjugate under triality.)

<P/>

<Example><![CDATA[
gap> matgroup:= DerivedSubgroup( GeneralOrthogonalGroup( 1, 8, 2 ) );;
gap> points:= NormedRowVectors( GF(2)^8 );;
gap> orbs:= OrbitsDomain( matgroup, points );;
gap> List( orbs, Length );
[ 135, 120 ]
gap> g:= Action( matgroup, orbs[2] );;
gap> Size( g );
174182400
gap> pi:= Sum( Irr( t ){ [ 1, 3, 7 ] } );
Character( CharacterTable( "O8+(2)" ),
 [ 120, 24, 32, 0, 0, 8, 36, 0, 0, 3, 6, 12, 4, 8, 0, 0, 0, 10, 0, 0, 
  12, 0, 0, 8, 0, 0, 3, 6, 0, 0, 2, 0, 0, 2, 1, 2, 2, 3, 0, 0, 2, 0, 
  0, 0, 0, 0, 3, 2, 0, 0, 1, 0, 0 ] )
]]></Example>

<P/>

In order to show statement&nbsp;(c),
we first observe that for <M>s</M> in the class <C>15A</C>
and <M>g</M> <E>not</E> in one of the classes <C>2A</C>, <C>2B</C>, <C>3A</C>,
<M>&total;(g,s) &lt; 1/3</M> holds,
and for the exceptional three classes,
we have <M>&total;(g,s) > 1/2</M>.

<P/>

<Example><![CDATA[
gap> approx:= ApproxP( prim, spos );;
gap> testpos:= PositionsProperty( approx, x -> x >= 1/3 );
[ 2, 3, 7 ]
gap> AtlasClassNames( t ){ testpos };
[ "2A", "2B", "3A" ]
gap> approx{ testpos };
[ 254/315, 334/315, 1093/1120 ]
gap> ForAll( approx{ testpos }, x -> x > 1/2 );
true
]]></Example>

<P/>

Now we compute the values <M>&prop;(g,s)</M>, for <M>s</M> in the class
<C>15A</C>
and <M>g</M> in one of the classes <C>2A</C>, <C>2B</C>, <C>3A</C>.

<P/>

By our choice of the character of the permutation representation we use,
the class <C>15A</C> is determined as the unique class of element order
<M>15</M> with one fixed point.
(Note that the three classes of element order <M>15</M> in <M>S</M> are conjugate
under triality.)
A <C>2A</C> element can be found as the fourth power of any element of order
<M>8</M> in <M>S</M>,
a <C>3A</C> element can be found as the fifth power of a <C>15A</C> element,
and a <C>2B</C> element can be found as the sixth power of an element
of order <M>12</M>, with <M>32</M> fixed points.

<P/>

<Example><![CDATA[
gap> ResetGlobalRandomNumberGenerators();
gap> repeat s:= Random( g );
>    until Order( s ) = 15 and NrMovedPoints( g ) = 1 + NrMovedPoints( s );
gap> 3A:= s^5;;
gap> repeat x:= Random( g ); until Order( x ) = 8;
gap> 2A:= x^4;;
gap> repeat x:= Random( g ); until Order( x ) = 12 and
>      NrMovedPoints( g ) = 32 + NrMovedPoints( x^6 );
gap> 2B:= x^6;;
gap> prop15A:= List( [ 2A, 2B, 3A ],
>                    x -> RatioOfNongenerationTransPermGroup( g, x, s ) );
[ 23/35, 29/42, 149/224 ]
gap> Maximum( prop15A );
29/42
]]></Example>

<P/>

This means that for <M>s</M> in the class <C>15A</C>,
we have <M>&prop;( S, s ) = 29/42</M>,
and the same holds for all <M>s</M> of order <M>15</M>
since the three classes of element order <M>15</M> are conjugate under triality.
Now we show that for <M>s</M> of order different from <M>15</M>,
the value <M>&prop;(g,s)</M> is larger than <M>29/42</M>,
for <M>g</M> in one of the classes <C>2A</C>, <C>2B</C>, <C>3A</C>,
or their images under triality.
This implies statement&nbsp;(c).

<P/>

<Example><![CDATA[
gap> test:= List( [ 2A, 2B, 3A ], x -> ConjugacyClass( g, x ) );;
gap> ccl:= ConjugacyClasses( g );;
gap> consider:= Filtered( ccl, c -> Size( c ) in List( test, Size ) );;
gap> Length( consider );
7
gap> filt:= Filtered( ccl, c -> ForAll( consider, cc ->
>       RatioOfNongenerationTransPermGroup( g, Representative( cc ),
>           Representative( c ) ) <= 29/42 ) );;
gap> Length( filt );
3
gap> List( filt, c -> Order( Representative( c ) ) );
[ 15, 15, 15 ]
]]></Example>

<!-- % The computation of <C>filt</C> requires 2896 seconds! -->

<P/>

Now we show statement&nbsp;(d).
First we observe that all those Klein four groups in <M>S</M> whose involutions
lie in the class <C>2A</C> are conjugate in <M>S</M>.
Note that this is the unique class of length <M>1\,575</M> in <M>S</M>,
and also the unique class whose elements have <M>24</M> fixed points
in the degree <M>120</M> permutation representation.

<P/>

For that, we use the character table of <M>S</M> to read off that <M>S</M> contains
exactly <M>14\,175</M> such subgroups,
and we use the group to compute one such subgroup and its normalizer
of index <M>14\,175</M>.

<P/>

<Example><![CDATA[
gap> SizesConjugacyClasses( t );
[ 1, 1575, 3780, 3780, 3780, 56700, 2240, 2240, 2240, 89600, 268800, 
  37800, 340200, 907200, 907200, 907200, 2721600, 580608, 580608, 
  580608, 100800, 100800, 100800, 604800, 604800, 604800, 806400, 
  806400, 806400, 806400, 2419200, 2419200, 2419200, 7257600, 
  24883200, 5443200, 5443200, 6451200, 6451200, 6451200, 8709120, 
  8709120, 8709120, 1209600, 1209600, 1209600, 4838400, 7257600, 
  7257600, 7257600, 11612160, 11612160, 11612160 ]
gap> NrPolyhedralSubgroups( t, 2, 2, 2 );
rec( number := 14175, type := "V4" )
gap> repeat x:= Random( g );
>    until     Order( x ) mod 2 = 0
>          and NrMovedPoints( x^( Order(x)/2 ) ) = 120 - 24;
gap> x:= x^( Order(x)/2 );;
gap> repeat y:= x^Random( g );
>    until NrMovedPoints( x*y ) = 120 - 24;
gap> v4:= SubgroupNC( g, [ x, y ] );;
gap> n:= Normalizer( g, v4 );;
gap> Index( g, n );
14175
]]></Example>

<P/>

We verify that the triple has the required property.

<P/>

<Example><![CDATA[
gap> maxorder:= RepresentativesMaximallyCyclicSubgroups( t );;
gap> maxorderreps:= List( ClassesPerhapsCorrespondingToTableColumns( g, t,
>        maxorder ), Representative );;
gap> Length( maxorderreps );
28
gap> CommonGeneratorWithGivenElements( g, maxorderreps, [ x, y, x*y ] );
fail
]]></Example>

<P/>

For the simple group <M>S</M>, it remains to show statement&nbsp;(e).
We want to show that for any choice of two nonidentity elements <M>x</M>, <M>y</M>
in <M>S</M>, there is an element <M>s</M> in the class <C>15A</C> such that
<M>\langle s, x \rangle = \langle s, y \rangle = S</M> holds.
Only <M>x</M>, <M>y</M> in the classes given by the list <C>testpos</C> must be considered,
by the estimates <M>&total;(g,s)</M>.

<P/>

We replace the values <M>&total;(g,s)</M> by the exact values <M>&prop;(g,s)</M>,
for <M>g</M> in one of these three classes.
Each of the three classes is determined by its element order and its number
of fixed points.

<P/>

<Example><![CDATA[
gap> reps:= List( ccl, Representative );;
gap> bading:= List( testpos, i -> Filtered( reps,
>        r -> Order( r ) = OrdersClassRepresentatives( t )[i] and
>             NrMovedPoints( r ) = 120 - pi[i] ) );;
gap> List( bading, Length );
[ 1, 1, 1 ]
gap> bading:= List( bading, x -> x[1] );;
]]></Example>

<P/>

For each pair <M>(C_1, C_2)</M> of classes represented by this list,
we have to show that for any choice of elements <M>x \in C_1</M>, <M>y \in C_2</M>
there is <M>s</M> in the class <C>15A</C> such that
<M>\langle s, x \rangle = \langle s, y \rangle = S</M> holds.
This is done with the random approach that is described in
Section&nbsp;<Ref Subsect="subsect:groups"/>.

<P/>

<Example><![CDATA[
gap> for pair in UnorderedTuples( bading, 2 ) do
>      test:= RandomCheckUniformSpread( g, pair, s, 80 );
>      if test <> true then
>        Error( test );
>      fi;
>    od;
]]></Example>

<P/>

We get no error message, so statement&nbsp;(e) holds.

<P/>

<!--
Alternatively, we could ...

For that, we work with an intransitive permutation representation of <M>S</M>,
which is the sum of the smallest six faithful transitive permutation
representations; any element of <M>S</M> fixes at least three points in this
representation.

gap> Sum( prim{ [ 1 .. 6 ] } );
Character( CharacterTable( "O8+(2)" ), [ 765, 189, 93, 93, 93, 45, 63, 63, 
  63, 9, 45, 45, 45, 21, 21, 21, 9, 15, 15, 15, 15, 15, 15, 15, 15, 15, 9, 
  21, 21, 21, 9, 9, 9, 9, 9, 9, 9, 3, 3, 3, 3, 3, 3, 3, 3, 3, 9, 3, 3, 3, 3, 
  3, 3 ] )
gap> tom:= TableOfMarks( t );;
gap> mx:= MaximalSubgroupsTom( tom );
[ [ 11170, 11169, 11168, 11167, 11166, 11165, 11164, 11163, 11162, 11158, 
      11157, 11156, 11155, 11077, 11076, 11075, 11074 ], 
  [ 120, 120, 120, 135, 135, 135, 960, 960, 960, 1120, 1120, 1120, 1575, 
      11200, 12096, 12096, 12096 ] ]
gap> reps:= List( mx[1]{ [ 1..6 ] }, i -> RepresentativeTom( tom, i ) );;
gap> g:= UnderlyingGroup( tom );;
gap> acts:= List( reps, x -> Action( g, RightTransversal( g, x ), OnRight ) );;
gap> g:= DiagonalProductOfPermGroups( acts );;
gap> NrMovedPoints( g );
765

First we compute a triple of involutions in <M>S</M> such that at least one
of them generates a proper subgroup of <M>S</M> together with any
element in a fixed class of element order <M>15</M>.

gap> repeat 8A:= Random( g ); until Order( 8A ) = 8;
gap> 2A:= 8A^4;;
gap> Size( Centralizer( g, 2A ) );
110592
gap> fix:= Difference( MovedPoints( g ), MovedPoints( 2A ) );;
gap> Length( fix );
189
gap> orb:= Orbit( g, fix, OnSets );;
gap> Length( orb );
1575
gap> repeat s:= Random( g );
>    until Order( s ) = 15;
gap> fixs:= Difference( MovedPoints( g ), MovedPoints( s ) );;
gap> Length( fixs );
3
gap> orbs:= Orbit( g, fixs, OnSets );;
gap> Length( orbs );
4320
gap> triple:= TripleWithProperty( [ orb{[1]}, orb, orb ],
>   t -> ForAll( orbs, x -> not IsEmpty( Intersection( x, Union( t ) ) ) ) );;
gap> IsList( triple );
true
gap> uni:= Union( triple );;
gap> Number( uni );
381

Note that each {\tt 2A} involution in <M>S</M> fixes exactly <M>189</M> points,
and the union of the fixed points of the triple found covers less than
half of the set of all points.
So it is not clear that this triple is good for our purposes.

Next we check that each element in <M>S</M> fixes a point that is also
fixed by one of the elements in our involution triple.
We have to consider only classes of maximal element order.

gap> maxorder:= RepresentativesMaximallyCyclicSubgroups( t );
[ 17, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 
  46, 47, 48, 49, 50, 51, 52, 53 ]
gap> maxorderccl:= ClassesPerhapsCorrespondingToTableColumns( g, t,
>        maxorder );;
gap> Length( maxorderccl );
28
gap> for c in maxorderccl do
>      s:= Representative( c );
>      fixs:= Difference( MovedPoints( g ), MovedPoints( s ) );
>      if ForAny( Orbit( g, fixs, OnSets ),
>              l -> IsEmpty( Intersection( l, uni ) ) ) then
>        Error( "bad element of order ", Order( s ) );
>      fi;
>    od;

(The above computation required more than one hour of CPU time.)

We get no error message, so the spread of <M>S</M> is less than three.
-->

<P/>

Now we turn to the automorphic extensions of <M>S</M>.
First we compute a permutation representation of <M>&SO;^+(8,2) \cong S.2</M>
and an element <M>g</M> in the class <C>2F</C>,
which is the unique conjugacy class of size <M>120</M> in <M>S.2</M>.

<P/>

<Example><![CDATA[
gap> matgrp:= SO(1,8,2);;
gap> g2:= Image( IsomorphismPermGroup( matgrp ) );;
gap> IsTransitive( g2, MovedPoints( g2 ) );
true
gap> repeat x:= Random( g2 ); until Order( x ) = 14;
gap> 2F:= x^7;;
gap> Size( ConjugacyClass( g2, 2F ) );
120
]]></Example>

<P/>

Only for <M>s</M> in six conjugacy classes of <M>S</M>,
there is a nonzero probability to have <M>S.2 = \langle g, s \rangle</M>.

<P/>

<Example><![CDATA[
gap> der:= DerivedSubgroup( g2 );;
gap> cclreps:= List( ConjugacyClasses( der ), Representative );;
gap> nongen:= List( cclreps,
>               x -> RatioOfNongenerationTransPermGroup( g2, 2F, x ) );;
gap> goodpos:= PositionsProperty( nongen, x -> x < 1 );;
gap> invariants:= List( goodpos, i -> [ Order( cclreps[i] ),
>      Size( Centralizer( g2, cclreps[i] ) ), nongen[i] ] );;
gap> SortedList( invariants );
[ [ 10, 20, 1/3 ], [ 10, 20, 1/3 ], [ 12, 24, 2/5 ], [ 12, 24, 2/5 ], 
  [ 15, 15, 0 ], [ 15, 15, 0 ] ]
]]></Example>

<P/>

<M>S</M> contains three classes of element order <M>10</M>, which are conjugate
in <M>S.3</M>.
For a fixed extension of the type <M>S.2</M>,
the element <M>s</M> can be chosen only in two of these three classes,
which means that there is another group of the type <M>S.2</M>
(more precisely, another subgroup of index three in <M>S.S_3</M>)
in which this choice of <M>s</M> is not suitable
&ndash;note that the general aim is to find <M>s \in S</M> uniformly for all
automorphic extensions of <M>S</M>.
Analogous statements hold for the other possibilities for <M>s</M>,
so statement&nbsp;(f) follows.

<P/>

Statement&nbsp;(g) follows from the list of maximal subgroups
in&nbsp;<Cite Key="CCN85" Where="p.&nbsp;85"/>.

<P/>

Statement&nbsp;(h) follows from the fact that <M>S</M> is the only maximal
subgroup of <M>S.3</M> that contains elements of order <M>15</M>,
according to the list of maximal subgroups
in&nbsp;<Cite Key="CCN85" Where="p.&nbsp;85"/>.
Alternatively, if we do not want to assume this information,
we can use explicit computations, as follows.
All we have to check is that any element in the classes <C>3F</C> and <C>3G</C>
generates <M>S.3</M> together with a fixed element of order <M>15</M> in <M>S</M>.

<P/>

We compute a permutation representation of <M>S.3</M> as the derived subgroup
of a subgroup of the type <M>S.S_3</M> inside the sporadic simple Fischer group
<M>Fi_{22}</M>;
these subgroups lie in the fourth class of maximal subgroups of <M>Fi_{22}</M>,
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;163"/>.
An element in the class <C>3F</C> of <M>S.3</M> can be found as a power of
an order <M>21</M> element,
and an element in the class <C>3G</C> can be found as the fourth power of
a <C>12P</C> element.

<P/>

<Example><![CDATA[
gap> aut:= Group( AtlasGenerators( "Fi22", 1, 4 ).generators );;
gap> Size( aut ) = 6 * Size( t );
true
gap> g3:= DerivedSubgroup( aut );;
gap> orbs:= OrbitsDomain( g3, MovedPoints( g3 ) );;
gap> List( orbs, Length );
[ 3150, 360 ]
gap> g3:= Action( g3, orbs[2] );;
gap> repeat s:= Random( g3 ); until Order( s ) = 15;
gap> repeat x:= Random( g3 ); until Order( x ) = 21;
gap> 3F:= x^7;;
gap> RatioOfNongenerationTransPermGroup( g3, 3F, s );
0
gap> repeat x:= Random( g3 );
>    until Order( x ) = 12 and Size( Centralizer( g3, x^4 ) ) = 648;
gap> 3G:= x^4;;
gap> RatioOfNongenerationTransPermGroup( g3, 3G, s );
0
]]></Example>

<P/>

Finally, consider statement&nbsp;(i).
It implies that&nbsp;<Cite Key="BGK" Where="Corollary&nbsp;1.5"/> holds
for <M>\Omega^+(8,2)</M>, with <M>s</M> of order <M>15</M>.
Note that by part&nbsp;(f),
<M>s</M> <E>cannot be chosen in a prescribed conjugacy class</E> of <M>S</M>
that is independent of the elements <M>x</M>, <M>y</M>.

<P/>

If <M>x</M> and <M>y</M> lie in <M>S</M> then statement&nbsp;(i) follows from part&nbsp;(e),
and by part&nbsp;(g), the case that <M>x</M> or <M>y</M> lie in <M>S.3 \setminus S</M>
is also not a problem.
We now show that also <M>x</M> or <M>y</M> in <M>S.2 \setminus S</M> is not a problem.
Here we have to deal with the cases that <M>x</M> and <M>y</M> lie in the same
subgroup of index <M>3</M> in <M>&Aut;(S)</M> or in different such subgroups.
Actually we show that for each index <M>3</M> subgroup
<M>H = S.2 &lt; &Aut;(S)</M>,
we can choose <M>s</M> from two of the three classes of element order <M>15</M> in <M>S</M>
such that <M>S</M> is the only maximal subgroup of <M>H</M> that contains <M>s</M>,
and thus <M>\langle x, s \rangle</M> contains <M>H</M>,
for any choice of <M>x \in H \setminus S</M>.

<P/>

For that, we note that no novelty in <M>S.2</M> contains elements of order <M>15</M>,
so all maximal subgroups of <M>S.2</M> that contain such elements &ndash;besides <M>S</M>&ndash;
have one of the indices <M>120, 135, 960, 1120</M>, or <M>12096</M>,
and point stabilizers of the types <M>S_6(2) \times 2</M>, <M>2^6:S_8</M>, <M>S_9</M>,
<M>S_3 \times U_4(2):2</M>, or
<M>S_5 \wr 2</M>.
We compute the corresponding permutation characters.

<P/>

<Example><![CDATA[
gap> t2:= CharacterTable( "O8+(2).2" );;
gap> s:= CharacterTable( "S6(2)" ) * CharacterTable( "Cyclic", 2 );;
gap> pi:= PossiblePermutationCharacters( s, t2 );;
gap> prim:= pi;;
gap> pi:= PermChars( t2, rec( torso:= [ 135 ] ) );;
gap> Append( prim, pi );
gap> pi:= PossiblePermutationCharacters( CharacterTable( "A9.2" ), t2 );;
gap> Append( prim, pi );
gap> s:= CharacterTable( "Dihedral(6)" ) * CharacterTable( "U4(2).2" );;
gap> pi:= PossiblePermutationCharacters( s, t2 );;
gap> Append( prim, pi );
gap> s:= CharacterTableWreathSymmetric( CharacterTable( "S5" ), 2 );;
gap> pi:= PossiblePermutationCharacters( s, t2 );;
gap> Append( prim, pi );
gap> Length( prim );
5
gap> ord15:= PositionsProperty( OrdersClassRepresentatives( t2 ),
>                               x -> x = 15 );
[ 39, 40 ]
gap> List( prim, pi -> pi{ ord15 } );
[ [ 1, 0 ], [ 2, 0 ], [ 2, 0 ], [ 1, 0 ], [ 1, 0 ] ]
gap> List( ord15, i -> Maximum( ApproxP( prim, i ) ) );
[ 307/120, 0 ]
]]></Example>

<P/>

Here it is appropriate to clean the workspace again.

<P/>

<Example><![CDATA[
gap> CleanWorkspace();
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="O8p3">
<Heading><M>O_8^+(3)</M></Heading>

We show that <M>S = O_8^+(3)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    <M>&total;(S) = 863/1820</M>,
    and this value is attained exactly for <M>&total;(S,s)</M>
    with <M>s</M> of order <M>20</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s \in S</M> of order <M>20</M>,
    <M>&M;(S,s)</M> consists of two nonconjugate groups of the type
    <M>O_7(3) = \Omega(7,3)</M>,
    two conjugate subgroups of the type <M>3^6:L_4(3)</M>,
    two nonconjugate subgroups of the type <M>(A_4 \times U_4(2)):2</M>,
    and one subgroup of each of the types <M>2.U_4(3).(2^2)_{122}</M>
    and <M>(A_6 \times A_6):2^2</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&prop;(S) = 194/455</M>,
    and this value is attained exactly for <M>&prop;(S,s)</M>
    with <M>s</M> of order <M>20</M>.
</Item>
<Mark>(d)</Mark>
<Item>
    The uniform spread of <M>S</M> is at least three,
    with <M>s</M> of order <M>20</M>.
</Item>
<Mark>(e)</Mark>
<Item>
    The preimage of <M>s</M> in the matrix group <M>2.S = \Omega^+(8,3)</M>
    can be chosen of order <M>40</M>,
    and then the maximal subgroups of <M>2.S</M> containing <M>s</M>
    have the structures <M>2.O_7(3)</M>, <M>3^6:2.L_4(3)</M>,
    <M>4.U_4(3).2^2 = &SU;(4,3).2^2</M>,
    <M>2.(A_4 \times U_4(2)).2 = 2.(&PSp;(2,3) \otimes &PSp;(4,3)).2</M>, and
    <M>2.(A_6 \times A_6):2^2 = 2.(\Omega^-(4,3) \times \Omega^-(4,3)):2^2</M>,
    respectively.
</Item>
<Mark>(f)</Mark>
<Item>
    For <M>s \in S</M> of order <M>20</M>, we have
    <M>&prop;^{\prime}(S.2_1, s) \in \{ 83/567, 574/1215 \}</M>,
    <M>&prop;^{\prime}(S.2_2, s) \in \{ 0, 1 \}</M>
    (depending on the choice of <M>s</M>), and
    <M>&total;^{\prime}(S.3, s) = 0</M>.

    <P/>

    Furthermore, for any choice of <M>s^{\prime} \in S</M>,
    we have <M>&total;^{\prime}(S.2_2, s^{\prime}) = 1</M>
    for some group <M>S.2_2</M>.
    However, if it is allowed to choose <M>s</M> from an <M>&Aut;(S)</M>-class
    of elements of order <M>20</M> (and not from a fixed <M>S</M>-class)
    then we can achieve <M>&total;(g,s) = 0</M> for any given
    <M>g \in S.2_2 \setminus S</M>.
</Item>
<Mark>(g)</Mark>
<Item>
    The maximal subgroups of <M>S.2_1</M> that contain an element of order
    <M>20</M> are either
    <M>S</M> and the extensions of the subgroups listed in statement&nbsp;(b)
    or they are
    <M>S</M> and <M>L_4(3).2^2</M>, <M>3^6:L_4(3).2</M> (twice),
    <M>2.U_4(3).(2^2)_{122}.2</M>, and
    <M>(A_6 \times A_6):2^2.2</M>.

    <P/>

    In the former case, the groups have the structures
    <M>O_7(3):2</M> (twice),
    <M>3^6:(L_4(3) \times 2)</M> (twice),
    <M>S_4 \times U_4(2).2</M> (twice),
    <M>2.U_4(3).(2^2)_{122}.2</M>, and
    <M>(A_6 \times A_6):2^2 \times 2</M>.
</Item>
</List>

<P/>

Statement&nbsp;(a) follows from inspection of the primitive permutation
characters.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "O8+(3)" );;
gap> ProbGenInfoSimple( t );
[ "O8+(3)", 863/1820, 2, [ "20A", "20B", "20C" ], [ 8, 8, 8 ] ]
]]></Example>

<P/>

Also statement&nbsp;(b) follows from the information provided by the
character table of <M>S</M> (cf.&nbsp;<Cite Key="CCN85" Where="p.&nbsp;140"/>).

<P/>

<Example><![CDATA[
gap> prim:= PrimitivePermutationCharacters( t );;
gap> ord:= OrdersClassRepresentatives( t );;
gap> spos:= Position( ord, 20 );;
gap> filt:= PositionsProperty( prim, x -> x[ spos ] <> 0 );
[ 1, 2, 7, 15, 18, 19, 24 ]
gap> Maxes( t ){ filt };
[ "O7(3)", "O8+(3)M2", "3^6:L4(3)", "2.U4(3).(2^2)_{122}", 
  "(A4xU4(2)):2", "O8+(3)M19", "(A6xA6):2^2" ]
gap> prim{ filt }{ [ 1, spos ] };
[ [ 1080, 1 ], [ 1080, 1 ], [ 1120, 2 ], [ 189540, 1 ], 
  [ 7960680, 1 ], [ 7960680, 1 ], [ 9552816, 1 ] ]
]]></Example>

<P/>

For statement&nbsp;(c), we first show that <M>&prop;(S,s) = 194/455</M> holds.
Since this value is larger than <M>1/3</M>,
we have to inspect only those classes <M>g^S</M> for which
<M>&total;(g,s) \geq 1/3</M> holds,

<P/>

<Example><![CDATA[
gap> ord:= OrdersClassRepresentatives( t );;
gap> ord20:= PositionsProperty( ord, x -> x = 20 );;
gap> cand:= [];;
gap> for i in ord20 do
>      approx:= ApproxP( prim, i );
>      Add( cand, PositionsProperty( approx, x -> x >= 1/3 ) );
>    od;
gap> cand;
[ [ 2, 6, 7, 10 ], [ 3, 6, 8, 11 ], [ 4, 6, 9, 12 ] ]
gap> AtlasClassNames( t ){ cand[1] };
[ "2A", "3A", "3B", "3E" ]
]]></Example>

<P/>

The three possibilities form one orbit under the outer automorphism group
of <M>S</M>.

<P/>

<Example><![CDATA[
gap> t3:= CharacterTable( "O8+(3).3" );;
gap> tfust3:= GetFusionMap( t, t3 );;
gap> List( cand, x -> tfust3{ x } );
[ [ 2, 4, 5, 6 ], [ 2, 4, 5, 6 ], [ 2, 4, 5, 6 ] ]
]]></Example>

<P/>

By symmetry, we may consider only the first possibility,
and assume that <M>s</M> is in the class <C>20A</C>.

<P/>

We work with a permutation representation of degree <M>1\,080</M>,
and assume that the permutation character is <C>1a+260a+819a</C>.
(Note that all permutation characters of <M>S</M> of degree <M>1\,080</M>
are conjugate under <M>&Aut;(S)</M>.)

<P/>

<Example><![CDATA[
gap> g:= Action( SO(1,8,3), NormedRowVectors( GF(3)^8 ), OnLines );;
gap> Size( g );
9904359628800
gap> g:= DerivedSubgroup( g );;  Size( g );
4952179814400
gap> orbs:= OrbitsDomain( g, MovedPoints( g ) );;
gap> List( orbs, Length );
[ 1080, 1080, 1120 ]
gap> g:= Action( g, orbs[1] );;
gap> PositionProperty( Irr( t ), chi -> chi[1] = 819 );
9
gap> permchar:= Sum( Irr( t ){ [ 1, 2, 9 ] } );
Character( CharacterTable( "O8+(3)" ),
 [ 1080, 128, 0, 0, 24, 108, 135, 0, 0, 108, 0, 0, 27, 27, 0, 0, 18, 
  9, 12, 16, 0, 0, 4, 15, 0, 0, 20, 0, 0, 12, 11, 0, 0, 20, 0, 0, 15, 
  0, 0, 12, 0, 0, 2, 0, 0, 3, 3, 0, 0, 6, 6, 0, 0, 3, 2, 2, 2, 18, 0, 
  0, 9, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 3, 0, 0, 12, 0, 0, 3, 0, 0, 0, 
  0, 0, 4, 3, 3, 0, 0, 1, 0, 0, 4, 0, 0, 1, 1, 2, 0, 0, 0, 0, 0, 3, 
  0, 0, 2, 0, 0, 5, 0, 0, 1, 0, 0 ] )
]]></Example>

<P/>

Now we show that for <M>s</M> in the class <C>20A</C> (which fixes one point),
the proportion of nongenerating elements <M>g</M> in one of the classes
<C>2A</C>, <C>3A</C>, <C>3B</C>, <C>3E</C> has the maximum <M>194/455</M>,
which is attained exactly for <C>3A</C>.
(We find a <C>2A</C> element as a power of <M>s</M>,
a <C>3A</C> element as a power of any element of order <M>18</M>,
a <C>3B</C> and a <C>3E</C> element as elements with <M>135</M> and <M>108</M>
fixed points, respectively, which occur as powers of suitable
elements of order <M>15</M>.)

<P/>

<Example><![CDATA[
gap> permchar{ ord20 };
[ 1, 0, 0 ]
gap> AtlasClassNames( t )[ PowerMap( t, 10 )[ ord20[1] ] ];
"2A"
gap> ord18:= PositionsProperty( ord, x -> x = 18 );;
gap> Set( AtlasClassNames( t ){ PowerMap( t, 6 ){ ord18 } } );
[ "3A" ]
gap> ord15:= PositionsProperty( ord, x -> x = 15 );;
gap> PowerMap( t, 5 ){ ord15 };
[ 7, 8, 9, 10, 11, 12 ]
gap> AtlasClassNames( t ){ [ 7 .. 12 ] };
[ "3B", "3C", "3D", "3E", "3F", "3G" ]
gap> permchar{ [ 7 .. 12 ] };
[ 135, 0, 0, 108, 0, 0 ]
gap> mp:= NrMovedPoints( g );;
gap> ResetGlobalRandomNumberGenerators();
gap> repeat 20A:= Random( g );
>    until Order( 20A ) = 20 and mp - NrMovedPoints( 20A ) = 1;
gap> 2A:= 20A^10;;
gap> repeat x:= Random( g ); until Order( x ) = 18;
gap> 3A:= x^6;;
gap> repeat x:= Random( g );
>    until Order( x ) = 15 and mp - NrMovedPoints( x^5 ) = 135;
gap> 3B:= x^5;;
gap> repeat x:= Random( g );
>    until Order( x ) = 15 and mp - NrMovedPoints( x^5 ) = 108;
gap> 3E:= x^5;;
gap> nongen:= List( [ 2A, 3A, 3B, 3E ],
>                   c -> RatioOfNongenerationTransPermGroup( g, c, 20A ) );
[ 3901/9477, 194/455, 451/1092, 451/1092 ]
gap> Maximum( nongen );
194/455
]]></Example>

<P/>

Next we compute the values <M>&prop;(g,s)</M>, for <M>g</M> is in the class
<C>3A</C> and certain elements <M>s</M>.
It is enough to consider representatives <M>s</M> of maximally cyclic subgroups
in <M>S</M>, but here we can do better, as follows.
Since <C>3A</C> is the unique class of length <M>72\,800</M>,
it is fixed under <M>&Aut;(S)</M>,
so it is enough to consider one element <M>s</M> from each <M>&Aut;(S)</M>-orbit
on the classes of <M>S</M>.
We use the class fusion between the character tables of <M>S</M> and <M>&Aut;(S)</M>
for computing orbit representatives.

<P/>

<Example><![CDATA[
gap> maxorder:= RepresentativesMaximallyCyclicSubgroups( t );;
gap> Length( maxorder );
57
gap> autt:= CharacterTable( "O8+(3).S4" );;
gap> fus:= PossibleClassFusions( t, autt );;
gap> orbreps:= Set( fus, map -> Set( ProjectionMap( map ) ) );
[ [ 1, 2, 5, 6, 7, 13, 17, 18, 19, 20, 23, 24, 27, 30, 31, 37, 43, 
      46, 50, 54, 55, 56, 57, 58, 64, 68, 72, 75, 78, 84, 85, 89, 95, 
      96, 97, 100, 106, 112 ] ]
gap> totest:= Intersection( maxorder, orbreps[1] );
[ 43, 50, 54, 56, 57, 64, 68, 75, 78, 84, 85, 89, 95, 97, 100, 106, 
  112 ]
gap> Length( totest );
17
gap> AtlasClassNames( t ){ totest };
[ "6Q", "6X", "6B1", "8A", "8B", "9G", "9K", "12A", "12D", "12J", 
  "12K", "12O", "13A", "14A", "15A", "18A", "20A" ]
]]></Example>

<P/>

This means that we have to test one element of each of the element orders
<M>13</M>, <M>14</M>, <M>15</M>, and <M>18</M>
(note that we know already a bound for elements of order <M>20</M>),
plus certain elements of the orders <M>6</M>, <M>8</M>, <M>9</M>, and <M>12</M>
which can be identified by their centralizer orders and (for elements of
order <M>6</M> and <M>8</M>) perhaps the centralizer orders of some powers.

<P/>

<Example><![CDATA[
gap> elementstotest:= [];;
gap> for elord in [ 13, 14, 15, 18 ] do
>      repeat s:= Random( g );
>      until Order( s ) = elord;
>      Add( elementstotest, s );
>    od;
]]></Example>

<P/>

The next elements to be tested are
in the classes <C>6B1</C> (centralizer order <M>162</M>),
in one of <C>9G</C>&ndash;<C>9J</C> (centralizer order <M>729</M>),
in one of <C>9K</C>&ndash;<C>9N</C> (centralizer order <M>81</M>),
in one of <C>12A</C>&ndash;<C>12C</C> (centralizer order <M>1\,728</M>),
in one of <C>12D</C>&ndash;<C>12I</C> (centralizer order <M>432</M>),
in <C>12J</C> (centralizer order <M>192</M>),
in one of <C>12K</C>&ndash;<C>12N</C> (centralizer order <M>108</M>),
and in one of <C>12O</C>&ndash;<C>12T</C> (centralizer order <M>72</M>).

<P/>

<Example><![CDATA[
gap> ordcent:= [ [ 6, 162 ], [ 9, 729 ], [ 9, 81 ], [ 12, 1728 ],
>                [ 12, 432 ], [ 12, 192 ], [ 12, 108 ], [ 12, 72 ] ];;
gap> cents:= SizesCentralizers( t );;
gap> for pair in ordcent do
>      Print( pair, ": ", AtlasClassNames( t ){
>          Filtered( [ 1 .. Length( ord ) ],
>                    i -> ord[i] = pair[1] and cents[i] = pair[2] ) }, "\n" );
>      repeat s:= Random( g );
>      until Order( s ) = pair[1] and Size( Centralizer( g, s ) ) = pair[2];
>      Add( elementstotest, s );
>    od;
[ 6, 162 ]: [ "6B1" ]
[ 9, 729 ]: [ "9G", "9H", "9I", "9J" ]
[ 9, 81 ]: [ "9K", "9L", "9M", "9N" ]
[ 12, 1728 ]: [ "12A", "12B", "12C" ]
[ 12, 432 ]: [ "12D", "12E", "12F", "12G", "12H", "12I" ]
[ 12, 192 ]: [ "12J" ]
[ 12, 108 ]: [ "12K", "12L", "12M", "12N" ]
[ 12, 72 ]: [ "12O", "12P", "12Q", "12R", "12S", "12T" ]
]]></Example>

<P/>

The next elements to be tested are
in one of the classes <C>6Q</C>&ndash;<C>6S</C> (centralizer order <M>648</M>).

<P/>

<Example><![CDATA[
gap> AtlasClassNames( t ){ Filtered( [ 1 .. Length( ord ) ],
>        i -> cents[i] = 648 and cents[ PowerMap( t, 2 )[i] ] = 52488
>                            and cents[ PowerMap( t, 3 )[i] ] = 26127360 ) };
[ "6Q", "6R", "6S" ]
gap> repeat s:= Random( g );
>    until Order( s ) = 6 and Size( Centralizer( g, s ) ) = 648
>      and Size( Centralizer( g, s^2 ) ) = 52488
>      and Size( Centralizer( g, s^3 ) ) = 26127360;
gap> Add( elementstotest, s );
]]></Example>

<P/>

The next elements to be tested are
in the class <C>6X</C>&ndash;<C>6A1</C> (centralizer order <M>648</M>).

<P/>

<Example><![CDATA[
gap> AtlasClassNames( t ){ Filtered( [ 1 .. Length( ord ) ],
>        i -> cents[i] = 648 and cents[ PowerMap( t, 2 )[i] ] = 52488
>                            and cents[ PowerMap( t, 3 )[i] ] = 331776 ) };
[ "6X", "6Y", "6Z", "6A1" ]
gap> repeat s:= Random( g );
>    until Order( s ) = 6 and Size( Centralizer( g, s ) ) = 648
>      and Size( Centralizer( g, s^2 ) ) = 52488
>      and Size( Centralizer( g, s^3 ) ) = 331776;
gap> Add( elementstotest, s );
]]></Example>

<P/>

Finally, we add elements from the classes <C>8A</C> and <C>8B</C>.

<P/>

<Example><![CDATA[
gap> AtlasClassNames( t ){ Filtered( [ 1 .. Length( ord ) ],
>        i -> ord[i] = 8 and cents[ PowerMap( t, 2 )[i] ] = 13824 ) };
[ "8A" ]
gap> repeat s:= Random( g );
>    until Order( s ) = 8 and Size( Centralizer( g, s^2 ) ) = 13824;
gap> Add( elementstotest, s );
gap> AtlasClassNames( t ){ Filtered( [ 1 .. Length( ord ) ],
>        i -> ord[i] = 8 and cents[ PowerMap( t, 2 )[i] ] = 1536 ) };
[ "8B" ]
gap> repeat s:= Random( g );
>    until Order( s ) = 8 and Size( Centralizer( g, s^2 ) ) = 1536;
gap> Add( elementstotest, s );
]]></Example>
<P/>
Now we compute the ratios.
It turns out that from these candidates,
only elements <M>s</M> of the orders <M>14</M> and <M>15</M> satisfy
<M>&prop;(g,s) &lt; 194/455</M>.

<P/>

<Example><![CDATA[
gap> nongen:= List( elementstotest,
>                   s -> RatioOfNongenerationTransPermGroup( g, 3A, s ) );;
gap> smaller:= PositionsProperty( nongen, x -> x < 194/455 );
[ 2, 3 ]
gap> nongen{ smaller };
[ 127/325, 1453/3640 ]
]]></Example>

<P/>

So the only candidates for <M>s</M> that may be better than order <M>20</M> elements
are elements of order <M>14</M> or <M>15</M>.
In order to exclude these two possibilities,
we compute <M>&prop;(g,s)</M> for <M>s</M> in the class <C>14A</C>
and <M>g = s^7</M> in the class <C>2A</C>,
and for <M>s</M> in the class <C>15A</C> and <M>g</M> in the class <C>2A</C>,
which yields values that are larger than <M>194/455</M>.

<P/>

<Example><![CDATA[
gap> repeat s:= Random( g );
>    until Order( s ) = 14 and NrMovedPoints( s ) = 1078;
gap> 2A:= s^7;;
gap> nongen:= RatioOfNongenerationTransPermGroup( g, 2A, s );
1573/3645
gap> nongen > 194/455;
true
gap> repeat s:= Random( g );
>    until Order( s ) = 15 and NrMovedPoints( s ) = 1080 - 3;
gap> nongen:= RatioOfNongenerationTransPermGroup( g, 2A, s );
490/1053
gap> nongen > 194/455;
true
]]></Example>

<P/>

For statement&nbsp;(d), we show that for each triple of elements
in the union of the classes <C>2A</C>, <C>3A</C>, <C>3B</C>, <C>3E</C>
there is an element in the class <C>20A</C> that generates <M>S</M>
together with each element of the triple.

<P/>

<Example><![CDATA[
gap> for tup in UnorderedTuples( [ 2A, 3A, 3B, 3E ], 3 ) do
>      cl:= ShallowCopy( tup );
>      test:= RandomCheckUniformSpread( g, cl, 20A, 100 );
>      if test <> true then
>        Error( test );
>      fi;
>    od;
]]></Example>

<P/>

We get no error message, so statement&nbsp;(d) is true.

<P/>

For statement&nbsp;(e), first we show that <M>2.S = \Omega^+(8,3)</M> contains
elements of order <M>40</M> but <M>S</M> does not.

<P/>

<Example><![CDATA[
gap> der:= DerivedSubgroup( SO(1,8,3) );;
gap> repeat x:= PseudoRandom( der ); until Order( x ) = 40;
gap> 40 in ord;
false
]]></Example>

<P/>

Thus elements of order <M>40</M> must arise as preimages of order <M>20</M> elements
under the natural epimorphism from <M>2.S</M> to <M>S</M>,
which means that we may choose an order <M>40</M> preimage <M>\hat{s}</M> of <M>s</M>.
Then <M>&M;(2.S, \hat{s})</M> consists of central extensions of the subgroups
listed in statement&nbsp;(b).
The perfect subgroups <M>O_7(3)</M>, <M>L_4(3)</M>, <M>2.U_4(3)</M>, and <M>U_4(2)</M>
of these groups must lift to their Schur double covers in <M>2.S</M> because
otherwise the preimages would not contain elements of order <M>40</M>.

<P/>

Next we consider the preimage of the subgroup <M>U = (A_4 \times U_4(2)).2</M>
of <M>S</M>.
We show that the preimages of the two direct factors <M>A_4</M> and <M>U_4(2)</M>
in <M>U^{\prime} = A_4 \times U_4(2)</M> are Schur covers.
For <M>A_4</M>, this follows from the fact that the preimage of <M>U^{\prime}</M>
must contain elements of order <M>20</M>,
and that <M>U_4(2)</M> does not contain elements of order <M>10</M>.

<P/>

<Example><![CDATA[
gap> u42:= CharacterTable( "U4(2)" );;
gap> Filtered( OrdersClassRepresentatives( u42 ), x -> x mod 5 = 0 );
[ 5 ]
]]></Example>

<P/>

In order to show that the <M>U_4(2)</M> type subgroup of <M>U^{\prime}</M> lifts to its
double cover in <M>2.S</M>, we note that the class <C>2B</C> of <M>U_4(2)</M>
lifts to a class of elements of order four in the double cover <M>2.U_4(2)</M>,
and that the corresponding class of elements in <M>U</M>
is <M>S</M>-conjugate to the class of involutions in the direct factor <M>A_4</M>
(which is the unique class of length three in <M>U</M>).

<P/>

<Example><![CDATA[
gap> u:= CharacterTable( Maxes( t )[18] );
CharacterTable( "(A4xU4(2)):2" )
gap> 2u42:= CharacterTable( "2.U4(2)" );;
gap> OrdersClassRepresentatives( 2u42 )[4];
4
gap> GetFusionMap( 2u42, u42 )[4];
3
gap> OrdersClassRepresentatives( u42 )[3];
2
gap> List( PossibleClassFusions( u42, u ), x -> x[3] );
[ 8 ]
gap> PositionsProperty( SizesConjugacyClasses( u ), x -> x = 3 );
[ 2 ]
gap> ForAll( PossibleClassFusions( u, t ), x -> x[2] = x[8] );
true
]]></Example>

<P/>


<!-- % An alternative argument to show that <M>A_4</M> lifts to its double cover -->
<!-- % is that its involutions lie in a class of <M>S</M> that lifts to elements -->
<!-- % of order four because it contains involutions in <M>O_7(3)</M> that lift to -->
<!-- % elements of order four in <M>2.O_7(3)</M>. -->

<P/>

The last subgroup for which the structure of the preimage has to be shown
is <M>U = (A_6 \times A_6):2^2</M>.
We claim that each of the <M>A_6</M> type subgroups in the derived subgroup
<M>U^{\prime} = A_6 \times A_6</M> lifts to its double cover in <M>2.S</M>.
Since all elements of order <M>20</M> in <M>U</M> lie in <M>U^{\prime}</M>,
at least one of the two direct factors must lift to its double cover,
in order to give rise to an order <M>40</M> element in <M>U</M>.
In fact both factors lift to the double cover
since the two direct factors are interchanged by conjugation in <M>U</M>;
the latter follows form tha fact that <M>U</M> has no normal subgroup
of type <M>A_6</M>.

<P/>

<Example><![CDATA[
gap> u:= CharacterTable( Maxes( t )[24] );
CharacterTable( "(A6xA6):2^2" )
gap> ClassPositionsOfDerivedSubgroup( u );
[ 1 .. 22 ]
gap> PositionsProperty( OrdersClassRepresentatives( u ), x -> x = 20 );
[ 8 ]
gap> List( ClassPositionsOfNormalSubgroups( u ),
>          x -> Sum( SizesConjugacyClasses( u ){ x } ) );
[ 1, 129600, 259200, 259200, 259200, 518400 ]
]]></Example>

<P/>

So statement&nbsp;(e) holds.

<P/>

For statement&nbsp;(f), we have to consider the upward extensions <M>S.2_1</M>,
<M>S.2_2</M>, and <M>S.3</M>.

<P/>

First we look at <M>S.2_1</M>, an extension by an outer automorphism that
acts as a double transposition in the outer automorphism group <M>S_4</M>.
Note that the symmetry between the three classes of element oder <M>20</M> in <M>S</M>
is broken in <M>S.2_1</M>,
two of these classes have square roots in <M>S.2_1</M>, the third has not.

<P/>

<Example><![CDATA[
gap> t2:= CharacterTable( "O8+(3).2_1" );;
gap> ord20:= PositionsProperty( OrdersClassRepresentatives( t2 ),
>                x -> x = 20 );;
gap> ord20:= Intersection( ord20, ClassPositionsOfDerivedSubgroup( t2 ) );
[ 84, 85, 86 ]
gap> List( ord20, x -> x in PowerMap( t2, 2 ) );
[ false, true, true ]
]]></Example>

<P/>

Changing the viewpoint, we see that for each class of element order <M>20</M>
in <M>S</M>,
there is a group of the type <M>S.2_1</M> in which the elements in this class
do not have square roots,
and there are groups of this type in which these elements have square roots.
So we have to deal with two different cases,
and we do this by first collecting the permutation characters induced from
<E>all</E> maximal subgroups of <M>S.2_1</M> (other than <M>S</M>) that contain
elements of order <M>20</M> in <M>S</M>,
and then considering <M>s</M> in each of these classes of <M>S</M>.

<P/>

We fix an embedding of <M>S</M> into <M>S.2_1</M> in which the elements
in the class <C>20A</C> do not have square roots.
This situation is given for the stored class fusion between the tables
in the &GAP; Character Table Library.

<P/>

<Example><![CDATA[
gap> tfust2:= GetFusionMap( t, t2 );;
gap> tfust2{ PositionsProperty( OrdersClassRepresentatives( t ),
>                x -> x = 20 ) };
[ 84, 85, 86 ]
]]></Example>

<P/>

The six different actions of <M>S</M> on the cosets of <M>O_7(3)</M> type subgroups
induce pairwise different permutation characters that form an orbit under
the action of <M>&Aut;(S)</M>.
Four of these characters cannot extend to <M>S.2_1</M>,
the other two extend to permutation characters of <M>S.2_1</M> on the cosets of
<M>O_7(3).2</M> type subgroups;
these subgroups contain <C>20A</C> elements.

<P/>

<Example><![CDATA[
gap> primt2:= [];;
gap> poss:= PossiblePermutationCharacters( CharacterTable( "O7(3)" ), t );;
gap> invfus:= InverseMap( tfust2 );;
gap> List( poss, pi -> ForAll( CompositionMaps( pi, invfus ), IsInt ) );
[ false, false, false, false, true, true ]
gap> PossiblePermutationCharacters(
>        CharacterTable( "O7(3)" ) * CharacterTable( "Cyclic", 2 ), t2 );
[  ]
gap> ext:= PossiblePermutationCharacters( CharacterTable( "O7(3).2" ), t2 );;
gap> List( ext, pi -> pi{ ord20 } );
[ [ 1, 0, 0 ], [ 1, 0, 0 ] ]
gap> Append( primt2, ext );
]]></Example>

<P/>

The novelties in <M>S.2_1</M> that arise from <M>O_7(3)</M> type subgroups of <M>S</M>
have the structure <M>L_4(3).2^2</M>.
These subgroups contain elements in the classes <C>20B</C> and <C>20C</C>
of <M>S</M>.

<P/>

<Example><![CDATA[
gap> ext:= PossiblePermutationCharacters( CharacterTable( "L4(3).2^2" ), t2 );;
gap> List( ext, pi -> pi{ ord20 } );
[ [ 0, 0, 1 ], [ 0, 1, 0 ] ]
gap> Append( primt2, ext );
]]></Example>

<P/>

Note that from the possible permutation characters of <M>S.2_1</M> on the cosets
of <M>L_4(3):2 \times 2</M> type subgroups,
we see that such subgroups must contain <C>20A</C> elements,
i.&nbsp;e., all such subgroups of <M>S.2_1</M> lie inside <M>O_7(3).2</M> type subgroups.
This means that the structure description of these novelties
in&nbsp;<Cite Key="CCN85" Where="p.&nbsp;140"/> is not correct.
The correct structure is <M>L_4(3).2^2</M>.)

<P/>

<Example><![CDATA[
gap> List( PossiblePermutationCharacters( CharacterTable( "L4(3).2_2" ) *
>              CharacterTable( "Cyclic", 2 ), t2 ), pi -> pi{ ord20 } );
[ [ 1, 0, 0 ] ]
]]></Example>

<P/>

All <M>3^6:L_4(3)</M> type subgroups of <M>S</M> extend to <M>S.2_1</M>.
We compute these permutation characters as the possible permutation characters
of the right degree.

<P/>

<Example><![CDATA[
gap> ext:= PermChars( t2, rec( torso:= [ 1120 ] ) );;
gap> List( ext, pi -> pi{ ord20 } );
[ [ 2, 0, 0 ], [ 0, 0, 2 ], [ 0, 2, 0 ] ]
gap> Append( primt2, ext );
]]></Example>

<P/>

Also all <M>2.U_4(3).2^2</M> type subgroups of <M>S</M> extend to <M>S.2_1</M>.
We compute the permutation characters as the extensions of the corresponding
permutation characters of <M>S</M>.

<P/>

<Example><![CDATA[
gap> filt:= Filtered( prim, x -> x[1] = 189540 );;
gap> cand:= List( filt, x -> CompositionMaps( x, invfus ) );;
gap> ext:= Concatenation( List( cand,
>              pi -> PermChars( t2, rec( torso:= pi ) ) ) );;
gap> List( ext, x -> x{ ord20 } );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
gap> Append( primt2, ext );
]]></Example>

<P/>

The extensions of <M>(A_4 \times U_4(2)):2</M> type subgroups of <M>S</M> to <M>S.2_1</M>
have the type <M>S_4 \times U_4(2):2</M>, they contain <C>20A</C> elements.

<P/>

<Example><![CDATA[
gap> ext:= PossiblePermutationCharacters( CharacterTable( "Symmetric", 4 ) *
>              CharacterTable( "U4(2).2" ), t2 );;
gap> List( ext, x -> x{ ord20 } );
[ [ 1, 0, 0 ], [ 1, 0, 0 ] ]
gap> Append( primt2, ext );
]]></Example>

<P/>

All <M>(A_6 \times A_6):2^2</M> type subgroups of <M>S</M> extend to <M>S.2_1</M>.
We compute the permutation characters as the extensions of the corresponding
permutation characters of <M>S</M>.

<P/>

<Example><![CDATA[
gap> filt:= Filtered( prim, x -> x[1] = 9552816 );;
gap> cand:= List( filt, x -> CompositionMaps( x, InverseMap( tfust2 ) ));;
gap> ext:= Concatenation( List( cand,
>              pi -> PermChars( t2, rec( torso:= pi ) ) ) );;
gap> List( ext, x -> x{ ord20 } );
[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
gap> Append( primt2, ext );
]]></Example>

<P/>

We have found all relevant permutation characters of <M>S.2_1</M>.
This together with the list
in&nbsp;<Cite Key="CCN85" Where="p.&nbsp;140"/> implies statement&nbsp;(g).

<P/>

Now we compute the bounds <M>&total;^{\prime}(S.2_1, s)</M>.

<P/>

<Example><![CDATA[
gap> Length( primt2 );
15
gap> approx:= List( ord20, x -> ApproxP( primt2, x ) );;
gap> outer:= Difference(
>      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
>      ClassPositionsOfDerivedSubgroup( t2 ) );;
gap> List( approx, l -> Maximum( l{ outer } ) );
[ 574/1215, 83/567, 83/567 ]
]]></Example>

<P/>

Next we look at <M>S.2_2</M>, an extension by an outer automorphism that
acts as a transposition in the outer automorphism group <M>S_4</M>.
Similar to the above situation,
the symmetry between the three classes of element oder <M>20</M> in <M>S</M>
is broken also in <M>S.2_2</M>:
The first is a conjugacy class of <M>S.2_2</M>,
the other two classes are fused in <M>S.2_2</M>,

<P/>

<Example><![CDATA[
gap> t2:= CharacterTable( "O8+(3).2_2" );;
gap> ord20:= PositionsProperty( OrdersClassRepresentatives( t2 ),
>                x -> x = 20 );;
gap> ord20:= Intersection( ord20, ClassPositionsOfDerivedSubgroup( t2 ) );
[ 82, 83 ]
gap> tfust2:= GetFusionMap( t, t2 );;
gap> tfust2{ PositionsProperty( OrdersClassRepresentatives( t ),
>                x -> x = 20 ) };
[ 82, 83, 83 ]
]]></Example>

<P/>

Like in the case <M>S.2_1</M>, we compute the permutation characters induced from
<E>all</E> maximal subgroups of <M>S.2_2</M> (other than <M>S</M>) that contain
elements of order <M>20</M> in <M>S</M>.

<P/>

We fix the embedding of <M>S</M> into <M>S.2_2</M> in which the class
<C>20A</C> of <M>S</M> is a class of <M>S.2_2</M>.
This situation is given for the stored class fusion between the tables
in the &GAP; Character Table Library.

<P/>

Exactly two classes of <M>O_7(3)</M> type subgroups in <M>S</M> extend to <M>S.2_2</M>,
these groups contain <C>20A</C> elements.

<P/>

<Example><![CDATA[
gap> primt2:= [];;
gap> ext:= PermChars( t2, rec( torso:= [ 1080 ] ) );;
gap> List( ext, pi -> pi{ ord20 } );
[ [ 1, 0 ], [ 1, 0 ] ]
gap> Append( primt2, ext );
]]></Example>

<P/>

Only one class of <M>3^6:L_4(3)</M> type subgroups extends to <M>S.2_2</M>.
(Note that we need not consider the novelties of the type
<M>3^{3+6}:(L_3(3) \times 2)</M>, because the order of these groups is not
divisible by <M>5</M>.)

<P/>

<Example><![CDATA[
gap> ext:= PermChars( t2, rec( torso:= [ 1120 ] ) );;
gap> List( ext, pi -> pi{ ord20 } );
[ [ 2, 0 ] ]
gap> Append( primt2, ext );
]]></Example>

<P/>

Only one class of <M>2.U_4(3).2^2</M> type subgroups of <M>S</M> extends to <M>S.2_2</M>.
We compute the permutation character as the extension of the corresponding
permutation characters of <M>S</M>.

<P/>

<Example><![CDATA[
gap> filt:= Filtered( prim, x -> x[1] = 189540 );;
gap> cand:= List( filt, x -> CompositionMaps( x, InverseMap( tfust2 ) ));;
gap> ext:= Concatenation( List( cand,
>              pi -> PermChars( t2, rec( torso:= pi ) ) ) );;
gap> List( ext, x -> x{ ord20 } );
[ [ 1, 0 ] ]
gap> Append( primt2, ext );
]]></Example>

<P/>

Two classes of <M>(A_4 \times U_4(2)):2</M> type subgroups of <M>S</M> extend
to <M>S.2_2</M>.

<P/>

<Example><![CDATA[
gap> filt:= Filtered( prim, x -> x[1] = 7960680 );;
gap> cand:= List( filt, x -> CompositionMaps( x, InverseMap( tfust2 ) ));;
gap> ext:= Concatenation( List( cand,
>              pi -> PermChars( t2, rec( torso:= pi ) ) ) );;
gap> List( ext, x -> x{ ord20 } );
[ [ 1, 0 ], [ 1, 0 ] ]
gap> Append( primt2, ext );
]]></Example>

<P/>

Exactly one class of <M>(A_6 \times A_6):2^2</M> type subgroups in <M>S</M>
extends to <M>S.2_2</M>, and the extensions have the structure
<M>S_6 \wr 2</M>.

<P/>

<Example><![CDATA[
gap> ext:= PossiblePermutationCharacters( CharacterTableWreathSymmetric(
>              CharacterTable( "S6" ), 2 ), t2 );;
gap> List( ext, x -> x{ ord20 } );
[ [ 1, 0 ] ]
gap> Append( primt2, ext );
]]></Example>

<P/>

We have found all relevant permutation characters of <M>S.2_2</M>,
and compute the bounds <M>&total;^{\prime}(S.2_2, s)</M>.

<P/>

<Example><![CDATA[
gap> Length( primt2 );
7
gap> approx:= List( ord20, x -> ApproxP( primt2, x ) );;
gap> outer:= Difference(
>      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
>      ClassPositionsOfDerivedSubgroup( t2 ) );;
gap> List( approx, l -> Maximum( l{ outer } ) );
[ 14/9, 0 ]
]]></Example>

<P/>

This means that there is an extension of the type <M>S.2_2</M> in which
<M>s</M> cannot be chosen such that the bound is less than <M>1/2</M>.
More precisely, we have <M>&total;(g,s) \geq 1/2</M> exactly for <M>g</M> in the
unique outer involution class of size <M>1\,080</M>.

<P/>

<Example><![CDATA[
gap> approx:= ApproxP( primt2, ord20[1] );;
gap> bad:= Filtered( outer, i -> approx[i] >= 1/2 );
[ 84 ]
gap> OrdersClassRepresentatives( t2 ){ bad };
[ 2 ]
gap> SizesConjugacyClasses( t2 ){ bad };
[ 1080 ]
gap> Number( SizesConjugacyClasses( t2 ), x -> x = 1080 );
1
]]></Example>

<P/>

So we compute the proportion of elements in this class that generate <M>S.2_2</M>
together with an element <M>s</M> of order <M>20</M> in <M>S</M>.
(As above, we have to consider two conjugacy classes.)
For that, we first compute a permutation representation of <M>S.2_2</M>,
using that <M>S.2_2</M> is isomporphic to the two subgroups of index <M>2</M> in
<M>&PGO;^+(8,3) = O_8^+(3).2^2_{122}</M> that are different from
<M>&PSO;^+(8,3) = O_8^+(3).2_1</M>,
cf.&nbsp;<Cite Key="CCN85" Where="p.&nbsp;140"/>.

<P/>

<Example><![CDATA[
gap> go:= GO(1,8,3);;
gap> so:= SO(1,8,3);;
gap> outerelm:= First( GeneratorsOfGroup( go ), x -> not x in so );;
gap> g2:= ClosureGroup( DerivedSubgroup( so ), outerelm );;
gap> Size( g2 );
19808719257600
gap> dom:= NormedRowVectors( GF(3)^8 );;
gap> orbs:= OrbitsDomain( g2, dom, OnLines );;
gap> List( orbs, Length );
[ 1080, 1080, 1120 ]
gap> act:= Action( g2, orbs[1], OnLines );;
]]></Example>

<P/>

An involution <M>g</M> can be found as a power of one of the given generators.

<P/>

<Example><![CDATA[
gap> Order( outerelm );
26
gap> g:= Permutation( outerelm^13, orbs[1], OnLines );;
gap> Size( ConjugacyClass( act, g ) );
1080
]]></Example>

<P/>

Now we find the candidates for the elements <M>s</M>,
and compute their ratios of nongeneration.

<P/>

<Example><![CDATA[
gap> ord20;
[ 82, 83 ]
gap> SizesCentralizers( t2 ){ ord20 };
[ 40, 20 ]
gap> der:= DerivedSubgroup( act );;
gap> repeat 20A:= Random( der );
>    until Order( 20A ) = 20 and Size( Centralizer( act, 20A ) ) = 40;
gap> RatioOfNongenerationTransPermGroup( act, g, 20A );
1
gap> repeat 20BC:= Random( der );
>    until Order( 20BC ) = 20 and Size( Centralizer( act, 20BC ) ) = 20;
gap> RatioOfNongenerationTransPermGroup( act, g, 20BC );
0
]]></Example>

<P/>

This means that for <M>s</M> in one <M>S</M>-class of elements of order <M>20</M>,
we have <M>&prop;^{\prime}(g, s) = 1</M>,
and <M>s</M> in the other two <M>S</M>-classes of elements of order <M>20</M> generates
with any conjugate of <M>g</M>.

<P/>

Concerning <M>S.2_2</M>, it remains to show that we cannot find a better element
than <M>s</M>.
For that, we first compute class representatives <M>s^{\prime}</M>
in <M>S</M>, w.r.t.&nbsp;conjugacy in <M>S.2_2</M>,
and then compute <M>&prop;^{\prime}( s^{\prime}, g )</M>.
(It would be enough to check representatives of classes of maximal element
order, but computing all classes is easy enough.)

<P/>

<Example><![CDATA[
gap> ccl:= ConjugacyClasses( act );;
gap> der:= DerivedSubgroup( act );;
gap> reps:= Filtered( List( ccl, Representative ), x -> x in der );;
gap> Length( reps );
83
gap> ratios:= List( reps,
>                   s -> RatioOfNongenerationTransPermGroup( act, g, s ) );;
gap> cand:= PositionsProperty( ratios, x -> x < 1 );;
gap> ratios:= ratios{ cand };;
gap> SortParallel( ratios, cand );
gap> ratios;
[ 0, 1/10, 1/10, 16/135, 1/3, 1/3, 11/27, 7/15, 7/15 ]
]]></Example>

<P/>

For <M>S.2_2</M>, it remains to show that there is no element <M>s^{\prime} \in S</M>
such that <M>&prop;^{\prime}( {s^{\prime}}^x, g ) &lt; 1</M> holds for any
<M>x \in &Aut;(S)</M> and <M>g \in S.2_2</M>.
So we are done when we can show that each class given by <C>cand</C>
is conjugate in <M>S.3</M> to a class outside <C>cand</C>.
The classes can be identified by element orders and centralizer orders.

<P/>

<Example><![CDATA[
gap> invs:= List( cand,
>       x -> [ Order( reps[x] ), Size( Centralizer( der, reps[x] ) ) ] );
[ [ 20, 20 ], [ 18, 108 ], [ 18, 108 ], [ 14, 28 ], [ 15, 45 ], 
  [ 15, 45 ], [ 10, 40 ], [ 12, 72 ], [ 12, 72 ] ]
]]></Example>

<P/>

Namely, <C>cand</C> contains no full <M>S.3</M>-orbit of classes of the element orders
<M>20</M>, <M>18</M>, <M>14</M>, <M>15</M>, and <M>10</M>; also, <C>cand</C> does not contain full
<M>S.3</M>-orbits on the classes <C>12O</C>&ndash;<C>12T</C>.

<P/>

Finally, we deal with <M>S.3</M>.
The fact that no maximal subgroup of <M>S</M> containing an element of order <M>20</M>
extends to <M>S.3</M> follows either from the list of maximal subgroups of <M>S</M>
in&nbsp;<Cite Key="CCN85" Where="p.&nbsp;140"/>
or directly from the permutation characters.

<P/>

<Example><![CDATA[
gap> t3:= CharacterTable( "O8+(3).3" );;
gap> tfust3:= GetFusionMap( t, t3 );;
gap> inv:= InverseMap( tfust3 );;
gap> filt:= PositionsProperty( prim, x -> x[ spos ] <> 0 );;
gap> ForAll( prim{ filt },
>            pi -> ForAny( CompositionMaps( pi, inv ), IsList ) );
true
]]></Example>

<P/>

So we have to consider only the classes of novelties in <M>S.3</M>,
but the order of none of these groups is divisible by <M>20</M>
&ndash;again see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;140"/>).
This means that <E>any</E> element in <M>S.3 \setminus S</M> together with an element
of order <M>20</M> in <M>S</M> generates <M>S.3</M>.
This is in fact stronger than statement&nbsp;(f),
which claims this property only for elements of prime order in
<M>S.3 \setminus S</M> (and their roots);
note that <M>S.3 \setminus S</M> contains elements of the orders <M>9</M> and <M>27</M>.

<P/>

<Example><![CDATA[
gap> outer:= Difference( [ 1 .. NrConjugacyClasses( t3 ) ],
>                ClassPositionsOfDerivedSubgroup( t3 ) );
[ 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 
  70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 
  87, 88, 89, 90, 91, 92, 93, 94 ]
gap> Set( OrdersClassRepresentatives( t3 ){ outer } );
[ 3, 6, 9, 12, 18, 21, 24, 27, 36, 39 ]
]]></Example>

<P/>

Before we turn to the next computations, we clean the workspace.

<P/>

<Example><![CDATA[
gap> CleanWorkspace();
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="O8p4">
<Heading><M>O^+_8(4)</M></Heading>

We show that <M>S = O^+_8(4) = \Omega^+(8,4)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For suitable <M>s \in S</M> of the type <M>2^- \perp 6^-</M>
    (i.&nbsp;e., <M>s</M> decomposes the natural <M>8</M>-dimensional module
    for <M>S</M> into an orthogonal sum of two irreducible modules
    of the dimensions <M>2</M> and <M>6</M>, respectively) and of order
    <M>65</M>,
    <M>&M;(S,s)</M> consists of exactly three pairwise nonconjugate subgroups
    of the type <M>(5 \times O^-_6(4)).2 = (5 \times \Omega^-(6,4)).2</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;( S, s ) \leq 34\,817 / 1\,645\,056</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    In the extensions <M>S.2_1</M> and <M>S.3</M> of <M>S</M> by
    graph automorphisms,
    there is at most one maximal subgroup besides <M>S</M> that contains
    <M>s</M>.
    For the extension <M>S.2_2</M> of <M>S</M> by a field automorphism,
    we have <M>&total;^{\prime}(S.2_2, s) = 0</M>.
    In the extension <M>S.2_3</M> of <M>S</M> by the product of an involutory
    graph automorphism and a field automorphism,
    there is a unique maximal subgroup besides <M>S</M> that contains <M>s</M>.
</Item>
</List>

<P/>

A safe source for determining <M>&M;(S,s)</M> is&nbsp;<Cite Key="Kle87"/>.
<!-- % (In the result matrix of this paper, we have <M>q = 4</M> and <M>d = 1</M>.) -->
<!-- % 1--3: <M>&GL;(4,q)</M> no, -->
<!-- % 4: <M>&GL;(2,q)</M> no, -->
<!-- % 5: <M>\Omega^+(4,q)</M> no, -->
<!-- % 6--8: <M>&GL;(3,q)</M> no, -->
<!-- % 9--14: <M>\Omega(7,q)</M> yes -->
<!-- %        but only three classes for even <M>q</M>, -->
<!-- % 15--18: <M>G_2(q)</M> no (and not maximal), -->
<!-- % 19--21: <M>\Omega^+(6,q)</M> no, -->
<!-- % 22: <M>&GL;(3,q)</M> no, -->
<!-- % 23--25: <M>\Omega^-(6,q)</M> yes, -->
<!-- %         so three classes of <M>(5 \times \Omega^-(6,4)).2</M> -->
<!-- % 26: <M>&GU;(3,q)</M> not maximal, -->
<!-- % 27--32: only for odd <M>q</M>, -->
<!-- % 33--54: only for prime <M>q</M>, -->
<!-- % 55, 56: <M>S_4</M> no, -->
<!-- % 58--60: <M>\Omega^-(4,q)</M> no, -->
<!-- % 61: <M>D_{34}</M> no, -->
<!-- % 62, 63: <M>&POmega;^+(8,2)</M> no, -->
<!-- % 64--69: <M>\Omega^-(8,2)</M> no, -->
<!-- % 70: <M>&PGL;(3,q)</M> no -->

By inspection of the result matrix in this paper,
we get that the only maximal subgroups of <M>S</M> that contain elements
of order <M>65</M> occur in the rows 9&ndash;14 and 23&ndash;25;
they have the isomorphism types
<M>S_6(4) = &Sp;(6,4) \cong O_7(4) = \Omega(7,4)</M> and
<M>(5 \times O_6^-(4)).2 = (5 \times \Omega^-(6,4)).2</M>, respectively,
and for each of these, there are three conjugacy classes of subgroups
in <M>S</M>, which are conjugate under the triality graph automorphism of <M>S</M>.

<P/>

We start with the natural matrix representation of <M>S</M>.
For convenience,
we compute an isomorphic permutation group on <M>5\,525</M> points.

<P/>

<Example><![CDATA[
gap> q:= 4;;  n:= 8;;
gap> G:= DerivedSubgroup( SO( 1, n, q ) );;
gap> points:= NormedRowVectors( GF(q)^n );;
gap> orbs:= OrbitsDomain( G, points, OnLines );;
gap> List( orbs, Length );
[ 5525, 16320 ]
gap> hom:= ActionHomomorphism( G, orbs[1], OnLines );;
gap> G:= Image( hom );;
]]></Example>

<P/>

The group <M>S</M> contains exactly six conjugacy classes of (cyclic) subgroups
of order <M>65</M>;
this follows from the fact that the centralizer of any Sylow <M>13</M> subgroup
in <M>S</M> has the structure <M>5 \times 5 \times 13</M>.

<P/>

<Example><![CDATA[
gap> Collected( Factors( Size( G ) ) );
[ [ 2, 24 ], [ 3, 5 ], [ 5, 4 ], [ 7, 1 ], [ 13, 1 ], [ 17, 2 ] ]
gap> ResetGlobalRandomNumberGenerators();
gap> repeat x:= Random( G );
>    until Order( x ) mod 13 = 0;
gap> x:= x^( Order( x ) / 13 );;
gap> c:= Centralizer( G, x );;
gap> IsAbelian( c );  AbelianInvariants( c );
true
[ 5, 5, 13 ]
]]></Example>

<P/>

The group <M>S_6(4)</M> contains exactly one class of subgroups of order <M>65</M>,
since the conjugacy classes of elements of order <M>65</M> in <M>S_6(4)</M> are
algebraically conjugate.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "S6(4)" );;
gap> ord65:= PositionsProperty( OrdersClassRepresentatives( t ),
>                               x -> x = 65 );
[ 105, 106, 107, 108, 109, 110, 111, 112 ]
gap> ord65 = ClassOrbit( t, ord65[1] );
true
]]></Example>

<P/>

Thus there are at least three classes of order <M>65</M> elements in <M>S</M>
that are <E>not</E> contained in <M>S_6(4)</M> type subgroups of <M>S</M>.
So we choose such an element <M>s</M>,
and have to consider only overgroups of the type
<M>(5 \times \Omega^-(6,4)).2</M>.

<P/>

The group <M>\Omega^-(6,4) \cong U_4(4)</M> contains exactly one class
of subgroups of order <M>65</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "U4(4)" );;
gap> ords:= OrdersClassRepresentatives( t );;
gap> ord65:= PositionsProperty( ords, x -> x = 65 );;
gap> ord65 = ClassOrbit( t, ord65[1] );
true
]]></Example>

<P/>

So <M>5 \times \Omega^-(6,4)</M> contains exactly six such classes.
Furthermore, subgroups in different classes are not <M>S</M>-conjugate.

<P/>

<Example><![CDATA[
gap> syl5:= SylowSubgroup( c, 5 );;
gap> elms:= Filtered( Elements( syl5 ), y -> Order( y ) = 5 );;
gap> reps:= Set( elms, SmallestGeneratorPerm );;  Length( reps );
6
gap> reps65:= List( reps, y -> SubgroupNC( G, [ y * x ] ) );;
gap> pairs:= Filtered( UnorderedTuples( [ 1 .. 6 ], 2 ),
>                      p -> p[1] <> p[2] );;
gap> ForAny( pairs, p -> IsConjugate( G, reps65[ p[1] ], reps65[ p[2] ] ) );
false
]]></Example>

<P/>

We consider only subgroups <M>M \leq S</M> in the three <M>S</M>-classes of the type
<M>(5 \times \Omega^-(6,4)).2</M>.

<P/>

<Example><![CDATA[
gap> cand:= List( reps, y -> Normalizer( G, SubgroupNC( G, [ y ] ) ) );;
gap> cand:= Filtered( cand, y -> Size( y ) = 10 * Size( t ) );;
gap> Length( cand );
3
]]></Example>

<P/>

<!--
We can identify the three classes that are contained also in <M>O_7(4)</M>
type subgroups, as follows.
The elements in the naturally embedded subgroup <M>O_7(4)</M> of <M>O_8^+(4)</M>
fix a <M>1</M>-space, and exactly one of the six representatives of order <M>65</M>
has this property; more precisely, it has the structure <M>1 \perp 1 \perp 6</M>,
whereas the other five representatives have the structure <M>2 \perp 6</M>.

gap> mats:= List( reps, y -> PreImagesRepresentative( hom, x * y ) );;
gap> List( mats,
>      x -> List( Factors( CharacteristicPolynomial( x ) ), Degree ) );
[ [ 2, 6 ], [ 2, 6 ], [ 1, 1, 6 ], [ 2, 6 ], [ 2, 6 ], [ 2, 6 ] ]

Furthermore, the corresponding elements of order <M>5</M> have two types of
normalizers.

gap> cand:= List( reps, y -> Normalizer( G, SubgroupNC( G, [ y ] ) ) );;
gap> List( cand, Size );
[ 10183680000, 3120000, 3120000, 10183680000, 3120000, 10183680000 ]

So the elements of order <M>65</M> that lie only in subgroups of the type
<M>(5 \times \Omega^-(6,4)).2</M> are precisely those whose <M>13</M>-th power
has a normalizer of the right order.
-->

<P/>

(Note that one of the members in <M>&M;(S,s)</M> is the stabilizer in <M>S</M> of the
orthogonal decomposition <M>2^- \perp 6^-</M>,
the other two members are not reducible.)

<P/>

By the above, the classes of subgroups of order <M>65</M> in each such <M>M</M>
are in bijection with the corresponding classes in <M>S</M>.
Since <M>N_S(\langle g \rangle) \subseteq M</M> holds
for any <M>g \in M</M> of order <M>65</M>, also the conjugacy classes of
<E>elements</E> of order <M>65</M> in <M>M</M> are in bijection with those in <M>S</M>.

<P/>

<Example><![CDATA[
gap> norms:= List( reps65, y -> Normalizer( G, y ) );;
gap> ForAll( norms, y -> ForAll( cand, M -> IsSubset( M, y ) ) );
true
]]></Example>

<P/>

As a consequence, we have <M>g^S \cap M = g^M</M> and thus <M>1_M^S(g) = 1</M>.
This implies statement&nbsp;(a).

<P/>

In order to show statement&nbsp;(b),
we want to use the function <C>UpperBoundFixedPointRatios</C> introduced in
Section&nbsp;<Ref Subsect="subsect:groups"/>.
For that, we first compute the conjugacy classes of
the three class representatives <M>M</M>.
(Since the groups have elementary abelian Sylow <M>5</M> subgroups of the order
<M>5^4</M>, computing all conjugacy classes appears to be faster than using
<C>ClassesOfPrimeOrder</C>.)
Then we compute an upper bound for <M>&total;(S,s)</M>.

<P/>

<Example><![CDATA[
gap> syl5:= SylowSubgroup( cand[1], 5 );;
gap> Size( syl5 );  IsElementaryAbelian( syl5 );
625
true
gap> UpperBoundFixedPointRatios( G, List( cand, ConjugacyClasses ), false );
[ 34817/1645056, false ]
]]></Example>

<P/>

<E>Remark:</E>

<P/>

Computing the exact value <M>&total;(S,s)</M> in the above setup would require
to test the <M>S</M>-conjugacy of certain order <M>5</M> elements in <M>M</M>.
With the current &GAP; implementation,
some of the relevant tests need several hours of CPU time.
<P/>
An alternative approach would be to compute the permutation action of
<M>S</M> on the cosets of <M>M</M>, of degree <M>6\,580\,224</M>,
and to count the fixed points of conjugacy class representatives
of prime order.
The currently available &GAP; library methods are not sufficient
for computing this in reasonable time.
<Q>Ad-hoc code</Q> for this special case works,
but it seemed to be not appropriate to include it here.

<P/>

In the proof of statement&nbsp;(c),
again we consult the result matrix in&nbsp;<Cite Key="Kle87"/>.
For <M>S.3</M>,
the maximal subgroups are in the rows <M>4</M>, <M>15</M>, <M>22</M>, <M>26</M>, and <M>61</M>.
Only row <M>26</M> yields subgroups that contain elements <M>s</M> of order <M>65</M>,
they have the isomorphism type
<M>(5 \times &GU;(3,4)).2 \cong (5^2 \times U_3(4)).2</M>.
Note that the conjugacy classes of the members in <M>&M;(S,s)</M> are permuted
by the outer automorphism of order <M>3</M>,
so none of the subgroups in <M>&M;(S,s)</M> extends to <M>S.3</M>.
By&nbsp;<Cite Key="BGK" Where="Lemma&nbsp;2.4&nbsp;(2)"/>,
if there is a maximal subgroup of <M>S.3</M>
besides <M>S</M> that contains <M>s</M> then this subgroup is the normalizer in <M>S.3</M>
of the intersection of the three members of <M>&M;(S,s)</M>,
i.&nbsp;e., <M>s</M> is contained in at most one such subgroup.

<!-- % If we do not believe this, we can see it character-theoretically, -->
<!-- % from the embedding of <M>&GU;(3,4)</M> into <M>U_4(4) \cong \Omega^-(6,4)</M>, -->
<!-- % the unique possible permutation character of degree <M>3264</M> -->
<!-- % takes the value <M>1</M> on all elements of order <M>13</M> and <M>65</M>, -->
<!-- % so the same holds for the direct product with the cyclic <M>5</M> -->
<!-- % and the extension by the outer <M>2</M>. -->
<!-- % So also inducing this character to <M>S</M> gives the value <M>1</M>. -->

<P/>

For <M>S.2_1</M>,
only the rows <M>9</M> and <M>23</M> yield maximal subgroups containing elements of
order <M>65</M>, and since we had chosen <M>s</M> in such a way
that row <M>9</M> was excluded already for the simple group,
only extensions of the elements in <M>&M;(S,s)</M> can appear.
Exactly one of these three subgroups of <M>S</M> extends to <M>S.2_1</M>,
so again we get just one maximal subgroup of <M>S.2_1</M>, besides <M>S</M>,
that contains <M>s</M>.

<!-- %T Just for curiosity: -->
<!-- %T What is the intersection of the two non-extending ones? -->

<P/>

All subgroups in <M>&M;(S,s)</M> extend to <M>S.2_2</M>, see&nbsp;<Cite Key="Kle87"/>.
We compute the extensions of the above subgroups <M>M</M> of <M>S</M> to <M>S.2_2</M>,
by constructing the action of the field automorphism
in the permutation representation we used for <M>S</M>.
In other words, we compute the projective action of the Frobenius map.

<P/>

<Example><![CDATA[
gap> frob:= PermList( List( orbs[1], v -> Position( orbs[1],
>              List( v, x -> x^2 ) ) ) );;
gap> G2:= ClosureGroupDefault( G, frob );;
gap> cand2:= List( cand, M -> Normalizer( G2, M ) );;
gap> ccl:= List( cand2,
>                M2 -> PcConjugacyClassReps( SylowSubgroup( M2, 2 ) ) );;
gap> List( ccl, l -> Number( l, x -> Order( x ) = 2 and not x in G ) );
[ 0, 0, 0 ]
]]></Example>

<P/>

So in each case, the extension of <M>M</M> to its normalizer in <M>S.2_2</M>
is non-split.
This implies <M>&total;^{\prime}(S.2_2,s) = 0</M>.

<P/>

Finally, in the extension of <M>S</M> by the product of a graph automorphism
and the field automorphism, exactly that member of <M>&M;(S,s)</M> is invariant
that is invariant under the graph automorphism,
hence statement&nbsp;(c) holds.

<P/>

It is again time to clean the workspace.

<P/>

<Example><![CDATA[
gap> CleanWorkspace();
]]></Example>

<P/>

<!--
the alternative approach:

compute the classes of <M>S</M>, then a right transversal of <M>M</M>,
and count fixed points.

gap> ccl:= ConjugacyClasses( permG );;  Length( ccl );
405

(The above computations require about <M>4</M> hours of CPU time.)

One class of the <M>(5 \times O^-_6(4)).2</M> type subgroups can be described as
the stabilizers of certain <M>2</M>-dimensional subspaces of the natural module.
So the idea is to enumerate the <M>S</M>-orbit of such a subspace
--it is of length <M>6\,580\,224</M>--
and to count, for each class representative of <M>S</M>,
the number of fixed points in this orbit.
This yields the first desired permutation character.

We first compute the <M>S</M>-orbit of a suitable <M>2</M>-dimensional space.
This could be done directly by representing each vector space by its
canonical basis, and acting with the matrix group on the canonical bases,
via the &GAP; function <C>OnSubspacesByCanonicalBasis</C>.
However,
it is more efficient to replace each canonical basis by
the normed nonzero vectors in the space spanned by this basis,
and then to perform the computations in the permutation group
obtained by identifying the normed vectors with points.

In our case, each <M>2</M>-dimensional space is thus represented by a set
of five numbers in the range between <M>1</M> and <M>21\,845</M>.

gap> basis:=
> [ [ Z(2), 0*Z(2), Z(2^2)^2, Z(2^2), Z(2), Z(2^2), Z(2), Z(2^2) ],
>   [ 0*Z(2), Z(2), 0*Z(2), Z(2^2)^2, Z(2^2)^2, Z(2^2), Z(2^2), 0*Z(2) ] ];;
gap> encode:= Set( NormedRowVectors( VectorSpace( GF(q), basis ) ),
>                  v -> Position( points, v ) );
[ 2366, 9148, 13028, 17520, 21064 ]
gap> MakeImmutable( encode );
gap> orb:= Orbit( Action( S, points, OnLines ), encode, OnSets );;
gap> Length( orb );
6580224

This computation is too large for the standard &GAP; functions!

The next step is the computation of the permutation character <M>\pi</M> of the
<M>S</M>-action on <C>orb</C>.
The class representatives <C>cclreps</C> are given w.r.t.&nbsp;the permutation
representation on <M>5\,525</M> points,
we first compute preimages in the matrix group, under the isomorphism <C>iso</C>,
and then the induced permutations of the <M>21\,845</M> normed vectors.

(Instead of using the &GAP; function <C>Permutation</C> for the second step,
we call <C>Sortex</C> for the list of images of the normed vectors of each matrix.
Note that the list <C>points</C> is strictly sorted.)

%T check that this really defines a permutation?

%T  Read( "~/construct/O8p4/classreps" );
%T  perm:= [];
%T  for r in ccl do
%T  Print( <Ref ???="process ...\n"/> );
%T  pre:= PreImagesRepresentative( iso, r );
%T  acting:= Sortex( List( points, v -> OnLines( v, pre ) ) );
%T  Add( perm, Number( orb, p -> OnSets( p, acting ) = x ) );
%T  od;

gap> IsSSortedList( points );
true
gap> preims:= List( cclreps, x -> PreImagesRepresentative( iso, x ) );;
gap> acts:= List( preims,
>                 mat -> Sortex( List( points, v -> OnLines( v, mat ) ) ) );;
gap> pi:= List( acts, perm -> Number( orb, x -> OnSets( x, perm ) = x ) );
[ 6580224, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3264,
  3264, 0, 0, 0, 0, 0, 0, 0, 8, 8, 72, 72, 84, 84, 72, 20, 20, 28160, 8, 0,
  0, 12, 12, 18432, 0, 0, 0, 12, 12, 209, 209, 2, 2, 74, 2, 2, 2, 2, 72, 2,
  2, 2, 2, 28289, 28289, 257, 257, 12, 12, 12, 12, 12, 12, 12, 12, 24, 209,
  209, 2, 2, 0, 0, 0, 0, 0, 0, 12, 12, 3264, 3264, 2, 2, 14, 14, 12, 12, 0,
  0, 0, 0, 0, 12, 12, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 209, 209, 0, 0, 12, 12, 0,
  0, 72, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 24192, 0, 1,
  1, 17, 17, 256, 192, 192, 16, 16, 1, 1, 225, 225, 9, 9, 224, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 137, 137, 2, 0, 0, 0, 0, 0, 0, 12, 12, 24, 192, 192, 2, 2,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 17, 0, 0, 0, 0, 0, 0,
  0, 0, 12, 12, 0, 8, 8, 8, 8, 136, 136, 136, 136, 9, 9, 224, 8, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,
  2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 2, 2, 8, 8, 2048, 0,
  17, 17, 8, 0, 0, 16, 0, 0, 0, 0, 0, 16, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
  1, 0, 0, 0, 0 ]

In order to determine <M>&M;(S,s)</M>, we first note that <M>S</M> contains six classes
of cyclic subgroups of order <M>65</M>, and that <M>\pi</M> takes the value <M>1</M> on
all elements of order <M>65</M>.

gap> ord65:= PositionsProperty( ccl,
>                      c -> Order( Representative( c ) ) = 65 );;
gap> Set( pi{ ord65 } );
[ 1 ]

Since <M>S_6(4)</M> contains exactly one class of cyclic subgroups of order <M>65</M>,
and since <M>S</M> contains three classes of <M>S_6(4)</M> type subgroups,
there are classes of cyclic subgroups of order <M>65</M> that are not contained
in any <M>S_6(4)</M> type subgroup of <M>S</M>.
So we choose <M>s</M> from one of these classes, and get that <M>&M;(S,s)</M> consists
of three groups of the type <M>(C_5 \times O_6^-(4)).2</M>.
By the fact that these groups are conjugate under the triality automorphism
of <M>S</M>, the three permutation characters take the same set of values,
so
\[
   &total;(S,s) = \sum_{M \in &MM;(s)} \frac{1_M^S(s) \cdot 1_M^S(g)}{1_M^S(1)}
               \leq 3 \max\{ \pi(g); g \in S^{\times} \} / \pi(1)
\]
holds.

Thus we get the following upper bound for <M>&total;(S,s)</M>.

gap> bound:= 3 * Maximum( pi{ [ 2 .. Length( pi ) ] } ) / pi[1];
28289/2193408

question of equality:

gap> approx:= ( pi{ [ 2 .. Length( pi ) ] } ) / pi[1];;
gap> mx:= Maximum( approx );
28289/6580224
gap> PositionsProperty( approx, x -> x = mx );
[ 90, 91 ]

equality?
-->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="O93">
<Heading><M>\ast</M>&nbsp;<M>O_9(3)</M></Heading>

The group <M>S = O_9(3) = \Omega_9(3)</M> is the first member in the series
dealt with in&nbsp;<Cite Key="BGK" Where="Proposition&nbsp;5.7"/>,
and serves as an example to illustrate this statement.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> of the type <M>1 \perp 8^-</M>
    (i.&nbsp;e., <M>s</M> decomposes the natural <M>9</M>-dimensional module
    for <M>S</M>
    into an orthogonal sum of two irreducible modules of the dimensions
    <M>1</M> and <M>8</M>, respectively) and of order <M>(3^4 + 1)/2 = 41</M>,
    <M>&M;(S,s)</M> consists of one group of the type
    <M>O_8^-(3).2_1 = &PGO;^-(8,3)</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 1/3</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    The uniform spread of <M>S</M> is at least three,
    with <M>s</M> of order <M>41</M>.
</Item>
</List>

<P/>

By&nbsp;<Cite Key="MSW94"/>, the only maximal subgroup of <M>S</M> that contains <M>s</M>
is the stabilizer <M>M</M> of the orthogonal decomposition.
The group <M>2 \times O_8^-(3).2_1 = &GO;^-(8,3)</M> embeds naturally into
<M>&SO;(9,3)</M>, its intersection with <M>S</M> is <M>&PGO;^-(8,3)</M>.
This proves statement&nbsp;(a).

<P/>

The group <M>M</M> is the stabilizer of a <M>1</M>-space, it has index <M>3\,240</M> in <M>S</M>.

<P/>

<Example><![CDATA[
gap> g:= SO( 9, 3 );;
gap> g:= DerivedSubgroup( g );;
gap> Size( g );
65784756654489600
gap> orbs:= OrbitsDomain( g, NormedRowVectors( GF(3)^9 ), OnLines );;
gap> List( orbs, Length ) / 41;
[ 3240/41, 81, 80 ]
gap> Size( SO( 9, 3 ) ) / Size( GO( -1, 8, 3 ) );
3240
]]></Example>

<P/>

So we compute the unique transitive permutation character of <M>S</M> that has
degree <M>3\,240</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "O9(3)" );;
gap> pi:= PermChars( t, rec( torso:= [ 3240 ] ) );
[ Character( CharacterTable( "O9(3)" ),
  [ 3240, 1080, 380, 132, 48, 324, 378, 351, 0, 0, 54, 27, 54, 27, 0, 
      118, 0, 36, 46, 18, 12, 2, 8, 45, 0, 108, 108, 135, 126, 0, 0, 
      56, 0, 0, 36, 47, 38, 27, 39, 36, 24, 12, 18, 18, 15, 24, 2, 
      18, 15, 9, 0, 0, 0, 2, 0, 18, 11, 3, 9, 6, 6, 9, 6, 3, 6, 3, 0, 
      6, 16, 0, 4, 6, 2, 45, 36, 0, 0, 0, 0, 0, 0, 0, 9, 9, 6, 3, 0, 
      0, 15, 13, 0, 5, 7, 36, 0, 10, 0, 10, 19, 6, 15, 0, 0, 0, 0, 
      12, 3, 10, 0, 3, 3, 7, 0, 6, 6, 2, 8, 0, 4, 0, 2, 0, 1, 3, 0, 
      0, 3, 0, 3, 2, 2, 3, 3, 6, 2, 2, 9, 6, 3, 0, 0, 18, 9, 0, 0, 
      12, 0, 0, 8, 0, 6, 9, 5, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 2, 1, 
      3, 3, 1, 0, 0, 4, 1, 0, 0, 1, 0, 3, 3, 1, 1, 2, 2, 0, 0, 1, 3, 
      4, 0, 1, 2, 0, 0, 1, 0, 4, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 
      1, 1, 1, 1, 0, 0, 1, 1, 1, 0 ] ) ]
gap> spos:= Position( OrdersClassRepresentatives( t ), 41 );
208
gap> approx:= ApproxP( pi, spos );;
gap> Maximum( approx );
1/3
gap> PositionsProperty( approx, x -> x = 1/3 );
[ 2 ]
gap> SizesConjugacyClasses( t )[2];
3321
gap> OrdersClassRepresentatives( t )[2];
2
]]></Example>

<P/>

We see that <M>&prop;( S, s ) = &total;( S, s ) = 1/3</M> holds,
and that <M>&total;( g, s )</M> attains this maximum only for <M>g</M> in one
class of involutions in <M>S</M>;
let us call this class <C>2A</C>.
(This class consists of the negatives of a class of <E>reflections</E>
in <M>&GO;(9,3)</M>.)
This shows statement&nbsp;(b).

<P/>

In order to show that the uniform spread of <M>S</M> is at least three,
it suffices to show that for each triple of <C>2A</C> elements,
there is an element <M>s</M> of order <M>41</M> in <M>S</M> that generates <M>S</M> with each
element of the triple.

<P/>

We work with the primitive permutation representation of <M>S</M> on <M>3\,240</M>
points.
In this representation, <M>s</M> fixes exactly one point,
and by statement&nbsp;(a),
<M>s</M> generates <M>S</M> with <M>x \in S</M> if and only if <M>x</M> moves this point.
Since the number of fixed points of each <C>2A</C> involution in <M>S</M> is
exactly one third of the moved points of <M>S</M>,
it suffices to show that we cannot choose three such involutions with
mutually disjoint fixed point sets.
And this is shown particularly easily because it will turn out that
already for any two different <C>2A</C> involutions,
the sets of fixed points of are never disjoint.

<P/>

First we compute a <C>2A</C> element, which is determined as an involution
with exactly <M>1\,080</M> fixed points.

<P/>

<Example><![CDATA[
gap> g:= Action( g, orbs[1], OnLines );;
gap> repeat
>      repeat x:= Random( g ); ord:= Order( x ); until ord mod 2 = 0;
>      y:= x^(ord/2);
> until NrMovedPoints( y ) = 3240 - 1080;
]]></Example>

<P/>

Next we compute the sets of fixed points of the elements in the class <C>2A</C>,
by forming the <M>S</M>-orbit of the set of fixed points of the chosen
<C>2A</C> element.

<P/>

<Example><![CDATA[
gap> fp:= Difference( MovedPoints( g ), MovedPoints( y ) );;
gap> orb:= Orbit( g, fp, OnSets );;
]]></Example>

<P/>

Finally, we show that for any pair of <C>2A</C> elements, their sets of
fixed points intersect nontrivially.
(Of course we can fix one of the two elements.)
This proves statement&nbsp;(c).

<P/>

<Example><![CDATA[
gap> ForAny( orb, l -> IsEmpty( Intersection( l, fp ) ) );
false
]]></Example>

<!-- %T remark: <M>\Omega(5,3)</M> is not interesting because nonsimple, -->
<!-- %T and there are three maxes not just one -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="O10m3">
<Heading><M>O_{10}^-(3)</M></Heading>

We show that the group <M>S = O_{10}^-(3) = &POmega;^-(10,3)</M> satisfies the
following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> irreducible of order <M>(3^5 + 1)/4 = 61</M>,
    <M>&M;(S,s)</M> consists of one subgroup of the type
    <M>&SU;(5,3) \cong U_5(3)</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 1/1\,066</M>.
</Item>
</List>

<P/>

By&nbsp;<Cite Key="Be00"/>, the maximal subgroups of <M>S</M> containing <M>s</M> are of
extension field type,
and by&nbsp;<Cite Key="KlL90" Where="Prop.&nbsp;4.3.18 and&nbsp;4.3.20"/>,
these groups have the structure
<M>&SU;(5,3) = U_5(3)</M>
(which lift to <M>2 \times U_5(3) &lt; &GU;(5,3)</M> in
<M>\Omega^-(10,3) = 2.S</M>) or <M>\Omega(5,9).2</M>,
but the order of the latter group is not divisible by <M>|s|</M>.
Furthermore, by&nbsp;<Cite Key="BGK" Where="Lemma&nbsp;2.12&nbsp;(b)"/>,
<M>s</M> is contained in only one member of the former class.

<P/>

<Example><![CDATA[
gap> Size( GO(5,9) ) / 61;
6886425600/61
]]></Example>

<P/>

<E>When the first version of these computations was written,
the character tables of both <M>S</M> and <M>U_5(3)</M> were not
contained in the &GAP; Character Table Library,
so we worked with the groups.
Meanwhile the character tables are available,
thus we can show also a character theoretic solution.)</E>

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "O10-(3)" );  s:= CharacterTable( "U5(3)" );
CharacterTable( "O10-(3)" )
CharacterTable( "U5(3)" )
gap> SigmaFromMaxes( t, "61A", [ s ], [ 1 ] );
1/1066
]]></Example>

<P/>

<E>(Now follow the computations with groups.)</E>

<P/>

The first step is the construction of the embedding of <M>M = &SU;(5,3)</M>
into the matrix group <M>2.S</M>,
that is, we write the matrix generators of <M>M</M> as linear mappings on
the natural module for <M>2.S</M>, and then conjugate them such that the
result matrices respect the bilinear form of <M>2.S</M>.
For convenience, we choose a basis for the field extension
<M>&F;_9/&F;_3</M> such that the <M>&F;_3</M>-linear mapping given by the invariant
form of <M>M</M> is invariant under the <M>&F;_3</M>-linear mappings given by
the generators of <M>M</M>.

<P/>

<!-- % We need that the basis vectors <C>v</C> satisfy -->
<!-- % <C>BlownUpMat( b, v^q ) = TransposedMat( BlownUpMat( b, v ) )</C>. -->

<Example><![CDATA[
gap> m:= SU(5,3);;
gap> so:= SO(-1,10,3);;
gap> omega:= DerivedSubgroup( so );;
gap> om:= InvariantBilinearForm( so ).matrix;;
gap> Display( om );
 . 1 . . . . . . . .
 1 . . . . . . . . .
 . . 1 . . . . . . .
 . . . 2 . . . . . .
 . . . . 2 . . . . .
 . . . . . 2 . . . .
 . . . . . . 2 . . .
 . . . . . . . 2 . .
 . . . . . . . . 2 .
 . . . . . . . . . 2
gap> b:= Basis( GF(9), [ Z(3)^0, Z(3^2)^2 ] );
Basis( GF(3^2), [ Z(3)^0, Z(3^2)^2 ] )
gap> blow:= List( GeneratorsOfGroup( m ), x -> BlownUpMat( b, x ) );;
gap> form:= BlownUpMat( b, InvariantSesquilinearForm( m ).matrix );;
gap> ForAll( blow, x -> x * form * TransposedMat( x ) = form );
true
gap> Display( form );
 . . . . . . . . 1 .
 . . . . . . . . . 1
 . . . . . . 1 . . .
 . . . . . . . 1 . .
 . . . . 1 . . . . .
 . . . . . 1 . . . .
 . . 1 . . . . . . .
 . . . 1 . . . . . .
 1 . . . . . . . . .
 . 1 . . . . . . . .
]]></Example>

<P/>

The matrix <C>om</C> of the invariant bilinear form of <M>2.S</M>
is equivalent to the identity matrix <M>I</M>.
So we compute matrices <C>T1</C> and <C>T2</C>
that transform <C>om</C> and <C>form</C>, respectively, to <M>\pm I</M>.

<P/>

<Example><![CDATA[
gap> T1:= IdentityMat( 10, GF(3) );;
gap> T1{[1..3]}{[1..3]}:= [[1,1,0],[1,-1,1],[1,-1,-1]]*Z(3)^0;;
gap> pi:= PermutationMat( (1,10)(3,8), 10, GF(3) );;
gap> tr:= NullMat( 10,10,GF(3) );;
gap> tr{[1, 2]}{[1, 2]}:= [[1,1],[1,-1]]*Z(3)^0;;
gap> tr{[3, 4]}{[3, 4]}:= [[1,1],[1,-1]]*Z(3)^0;;
gap> tr{[7, 8]}{[7, 8]}:= [[1,1],[1,-1]]*Z(3)^0;;
gap> tr{[9,10]}{[9,10]}:= [[1,1],[1,-1]]*Z(3)^0;;
gap> tr{[5, 6]}{[5, 6]}:= [[1,0],[0,1]]*Z(3)^0;;
gap> tr2:= IdentityMat( 10,GF(3) );;
gap> tr2{[1,3]}{[1,3]}:= [[-1,1],[1,1]]*Z(3)^0;;
gap> tr2{[7,9]}{[7,9]}:= [[-1,1],[1,1]]*Z(3)^0;;
gap> T2:= tr2 * tr * pi;;
gap> D:= T1^-1 * T2;;
gap> tblow:= List( blow, x -> D * x * D^-1 );;
gap> IsSubset( omega, tblow );
true
]]></Example>

<P/>

Now we switch to a permutation representation of <M>S</M>,
and use the embedding of <M>M</M> into <M>2.S</M> to obtain the corresponding
subgroup of type <M>M</M> in <M>S</M>.

<!-- % Note that the negative of the identity of <M>M</M> is contained in <M>2.S</M> -->
<!-- % but not in <M>M</M>. -->

Then we compute an upper bound for <M>\max\{ &fpr;(g,S/M); g \in S^{\times} \}</M>.

<P/>

<Example><![CDATA[
gap> orbs:= OrbitsDomain( omega, NormedRowVectors( GF(3)^10 ), OnLines );;
gap> List( orbs, Length );
[ 9882, 9882, 9760 ]
gap> permgrp:= Action( omega, orbs[3], OnLines );;
gap> M:= SubgroupNC( permgrp,
>            List( tblow, x -> Permutation( x, orbs[3], OnLines ) ) );;
gap> ccl:= ClassesOfPrimeOrder( M, PrimeDivisors( Size( M ) ),
>                               TrivialSubgroup( M ) );;
gap> UpperBoundFixedPointRatios( permgrp, [ ccl ], false );
[ 1/1066, true ]
]]></Example>

<P/>

The entry <K>true</K> in the second position of the result indicates
that in fact the <E>exact</E> value for the maximum of <M>&fpr;(g,S/M)</M>
has been computed.
This implies statement&nbsp;(b).

<P/>

We clean the workspace.

<P/>

<Example><![CDATA[
gap> CleanWorkspace();
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="O14m2">
<Heading><M>O_{14}^-(2)</M></Heading>

We show that the group <M>S = O_{14}^-(2) = \Omega^-(14,2)</M> satisfies the
following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> irreducible of order <M>2^7+1 = 129</M>,
    <M>&M;(S,s)</M> consists of one subgroup <M>M</M> of the type
    <M>&GU;(7,2) \cong 3 \times U_7(2)</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 1/2\,015</M>.
</Item>
</List>

<P/>

By&nbsp;<Cite Key="Be00"/>,
any maximal subgroup of <M>S</M> containing <M>s</M> is of extension
field type,
and by&nbsp;<Cite Key="KlL90" Where="Table&nbsp;3.5.F, Prop.&nbsp;4.3.18"/>,
these groups have the type <M>&GU;(7,2)</M>,
and there is exactly one class of subgroups of this type.
Furthermore, by&nbsp;<Cite Key="BGK" Where="Lemma&nbsp;2.12&nbsp;(a)"/>,
<M>s</M> is contained in only one member of this class.

<P/>

We embed <M>U_7(2)</M> into <M>S</M>,
by first replacing each element in <M>&F;_4</M> by the <M>2 \times 2</M> matrix
of the induced <M>&F;_2</M>-linear mapping w.r.t.&nbsp;a suitable basis,
and then conjugating the images of the generators such that the invariant
quadratic form of <M>S</M> is respected.

<P/>

<Example><![CDATA[
gap> o:= SO(-1,14,2);;
gap> g:= SU(7,2);;
gap> b:= Basis( GF(4) );;
gap> blow:= List( GeneratorsOfGroup( g ), x -> BlownUpMat( b, x ) );;
gap> form:= NullMat( 14, 14, GF(2) );;
gap> for i in [ 1 .. 14 ] do form[i][ 15-i ]:= Z(2); od;
gap> ForAll( blow, x -> x * form * TransposedMat( x ) = form );
true
gap> pi:= PermutationMat( (1,13)(3,11)(5,9), 14, GF(2) );;
gap> pi * form * TransposedMat( pi ) = InvariantBilinearForm( o ).matrix;
true
gap> pi2:= PermutationMat( (7,3)(8,4), 14, GF(2) );;
gap> D:= pi2 * pi;;
gap> tblow:= List( blow, x -> D * x * D^-1 );;
gap> IsSubset( o, tblow );
true
]]></Example>

<P/>

Note that the central subgroup of order three in <M>&GU;(7,2)</M> consists of
scalar matrices.

<P/>

<Example><![CDATA[
gap> omega:= DerivedSubgroup( o );;
gap> IsSubset( omega, tblow );
true
gap> z:= Z(4) * One( g );;
gap> tz:= D * BlownUpMat( b, z ) * D^-1;;
gap> tz in omega;
true
]]></Example>

<P/>

Now we switch to a permutation representation of <M>S</M>,
and compute the conjugacy classes of prime element order in the subgroup <M>M</M>.
The latter is done in two steps, first class representatives of the
simple subgroup <M>U_7(2)</M> of <M>M</M> are computed, and then they are multiplied
with the scalars in <M>M</M>.

<P/>

<Example><![CDATA[
gap> orbs:= OrbitsDomain( omega, NormedRowVectors( GF(2)^14 ), OnLines );;
gap> List( orbs, Length );
[ 8127, 8256 ]
gap> omega:= Action( omega, orbs[1], OnLines );;
gap> gens:= List( GeneratorsOfGroup( g ),
>             x -> Permutation( D * BlownUpMat( b, x ) * D^-1, orbs[1] ) );;
gap> g:= Group( gens );;
gap> ccl:= ClassesOfPrimeOrder( g, PrimeDivisors( Size( g ) ),
>                               TrivialSubgroup( g ) );;
gap> tz:= Permutation( tz, orbs[1] );;
gap> primereps:= List( ccl, Representative );;
gap> Add( primereps, () );
gap> reps:= Concatenation( List( primereps,
>               x -> List( [ 0 .. 2 ], i -> x * tz^i ) ) );;
gap> primereps:= Filtered( reps, x -> IsPrimeInt( Order( x ) ) );;
gap> Length( primereps );
48
]]></Example>

<P/>

Finally, we apply <C>UpperBoundFixedPointRatios</C>
(see Section&nbsp;<Ref Subsect="subsect:groups"/>)
to compute an upper bound for <M>&fpr;(g,S/M)</M>, for <M>g \in S^{\times}</M>.

<P/>

<Example><![CDATA[
gap> M:= ClosureGroup( g, tz );;
gap> bccl:= List( primereps, x -> ConjugacyClass( M, x ) );;
gap> UpperBoundFixedPointRatios( omega, [ bccl ], false );
[ 1/2015, true ]
]]></Example>

<P/>

Although some of the classes of <M>M</M> in the list <C>bccl</C> may be <M>S</M>-conjugate,
the entry <K>true</K> in the second position of the result indicates
that in fact the <E>exact</E> value for the maximum of <M>&fpr;(g,S/M)</M>,
for <M>g \in S^{\times}</M>, has been computed.
This implies statement&nbsp;(b).

<P/>

We clean the workspace.

<P/>

<Example><![CDATA[
gap> CleanWorkspace();
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="O12p3">
<Heading><M>O_{12}^+(3)</M></Heading>

We show that the group <M>S = O_{12}^+(3) = &POmega;^+(12,3)</M> satisfies the
following.

<P/>


<List>
<Mark>(a)</Mark>
<Item>
    <M>S</M> has a maximal subgroup <M>M</M> of the type
    <M>N_S(&POmega;^+(6,9))</M>,
    which has the structure <M>&POmega;^+(6,9).[4]</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&fpr;(g,S/M) \leq 2/88\,209</M> holds for all <M>g \in S^{\times}</M>.
</Item>
</List>

<P/>

(This result is used in the proof
of&nbsp;<Cite Key="BGK" Where="Proposition&nbsp;5.14"/>,
where it is shown that for <M>s \in S</M> of order <M>205</M>,
<M>&M;(S,s)</M> consists of one reducible subgroup <M>G_8</M>
and at most two extension field type subgroups
of the type <M>N_S(&POmega;^+(6,9))</M>.
By&nbsp;<Cite Key="GK" Where="Proposition&nbsp;3.16"/>,
<M>&fpr;(g,S/G_8) \leq 19/3^5</M> holds
for all <M>g \in S^{\times}</M>.
This implies
<M>&prop;(g,s) \leq 19/3^5 + 2 \cdot 2/88\,209 = 6\,901/88\,209 &lt; 1/3</M>.)

<P/>

Statement&nbsp;(a) follows
from&nbsp;<Cite Key="KlL90" Where="Prop.&nbsp;4.3.14"/>.

<P/>

<!-- % The table of O12+(3) is now available. -->

For statement&nbsp;(b), we embed <M>&GO;^+(6,9) \cong \Omega^+(6,9).2^2</M>
into <M>&SO;^+(12,3) = 2.S.2</M>,
by replacing each element in <M>&F;_9</M> by the <M>2 \times 2</M> matrix of the
induced <M>&F;_3</M>-linear mapping w.r.t.&nbsp;a suitable basis <M>(b_1, b_2)</M>.
We choose a basis with the property <M>b_1 = 1</M> and <M>b_2^2 = 1 + b_2</M>,
because then the image of a symmetric matrix is again symmetric
(so the image of the invariant form is an invariant form for the image
of the group),
and apply an appropriate transformation to the images of the generators.

<P/>

<Example><![CDATA[
gap> so:= SO(+1,12,3);;
gap> Display( InvariantBilinearForm( so ).matrix );
 . 1 . . . . . . . . . .
 1 . . . . . . . . . . .
 . . 1 . . . . . . . . .
 . . . 2 . . . . . . . .
 . . . . 2 . . . . . . .
 . . . . . 2 . . . . . .
 . . . . . . 2 . . . . .
 . . . . . . . 2 . . . .
 . . . . . . . . 2 . . .
 . . . . . . . . . 2 . .
 . . . . . . . . . . 2 .
 . . . . . . . . . . . 2
gap> g:= GO(+1,6,9);;
gap> Z(9)^2 = Z(3)^0 + Z(9);
true
gap> b:= Basis( GF(9), [ Z(3)^0, Z(9) ] );
Basis( GF(3^2), [ Z(3)^0, Z(3^2) ] )
gap> blow:= List( GeneratorsOfGroup( g ), x -> BlownUpMat( b, x ) );;
gap> m:= BlownUpMat( b, InvariantBilinearForm( g ).matrix );;
gap> Display( m );
 . . 1 . . . . . . . . .
 . . . 1 . . . . . . . .
 1 . . . . . . . . . . .
 . 1 . . . . . . . . . .
 . . . . 2 . . . . . . .
 . . . . . 2 . . . . . .
 . . . . . . 2 . . . . .
 . . . . . . . 2 . . . .
 . . . . . . . . 2 . . .
 . . . . . . . . . 2 . .
 . . . . . . . . . . 2 .
 . . . . . . . . . . . 2
gap> pi:= PermutationMat( (2,3), 12, GF(3) );;
gap> tr:= IdentityMat( 12, GF(3) );;
gap> tr{[3,4]}{[3,4]}:= [[1,-1],[1,1]]*Z(3)^0;;
gap> D:= tr * pi;;
gap> D * m * TransposedMat( D ) = InvariantBilinearForm( so ).matrix;
true
gap> tblow:= List( blow, x -> D * x * D^-1 );;
gap> IsSubset( so, tblow );
true
]]></Example>

<P/>

The image of <M>&GO;^+(6,9)</M> under the embedding into <M>&SO;^+(12,3)</M>
does not lie in <M>\Omega^+(12,3) = 2.S</M>,
so a factor of two is missing in <M>&GO;^+(6,9) \cap 2.S</M> for getting
(the preimage <M>2.M</M> of) the required maximal subgroup <M>M</M> of <M>S</M>.
Because of this, and also because currently it is time consuming
to compute the derived subgroup of <M>&SO;^+(12,3)</M>,
we work with the upward extension <M>&PSO;^+(12,3) = S.2</M>.
Note that <M>M</M> extends to a maximal subgroup of <M>S.2</M>.

<P/>

First we factor out the centre of <M>&SO;^+(12,3)</M>,
and switch to a permutation representation of <M>S.2</M>.

<P/>

<Example><![CDATA[
gap> orbs:= OrbitsDomain( so, NormedRowVectors( GF(3)^12 ), OnLines );;
gap> List( orbs, Length );
[ 88452, 88452, 88816 ]
gap> act:= Action( so, orbs[1], OnLines );;
gap> SetSize( act, Size( so ) / 2 );
]]></Example>

<!-- Calling <C>DerivedSubgroup</C> for the matrix group is very expensive.
     One could provide explicit generators, as follows.

<Example><![CDATA[
gap> gens:= [ Comm( act.1, act.2 ), Comm( act.1, act.3 ),
>             Comm( act.2, act.3 ), act.1^2, act.2^2, act.3^2 ];;
gap> omega:= SubgroupNC( act, gens );;
gap> Size( act ) / Size( omega );
2
]]></Example>

     Still this (computing the order) requires about 136 seconds. -->

<P/>

Next we rewrite the matrix generators for <M>&GO;^+(6,9)</M> accordingly,
and compute the normalizer in <M>S.2</M> of the subgroup they generate;
this is the maximal subgroup <M>M.2</M> we need.

<P/>

<Example><![CDATA[
gap> u:= SubgroupNC( act,
>            List( tblow, x -> Permutation( x, orbs[1], OnLines ) ) );;
gap> n:= Normalizer( act, u );;
gap> Size( n ) / Size( u );
2
]]></Example>

<!-- % Computing the normalizer exceeds 200MB an and needs 251 seconds. -->

<P/>

Now we compute class representatives of prime order in <M>M.2</M>,
in a smaller faithful permutation representation,
and then the desired upper bound for <M>&fpr;(g, S/M)</M>.

<!-- In the earlier version of this file, the conjugacy classes of the whole
     group <C>nact</C> were computed, a list of length 333.
     The computation of the classes needed 5772 sec. in GAP 4.4.12
     and was very space consuming.
     In GAP 4.5, the problems were even larger.
     Thus I decided to compute directly only the classes whose element orders
     are primes. -->

<P/>

<Example><![CDATA[
gap> norbs:= OrbitsDomain( n, MovedPoints( n ) );;
gap> List( norbs, Length );
[ 58968, 29484 ]
gap> hom:= ActionHomomorphism( n, norbs[2] );;
gap> nact:= Image( hom );;
gap> Size( nact ) = Size( n );
true
gap> ccl:= ClassesOfPrimeOrder( nact, PrimeDivisors( Size( nact ) ),
>                               TrivialSubgroup( nact ) );;
gap> Length( ccl );
26
gap> preim:= List( ccl,
>        x -> PreImagesRepresentative( hom, Representative( x ) ) );;
gap> pccl:= List( preim, x -> ConjugacyClass( n, x ) );;
gap> for i in [ 1 .. Length( pccl ) ] do
>      SetSize( pccl[i], Size( ccl[i] ) );
>    od;
gap> UpperBoundFixedPointRatios( act, [ pccl ], false );
[ 2/88209, true ]
]]></Example>

<!-- If we would work with the central extension,
     we would get [ 4/88209, false ] -->

<P/>

Note that we have computed
<M>\max\{ &fpr;(g,S.2/M.2), g \in S.2^{\times} \} \geq
 \max\{ &fpr;(g,S.2/M.2), g \in S^{\times} \} =
 \max\{ &fpr;(g,S/M), g \in S^{\times} \}</M>.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="S48">
<Heading><M>\ast</M>&nbsp;<M>S_4(8)</M></Heading>

We show that the group <M>S = S_4(8) = &Sp;(4,8)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> irreducible of order <M>65</M>,
    <M>&M;(S,s)</M> consists of two nonconjugate subgroups of the type
    <M>S_2(64).2 = &Sp;(2,64).2 \cong L_2(64).2
    \cong O_4^-(8).2 = \Omega^-(4,8).2</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 8/63</M>.
</Item>
</List>

<P/>

By&nbsp;<Cite Key="Be00"/>, the only maximal subgroups of <M>S</M> that contain <M>s</M>
are <M>O_4^-(8).2 = &SO;^-(4,8)</M> or of extension field type.
By&nbsp;<Cite Key="KlL90" Where="Prop.&nbsp;4.3.10, 4.8.6"/>,
there is one class of each of these subgroups (which happen to be isomorphic).

<P/>

These classes of subgroups induce different permutation characters.
One argument to see this is that the involutions in the outer half
of extension field type subgroup <M>S_2(64).2 &lt; S_4(8)</M> have
a two-dimensional fixed space,
whereas the outer involutions in <M>&SO;^-(4,8)</M> have a three-dimensional
fixed space.

<P/>

The former statement can be seen by using a normal basis of the field
extension <M>&F;_{64}/&F;_8</M>, such that the action of the Frobenius
automorphism (which yields a suitable outer involution) is just a
double transposition on the basis vectors of the natural module for <M>S</M>.

<P/>

<Example><![CDATA[
gap> sp:= SP(4,8);;
gap> Display( InvariantBilinearForm( sp ).matrix );
 . . . 1
 . . 1 .
 . 1 . .
 1 . . .
gap> z:= Z(64);;
gap> f:= AsField( GF(8), GF(64) );;
gap> repeat
>      b:= Basis( f, [ z, z^8 ] );
>      z:= z * Z(64);
> until b <> fail;
gap> sub:= SP(2,64);;
gap> Display( InvariantBilinearForm( sub ).matrix );
 . 1
 1 .
gap> ext:= Group( List( GeneratorsOfGroup( sub ),
>                       x -> BlownUpMat( b, x ) ) );;
gap> tr:= PermutationMat( (3,4), 4, GF(2) );;
gap> conj:= ConjugateGroup( ext, tr );;
gap> IsSubset( sp, conj );
true
gap> inv:= [[0,1,0,0],[1,0,0,0],[0,0,0,1],[0,0,1,0]] * Z(2);;
gap> inv in sp;
true
gap> inv in conj;
false
gap> Length( NullspaceMat( inv - inv^0 ) );
2
]]></Example>

<P/>

The latter statement can be shown by looking at an outer involution in
<M>&SO;^-(4,8)</M>.

<P/>

<Example><![CDATA[
gap> so:= SO(-1,4,8);;
gap> der:= DerivedSubgroup( so );;
gap> x:= First( GeneratorsOfGroup( so ), x -> not x in der );;
gap> x:= x^( Order(x)/2 );;
gap> Length( NullspaceMat( x - x^0 ) );
3
]]></Example>

<!-- We could also embed <M>&SO;^-(4,8)</M> into <M>S_4(8)</M>.
     Since the invariant forms of the two groups do not coincide,
     we have to conjugate one of the groups.

<Example><![CDATA[
gap> Display( InvariantBilinearForm( so ).matrix );
 . 1 . .
 1 . . .
 . . . 1
 . . 1 .
gap> tr:= PermutationMat( (2,4), 4, GF(2) );;
gap> conj:= ConjugateGroup( so, tr );;
gap> IsSubset( sp, conj );
true
]]></Example>

-->

<P/>

The character table of <M>L_2(64).2</M> is currently not available in the
&GAP; Character Table Library, so we compute the possible permutation
characters with a combinatorial approach,
and show statement&nbsp;(a).

<P/>

<Example><![CDATA[
gap> CharacterTable( "L2(64).2" );
fail
gap> t:= CharacterTable( "S4(8)" );;
gap> degree:= Size( t ) / ( 2 * Size( SL(2,64) ) );;
gap> pi:= PermChars( t, rec( torso:= [ degree ] ) );
[ Character( CharacterTable( "S4(8)" ),
  [ 2016, 0, 256, 32, 0, 36, 0, 8, 1, 0, 4, 0, 0, 0, 28, 28, 28, 0, 
      0, 0, 0, 0, 0, 36, 36, 36, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 
      4, 4, 4, 0, 0, 0, 4, 4, 4, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 
      0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
      1, 1, 1 ] ), Character( CharacterTable( "S4(8)" ),
  [ 2016, 256, 0, 32, 36, 0, 0, 8, 1, 4, 0, 28, 28, 28, 0, 0, 0, 0, 
      0, 0, 36, 36, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 4, 4, 4, 
      0, 0, 0, 4, 4, 4, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 
      1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
      1, 1, 1 ] ) ]
gap> spos:= Position( OrdersClassRepresentatives( t ), 65 );;
gap> List( pi, x -> x[ spos ] );
[ 1, 1 ]
]]></Example>

<P/>

Now we compute <M>&total;(S,s)</M>, which yields statement&nbsp;(b).

<P/>

<Example><![CDATA[
gap> Maximum( ApproxP( pi, spos ) );
8/63
]]></Example>

<P/>

We clean the workspace.

<P/>

<Example><![CDATA[
gap> CleanWorkspace();
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="S62">
<Heading><M>S_6(2)</M></Heading>

We show that the group <M>S = S_6(2) = &Sp;(6,2)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    <M>&total;(S) = 4/7</M>,
    and this value is attained exactly for <M>&total;(S,s)</M>
    with <M>s</M> of order <M>9</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s \in S</M> of order <M>9</M>,
    <M>&M;(S,s)</M> consists of one subgroup of the type
    <M>U_4(2).2 = \Omega^-(6,2).2</M> and three conjugate subgroups
    of the type <M>L_2(8).3 = &Sp;(2,8).3</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    For <M>s \in S</M> of order <M>9</M>,
    and <M>g \in S^{\times}</M>,
    we have <M>&prop;(g,s) &lt; 1/3</M>,
    except if <M>g</M> is in one of the classes
    <C>2A</C> (the transvection class) or <C>3A</C>.
</Item>
<Mark>(d)</Mark>
<Item>
    For <M>s \in S</M> of order <M>15</M>,
    and <M>g \in S^{\times}</M>,
    we have <M>&prop;(g,s) &lt; 1/3</M>,
    except if <M>g</M> is in one of the classes <C>2A</C> or <C>2B</C>.
</Item>
<Mark>(e)</Mark>
<Item>
    <M>&prop;(S) = 11/21</M>,
    and this value is attained exactly for <M>&prop;(S,s)</M>
    with <M>s</M> of order <M>15</M>.
</Item>
<Mark>(f)</Mark>
<Item>
    For all <M>s^{\prime} \in S</M>,
    we have <M>&prop;(g,s^{\prime}) > 1/3</M>
    for <M>g</M> in at least two classes.
</Item>
<Mark>(g)</Mark>
<Item>
    The uniform spread of <M>S</M> is at least two,
    with <M>s</M> of order <M>9</M>.
</Item>
</List>

<!-- %T show: exact spread equal to <M>2</M> -->

<P/>

(Note that in this example,
the optimal choice of <M>s</M> w.r.t. <M>&total;(S,s)</M>
is not optimal w.r.t. <M>&prop;(S,s)</M>.)

<P/>

Statement&nbsp;(a) follows from the inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<Ref Subsect="easyloop"/>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "S6(2)" );;
gap> ProbGenInfoSimple( t );
[ "S6(2)", 4/7, 1, [ "9A" ], [ 4 ] ]
]]></Example>

<P/>

Also statement&nbsp;(b) follows from the information provided by the
character table of <M>S</M> (cf.&nbsp;<Cite Key="CCN85" Where="p.&nbsp;46"/>).

<P/>

<Example><![CDATA[
gap> prim:= PrimitivePermutationCharacters( t );;
gap> ord:= OrdersClassRepresentatives( t );;
gap> spos:= Position( ord, 9 );;
gap> filt:= PositionsProperty( prim, x -> x[ spos ] <> 0 );
[ 1, 8 ]
gap> Maxes( t ){ filt };
[ "U4(2).2", "L2(8).3" ]
gap> List( prim{ filt }, x -> x[ spos ] );
[ 1, 3 ]
]]></Example>

<P/>

Now we consider statement&nbsp;(c).
For <M>s</M> of order <M>9</M> and <M>g</M> in one of the classes <C>2A</C>,
<C>3A</C>,
we observe that <M>&prop;(g,s) = &total;(g,s)</M> holds.
This is because exactly one maximal subgroup of <M>S</M>
contains both <M>s</M> and <M>g</M>.
For all other elements <M>g</M>, we have even <M>&total;(g,s) &lt; 1/3</M>.

<P/>

<Example><![CDATA[
gap> prim:= PrimitivePermutationCharacters( t );;
gap> spos9:= Position( ord, 9 );;
gap> approx9:= ApproxP( prim, spos9 );;
gap> filt9:= PositionsProperty( approx9, x -> x >= 1/3 );
[ 2, 6 ]
gap> AtlasClassNames( t ){ filt9 };
[ "2A", "3A" ]
gap> approx9{ filt9 };
[ 4/7, 5/14 ]
gap> List( Filtered( prim, x -> x[ spos9 ] <> 0 ), x -> x{ filt9 } );
[ [ 16, 10 ], [ 0, 0 ] ]
]]></Example>

<P/>

Similarly, statement&nbsp;(d) follows.
For <M>s</M> of order <M>15</M> and <M>g</M> in one of the classes <C>2A</C>,
<C>2B</C>,
already the degree <M>36</M> permutation character yields <M>&prop;(g,s) \geq 1/3</M>.
And for all other elements <M>g</M>, again we have <M>&total;(g,s) &lt; 1/3</M>.

<P/>

<Example><![CDATA[
gap> spos15:= Position( ord, 15 );;
gap> approx15:= ApproxP( prim, spos15 );;
gap> filt15:= PositionsProperty( approx15, x -> x >= 1/3 );
[ 2, 3 ]
gap> PositionsProperty( ApproxP( prim{ [ 2 ] }, spos15 ), x -> x >= 1/3 );
[ 2, 3 ]
gap> AtlasClassNames( t ){ filt15 };
[ "2A", "2B" ]
gap> approx15{ filt15 };
[ 46/63, 8/21 ]
]]></Example>

<P/>

For the remaining statements, we use explicit computations with <M>S</M>,
in the transitive degree <M>63</M> permutation representation.
We start with a function that computes a transvection in <M>S_d(2)</M>;
note that the invariant bilinear form used for symplectic groups in &GAP;
is described by a matrix with nonzero entries exactly in the positions
<M>(i,d+1-i)</M>, for <M>1 \leq i \leq d</M>.

<P/>

<Example><![CDATA[
gap> transvection:= function( d )
>     local mat;
>     mat:= IdentityMat( d, Z(2) );
>     mat{ [ 1, d ] }{ [ 1, d ] }:= [ [ 0, 1 ], [ 1, 0 ] ] * Z(2);
>     return mat;
> end;;
]]></Example>

<P/>

First we compute, for statement&nbsp;(d), the exact values <M>&prop;(g,s)</M> for <M>g</M>
in one of the classes <C>2A</C> or <C>2B</C>, and <M>s</M> of order <M>15</M>.
Note that the classes <C>2A</C>, <C>2B</C> are the unique classes of the
lengths <M>63</M> and <M>315</M>, respectively.

<P/>

<Example><![CDATA[
gap> PositionsProperty( SizesConjugacyClasses( t ), x -> x in [ 63, 315 ] );
[ 2, 3 ]
gap> d:= 6;;
gap> matgrp:= Sp(d,2);;
gap> hom:= ActionHomomorphism( matgrp, NormedRowVectors( GF(2)^d ) );;
gap> g:= Image( hom, matgrp );;
gap> ResetGlobalRandomNumberGenerators();
gap> repeat s15:= Random( g );
>    until Order( s15 ) = 15;
gap> 2A:= Image( hom, transvection( d ) );;
gap> Size( ConjugacyClass( g, 2A ) );
63
gap> IsTransitive( g, MovedPoints( g ) );
true
gap> RatioOfNongenerationTransPermGroup( g, 2A, s15 );
11/21
gap> repeat 12C:= Random( g );
>    until Order( 12C ) = 12 and Size( Centralizer( g, 12C ) ) = 12;
gap> 2B:= 12C^6;;
gap> Size( ConjugacyClass( g, 2B ) );
315
gap> RatioOfNongenerationTransPermGroup( g, 2B, s15 );
8/21
]]></Example>

<P/>

For statement&nbsp;(e), we compute <M>&prop;(g, s^{\prime})</M>,
for a transvection <M>g</M> and class representatives <M>s^{\prime}</M> of <M>S</M>.
It turns out that the minimum is <M>11/21</M>,
and it is attained for exactly one <M>s^{\prime}</M>;
by the above, this element has order <M>15</M>.

<P/>

<Example><![CDATA[
gap> ccl:= ConjugacyClasses( g );;
gap> reps:= List( ccl, Representative );;
gap> nongen2A:= List( reps,
>        x -> RatioOfNongenerationTransPermGroup( g, 2A, x ) );;
gap> min:= Minimum( nongen2A );
11/21
gap> Number( nongen2A, x -> x = min );
1
]]></Example>

<P/>

For statement&nbsp;(f), we show that for any choice of <M>s^{\prime}</M>,
at least two of the values <M>&prop;(g,s^{\prime})</M>,
with <M>g</M> in the classes <C>2A</C>, <C>2B</C>, or <C>3A</C>,
are larger than <M>1/3</M>.

<P/>

<Example><![CDATA[
gap> nongen2B:= List( reps,
>        x -> RatioOfNongenerationTransPermGroup( g, 2B, x ) );;
gap> 3A:= s15^5;;
gap> nongen3A:= List( reps,
>        x -> RatioOfNongenerationTransPermGroup( g, 3A, x ) );;
gap> bad:= List( [ 1 .. NrConjugacyClasses( t ) ],
>                i -> Number( [ nongen2A, nongen2B, nongen3A ],
>                             x -> x[i] > 1/3 ) );;
gap> Minimum( bad );
2
]]></Example>

<P/>

Finally, for statement&nbsp;(g), we have to consider only the case that the
two elements <M>x</M>, <M>y</M> are transvections.

<P/>

<Example><![CDATA[
gap> PositionsProperty( approx9, x -> x + approx9[2] >= 1 );
[ 2 ]
]]></Example>

<P/>

We use the random approach described in
Section&nbsp;<Ref Subsect="subsect:groups"/>.

<P/>

<Example><![CDATA[
gap> repeat s9:= Random( g );
>    until Order( s9 ) = 9;
gap> RandomCheckUniformSpread( g, [ 2A, 2A ], s9, 20 );
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="S82">
<Heading><M>S_8(2)</M></Heading>

We show that the group <M>S = S_8(2)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> of order <M>17</M>,
    <M>&M;(S,s)</M> consists of one subgroup of each of the types
    <M>O_8^-(2).2 = \Omega^-(8,2).2</M>, <M>S_4(4).2 = &Sp;(4,4).2</M>,
    and <M>L_2(17) = &PSL;(2,17)</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s \in S</M> of order <M>17</M>,
    and <M>g \in S^{\times}</M>,
    we have <M>&prop;(g,s) &lt; 1/3</M>, except if <M>g</M> is a transvection.
</Item>
<Mark>(c)</Mark>
<Item>
    The uniform spread of <M>S</M> is at least two,
    with <M>s</M> of order <M>17</M>.
</Item>
</List>

<P/>

Statement&nbsp;(a) follows from the list of maximal subgroups of <M>S</M>
in&nbsp;<Cite Key="CCN85" Where="p.&nbsp;123"/>,
and the fact that <M>1_H^S(s) = 1</M> holds for each <M>H \in &M;(S,s)</M>.
Note that <M>17</M> divides the indices of the maximal subgroups of the types
<M>O_8^+(2).2</M> and <M>2^7 : S_6(2)</M> in <M>S</M>,
and obviously <M>17</M> does not divide the orders of the remaining maximal
subgroups.

<P/>

The permutation characters induced from the first two subgroups
are uniquely determined by the ordinary character tables.
The permutation character induced from the last subgroup is
uniquely determined if one considers also the corresponding Brauer tables;
the correct class fusion is stored in the &GAP; Character Table Library,
see&nbsp;<Cite Key="AmbigFus"/>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "S8(2)" );;
gap> pi1:= PossiblePermutationCharacters( CharacterTable( "O8-(2).2" ), t );;
gap> pi2:= PossiblePermutationCharacters( CharacterTable( "S4(4).2" ), t );;
gap> pi3:= [ TrivialCharacter( CharacterTable( "L2(17)" ) )^t ];;
gap> prim:= Concatenation( pi1, pi2, pi3 );;
gap> Length( prim );
3
gap> spos:= Position( OrdersClassRepresentatives( t ), 17 );;
gap> List( prim, x -> x[ spos ] );
[ 1, 1, 1 ]
]]></Example>

<P/>

For statement&nbsp;(b),
we observe that <M>&total;(g,s) &lt; 1/3</M> if <M>g</M> is not a transvection,
and that <M>&prop;(g,s) = &total;(g,s)</M> for transvections <M>g</M>
because exactly one of the three permutation characters is nonzero
on both <M>s</M> and the class of transvections.

<P/>

<Example><![CDATA[
gap> approx:= ApproxP( prim, spos );;
gap> PositionsProperty( approx, x -> x >= 1/3 );
[ 2 ]
gap> Number( prim, pi -> pi[2] <> 0 and pi[ spos ] <> 0 );
1
gap> approx[2];
8/15
]]></Example>

<P/>

In statement&nbsp;(c), we have to consider only the case that the
two elements <M>x</M>, <M>y</M> are transvections.

<P/>

<Example><![CDATA[
gap> PositionsProperty( approx, x -> x + approx[2] >= 1 );
[ 2 ]
]]></Example>

<P/>

We use the random approach described in
Section&nbsp;<Ref Subsect="subsect:groups"/>.

<P/>

<Example><![CDATA[
gap> d:= 8;;
gap> matgrp:= Sp(d,2);;
gap> hom:= ActionHomomorphism( matgrp, NormedRowVectors( GF(2)^d ) );;
gap> x:= Image( hom, transvection( d ) );;
gap> g:= Image( hom, matgrp );;
gap> C:= ConjugacyClass( g, x );;  Size( C );
255
gap> ResetGlobalRandomNumberGenerators();
gap> repeat s:= Random( g );
>    until Order( s ) = 17;
gap> RandomCheckUniformSpread( g, [ x, x ], s, 20 );
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="S102">
<Heading><M>\ast</M>&nbsp;<M>S_{10}(2)</M></Heading>

We show that the group <M>S = S_{10}(2)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> of order <M>33</M>,
    <M>&M;(S,s)</M> consists of one subgroup of each of the types
    <M>\Omega^-(10,2).2</M> and <M>L_2(32).5 = &Sp;(2,32).5</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s \in S</M> of order <M>33</M>,
    and <M>g \in S^{\times}</M>,
    we have <M>&prop;(g,s) &lt; 1/3</M>, except if <M>g</M> is a transvection.
</Item>
<Mark>(c)</Mark>
<Item>
    The uniform spread of <M>S</M> is at least two,
    with <M>s</M> of order <M>33</M>.
</Item>
</List>

<P/>

By&nbsp;<Cite Key="Be00"/>, the only maximal subgroups of <M>S</M> that contain <M>s</M>
have the types stated in&nbsp;(a),
and by&nbsp;<Cite Key="KlL90" Where="Prop.&nbsp;4.3.10 and 4.8.6"/>,
there is exactly one class of each of these subgroups.

<P/>

We compute the values <M>&total;( g, s )</M>, for all <M>g \in S^{\times}</M>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "S10(2)" );;
gap> pi1:= PossiblePermutationCharacters( CharacterTable( "O10-(2).2" ), t );;
gap> pi2:= PossiblePermutationCharacters( CharacterTable( "L2(32).5" ), t );;
gap> prim:= Concatenation( pi1, pi2 );;  Length( prim );
2
gap> spos:= Position( OrdersClassRepresentatives( t ), 33 );;
gap> approx:= ApproxP( prim, spos );;
]]></Example>

<P/>

For statement&nbsp;(b),
we observe that <M>&total;(g,s) &lt; 1/3</M> if <M>g</M> is not a transvection,
and that <M>&prop;(g,s) = &total;(g,s)</M> for transvections <M>g</M>
because exactly one of the two permutation characters is nonzero
on both <M>s</M> and the class of transvections.

<P/>

<Example><![CDATA[
gap> PositionsProperty( approx, x -> x >= 1/3 );
[ 2 ]
gap> Number( prim, pi -> pi[2] <> 0 and pi[ spos ] <> 0 );
1
gap> approx[2];
16/31
]]></Example>

<P/>

In statement&nbsp;(c), we have to consider only the case that the
two elements <M>x</M>, <M>y</M> are transvections.
We use the random approach described in
Section&nbsp;<Ref Subsect="subsect:groups"/>.

<P/>

<Example><![CDATA[
gap> d:= 10;;
gap> matgrp:= Sp(d,2);;
gap> hom:= ActionHomomorphism( matgrp, NormedRowVectors( GF(2)^d ) );;
gap> x:= Image( hom, transvection( d ) );;
gap> g:= Image( hom, matgrp );;
gap> C:= ConjugacyClass( g, x );;  Size( C );
1023
gap> ResetGlobalRandomNumberGenerators();
gap> repeat s:= Random( g );
>    until Order( s ) = 33;
gap> RandomCheckUniformSpread( g, [ x, x ], s, 20 );
true
]]></Example>

</Subsection>


<!-- % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- % <Subsection Label="sect:<M>\ast</M>&nbsp;<M>S_{10">
<Heading><M>\ast</M>&nbsp;<M>S_{10</Heading>(2)</M>}\label{S102} -->
<!-- %  -->
<!-- % We show that the group <M>S = S_{10}(2)</M> satisfies the following. -->
<!-- % \begin{enumerate} -->
<!-- % \item[(a)] -->
<!-- %     For <M>s \in S</M> of order <M>45</M>, -->
<!-- %     and <M>g \in S^{\times}</M>, -->
<!-- %     we have <M>&prop;(g,s) < 1/3</M>, except if <M>g</M> is a transvection. -->
<!-- % \item[(b)] -->
<!-- %     The uniform spread of <M>S</M> is at least two, -->
<!-- %     with <M>s</M> of order <M>45</M>. -->
<!-- % \end{enumerate} -->
<!-- %  -->
<!-- % In&nbsp;<Cite Key="KlL90" Where="Table&nbsp;3.5.C"/>, only the subgroups of the types -->
<!-- % <M>O_{10}^+(2).2</M> and <M>S_4(2) \perp S_6(2) \cong S_6 \times S_6(2)</M> -->
<!-- % contain elements of order <M>45</M>, -->
<!-- % and that there is only one conjugacy class of each of these subgroups. -->
<!-- %  -->
<!-- % For that, observe that we have <M>n = 10</M> and <M>q = 2</M>. -->
<!-- % <M>C_1</M> contains the subgroups <M>P_m</M> and <M>Sp_m(2) \perp Sp_{10-m}(2)</M>; -->
<!-- % the former do not occur because for <M>1 \leq m \leq 5</M>, the groups -->
<!-- % <M>&PGL;_m(2) \times PSp_{10-2m}(2)</M> do not contain elements of order <M>45</M>, -->
<!-- % and for the latter type, <M>m = 2</M> does not occur but <M>m = 4</M> yields the -->
<!-- % maximal subgroup <M>S_4(2) \perp S_6(2)</M>. -->
<!-- % Only the groups <M>Sp_2(2) \wr S_5</M> and <M>Sp_2(2^5)</M> occur for <M>C_2</M> -->
<!-- % and <M>C_3</M>, but they do not contain elements of order <M>45</M>. -->
<!-- % The classes <M>C_4</M>--<M>C_7</M> do not do not occur because <M>q</M> is -->
<!-- % a prime and not odd. -->
<!-- % Finally, <M>C_8</M> contains the maximal subgroups <M>O_{10}^{\pm}(2).2</M>, -->
<!-- % but <M>O_{10}^-(2).2</M> does not contain elements of order <M>45</M>. -->
<!--
gap> 45 in OrdersClassRepresentatives( CharacterTable( "O10-(2)" ) );
false
-->
<!-- % It remains to check whether other finite nonabelian simple groups can be -->
<!-- % involved. -->
<!-- % We list all finite nonabelian simple groups whose order divides that of <M>S</M>, -->
<!-- % and then filter out those whose order is a multiple of <M>45</M>. -->
<!--
<Example><![CDATA[
gap> LoadPackage( "genus", false );
gap> cand:= SizesSimpleGroupsInfo( [ Size( SP(10,2) ) ], "divides" );;
gap> cand:= Filtered( cand, x -> x[1] mod 45 = 0 );;
gap> Filtered( cand, x -> CharacterTable( x[2] ) = fail or
>              45 in OrdersClassRepresentatives( CharacterTable( x[2] ) ) );
[ [ 23499295948800, "O10+(2)" ], [ 258492255436800, "L5(4)" ],
  [ 24815256521932800, "S10(2)" ] ]
-->
<!-- % Note that <M>L_5(4)</M> cannot be a subgroup of <M>S_{10}(2)</M>, for example -->
<!-- % because of the too large element order <M>(4^5-1)/(4-1)</M> in <M>L_5(4)</M>. -->
<!--
gap> t:= CharacterTable( "S10(2)" );;
gap> s1:= CharacterTable( "O10+(2).2" );;
gap> s2:= CharacterTable( "S6" ) * CharacterTable( "S6(2)" );;
gap> pi1:= PossiblePermutationCharacters( s1, t );
[ Character( CharacterTable( "S10(2)" ), [ 528, 256, 144, 128, 64, 48, 32, 
      16, 120, 0, 36, 3, 6, 56, 72, 24, 40, 32, 0, 8, 24, 16, 16, 8, 16, 8, 
      12, 4, 12, 0, 8, 4, 4, 28, 3, 64, 24, 32, 36, 0, 16, 16, 0, 1, 8, 16, 
      12, 6, 4, 0, 8, 12, 0, 3, 2, 8, 4, 1, 4, 0, 4, 3, 2, 1, 10, 12, 20, 8, 
      0, 8, 8, 0, 4, 4, 4, 0, 4, 2, 6, 2, 2, 6, 3, 0, 16, 4, 8, 4, 1, 3, 1, 
      0, 20, 12, 12, 4, 8, 0, 8, 4, 6, 0, 2, 0, 0, 2, 6, 4, 0, 4, 0, 4, 0, 0, 
      2, 6, 3, 4, 2, 0, 4, 2, 0, 1, 0, 2, 2, 3, 0, 2, 1, 4, 4, 2, 10, 1, 0, 
      1, 3, 0, 0, 2, 1, 1, 4, 0, 2, 1, 0, 4, 6, 2, 0, 2, 1, 1, 6, 2, 2, 2, 0, 
      2, 0, 2, 2, 0, 0, 0, 2, 4, 4, 1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 
      0, 2, 0, 2, 0, 1, 1, 1, 1, 1, 0, 2, 1 ] ) ]
gap> pi2:= PossiblePermutationCharacters( s2, t );
[ Character( CharacterTable( "S10(2)" ), [ 23744512, 1810432, 90112, 176128, 
      28672, 5120, 9216, 5120, 96832, 3520, 1009, 280, 253, 5440, 5440, 256, 
      256, 1600, 256, 320, 320, 256, 256, 256, 576, 320, 0, 64, 64, 64, 64, 
      0, 64, 337, 12, 12160, 832, 2176, 337, 320, 640, 289, 256, 280, 384, 
      97, 49, 85, 109, 13, 97, 17, 32, 40, 61, 33, 49, 40, 37, 5, 17, 8, 21, 
      8, 1, 16, 16, 16, 16, 16, 16, 0, 16, 16, 0, 16, 16, 0, 0, 0, 0, 1, 1, 
      1, 97, 17, 33, 17, 12, 0, 0, 0, 112, 112, 16, 16, 32, 32, 64, 16, 1, 1, 
      13, 13, 16, 13, 13, 48, 0, 1, 1, 16, 16, 16, 5, 5, 4, 1, 13, 1, 1, 5, 
      5, 4, 0, 1, 5, 0, 1, 1, 0, 1, 1, 1, 22, 13, 12, 4, 0, 0, 0, 0, 0, 0, 1, 
      1, 1, 1, 1, 1, 5, 5, 1, 5, 1, 1, 4, 4, 4, 4, 1, 1, 1, 1, 0, 0, 0, 1, 1, 
      10, 2, 5, 6, 2, 4, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 
      1, 0, 0, 2, 2, 1 ] ) ]
gap> prim:= Concatenation( pi1, pi2 );;
gap> spos:= Position( OrdersClassRepresentatives( t ), 45 );;
gap> approx:= ApproxP( prim, spos );;
gap> PositionsProperty( approx, x -> x >= 1/3 );
[ 2 ]
-->
<!-- % We compute <M>&prop;(g,s)</M>, for a transvection <M>g</M> and <M>s</M> of order <M>45</M>. -->
<!--
gap> d:= 10;;
gap> matgrp:= Sp(d,2);;
gap> hom:= ActionHomomorphism( matgrp, NormedRowVectors( GF(2)^d ) );;
gap> x:= Image( hom, transvection( d ) );;
gap> g:= Image( hom, matgrp );;
gap> Size( ConjugacyClass( g, x ) );;
1023
gap> repeat s:= Random( g ); until Order( s ) = 45;
gap> RatioOfNongenerationTransPermGroup( g, x, s );
16/31
-->
<!-- % In statement&nbsp;(b), we have to consider only the case that the -->
<!-- % two elements <M>x</M>, <M>y</M> are both transvections. -->
<!--
gap> PositionsProperty( approx, x -> x + approx[2] >= 1 );
[ 2 ]
-->
<!-- % We use the random approach described in Section&nbsp;<Ref Subsect="subsect:groups"/>. -->
<!--
gap> RandomCheckUniformSpread( g, [ x, x ], s, 20 );
true
-->
<!-- %  -->
<!-- % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<!-- % <Subsection Label="sect:<M>\ast</M>&nbsp;<M>S_{14">
<Heading><M>\ast</M>&nbsp;<M>S_{14</Heading>(2)</M>}\label{S142} -->
<!-- %  -->
<!-- % We show that for the maximal subgroup <M>M = &Sp;(6,2) \perp &Sp;(8,2)</M> -->
<!-- % in <M>S = S_{14}(2)</M>, -->
<!-- % we have <M>&fpr;(g, S/M) \leq 106/5\,461</M> for all <M>g \in S^{\times}</M>. -->
<!-- %  -->
<!-- % For that, we first compute class representatives of prime order for the -->
<!-- % direct factors <M>&Sp;(6,2)</M> and <M>&Sp;(8,2)</M> of <M>M</M>, -->
<!-- % and the embedding of the two groups into <M>S</M>. -->
<!-- % (A suitable permutation matrix transforms the diagonal product of the -->
<!-- % invariant forms of the two factors to the invariant form of <M>S</M>.) -->
<!-- % Then the class representatives of prime order in <M>M</M> are obtained -->
<!-- % as certain products of the representatives in the two factors. -->
<!--
gap> reps1:= List( ConjugacyClasses( Sp(6,2) ), Representative );;
gap> reps1:= Filtered( reps1, x -> IsPrimeInt( Order( x ) ) );;
gap> for i in [ 1 .. Length( reps1 ) ] do
>      m:= IdentityMat( 14, GF(2) );
>      m{ [ 1 .. 6 ] }{ [ 1 .. 6 ] }:= reps1[i];
>      reps1[i]:= m;
>    od;
gap> Length( reps1 );
9
gap> reps2:= List( ConjugacyClasses( Sp(8,2) ), Representative );;
gap> reps2:= Filtered( reps2, x -> IsPrimeInt( Order( x ) ) );;
gap> for i in [ 1 .. Length( reps2 ) ] do
>      m:= IdentityMat( 14, GF(2) );
>      m{ [ 7 .. 14 ] }{ [ 7 .. 14 ] }:= reps2[i];
>      reps2[i]:= m;
>    od;
gap> Length( reps2 );
15
gap> form:= NullMat( 14, 14, GF(2) );;
gap> for i in [ 1 .. 6 ] do form[i][7-i]:= Z(2); od;
gap> for i in [ 7 .. 14 ] do form[i][21-i]:= Z(2); od;
gap> Display( form );
 . . . . . 1 . . . . . . . .
 . . . . 1 . . . . . . . . .
 . . . 1 . . . . . . . . . .
 . . 1 . . . . . . . . . . .
 . 1 . . . . . . . . . . . .
 1 . . . . . . . . . . . . .
 . . . . . . . . . . . . . 1
 . . . . . . . . . . . . 1 .
 . . . . . . . . . . . 1 . .
 . . . . . . . . . . 1 . . .
 . . . . . . . . . 1 . . . .
 . . . . . . . . 1 . . . . .
 . . . . . . . 1 . . . . . .
 . . . . . . 1 . . . . . . .
gap> tr:= (2,10,4,12,6,14,8);;
gap> T:= PermutationMat( tr, 14, GF(2) );;
gap> g:= Sp(14,2);;
gap> T^-1 * form * T = InvariantBilinearForm( g ).matrix;
true
gap> emb1:= List( reps1, x -> T^-1 * x * T );;
gap> IsSubset( g, emb1 );
true
gap> emb2:= List( reps2, x -> T^-1 * x * T );;
gap> IsSubset( g, emb2 );
true
gap> Add( emb1, One( g ) );
gap> Add( emb2, One( g ) );
gap> prods:= Concatenation( List( emb1, x -> x * emb2 ) );;
gap> Length( prods );
160
gap> prods:= Filtered( prods, x -> IsPrimeInt( Order( x ) ) );;
gap> Length( prods );
63
-->
<!-- % Now we compute generators of <M>M</M>, and use the function -->
<!-- % <C>UpperBoundFixedPointRatios</C> (see Section&nbsp;<Ref Subsect="subsect:groups"/>) -->
<!-- % to compute an upper bound for <M>\max \{ &fpr;(g,S/M); g \in S^{\times} \}</M>. -->
<!--
<Example><![CDATA[
gap> gens1:= ShallowCopy( GeneratorsOfGroup( Sp(6,2) ) );;
gap> for i in [ 1 .. Length( gens1 ) ] do
>      m:= IdentityMat( 14, GF(2) );
>      m{ [ 1 .. 6 ] }{ [ 1 .. 6 ] }:= gens1[i];
>      gens1[i]:= m;
>    od;
gap> gens2:= ShallowCopy( GeneratorsOfGroup( Sp(8,2) ) );;
gap> for i in [ 1 .. Length( gens2 ) ] do
>      m:= IdentityMat( 14, GF(2) );
>      m{ [ 7 .. 14 ] }{ [ 7 .. 14 ] }:= gens2[i];
>      gens2[i]:= m;
>    od;
gap> gens:= List( Concatenation( gens1, gens2 ), x -> T^-1 * x * T );;
gap> M:= Subgroup( g, gens );;
gap> classes:= List( prods, x -> ConjugacyClass( M, x ) );;
gap> UpperBoundFixedPointRatios( g, [ classes ], false );
[ 106/5461, false ]
-->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="U42">
<Heading><M>U_4(2)</M></Heading>

We show that <M>S = U_4(2) = &SU;(4,2) \cong S_4(3) = &PSp;(4,3)</M>
satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    <M>&total;(S) = 21/40</M>,
    and this value is attained exactly for <M>&total;(S,s)</M>
    with <M>s</M> of order <M>12</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s \in S</M> of order <M>9</M>,
    <M>&M;(S,s)</M> consists of two groups,
    of the types <M>3^{1+2}_+ \colon 2A_4 = &GU;(3,2)</M>
    and <M>3^3 \colon S_4</M>, respectively.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&prop;(S) = 2/5</M>,
    and this value is attained exactly for <M>&prop;(S,s)</M>
    with <M>s</M> of order <M>9</M>.
</Item>
<Mark>(d)</Mark>
<Item>
    The uniform spread of <M>S</M> is at least three,
    with <M>s</M> of order <M>9</M>.
</Item>
<Mark>(e)</Mark>
<Item>
    <M>&total;^{\prime}(&Aut;(S),s) = 7/20</M>.
</Item>
</List>

<!-- %T Can we compute the exact (uniform) spread? -->

<P/>

(Note that in this example,
the optimal choice of <M>s</M> w.r.t. <M>&total;(S,s)</M>
is not optimal w.r.t. <M>&prop;(S,s)</M>.)

<P/>

Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<Ref Subsect="easyloop"/>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "U4(2)" );;
gap> ProbGenInfoSimple( t );
[ "U4(2)", 21/40, 1, [ "12A" ], [ 2 ] ]
]]></Example>

<P/>

Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the only classes of maximal subgroups that contain
elements of order <M>9</M> consist of groups of the structures
<M>3^{1+2}_+:2A_4</M> and <M>3^3:S_4</M>,
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;26"/>.

<P/>

<Example><![CDATA[
gap> OrdersClassRepresentatives( t );
[ 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, 6, 6, 6, 6, 6, 9, 9, 12, 12 ]
gap> prim:= PrimitivePermutationCharacters( t );
[ Character( CharacterTable( "U4(2)" ),
  [ 27, 3, 7, 0, 0, 9, 0, 3, 1, 2, 0, 0, 3, 3, 0, 1, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "U4(2)" ),
  [ 36, 12, 8, 0, 0, 6, 3, 0, 2, 1, 0, 0, 0, 0, 3, 2, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "U4(2)" ),
  [ 40, 8, 0, 13, 13, 4, 4, 4, 0, 0, 5, 5, 2, 2, 2, 0, 1, 1, 1, 1 ] ),
  Character( CharacterTable( "U4(2)" ),
  [ 40, 16, 4, 4, 4, 1, 7, 0, 2, 0, 4, 4, 1, 1, 1, 1, 1, 1, 0, 0 ] ), 
  Character( CharacterTable( "U4(2)" ),
  [ 45, 13, 5, 9, 9, 6, 3, 1, 1, 0, 1, 1, 4, 4, 1, 2, 0, 0, 1, 1 ] ) ]
]]></Example>

<P/>

For statement&nbsp;(c),
we use a primitive permutation representation on <M>40</M> points
that occurs in the natural action of <M>&SU;(4,2)</M>.

<P/>

<Example><![CDATA[
gap> g:= SU(4,2);;
gap> orbs:= OrbitsDomain( g, NormedRowVectors( GF(4)^4 ), OnLines );;
gap> List( orbs, Length );
[ 45, 40 ]
gap> g:= Action( g, orbs[2], OnLines );;
]]></Example>

<P/>

First we show that for <M>s</M> of order <M>9</M>, <M>&prop;(S,s) = 2/5</M> holds.
For that, we have to consider only <M>&prop;(g,s)</M>,
with <M>g</M> in one of the classes <C>2A</C> (of length <M>45</M>)
and <C>3A</C> (of length <M>40</M>);
since the class <C>3B</C> contains the inverses of the elements in
the class <C>3A</C>, we need not test it.

<P/>

<Example><![CDATA[
gap> spos:= Position( OrdersClassRepresentatives( t ), 9 );
17
gap> approx:= ApproxP( prim, spos );
[ 0, 3/5, 1/10, 17/40, 17/40, 1/8, 11/40, 1/10, 1/20, 0, 9/40, 9/40, 
  3/40, 3/40, 3/40, 1/40, 1/20, 1/20, 1/40, 1/40 ]
gap> badpos:= PositionsProperty( approx, x -> x >= 2/5 );
[ 2, 4, 5 ]
gap> PowerMap( t, 2 )[4];
5
gap> OrdersClassRepresentatives( t );
[ 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, 6, 6, 6, 6, 6, 9, 9, 12, 12 ]
gap> SizesConjugacyClasses( t );
[ 1, 45, 270, 40, 40, 240, 480, 540, 3240, 5184, 360, 360, 720, 720, 
  1440, 2160, 2880, 2880, 2160, 2160 ]
]]></Example>

<P/>

A representative <M>g</M> of a class of length <M>40</M> can be found as the third
power of any order <M>9</M> element.

<P/>

<Example><![CDATA[
gap> PowerMap( t, 3 )[ spos ];
4
gap> ResetGlobalRandomNumberGenerators();
gap> repeat s:= Random( g );
>    until Order( s ) = 9;
gap> Size( ConjugacyClass( g, s^3 ) );
40
gap> prop:= RatioOfNongenerationTransPermGroup( g, s^3, s );
13/40
]]></Example>

<P/>

Next we examine <M>g</M> in the class <C>2A</C>.

<P/>

<Example><![CDATA[
gap> repeat x:= Random( g ); until Order( x ) = 12;
gap> Size( ConjugacyClass( g, x^6 ) );
45
gap> prop:= RatioOfNongenerationTransPermGroup( g, x^6, s );
2/5
]]></Example>

<P/>

Finally, we compute that for <M>s</M> of order different from <M>9</M>
and <M>g</M> in the class <C>2A</C>,
<M>&prop;(g,s)</M> is larger than <M>2/5</M>.

<P/>

<Example><![CDATA[
gap> ccl:= List( ConjugacyClasses( g ), Representative );;
gap> SortParallel( List( ccl, Order ), ccl );
gap> List( ccl, Order );
[ 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, 6, 6, 6, 6, 6, 9, 9, 12, 12 ]
gap> prop:= List( ccl, r -> RatioOfNongenerationTransPermGroup( g, x^6, r ) );
[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 5/9, 1, 1, 1, 1, 1, 1, 2/5, 2/5, 7/15, 
  7/15 ]
gap> Minimum( prop );
2/5
]]></Example>

<P/>

In order to show statement&nbsp;(d),
we have to consider triples <M>(x_1, x_2, x_3)</M>
with <M>x_i</M> of prime order and <M>\sum_{i=1}^3 &prop;(x_i,s) \geq 1</M>.
This means that it suffices to check <M>x</M> in the class <C>2A</C>,
<M>y</M> in <C>2A</C><M> \cup </M><C>3A</C>,
and <M>z</M> in <C>2A</C><M> \cup </M><C>3A</C><M> \cup </M><C>3D</C>.

<P/>

<Example><![CDATA[
gap> approx[2]:= 2/5;;
gap> approx[4]:= 13/40;;
gap> primeord:= PositionsProperty( OrdersClassRepresentatives( t ),
>                                  IsPrimeInt );
[ 2, 3, 4, 5, 6, 7, 10 ]
gap> RemoveSet( primeord, 5 );
gap> primeord;
[ 2, 3, 4, 6, 7, 10 ]
gap> approx{ primeord };
[ 2/5, 1/10, 13/40, 1/8, 11/40, 0 ]
gap> AtlasClassNames( t ){ primeord };
[ "2A", "2B", "3A", "3C", "3D", "5A" ]
gap> triples:= Filtered( UnorderedTuples( primeord, 3 ),
>                  t -> Sum( approx{ t } ) >= 1 );
[ [ 2, 2, 2 ], [ 2, 2, 4 ], [ 2, 2, 7 ], [ 2, 4, 4 ], [ 2, 4, 7 ] ]
]]></Example>

<P/>

We use the random approach described in
Section&nbsp;<Ref Subsect="subsect:groups"/>.

<P/>

<Example><![CDATA[
gap> repeat 6E:= Random( g );
>    until Order( 6E ) = 6 and Size( Centralizer( g, 6E ) ) = 18;
gap> 2A:= 6E^3;;
gap> 3A:= s^3;;
gap> 3D:= 6E^2;;
gap> RandomCheckUniformSpread( g, [ 2A, 2A, 2A ], s, 50 );
true
gap> RandomCheckUniformSpread( g, [ 2A, 2A, 3A ], s, 50 );
true
gap> RandomCheckUniformSpread( g, [ 3D, 2A, 2A ], s, 50 );
true
gap> RandomCheckUniformSpread( g, [ 2A, 3A, 3A ], s, 50 );
true
gap> RandomCheckUniformSpread( g, [ 3D, 3A, 2A ], s, 50 );
true
]]></Example>

<P/>

Statement&nbsp;(e) can be proved using <C>ProbGenInfoAlmostSimple</C>,
cf. Section&nbsp;<Ref Subsect="easyloopaut"/>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "U4(2)" );;
gap> t2:= CharacterTable( "U4(2).2" );;
gap> spos:= PositionsProperty( OrdersClassRepresentatives( t ), x -> x = 9 );;
gap> ProbGenInfoAlmostSimple( t, t2, spos );
[ "U4(2).2", 7/20, [ "9AB" ], [ 2 ] ]
]]></Example>

<P/>

<!-- % spread at least four? -->
<!-- % upper bound five for the spread: -->
<!-- %  -->
<!-- % gap> Sum( prim{[3,5]} ); -->
<!-- % Character( CharacterTable( <Ref ???="U4(2)"/> ), [ 85, 29, 9, 13, 13, 7, 10, 1, 3, 0, 5,  -->
<!-- %   5, 5, 5, 2, 3, 1, 1, 1, 1 ] ) -->
<!-- % gap> g:= UnderlyingGroup( tom );; -->
<!-- % gap> g:= DiagonalProductOfPermGroups( List( mx, m -> -->
<!-- % >            Action( g, RightTransversal( g, m ), OnRight ) ) );; -->
<!-- % gap> NrMovedPoints( g ); -->
<!-- % 85 -->
<!-- % gap> mp:= MovedPoints( g );; -->
<!-- % gap> repeat 6E:= Random( g ); -->
<!-- % >    until Order( 6E ) = 6 and Size( Centralizer( g, 6E ) ) = 18; -->
<!-- % gap> 2A:= 6E^3;; -->
<!-- % gap> NrMovedPoints( 2A ); -->
<!-- % 56 -->
<!-- % gap> orb2A:= Orbit( g, Difference( mp, MovedPoints( 2A ) ), OnSets );; -->
<!-- % gap> repeat union:= Union(List([1..5], x -> Random(orb2A ) ) ); until Number( union ) = 85; -->
<!-- %  -->
<!-- %not needed, -->
<!-- %also not successful for bounding the spread from above: -->
<!-- % -->
<!-- %.... -->
<!-- % -->
<!-- %We work with the imprimitive permutation representation that is the -->
<!-- %direct sum of the two nonequivalent transitive representations of -->
<!-- %degree <M>40</M>. -->
<!-- %Each element <M>s</M> of order <M>9</M> fixes two of the <M>80</M> points, -->
<!-- %and an element <M>s</M> generates <M>S</M> together with <M>s</M> if and only if -->
<!-- %<M>x</M> moves the two fixed points of <M>s</M>. -->
<!--
gap> tom:= TableOfMarks( t );
TableOfMarks( "U4(2)" )
gap> maxes:= MaximalSubgroupsTom( tom );
[ [ 115, 114, 113, 112, 111 ], [ 27, 36, 40, 40, 45 ] ]
gap> mx:= List( maxes[1]{ [ 3, 4 ] },
>               i -> RepresentativeTom( tom, i ) );;
gap> g:= UnderlyingGroup( tom );;
gap> g:= DiagonalProductOfPermGroups( List( mx, m ->
>            Action( g, RightTransversal( g, m ), OnRight ) ) );;
gap> NrMovedPoints( g );
80
gap> repeat s:= Random( g ); until Order( s ) = 9;
gap> NrMovedPoints( s );
78
gap> mp:= MovedPoints( g );;
gap> fixs:= Difference( mp, MovedPoints( s ) );
[ 20, 77 ]
gap> orbs:= Orbit( g, fixs, OnSets );;
gap> Length( orbs );
160
-->
<!-- %We need elements in the classes {\tt 2A}, {\tt 3A}, and {\tt 3D}. -->
<!--
gap> 3A:= s^3;;
gap> repeat 6E:= Random( g );
>    until Order( 6E ) = 6 and Size( Centralizer( g, 6E ) ) = 18;
gap> 2A:= 6E^3;;
gap> 3D:= 6E^2;;
gap> orb2A:= Orbit( g, Difference( mp, MovedPoints( 2A ) ), OnSets );;
gap> orb3A:= Orbit( g, Difference( mp, MovedPoints( 3A ) ), OnSets );;
gap> orb3D:= Orbit( g, Difference( mp, MovedPoints( 3D ) ), OnSets );;
-->
<!-- %Now we perform the tests. -->
<!--
gap> prop:= function( triple )
>     local union;
>     union:= Union( triple );
>     return ForAll( orbs, p -> not IsEmpty( Intersection( p, union ) ) );
> end;
function( triple ) ... end
gap> TripleWithProperty( [ orb2A{ [ 1 ] }, orb2A, orb2A ], prop );
fail
gap> TripleWithProperty( [ orb2A{ [ 1 ] }, orb2A, orb3A ], prop );
fail
gap> TripleWithProperty( [ orb2A{ [ 1 ] }, orb2A, orb3D ], prop );
fail
gap> TripleWithProperty( [ orb2A{ [ 1 ] }, orb3A, orb3A ], prop );
fail
gap> TripleWithProperty( [ orb2A{ [ 1 ] }, orb3A, orb3D ], prop );
fail
-->
<!-- %Better take the longest class first. -->
<!-- %Better replace this by a ForAll statement. -->
<!-- % -->
<!-- %  alternatively: spread at least three with s of order 12 -->
<!-- %  (easier construction of the representation!) -->
<!-- % -->
<!-- %so the triples that must be checked are -->
<!-- %<M>(2A \cup 3A, 2A \cup 3A, \ast)</M>, -->
<!-- %where <M>\ast</M> stands for the elements of order 2 or three -->
<!-- %(prime order elements, note that order 5 cannot occur) -->
<!-- % -->
<!-- %thus first check <M>(2A, 2A \cup 3A, \ast)</M> -->
<!-- %and then <M>(3A, 2A \cup 3A, \ast)</M> -->
<!-- % -->
<!-- %(up to conjugacy, so first element one fixed in 2A or 3A!) -->
<!-- % -->
<!-- %We use the imprimitive permutation representation on 40+45 points -->
<!-- %in which <M>s</M> fixes two points. -->
<!-- %In this representation, the element <M>g \in S</M> generates -->
<!-- %<M>S</M> together with <M>s</M> if no point is fixed by both <M>g</M> and <M>s</M>. -->
<!--
gap> g:= SU(4,2);
SU(4,2)
gap> g:= Action( g, NormedRowVectors( GF(4)^4 ), OnLines );
<permutation group with 2 generators>
gap> repeat s:= Random( g ); until Order( s ) = 12;
gap> NrMovedPoints( s );
83
gap> fix12:= Difference( [1..85], MovedPoints( s ) );
[ 22, 50 ]
gap> 2a:= s^6;;
gap> NrMovedPoints( 2a );
64
gap> 3a:= s^4;;
gap> NrMovedPoints( 3a );
63
gap> repeat 2b:= Random( g ); until Order( 2b ) = 2
>     and Size( Centralizer( g, 2b ) ) = 96;
gap> repeat 3c:= Random( g ); until Order( 3c ) = 3
>     and Size( Centralizer( g, 3c ) ) = 108;
gap> repeat 3d:= Random( g ); until Order( 3c ) = 3
>     and Size( Centralizer( g, 3d ) ) = 54;
gap> orb12:= Orbit( g, fix12, OnSets );;
gap> Length( orb12 );
360
gap> orb2a:= Orbit( g, Difference( [ 1 .. 85 ], MovedPoints( 2a ) ), OnSets );;
gap> orb2b:= Orbit( g, Difference( [ 1 .. 85 ], MovedPoints( 2b ) ), OnSets );;
gap> orb3a:= Orbit( g, Difference( [ 1 .. 85 ], MovedPoints( 3a ) ), OnSets );;
gap> orb3c:= Orbit( g, Difference( [ 1 .. 85 ], MovedPoints( 3c ) ), OnSets );;
gap> orb3d:= Orbit( g, Difference( [ 1 .. 85 ], MovedPoints( 3d ) ), OnSets );;
gap> orb2aor3a:= Union( orb2a, orb3a );;
gap> orball:= Union( orb2a, orb2b, orb3a, orb3c, orb3d );;
gap> for l1 in orb2aor3a do
>      for l2 in orball do
>        fixed:= Union( orb2a[1], l1, l2 );
>        if ForAll( orb12, f -> not IsEmpty( Intersection( fixed, f ) ) )
>          then
>          Error( "!" );
>        fi;
>      od;
>    od;
gap> for l1 in orb2aor3a do
>      for l2 in orball do
>        fixed:= Union( orb3a[1], l1, l2 );
>        if ForAll( orb12, f -> not IsEmpty( Intersection( fixed, f ) ) )
>          then
>          Error( "!" );
>        fi;
>      od;
>    od;
-->
<!-- %no output, so uniform spread at least three! -->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="U43">
<Heading><M>U_4(3)</M></Heading>

We show that <M>S = U_4(3) = &PSU;(4,3)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    <M>&total;(S) = 53/153</M>,
    and this value is attained exactly for <M>&total;(S,s)</M>
    with <M>s</M> of order <M>7</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    For <M>s \in S</M> of order <M>7</M>,
    <M>&M;(S,s)</M> consists of two nonconjugate groups of the type
    <M>L_3(4)</M>,
    one group of the type <M>U_3(3)</M>, and four pairwise nonconjugate
    groups of the type <M>A_7</M>.
</Item>
<Mark>(c)</Mark>
<Item>
    <M>&prop;(S) = 43/135</M>,
    and this value is attained exactly for <M>&prop;(S,s)</M>
    with <M>s</M> of order <M>7</M>.
</Item>
<Mark>(d)</Mark>
<Item>
    The uniform spread of <M>S</M> is at least three,
    with <M>s</M> of order <M>7</M>.
</Item>
<Mark>(e)</Mark>
<Item>
    The preimage of <M>s</M> in the matrix group <M>&SU;(4,3) \cong 4.U_4(3)</M>
    has order <M>28</M>,
    the preimages of the groups in <M>&M;(S,s)</M> have the structures
    <M>4_2.L_3(4)</M>, <M>4 \times U_3(3) \cong &GU;(3,3)</M>, and <M>4.A_7</M>
    (the latter being a central product of a cyclic group of order four
    and <M>2.A_7</M>).
</Item>
<Mark>(f)</Mark>
<Item>
    <M>&prop;^{\prime}(S.2_1,s) = 13/27</M>,
    <M>&total;^{\prime}(S.2_2) = 1/3</M>,
    and <M>&total;^{\prime}(S.2_3) = 31/162</M>,
    with <M>s</M> of order <M>7</M> in each case.
</Item>
</List>

<P/>

Statement&nbsp;(a) follows from inspection of the primitive permutation
characters, cf.&nbsp;Section&nbsp;<Ref Subsect="easyloop"/>.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "U4(3)" );;
gap> ProbGenInfoSimple( t );
[ "U4(3)", 53/135, 2, [ "7A" ], [ 7 ] ]
]]></Example>

<P/>

Statement&nbsp;(b) can be read off from the permutation characters,
and the fact that the only classes of maximal subgroups that contain
elements of order <M>7</M> consist of groups of the structures
as claimed,
see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;52"/>.

<P/>

<Example><![CDATA[
gap> prim:= PrimitivePermutationCharacters( t );;
gap> spos:= Position( OrdersClassRepresentatives( t ), 7 );
13
gap> List( Filtered( prim, x -> x[ spos ] <> 0 ), l -> l{ [ 1, spos ] } );
[ [ 162, 1 ], [ 162, 1 ], [ 540, 1 ], [ 1296, 1 ], [ 1296, 1 ], 
  [ 1296, 1 ], [ 1296, 1 ] ]
]]></Example>

<P/>

In order to show statement&nbsp;(c) (which then implies statement&nbsp;(d)),
we use a permutation representation on <M>112</M> points.
It corresponds to an orbit of one-dimensional subspaces in the
natural module of <M>\Omega^-(6,3) \cong S</M>.

<P/>

<Example><![CDATA[
gap> matgrp:= DerivedSubgroup( SO( -1, 6, 3 ) );;
gap> orbs:= OrbitsDomain( matgrp, NormedRowVectors( GF(3)^6 ), OnLines );;
gap> List( orbs, Length );
[ 126, 126, 112 ]
gap> G:= Action( matgrp, orbs[3], OnLines );;
]]></Example>

<P/>

It is sufficient to compute <M>&prop;(g,s)</M>, for involutions <M>g \in S</M>.

<P/>

<Example><![CDATA[
gap> approx:= ApproxP( prim, spos );
[ 0, 53/135, 1/10, 1/24, 1/24, 7/45, 4/45, 1/27, 1/36, 1/90, 1/216, 
  1/216, 7/405, 7/405, 1/270, 0, 0, 0, 0, 1/270 ]
gap> Filtered( approx, x -> x >= 43/135 );
[ 53/135 ]
gap> OrdersClassRepresentatives( t );
[ 1, 2, 3, 3, 3, 3, 4, 4, 5, 6, 6, 6, 7, 7, 8, 9, 9, 9, 9, 12 ]
gap> ResetGlobalRandomNumberGenerators();
gap> repeat g:= Random( G ); until Order(g) = 2;
gap> repeat s:= Random( G );
>    until Order(s) = 7;
gap> bad:= RatioOfNongenerationTransPermGroup( G, g, s );
43/135
gap> bad < 1/3;
true
]]></Example>

<P/>

Statement&nbsp;(e) can be shown easily with character-theoretic methods,
as follows.
Since <M>&SU;(4,3)</M> is a Schur cover of <M>S</M> and the groups in <M>&M;(S,s)</M>
are simple, only very few possibilities have to be checked.
The Schur multiplier of <M>U_3(3)</M> is trivial
(see, e.&nbsp;g., <Cite Key="CCN85" Where="p.&nbsp;14"/>),
so the preimage in <M>&SU;(4,3)</M> is a direct product of <M>U_3(3)</M> and the
centre of <M>&SU;(4,3)</M>.
Neither <M>L_3(4)</M> nor its double cover <M>2.L_3(4)</M> can be a subgroup of
<M>&SU;(4,3)</M>, so the preimage of <M>L_3(4)</M> must be a Schur cover of <M>L_3(4)</M>,
i.&nbsp;e., it must have either the type <M>4_1.L_3(4)</M> or <M>4_2.L_3(4)</M>
(see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;23"/>);
only the type <M>4_2.L_3(4)</M> turns out to be possible.

<P/>

<Example><![CDATA[
gap> 4t:= CharacterTable( "4.U4(3)" );;
gap> Length( PossibleClassFusions( CharacterTable( "L3(4)" ), 4t ) );
0
gap> Length( PossibleClassFusions( CharacterTable( "2.L3(4)" ), 4t ) );
0
gap> Length( PossibleClassFusions( CharacterTable( "4_1.L3(4)" ), 4t ) );
0
gap> Length( PossibleClassFusions( CharacterTable( "4_2.L3(4)" ), 4t ) );
4
]]></Example>

<P/>

As for the preimage of the <M>A_7</M> type subgroups,
we first observe that the double cover of <M>A_7</M> cannot be a subgroup of the
double cover of <M>S</M>,
so the preimage of <M>A_7</M> in the double cover of <M>U_4(3)</M> is a direct product
<M>2 \times A_7</M>.
The group <M>&SU;(4,3)</M> does not contain <M>A_7</M> type subgroups,
thus the <M>A_7</M> type subgroups in <M>2.U_4(3)</M> lift to double covers of <M>A_7</M>
in <M>&SU;(4,3)</M>.
This proves the claimed structure.

<P/>

<Example><![CDATA[
gap> 2t:= CharacterTable( "2.U4(3)" );;
gap> Length( PossibleClassFusions( CharacterTable( "2.A7" ), 2t ) );
0
gap> Length( PossibleClassFusions( CharacterTable( "A7" ), 4t ) );
0
]]></Example>

<P/>

For statement&nbsp;(f), we consider automorphic extensions of <M>S</M>.
The bound for <M>S.2_3</M> has been computed in Section&nbsp;<Ref Subsect="easyloopaut"/>.
That for <M>S.2_2</M> can be computed form the fact that the classes of
maximal subgroups of <M>S.2_2</M> containing <M>s</M> of order <M>7</M> are
<M>S</M>, one class of <M>U_3(3).2</M> type subgroups, and two classes of <M>S_7</M> type
subgroups which induce the same permutation character
(see&nbsp;<Cite Key="CCN85" Where="p.&nbsp;52"/>).

<P/>

<Example><![CDATA[
gap> t2:= CharacterTable( "U4(3).2_2" );;
gap> pi1:= PossiblePermutationCharacters( CharacterTable( "U3(3).2" ), t2 );
[ Character( CharacterTable( "U4(3).2_2" ),
  [ 540, 12, 54, 0, 0, 9, 8, 0, 0, 6, 0, 0, 1, 2, 0, 0, 0, 2, 0, 24, 
      4, 0, 0, 0, 0, 0, 0, 3, 2, 0, 4, 0, 0, 0 ] ) ]
gap> pi2:= PossiblePermutationCharacters( CharacterTable( "A7.2" ), t2 );
[ Character( CharacterTable( "U4(3).2_2" ),
  [ 1296, 48, 0, 27, 0, 9, 0, 4, 1, 0, 3, 0, 1, 0, 0, 0, 0, 0, 216, 
      24, 0, 4, 0, 0, 0, 9, 0, 3, 0, 1, 0, 1, 0, 0 ] ) ]
gap> prim:= Concatenation( pi1, pi2, pi2 );;
gap> outer:= Difference(
>      PositionsProperty( OrdersClassRepresentatives( t2 ), IsPrimeInt ),
>      ClassPositionsOfDerivedSubgroup( t2 ) );;
gap> spos:= Position( OrdersClassRepresentatives( t2 ), 7 );;
gap> Maximum( ApproxP( prim, spos ){ outer } );
1/3
]]></Example>

<P/>

Finally, Section&nbsp;<Ref Subsect="easyloopaut"/> shows that the character tables are
not sufficient for what we need, so we compute the exact proportion of
nongeneration for <M>U_4(3).2_1 \cong &SO;^-(6,3)</M>.

<P/>

<Example><![CDATA[
gap> matgrp:= SO( -1, 6, 3 );
SO(-1,6,3)
gap> orbs:= OrbitsDomain( matgrp, NormedRowVectors( GF(3)^6 ), OnLines );;
gap> List( orbs, Length );
[ 126, 126, 112 ]
gap> G:= Action( matgrp, orbs[3], OnLines );;
gap> repeat s:= Random( G );
>    until Order( s ) = 7;
gap> repeat
>      repeat 2B:= Random( G ); until Order( 2B ) mod 2 = 0;
>      2B:= 2B^( Order( 2B ) / 2 );
>      c:= Centralizer( G, 2B );
>    until Size( c ) = 12096;
gap> RatioOfNongenerationTransPermGroup( G, 2B, s );
13/27
gap> repeat
>      repeat 2C:= Random( G ); until Order( 2C ) mod 2 = 0;
>      2C:= 2C^( Order( 2C ) / 2 );
>      c:= Centralizer( G, 2C );
>    until Size( c ) = 1440;
gap> RatioOfNongenerationTransPermGroup( G, 2C, s );
0
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="U63">
<Heading><M>U_6(3)</M></Heading>

We show that <M>S = U_6(3) = &PSU;(6,3)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> of the type <M>1 \perp 5</M>
    (i.&nbsp;e., the preimage of <M>s</M> in <M>2.S = &SU;(6,3)</M> decomposes
    the natural
    <M>6</M>-dimensional module for <M>2.S</M> into an orthogonal sum of two
    irreducible modules of the dimensions <M>1</M> and <M>5</M>, respectively)
    and of order <M>(3^5 + 1)/2 = 122</M>,
    <M>&M;(S,s)</M> consists of one group of the type <M>2 \times U_5(3)</M>,
    which lifts to a subgroup of the type <M>4 \times U_5(3) = &GU;(5,3)</M>
    in <M>2.S</M>.
    (The preimage of <M>s</M> in <M>2.S</M> has order <M>3^5 + 1 = 244</M>.)
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 353/3\,159</M>.
</Item>
</List>

<P/>

By&nbsp;<Cite Key="MSW94"/>, the only maximal subgroup of <M>S</M> that contains <M>s</M>
is the stabilizer <M>H \cong 2 \times U_5(3)</M> of the orthogonal decomposition.
This proves statement&nbsp;(a).

<P/>

The character table of <M>S</M> is currently not available in the &GAP;
Character Table Library.
We consider the permutation action of <M>S</M> on the orbit of the stabilized
<M>1</M>-space.
So <M>M</M> can be taken as a point stabilizer in this action.

<P/>

<Example><![CDATA[
gap> CharacterTable( "U6(3)" );
fail
gap> g:= SU(6,3);;
gap> orbs:= OrbitsDomain( g, NormedRowVectors( GF(9)^6 ), OnLines );;
gap> List( orbs, Length );
[ 22204, 44226 ]
gap> repeat x:= PseudoRandom( g ); until Order( x ) = 244;
gap> List( orbs, o -> Number( o, v -> OnLines( v, x ) = v ) );
[ 0, 1 ]
gap> g:= Action( g, orbs[2], OnLines );;
gap> M:= Stabilizer( g, 1 );;
]]></Example>

<P/>

Then we compute a list of elements in <M>M</M> that covers the conjugacy classes
of prime element order, from which the numbers of fixed points
and thus <M>\max\{ &fpr;( S/M, g ); g \in M^{\times} \} = &total;( S, s )</M>
can be derived.
This way we avoid completely to check the <M>S</M>-conjugacy
of elements (class representatives of Sylow subgroups in <M>M</M>).

<P/>

<Example><![CDATA[
gap> elms:= [];;
gap> for p in PrimeDivisors( Size( M ) ) do
>      syl:= SylowSubgroup( M, p );
>      Append( elms, Filtered( PcConjugacyClassReps( syl ),
>                              r -> Order( r ) = p ) );
>    od;
gap> 1 - Minimum( List( elms, NrMovedPoints ) ) / Length( orbs[2] );
353/3159
]]></Example>

<!-- Alternatively, we can also compute the conjugacy classes of SU(6,3);
     after 22151560 msec, one gets 264 classes (with quite a large workspace)

     Note that <M>S</M> contains only one class of cyclic subgroups of order
     <M>122</M>,
     for example because the elements of order <M>61</M> in
     <M>U_5(3) = &SU;(5,3)</M> are self-centralizing.

<Example><![CDATA[
gap> u:= SU(5,3);;
gap> orbs:= OrbitsDomain( u, NormedRowVectors( GF(9)^5 ), OnLines );;
gap> u:= Action( u, orbs[1], OnLines );;
gap> repeat x:= Random( u );
> until Order( x ) mod 61 = 0;
gap> Order( x );
61
gap> Size( Centralizer( u, x ) );
61
]]></Example>
-->

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="U82">
<Heading><M>U_8(2)</M></Heading>

We show that <M>S = U_8(2) = &SU;(8,2)</M> satisfies the following.

<P/>

<List>
<Mark>(a)</Mark>
<Item>
    For <M>s \in S</M> of the type <M>1 \perp 7</M>
    (i.&nbsp;e., <M>s</M> decomposes the natural <M>8</M>-dimensional module
    for <M>S</M> into an orthogonal sum of two irreducible modules
    of the dimensions <M>1</M> and <M>7</M>, respectively) and of order
    <M>2^7 + 1 = 129</M>,
    <M>&M;(S,s)</M> consists of one group of the type
    <M>3 \times U_7(2) = &GU;(7,2)</M>.
</Item>
<Mark>(b)</Mark>
<Item>
    <M>&total;(S,s) = 2\,753/10\,880</M>.
</Item>
</List>

<P/>

By&nbsp;<Cite Key="MSW94"/>, the only maximal subgroup of <M>S</M> that contains <M>s</M>
is the stabilizer <M>M \cong &GU;(7,2)</M> of the orthogonal decomposition.
This proves statement&nbsp;(a).

<P/>

The character table of <M>S</M> is currently not available in the &GAP;
Character Table Library.
We proceed exactly as in Section&nbsp;<Ref Subsect="U63"/> in order to prove statement&nbsp;(b).

<P/>

<Example><![CDATA[
gap> CharacterTable( "U8(2)" );
fail
gap> g:= SU(8,2);;
gap> orbs:= OrbitsDomain( g, NormedRowVectors( GF(4)^8 ), OnLines );;
gap> List( orbs, Length );
[ 10965, 10880 ]
gap> repeat x:= PseudoRandom( g ); until Order( x ) = 129;
gap> List( orbs, o -> Number( o, v -> OnLines( v, x ) = v ) );
[ 0, 1 ]
gap> g:= Action( g, orbs[2], OnLines );;
gap> M:= Stabilizer( g, 1 );;
gap> elms:= [];;
gap> for p in PrimeDivisors( Size( M ) ) do
>      syl:= SylowSubgroup( M, p );
>      Append( elms, Filtered( PcConjugacyClassReps( syl ),
>                              r -> Order( r ) = p ) );
>    od;
gap> Length( elms );
611
gap> 1 - Minimum( List( elms, NrMovedPoints ) ) / Length( orbs[2] );
2753/10880
]]></Example>

<!-- Alternatively, we can also compute the conjugacy classes of SU(8,2);
     after 16376160 msec, one gets 520 classes (with quite a large workspace)

     Note that <M>S</M> contains only one class of cyclic subgroups of order
     <M>129</M>,
     for example because the elements of order <M>43</M> in
     <M>U_7(2) = &SU;(7,2)</M> are self-centralizing.

<Example><![CDATA[
gap> u:= SU(7,2);;
gap> orbs:= OrbitsDomain( u, NormedRowVectors( GF(4)^7 ), OnLines );;
gap> u:= Action( u, orbs[1], OnLines );;
gap> repeat x:= Random( u );  until Order( x ) mod 43 = 0;
gap> Order( x );
43
gap> Size( Centralizer( u, x ) );
43
]]></Example>
-->

</Subsection>
</Section>
</Chapter>

<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->

