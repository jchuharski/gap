<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.59">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 

             <title>Constructing the ordinary character tables of some Atlas groups using character theoretic methods</title>
<h1 align="center">Constructing the ordinary character tables of some Atlas groups using character theoretic methods</h1>
  <body bgcolor="FFFFFF"> 

<div class="p"><!----></div>

<h3 align="center"> T<font size="-2">HOMAS</font> B<font size="-2">REUER</font> <br />
<i>Lehrstuhl D f&#252;r Mathematik</i> <br />
<i>RWTH, 52056 Aachen, Germany</i> </h3>

<div class="p"><!----></div>

<h3 align="center">May 8th, 2016 </h3>

<div class="p"><!----></div>


<div class="p"><!----></div>
We compute the character tables of the following groups
with character theoretic methods,
using known information about the conjugacy classes
and about the character tables of some subgroups and factor groups:
Th, J<sub>4</sub>, 2.<sup>2</sup>E<sub>6</sub>(2), 2.<sup>2</sup>E<sub>6</sub>(2).2, and 2.B.

<div class="p"><!----></div>



<div class="p"><!----></div>

<h1>Contents </h1><a href="#tth_sEc1"
>1&nbsp; Overview</a><br /><a href="#tth_sEc2"
>2&nbsp; The character table of Th (December 30th, 2015)</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.1"
>2.1&nbsp; The conjugacy classes of Th</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.2"
>2.2&nbsp; The subgroup 2<sup>5</sup>.L<sub>5</sub>(2)</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.3"
>2.3&nbsp; The power maps of Th</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4"
>2.4&nbsp; The irreducible characters of Th</a><br /><a href="#tth_sEc3"
>3&nbsp; The character table of J<sub>4</sub> (January 1st, 2016)</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1"
>3.1&nbsp; The conjugacy classes of J<sub>4</sub></a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2"
>3.2&nbsp; The subgroup 2<sup>11</sup>:M<sub>24</sub></a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3"
>3.3&nbsp; The power maps of J<sub>4</sub></a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4"
>3.4&nbsp; The irreducible characters of J<sub>4</sub></a><br /><a href="#tth_sEc4"
>4&nbsp; The character table of 2.<sup>2</sup>E<sub>6</sub>(2) (February 29th, 2016)</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1"
>4.1&nbsp; Assumptions</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2"
>4.2&nbsp; Outer automorphisms of G</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3"
>4.3&nbsp; Tools for determining the conjugacy classes of 2.G</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.1"
>4.3.1&nbsp; Elementary criteria</a><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3.2"
>4.3.2&nbsp; Norms of induced characters</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4"
>4.4&nbsp; Subgroups of the type F<sub>4</sub>(2) in G</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5"
>4.5&nbsp; Element orders in 2.G</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6"
>4.6&nbsp; The class fusion from &#960;<sup>&#8722;1</sup>( M<sub>3</sub> )</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.7"
>4.7&nbsp; Subgroups of the type Fi<sub>22</sub> in G</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.8"
>4.8&nbsp; The class fusion from &#960;<sup>&#8722;1</sup>( M<sub>7</sub> )</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.9"
>4.9&nbsp; The class fusion from &#960;<sup>&#8722;1</sup>( M<sub>8</sub> )</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.10"
>4.10&nbsp; The class fusion from &#960;<sup>&#8722;1</sup>( M<sub>9</sub> )</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.11"
>4.11&nbsp; The class fusion from &#960;<sup>&#8722;1</sup>( M<sub>4</sub> )</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.12"
>4.12&nbsp; The class fusion from &#960;<sup>&#8722;1</sup>( M<sub>5</sub> )</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.13"
>4.13&nbsp; Subgroups of the type 3 &times;U<sub>6</sub>(2) in G</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.14"
>4.14&nbsp; Subgroups of the type O<sup>&#8722;</sup><sub>10</sub>(2) in G</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.15"
>4.15&nbsp; What do we know up to now about the table of 2.G?</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.16"
>4.16&nbsp; Additional characters of 2.G</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.17"
>4.17&nbsp; The faithful irreducible characters of 2.G</a><br /><a href="#tth_sEc5"
>5&nbsp; The character table of 2.<sup>2</sup>E<sub>6</sub>(2).2 (March 28th, 2016)</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1"
>5.1&nbsp; Class numbers of 2.G.2</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2"
>5.2&nbsp; Subgroups of the type 2 &times;F<sub>4</sub>(2) &times;2 in 2.G.2</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3"
>5.3&nbsp; Subgroups of the type 3 &times;2.U<sub>6</sub>(2).2 in 2.G.2</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.4"
>5.4&nbsp; Norms of induced characters - a refinement</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.5"
>5.5&nbsp; Element orders in 2.G.2</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.6"
>5.6&nbsp; The class fusion from 2 &times;F<sub>4</sub>(2) &times;2</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.7"
>5.7&nbsp; The class fusion from 3 &times;2.U<sub>6</sub>(2).2</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.8"
>5.8&nbsp; Approximations for some power maps of 2.G.2</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.9"
>5.9&nbsp; The faithful irreducible characters of 2.G.2</a><br /><a href="#tth_sEc6"
>6&nbsp; The character table of 2.B (May 8th, 2016)</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1"
>6.1&nbsp; Assumptions</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2"
>6.2&nbsp; Subgroups of the type 2<sup>2</sup>.<sup>2</sup>E<sub>6</sub>(2).2 in 2.B</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.3"
>6.3&nbsp; Element orders in 2.B</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.4"
>6.4&nbsp; The class fusion from 2<sup>2</sup>.<sup>2</sup>E<sub>6</sub>(2).2</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.5"
>6.5&nbsp; Subgroups of the type 2 &times;Th in 2.B</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.6"
>6.6&nbsp; Additional characters of 2.B</a><br />&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.7"
>6.7&nbsp; The irreducible characters of 2.B</a><br />

<div class="p"><!----></div>

<div class="p"><!----></div>

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Overview</h2>

<div class="p"><!----></div>
The character tables of
Th, J<sub>4</sub>, 2.<sup>2</sup>E<sub>6</sub>(2), 2.<sup>2</sup>E<sub>6</sub>(2).2, and 2.B
are shown in the  A<font size="-2">TLAS</font> of Finite Groups&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>], and these  A<font size="-2">TLAS</font>
tables are contained in the character table library&nbsp;[<a href="#CTblLib" name="CITECTblLib">Bre21</a>]
of the computer algebra system <font face="helvetica">GAP</font>&nbsp;[<a href="#GAP483" name="CITEGAP483">GAP16</a>].
Except for the case of Th (see&nbsp;[<a href="#BMO17" name="CITEBMO17">BMO17</a>]),
I am not aware of published proofs of the correctness
of these character tables.

<div class="p"><!----></div>
In the following sections,
we show how one can compute the tables in question with <font face="helvetica">GAP</font>,
using character theoretic methods.
We will assume the character tables of certain proper subgroups
and factor groups;
except in the case of 2.B, these tables have been verified either
by direct computations with the group in question
or by character theoretic methods.
I am not aware of such a verification for the character table of B,
thus the construction of the character table of 2.B in
Section&nbsp;<a href="#section2B">6</a> relies on the correctness of the  A<font size="-2">TLAS</font> table
of B.

<div class="p"><!----></div>
The main tools for the computation of the irreducible characters
will be LLL reduction (see&nbsp;[<a href="#LLL82" name="CITELLL82">LLJL82</a>])
and the enumeration of orthogonal embeddings (see&nbsp;[<a href="#Ple90" name="CITEPle90">Ple95</a>]).
Several <font face="helvetica">GAP</font> library functions from the Chapter
"Maps Concerning Character Tables" of the <font face="helvetica">GAP</font> Reference Manual
will be used without comments.
We will use the <font face="helvetica">GAP</font> Character Table Library,
thus we have to load this <font face="helvetica">GAP</font> package.

<div class="p"><!----></div>

<pre>
    gap&#62; LoadPackage( "ctbllib", false );
    true

</pre>

<div class="p"><!----></div>

 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;The character table of Th (December 30th, 2015)</h2>

<div class="p"><!----></div>
The character table of the sporadic simple Thompson group Th
has been published in&nbsp;[<a href="#Smi76c" name="CITESmi76c">Smi76</a>,pp.&nbsp;162-163] without proof.
This table (with some rows and columns permuted) is shown in the
 A<font size="-2">TLAS</font> of Finite Groups (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;176]),
and this  A<font size="-2">TLAS</font> table is contained in the character table library
&nbsp;[<a href="#CTblLib" name="CITECTblLib">Bre21</a>]
of the computer algebra system <font face="helvetica">GAP</font>&nbsp;[<a href="#GAP483" name="CITEGAP483">GAP16</a>].

<div class="p"><!----></div>
We start with the description of the conjugacy classes of Th
as given in&nbsp;[<a href="#Par77" name="CITEPar77">Par77</a>] (see Section<a href="#sectclassesTh">2.1</a>),
then we compute the character table of a subgroup of type 2<sup>5</sup>:L<sub>5</sub>(2)
in Th (the so-called Dempwolff group, see Section&nbsp;<a href="#sectsubgroupTh">2.2</a>),
then we write down the power maps of Th
(see Section&nbsp;<a href="#sectpowermapsTh">2.3</a>),
and finally we compute the irreducible characters of Th
(see Section&nbsp;<a href="#sectirreduciblesTh">2.4</a>).

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;The conjugacy classes of Th</h3><a name="sectclassesTh">
</a>

<div class="p"><!----></div>
The conjugacy classes of elements of order different from
1, 19, and 31 in Th are listed in&nbsp;[<a href="#Par77" name="CITEPar77">Par77</a>,Table&nbsp;I],
and&nbsp;[<a href="#Par77" name="CITEPar77">Par77</a>,(6.3)] states that there are
one class of elements of order 19
and two (nonreal) classes of elements of order 31;
note that Case&nbsp;I&nbsp;(&#945;) holds by the proof of (6.1).

<div class="p"><!----></div>
Up to a permutation of classes,
this description of the classes agrees with the element orders
and centralizer orders in the character table that is claimed for Th
in <font face="helvetica">GAP</font>'s Character Table Library&nbsp;[<a href="#CTblLib" name="CITECTblLib">Bre21</a>].

<div class="p"><!----></div>

<pre>
    gap&#62; lib:= CharacterTable( "Th" );;
    gap&#62; parrottnames:= [
    &#62;      "1A", "z", "c2", "c3", "c1", "r1", "v", "b", "zc1", "zc2",
    &#62;      "zc3", "a", "us1", "w", "f1", "f3", "f2", "zb",
    &#62;      "r1c2", "(r1c2)^-1", "r1c3", "vc1", "l", "za",
    &#62;      "c1b", "(c1b)^-1", "zf1", "zf2", "19A", "vb", "c2a2",
    &#62;      "us1c2", "(us1c2)^-1", "wc1", "(wc1)^-1",
    &#62;      "f4", "f5", "(f5)^-1", "r1a", "zbc1", "(zbc1)^-1",
    &#62;      "31A", "31B", "r1f1", "s1f1", "(s1f1)^-1",
    &#62;      "c2l", "(c2l)^-1" ];;
    gap&#62; orders:= OrdersClassRepresentatives( lib );;
    gap&#62; centralizers:= SizesCentralizers( lib );;
    gap&#62; descr:= TransposedMat( [ parrottnames, orders, centralizers ] );;
    gap&#62; for entry in descr do
    &#62;      Print( String( entry[1], -12 ),
    &#62;             String( entry[2], 2 ), "  ",
    &#62;             StringPP( entry[3] ), "\n" );
    &#62;    od;
    1A           1  2^15*3^10*5^3*7^2*13*19*31
    z            2  2^15*3^4*5*7
    c2           3  2^6*3^7*7*13
    c3           3  2^3*3^10
    c1           3  2^4*3^7*5
    r1           4  2^11*3^3*7
    v            4  2^9*3*5
    b            5  2^3*3*5^3
    zc1          6  2^4*3^3*5
    zc2          6  2^6*3^3
    zc3          6  2^3*3^4
    a            7  2^3*3*7^2
    us1          8  2^7*3
    w            8  2^5*3
    f1           9  2^3*3^6
    f3           9  3^6
    f2           9  2*3^4
    zb          10  2^3*3*5
    r1c2        12  2^5*3^2
    (r1c2)^-1   12  2^5*3^2
    r1c3        12  2^2*3^3
    vc1         12  2^3*3
    l           13  3*13
    za          14  2^3*7
    c1b         15  2*3*5
    (c1b)^-1    15  2*3*5
    zf1         18  2^3*3^2
    zf2         18  2*3^2
    19A         19  19
    vb          20  2^2*5
    c2a2        21  3*7
    us1c2       24  2^3*3
    (us1c2)^-1  24  2^3*3
    wc1         24  2^3*3
    (wc1)^-1    24  2^3*3
    f4          27  3^3
    f5          27  3^3
    (f5)^-1     27  3^3
    r1a         28  2^2*7
    zbc1        30  2*3*5
    (zbc1)^-1   30  2*3*5
    31A         31  31
    31B         31  31
    r1f1        36  2^2*3^2
    s1f1        36  2^2*3^2
    (s1f1)^-1   36  2^2*3^2
    c2l         39  3*13
    (c2l)^-1    39  3*13

</pre>

<div class="p"><!----></div>
We create a new character table object for a group of the given order
and with the given element orders and centralizer orders.

<div class="p"><!----></div>

<pre>
    gap&#62; th:= rec( UnderlyingCharacteristic:= 0,
    &#62;              OrdersClassRepresentatives:= orders,
    &#62;              SizesCentralizers:= centralizers,
    &#62;              Size:= centralizers[1] );;
    gap&#62; ConvertToCharacterTableNC( th );;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;The subgroup 2<sup>5</sup>.L<sub>5</sub>(2)</h3><a name="sectsubgroupTh">
</a>

<div class="p"><!----></div>
The group Th contains a subgroup D that is a non-split extension
of an elementary abelian group of order 2<sup>5</sup> by the general linear group
<span class="roman">GL</span>(5,2), see&nbsp;[<a href="#Smi76c" name="CITESmi76c">Smi76</a>].
This subgroup is uniquely determined up to isomorphism by these properties
(see&nbsp;[<a href="#Dem72" name="CITEDem72">Dem72</a>]), it is usually called the <em>Dempwolff group</em>.

<div class="p"><!----></div>
The character table of D is available in <font face="helvetica">GAP</font>'s character table library,
but we recompute it anew from a permutation representation of D,
in order to make the construction of the character table of Th
self-contained.

<div class="p"><!----></div>
Since <font face="helvetica">GAP</font>'s current default algorithm requires more than 4&nbsp;GB of space
-too much for my small notebook-
we use some character theoretic methods for computing the irreducible
characters of D.

<div class="p"><!----></div>
First we compute the irreducible characters that are inflated from the
factor group <span class="roman">GL</span>(5,2).

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; g:= AtlasGroup( "2^5.L5(2)" );;
    gap&#62; bl:= Blocks( g, MovedPoints( g ) );;
    gap&#62; Length( bl[1] );
    2
    gap&#62; acthom:= ActionHomomorphism( g, bl, OnSets );;
    gap&#62; img:= Image( acthom );;
    gap&#62; Size( g ) / Size( img );
    32
    gap&#62; sm:= SmallerDegreePermutationRepresentation( img );;
    gap&#62; NrMovedPoints( Image( sm ) );
    31
    gap&#62; f:= CharacterTable( Image( sm ) );;
    gap&#62; d:= CharacterTable( g );;
    gap&#62; fus:= List( ConjugacyClasses( d ),
    &#62;            c -&#62; PositionProperty( ConjugacyClasses( f ),
    &#62;                   cc -&#62; ( Representative( c )^acthom )^sm in cc ) );;
    gap&#62; infl:= List( Irr( f ), x -&#62; x{ fus } );;

</pre>

<div class="p"><!----></div>
Next we compute the characters induced from all linear characters of
cyclic subgroups of D,
and the permutation character of the given permutation representation.
Reducing these characters with the known irreducibles yields one
faithful irreducible character.
Then we form tensor products of the known irreducible characters
with the faithful irreducible character, reduce them with the known
irreducibles,
and apply the LLL algorithm to the reducible characters which we have;
this yields five new irreducible characters.

<div class="p"><!----></div>

<pre>
    gap&#62; indcyc:= InducedCyclic( d, [ 2 .. NrConjugacyClasses( d ) ], "all" );;
    gap&#62; nat:= NaturalCharacter( g );;
    gap&#62; red:= ReducedOrdinary( d, infl, Concatenation( indcyc, [ nat ] ) );;
    gap&#62; Length( red.irreducibles );
    1
    gap&#62; faithirr:= ShallowCopy( red.irreducibles );;
    gap&#62; ten:= Set( Tensored( infl, faithirr ) );;
    gap&#62; ten:= Reduced( d, faithirr, ten );;
    gap&#62; lll:= LLL( d, Concatenation( red.remainders, ten.remainders ) );;
    gap&#62; Length( lll.irreducibles );
    5
    gap&#62; Append( faithirr, lll.irreducibles );

</pre>

<div class="p"><!----></div>
Next we compute symmetrization of the known irreducible characters,
reduce them, and apply LLL again -four new irreducibles.

<div class="p"><!----></div>

<pre>
    gap&#62; sym2:= Symmetrizations( d, faithirr, 2 );;
    gap&#62; sym3:= Symmetrizations( d, faithirr, 3 );;
    gap&#62; irr:= Concatenation( infl, faithirr );;
    gap&#62; sym:= Reduced( d, irr, Concatenation( sym2, sym3 ) );;
    gap&#62; lll:= LLL( d, Concatenation( lll.remainders, sym.remainders ) );;
    gap&#62; Length( lll.irreducibles );
    4
    gap&#62; Append( irr, lll.irreducibles );

</pre>

<div class="p"><!----></div>
Next we compute the possible orthogonal embeddings of the
four-dimensional LLL-reduced lattice into the four-dimensional
standard lattice.
we get two solutions for the missing irreducibles of D.

<div class="p"><!----></div>

<pre>
    gap&#62; gram:= MatScalarProducts( d, lll.remainders, lll.remainders );;
    gap&#62; emb:= OrthogonalEmbeddings( gram );;                           
    gap&#62; Length( emb.solutions );
    3
    gap&#62; dec:= List( emb.solutions,
    &#62;                x -&#62; Decreased( d, lll.remainders, emb.vectors{ x } ) );;
    gap&#62; dec:= Filtered( dec, x -&#62; x &lt;&#62; fail );;
    gap&#62; Length( dec );
    2

</pre>

<div class="p"><!----></div>
One solution is not compatible with the given 2-nd power map of D.
Thus the other solution is the correct one.

<div class="p"><!----></div>

<pre>
    gap&#62; sym:= List( [ 1, 2 ],
    &#62;            i -&#62; Symmetrizations( d, [ dec[i].irreducibles[1] ], 2 ) );;
    gap&#62; good:= Filtered( [ 1, 2 ],
    &#62;             i -&#62; ForAll( dec[i].irreducibles,
    &#62;                    x -&#62; IsInt( ScalarProduct( d, sym[i][1], x ) ) ) );;
    gap&#62; Length( good );
    1
    gap&#62; SetIrr( d, Concatenation( irr, dec[ good[1] ].irreducibles ) );

</pre>

<div class="p"><!----></div>
Finally, we show that we have really computed the character table of
a group which contains an elementary abelian normal subgroup N
of order 2<sup>5</sup>, ...

<div class="p"><!----></div>

<pre>
    gap&#62; nsg:= ClassPositionsOfNormalSubgroups( d );
    [ [ 1 ], [ 1, 2 ], [ 1 .. 41 ] ]
    gap&#62; SizesConjugacyClasses( d ){ nsg[2] };
    [ 1, 31 ]
    gap&#62; OrdersClassRepresentatives( d ){ nsg[2] };
    [ 1, 2 ]

</pre>

<div class="p"><!----></div>
... that the extension is non-split, ...

<div class="p"><!----></div>

<pre>
    gap&#62; f:= d / nsg[2];;
    gap&#62; PossibleClassFusions( f, d );
    [  ]

</pre>

<div class="p"><!----></div>
... that the factor group by N is isomorphic with <span class="roman">GL</span>(5,2), ...

<div class="p"><!----></div>

<pre>
    gap&#62; n:= PCore( g, 2 );
    &lt;permutation group with 5 generators&#62;
    gap&#62; Size( n );
    32
    gap&#62; IsomorphismGroups( g / n, GL(5,2) ) = fail;
    false

</pre>

<div class="p"><!----></div>
... and that the computed character table is equivalent to the table
which can fetched from <font face="helvetica">GAP</font>'s character table library via the call
<tt>CharacterTable( "2^5.L5(2)" )</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; libsub:= CharacterTable( "2^5.L5(2)" );;
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( d, libsub ) );
    true
    gap&#62; d:= libsub;;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;The power maps of Th</h3><a name="sectpowermapsTh">
</a>

<div class="p"><!----></div>
Before we can compute the irreducible characters of Th by inducing
characters from D and from cyclic subgroups of Th,
we determine the power maps of Th.

<div class="p"><!----></div>
In addition to the conditions that are imposed by the representative orders
and centralizer orders,
we use the following information from&nbsp;[<a href="#Par77" name="CITEPar77">Par77</a>];
each entry <tt>[ c, p, i ]</tt> means that the <tt>p</tt>-th power of the class with
the name <tt>c</tt> is the class with the name <tt>i</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; powinfo:= [
    &#62;     [ "zc3", 2, "c3" ],     # c3 commutes with z
    &#62;     [ "zf2", 2, "f2" ],     # f2 commutes with z
    &#62;     [ "r1c3", 2, "zc3" ],   # r1 commutes with c3
    &#62;     [ "vc1", 2, "zc1" ],    # v squares to z and commutes with c1
    &#62;     [ "wc1", 2, "vc1" ],    # w squares to v and commutes with c1
    &#62;     [ "(wc1)^-1", 2, "vc1" ],
    &#62;     [ "us1c2", 2, "r1c2" ], # us1 squares to r1
    &#62;     [ "(us1c2)^-1", 2, "(r1c2)^-1" ],
    &#62;     [ "us1", 2, "r1" ],     # (5.1)
    &#62;     [ "w", 2, "v" ],        # (5.1)
    &#62;     [ "zbc1", 2, "c1b" ],
    &#62;     [ "(zbc1)^-1", 2, "(c1b)^-1" ],
    &#62;     [ "f1", 3, "c3" ],
    &#62;     [ "f2", 3, "c3" ],
    &#62;     [ "f3", 3, "c3" ],
    &#62;     [ "vc1", 3, "v" ],      # v commutes with c1
    &#62;     [ "zf1", 3, "zc3" ],
    &#62;     [ "zf2", 3, "zc3" ],
    &#62;     [ "us1c2", 3, "us1" ],
    &#62;     [ "(us1c2)^-1", 3, "us1" ],
    &#62;     [ "wc1", 3, "w" ],
    &#62;     [ "(wc1)^-1", 3, "w" ],
    &#62;     [ "f4", 3, "f3" ],
    &#62;     [ "f5", 3, "f3" ],
    &#62;     [ "(f5)^-1", 3, "f3" ],
    &#62;     [ "r1f1", 3, "r1c3" ],
    &#62;     [ "s1f1", 3, "r1c3" ],
    &#62;     [ "(s1f1)^-1", 3, "r1c3" ],
    &#62;     ];;

</pre>

<div class="p"><!----></div>
Next we enter information about Galois conjugation;
we will need p-th power maps for primes p up to the largest
element order in Th.

<div class="p"><!----></div>

<pre>
    gap&#62; maxorder:= Maximum( OrdersClassRepresentatives( th ) );
    39
    gap&#62; primes:= Filtered( [ 1 .. maxorder ], IsPrimeInt );;

</pre>

<div class="p"><!----></div>
The classes of <tt>r1f1</tt> and <tt>f4</tt> (element orders 36 and 27, respectively)
are rational.

<div class="p"><!----></div>

<pre>
    gap&#62; for p in primes do
    &#62;      if 36 mod p &lt;&#62; 0 then
    &#62;        Add( powinfo, [ "r1f1", p, "r1f1" ] );
    &#62;      fi;
    &#62;      if 27 mod p &lt;&#62; 0 then
    &#62;        Add( powinfo, [ "f4", p, "f4" ] );
    &#62;      fi;
    &#62;    od;

</pre>

<div class="p"><!----></div>
For the non-rational classes, it is more suitable to set the power map entries
directly, instead of using the list <tt>powinfo</tt>.
Thus we first initialize the power maps and then evaluate this list.

<div class="p"><!----></div>

<pre>
    gap&#62; powermaps:= [];;
    gap&#62; for p in primes do
    &#62;      powermaps[p]:= InitPowerMap( th, p );
    &#62;    od;
    gap&#62; for entry in powinfo do
    &#62;      p:= entry[2];
    &#62;      pow:= powermaps[p];
    &#62;      src:= Position( parrottnames, entry[1] );
    &#62;      trg:= Position( parrottnames, entry[3] );
    &#62;      if IsInt( pow[ src ] ) then
    &#62;        if pow[ src ] &lt;&#62; trg then
    &#62;          Error( "contradiction!" );
    &#62;        fi;
    &#62;      elif not trg in pow[ src ] then
    &#62;        Error( "contradiction!" );
    &#62;      else
    &#62;        pow[ src ]:= trg;
    &#62;      fi;
    &#62;    od;
    gap&#62; SetComputedPowerMaps( th, powermaps );

</pre>

<div class="p"><!----></div>
Any non-rational class C, say, of Th has exactly one Galois conjugate
class,
that is, the character values attained on C generate a quadratic
extension field of the rationals.
Let x be a generating element of this extension.
If p does not divide the order of the elements in C
then the p-th power map swaps C and its Galois conjugate
if and only if x differs from the Galois image x<sup>&#8727;p</sup>,
otherwise the p-th power map fixes the two classes.
The following small function is suitable for setting the
power map info in these cases.

<div class="p"><!----></div>

<pre>
    gap&#62; setGaloisInfo:= function( powermaps, classes, orders, primes, x )
    &#62;    local ord, p;
    &#62;    ord:= orders[ classes[1] ];
    &#62;    for p in primes do
    &#62;      if ord mod p &lt;&#62; 0 then
    &#62;        if GaloisCyc( x, p ) = x then
    &#62;          powermaps[p]{ classes }:= classes;
    &#62;        else
    &#62;          powermaps[p]{ classes }:= classes{ [ 2, 1 ] };
    &#62;        fi;
    &#62;      fi;
    &#62;    od;
    &#62;    end;;

</pre>

<div class="p"><!----></div>
The elements <tt>c1b</tt> and <tt>(c1b)^-1</tt> have order 15,
so the character values on these elements lie in a
non-real quadratic subfield of the field of 15-th roots of unity,
that is, in the extension by &#8730;{&#8722;3} or &#8730;{&#8722;15}.
Since the subgroup D contains exactly two Galois conjugate classes
of element order 15,
we can decide from the character table of D which case occurs.

<div class="p"><!----></div>
The same argument holds for the classes of the elements <tt>zbc1</tt> and <tt>(zbc1)^-1</tt>,
which have order 30.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Positions( OrdersClassRepresentatives( d ), 15 );
    [ 22, 24 ]
    gap&#62; f:= Field( List( Irr( d ), x -&#62; x[ pos[1] ] ) );
    NF(15,[ 1, 2, 4, 8 ])
    gap&#62; Sqrt( -15 ) in f;
    true
    gap&#62; pos:= Positions( orders, 15 );
    [ 25, 26 ]
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, Sqrt( -15 ) );
    gap&#62; pos:= Positions( OrdersClassRepresentatives( d ), 30 );
    [ 23, 25 ]
    gap&#62; f:= Field( List( Irr( d ), x -&#62; x[ pos[1] ] ) );
    NF(15,[ 1, 2, 4, 8 ])
    gap&#62; pos:= Positions( orders, 30 );
    [ 40, 41 ]
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, Sqrt( -15 ) );

</pre>

<div class="p"><!----></div>
The character values on <tt>f5</tt>, <tt>(f5)^-1</tt> lie in the unique
quadratic subfield of the field of 27-th roots of unity,
which is generated by &#8730;{&#8722;3}.
Analogously, the character values on the two classes of element order 31
lie in the extension by &#8730;{&#8722;31}.

<div class="p"><!----></div>

<pre>
    gap&#62; setGaloisInfo( powermaps,
    &#62;        List( [ "f5", "(f5)^-1" ], x -&#62; Position( parrottnames, x ) ),
    &#62;        orders, primes, Sqrt( -3 ) );
    gap&#62; setGaloisInfo( powermaps, Positions( orders, 31 ), orders, primes,
    &#62;                   Sqrt( -31 ) );

</pre>

<div class="p"><!----></div>
Concerning the two classes of element order 39,
with representatives <tt>c2l</tt> and <tt>(c2l)^-1</tt>,
the field of character values is generated either by &#8730;{&#8722;3}
or &#8730;{&#8722;39}.
We try both possibilities,
only with the second one the characters induced from the cyclic subgroup
of order 39 have integral norms.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Positions( orders, 39 );
    [ 47, 48 ]
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, Sqrt( -3 ) );
    gap&#62; indcyc:= InducedCyclic( th, [ pos[1] ], "all" );;
    gap&#62; ForAll( indcyc, x -&#62; IsInt( ScalarProduct( th, x, x ) ) );
    false
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, Sqrt( -39 ) );
    gap&#62; indcyc:= InducedCyclic( th, [ pos[1] ], "all" );;
    gap&#62; ForAll( indcyc, x -&#62; IsInt( ScalarProduct( th, x, x ) ) );
    true

</pre>

<div class="p"><!----></div>
The elements <tt>s1f1</tt>, <tt>(s1f1)^-1</tt> have order 36,
the field of character values on their classes is generated
by &#8730;{&#8722;3} or &#8730;{&#8722;1}.
Only the first candidate is compatible with induced characters.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Positions( orders, 36 );
    [ 44, 45, 46 ]
    gap&#62; parrottnames{ pos };
    [ "r1f1", "s1f1", "(s1f1)^-1" ]
    gap&#62; setGaloisInfo( powermaps, [ 45, 46 ], orders, primes, Sqrt( -3 ) );
    gap&#62; indcyc:= InducedCyclic( th, [ 45 ], "all" );;    
    gap&#62; ForAll( indcyc, x -&#62; IsInt( ScalarProduct( th, x, x ) ) );
    true
    gap&#62; setGaloisInfo( powermaps, [ 45, 46 ], orders, primes, Sqrt( -1 ) );
    gap&#62; indcyc:= InducedCyclic( th, [ 45 ], "all" );;
    gap&#62; ForAll( indcyc, x -&#62; IsInt( ScalarProduct( th, x, x ) ) );
    false
    gap&#62; setGaloisInfo( powermaps, [ 45, 46 ], orders, primes, Sqrt( -3 ) );

</pre>

<div class="p"><!----></div>
The elements <tt>wc1</tt>, <tt>(wc1)^-1</tt> have order 24,
the field of character values on their classes is a non-real
quadratic subfield of the field of 24-th roots of unity,
the generators to check are &#8730;{&#8722;3}, &#8730;{&#8722;1}, &#8730;{&#8722;2},
and &#8730;{&#8722;6}.
Only the last candidate is compatible with induced characters.

<div class="p"><!----></div>

<pre>
    gap&#62; List( [ "wc1", "(wc1)^-1" ], x -&#62; Position( parrottnames, x ) );
    [ 34, 35 ]
    gap&#62; vals:= [ Sqrt( -3 ), Sqrt( -1 ), Sqrt( -2 ), Sqrt( -6 ) ];
    [ E(3)-E(3)^2, E(4), E(8)+E(8)^3, E(24)+E(24)^11-E(24)^17-E(24)^19 ]
    gap&#62; good:= [];;
    gap&#62; for val in vals do
    &#62;      setGaloisInfo( powermaps, [ 34, 35 ], orders, primes, val );
    &#62;      indcyc:= InducedCyclic( th, [ 34 ], "all" );
    &#62;      if ForAll( indcyc, x -&#62; IsInt( ScalarProduct( th, x, x ) ) ) then
    &#62;        Add( good, val );
    &#62;      fi;
    &#62;    od;
    gap&#62; good;
    [ E(24)+E(24)^11-E(24)^17-E(24)^19 ]
    gap&#62; setGaloisInfo( powermaps, [ 34, 35 ], orders, primes, good[1] );

</pre>

<div class="p"><!----></div>
The only classes for which the information about powers is missing
are those of the elements <tt>r1c2</tt> and <tt>(r1c2)^-1</tt> (of order 12)
and their roots <tt>us1c2</tt>, <tt>(us1c2)^-1</tt> (of order 24).
We use that the subgroup D of Th contains elements from these classes,
which can be seen from the fact that the elements of order 12 in D
lie in the classes of <tt>r1c2</tt> and <tt>(r1c2)^-1</tt>.
(The class fusion from D to Th will be determined below,
here we need only the compatibility of element orders and centralizer orders
of a class of the subgroup and the possible image classes in the overgroup.)

<div class="p"><!----></div>
Note that the classes of <tt>us1c2</tt>, <tt>(us1c2)^-1</tt> must have the same
field of character values as their squares.

<div class="p"><!----></div>

<pre>
    gap&#62; parrottnames{ [ 19, 20, 32, 33 ] };
    [ "r1c2", "(r1c2)^-1", "us1c2", "(us1c2)^-1" ]
    gap&#62; fus:= InitFusion( d, th );;
    gap&#62; pos:= Positions( OrdersClassRepresentatives( d ), 12 );
    [ 12, 15, 16 ]
    gap&#62; fus{ pos };
    [ [ 19, 20, 21, 22 ], [ 19, 20 ], [ 19, 20 ] ]
    gap&#62; List( pos, x -&#62; Field( List( Irr( d ), chi -&#62; chi[x] ) ) );
    [ Rationals, CF(3), CF(3) ]
    gap&#62; Sqrt( -3 ) in CF(3);
    true
    gap&#62; setGaloisInfo( powermaps, [ 19, 20 ], orders, primes, Sqrt( -3 ) );
    gap&#62; setGaloisInfo( powermaps, [ 32, 33 ], orders, primes, Sqrt( -3 ) );

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc2.4">
2.4</a>&nbsp;&nbsp;The irreducible characters of Th</h3><a name="sectirreduciblesTh">
</a>

<div class="p"><!----></div>
We start with creating some characters of Th by inducing all linear
characters of cyclic subgroups.

<div class="p"><!----></div>

<pre>
    gap&#62; indcyc:= InducedCyclic( th, [ 2 .. NrConjugacyClasses( th ) ], "all" );;

</pre>

<div class="p"><!----></div>
In order to induce characters from the subgroup D,
we have to determine the class fusion from D to Th.
For that, we use element orders, centralizer orders, power maps,
and the fact that the restrictions of the known characters of Th
are characters of D.
Since the table of Th will have a table automorphism that swaps
exactly the classes of element order 31,
we may choose a fixed such class as the image of one class of element order
31 in D.

<div class="p"><!----></div>

<pre>
    gap&#62; fus:= InitFusion( d, th );
    [ 1, 2, 2, 6, [ 6, 7 ], [ 6, 7 ], 13, [ 13, 14 ], [ 13, 14 ], 5, 9, 
      [ 19, 20, 21, 22 ], 3, 10, [ 19, 20 ], [ 19, 20 ], [ 9, 10 ], 
      [ 32, 33, 34, 35 ], [ 32, 33, 34, 35 ], 8, 18, [ 25, 26 ], [ 40, 41 ], 
      [ 25, 26 ], [ 40, 41 ], 12, 24, 24, 39, 31, 12, 24, 24, 39, 31, [ 42, 43 ], 
      [ 42, 43 ], [ 42, 43 ], [ 42, 43 ], [ 42, 43 ], [ 42, 43 ] ]
    gap&#62; Positions( OrdersClassRepresentatives( d ), 31 );
    [ 36, 37, 38, 39, 40, 41 ]
    gap&#62; fus[36];
    [ 42, 43 ]
    gap&#62; fus[36]:= 42;;
    gap&#62; TestConsistencyMaps( ComputedPowerMaps( d ), fus,
    &#62;        ComputedPowerMaps( th ) );
    true
    gap&#62; possfus:= FusionsAllowedByRestrictions( d, th, Irr( d ), indcyc, fus,
    &#62;      rec( maxlen:= 10, minamb:= 1, maxamb:= 10^6, quick:= false,
    &#62;           contained:= ContainedPossibleCharacters ) );;
    gap&#62; possfus:= RepresentativesFusions( d, possfus, Group( () ) );
    [ [ 1, 2, 2, 6, 7, 6, 13, 14, 13, 5, 9, 22, 3, 10, 19, 20, 10, 33, 32, 8, 18, 
          25, 40, 26, 41, 12, 24, 24, 39, 31, 12, 24, 24, 39, 31, 42, 43, 42, 42, 
          43, 43 ], 
      [ 1, 2, 2, 6, 7, 7, 13, 14, 14, 5, 9, 22, 3, 10, 19, 20, 10, 33, 32, 8, 18, 
          25, 40, 26, 41, 12, 24, 24, 39, 31, 12, 24, 24, 39, 31, 42, 43, 42, 42, 
          43, 43 ] ]

</pre>

<div class="p"><!----></div>
We get two solutions, up to symmetries of the character table of D.
Using that characters induced from D must have integral norm,
one of these candidates gets excluded.

<div class="p"><!----></div>

<pre>
    gap&#62; indd:= InducedClassFunctionsByFusionMap( d, th, Irr( d ), possfus[1] );;
    gap&#62; ForAll( indd, x -&#62; IsInt( ScalarProduct( th, x, x ) ) );
    false
    gap&#62; indd:= InducedClassFunctionsByFusionMap( d, th, Irr( d ), possfus[2] );;
    gap&#62; ForAll( indd, x -&#62; IsInt( ScalarProduct( th, x, x ) ) );
    true

</pre>

<div class="p"><!----></div>
We initialize the list of known irreducibles (with the trivial character),
and reduce the induced characters.
Applying the LLL algorithm to the reduced characters yields four new
irreducibles.

<div class="p"><!----></div>

<pre>
    gap&#62; irr:= [ TrivialCharacter( th ) ];;
    gap&#62; red:= ReducedOrdinary( th, irr, Concatenation( indcyc, indd ) );;
    gap&#62; lll:= LLL( th, red.remainders );;
    gap&#62; Length( lll.irreducibles );
    4
    gap&#62; Append( irr, lll.irreducibles );

</pre>

<div class="p"><!----></div>
We create symmetrizations and tensor products of the known irreducibles,
and apply LLL again.
This yields three new irreducibles.

<div class="p"><!----></div>

<pre>
    gap&#62; sym:= Concatenation( List( [ 2, 3, 4, 5 ],
    &#62;              p -&#62; Symmetrizations( th, irr, p ) ) );;
    gap&#62; sym:= ReducedOrdinary( th, irr, sym );;
    gap&#62; ten:= Set( Tensored( irr, irr ) );;
    gap&#62; ten:= ReducedOrdinary( th, irr, ten );;
    gap&#62; lll:= LLL( th, Concatenation( lll.remainders, sym.remainders,
    &#62;                               ten.remainders ) );;
    gap&#62; Length( lll.irreducibles );
    3
    gap&#62; Append( irr, lll.irreducibles );
    gap&#62; DimensionsMat( irr );
    [ 8, 48 ]

</pre>

<div class="p"><!----></div>
The missing 40 irreducibles are found in one step,
by computing the possible orthogonal embeddings of the LLL-reduced
lattice of virtual characters into the 40-dimensional standard lattice.

<div class="p"><!----></div>
(In order to accelerate these computations,
we create a new LLL-reduced lattice.)

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; indcyc:= ReducedOrdinary( th, irr, indcyc );;
    gap&#62; indd:= ReducedOrdinary( th, irr, indd );;
    gap&#62; sym:= ReducedOrdinary( th, irr, sym.remainders );;
    gap&#62; ten:= ReducedOrdinary( th, irr, ten.remainders );;
    gap&#62; lll:= LLL( th, Concatenation( indcyc.remainders, indd.remainders,
    &#62;                       sym.remainders, ten.remainders ) );;
    gap&#62; gram:= MatScalarProducts( th, lll.remainders, lll.remainders );;
    gap&#62; emb:= OrthogonalEmbeddings( gram, 40 );;
    gap&#62; Length( emb.solutions );
    4

</pre>

<div class="p"><!----></div>
Two of the four solutions do not satisfy the condition that the standard
basis vectors are irreducible characters.

<div class="p"><!----></div>

<pre>
    gap&#62; dec:= List( emb.solutions,
    &#62;                x -&#62; Decreased( th, lll.remainders, emb.vectors{ x } ) );;
    gap&#62; dec:= Filtered( dec, x -&#62; x &lt;&#62; fail );;
    gap&#62; Length( dec );
    2

</pre>

<div class="p"><!----></div>
We check whether the first solution yields a character table for Th
that is permutation equivalent to the character table in
<font face="helvetica">GAP</font>'s library of character tables,
which is equal to the table that is shown in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;176].

<div class="p"><!----></div>

<pre>
    gap&#62; SetIrr( th, List( Concatenation( irr, dec[1].irreducibles ),
    &#62;                      x -&#62; Character( th, x ) ) );
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( th, lib ) );
    true

</pre>

<div class="p"><!----></div>
We do the same for the second solution.

<div class="p"><!----></div>

<pre>
    gap&#62; ResetFilterObj( th, HasIrr );
    gap&#62; SetIrr( th, List( Concatenation( irr, dec[2].irreducibles ),
    &#62;                      x -&#62; Character( th, x ) ) );
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( th, lib ) );
    true

</pre>

<div class="p"><!----></div>
We see that both solutions are permutation equivalent
to the  A<font size="-2">TLAS</font> table of Th.

<div class="p"><!----></div>

 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;The character table of J<sub>4</sub> (January 1st, 2016)</h2>

<div class="p"><!----></div>
The character table of the sporadic simple Janko group J<sub>4</sub>
is shown in the  A<font size="-2">TLAS</font> of Finite Groups (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,pp.&nbsp;188-189]),
and this  A<font size="-2">TLAS</font> table is contained in
the character table library&nbsp;[<a href="#CTblLib" name="CITECTblLib">Bre21</a>]
of the computer algebra system <font face="helvetica">GAP</font>&nbsp;[<a href="#GAP483" name="CITEGAP483">GAP16</a>].

<div class="p"><!----></div>
We start with the description of the conjugacy classes of J<sub>4</sub>
as given in&nbsp;[<a href="#Jan76" name="CITEJan76">Jan76</a>] (see Section&nbsp;<a href="#sectclassesJ4">3.1</a>),
then we compute the character table of a subgroup of the type 2<sup>11</sup>:M<sub>24</sub>
in J<sub>4</sub> (see Section&nbsp;<a href="#sectsubgroupJ4">3.2</a>),
then we write down the power maps of J<sub>4</sub>
(see Section&nbsp;<a href="#sectpowermapsJ4">3.3</a>),
and finally we compute the irreducible characters of J<sub>4</sub>
(see Section&nbsp;<a href="#sectirreduciblesJ4">3.4</a>).

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;The conjugacy classes of J<sub>4</sub></h3><a name="sectclassesJ4">
</a>

<div class="p"><!----></div>
The conjugacy classes of elements of J<sub>4</sub> are listed in&nbsp;[<a href="#Jan76" name="CITEJan76">Jan76</a>,Table&nbsp;I].

<div class="p"><!----></div>
Up to the permutation (x<sub>14</sub>, x<sub>15</sub>)(x<sub>21</sub>, x<sub>22</sub>),
this description of the classes agrees with the element orders
and centralizer orders in the character table that is claimed for J<sub>4</sub>
in <font face="helvetica">GAP</font>'s Character Table Library&nbsp;[<a href="#CTblLib" name="CITECTblLib">Bre21</a>].

<div class="p"><!----></div>
(The permutation is obvious for x<sub>14</sub> and x<sub>15</sub> because of the
centralizer orders.
For x<sub>21</sub> and x<sub>22</sub>,
the flip is necessary in order to get a table with the same third power map
as in the <font face="helvetica">GAP</font> table.)

<div class="p"><!----></div>

<pre>
    gap&#62; lib:= CharacterTable( "J4" );;
    gap&#62; pos:= [ 1 .. NrConjugacyClasses( lib ) ];;
    gap&#62; orders:= OrdersClassRepresentatives( lib );;
    gap&#62; centralizers:= SizesCentralizers( lib );;
    gap&#62; descr:= TransposedMat( [ pos, orders, centralizers ] );;
    gap&#62; for entry in descr do
    &#62;      Print( String( entry[1], 2 ), "  ",
    &#62;             String( entry[2], 2 ), "  ",
    &#62;             StringPP( entry[3] ), "\n" );
    &#62;    od;
     1   1  2^21*3^3*5*7*11^3*23*29*31*37*43
     2   2  2^21*3^3*5*7*11
     3   2  2^19*3^2*5*7*11
     4   3  2^8*3^3*5*7*11
     5   4  2^15*3*5*11
     6   4  2^15*3
     7   4  2^11*3*7
     8   5  2^6*3*5*7
     9   6  2^8*3^3*5*7*11
    10   6  2^8*3^2
    11   6  2^8*3^2
    12   7  2^3*3*5*7
    13   7  2^3*3*5*7
    14   8  2^8*5
    15   8  2^8*3
    16   8  2^9
    17  10  2^6*3*5
    18  10  2^4*5
    19  11  2^3*3*11^3
    20  11  2*11^2
    21  12  2^6*3
    22  12  2^6*3
    23  12  2^4*3
    24  14  2^2*3*7
    25  14  2^2*3*7
    26  14  2^3*7
    27  14  2^3*7
    28  15  2*3*5
    29  16  2^5
    30  20  2^5*5
    31  20  2^5*5
    32  21  2*3*7
    33  21  2*3*7
    34  22  2^3*3*11
    35  22  2*11
    36  23  23
    37  24  2^4*3
    38  24  2^4*3
    39  28  2^2*7
    40  28  2^2*7
    41  29  29
    42  30  2*3*5
    43  31  31
    44  31  31
    45  31  31
    46  33  2*3*11
    47  33  2*3*11
    48  35  5*7
    49  35  5*7
    50  37  37
    51  37  37
    52  37  37
    53  40  2^3*5
    54  40  2^3*5
    55  42  2*3*7
    56  42  2*3*7
    57  43  43
    58  43  43
    59  43  43
    60  44  2^2*11
    61  66  2*3*11
    62  66  2*3*11

</pre>

<div class="p"><!----></div>
We create a new character table object for a group of the given order
and with the given element orders and centralizer orders.

<div class="p"><!----></div>

<pre>
    gap&#62; j4:= rec( UnderlyingCharacteristic:= 0,
    &#62;              OrdersClassRepresentatives:= orders,
    &#62;              SizesCentralizers:= centralizers,
    &#62;              Size:= centralizers[1] );;
    gap&#62; ConvertToCharacterTableNC( j4 );;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;The subgroup 2<sup>11</sup>:M<sub>24</sub></h3><a name="sectsubgroupJ4">
</a>

<div class="p"><!----></div>
By&nbsp;[<a href="#Jan76" name="CITEJan76">Jan76</a>,Theorem&nbsp;A&nbsp;(4)],
the group J<sub>4</sub> contains a subgroup U that is a split extension
of an elementary abelian group N of order 2<sup>11</sup> by the Mathieu group
M<sub>24</sub>.

<div class="p"><!----></div>
E.&nbsp;O'Brien has computed the character table of this subgroup
with the MAGMA system&nbsp;[<a href="#Magma" name="CITEMagma">BCP97</a>] from a representation of J<sub>4</sub>.
This character table is permutation equivalent to the character table
that is available in <font face="helvetica">GAP</font>'s character table library,
with the name <tt>"J4M1"</tt>, which stands for "the first class of maximal
subgroups in J<sub>4</sub>".

<div class="p"><!----></div>

<pre>
    gap&#62; u:= CharacterTable( "J4M1" );
    CharacterTable( "mx1j4" )

</pre>

<div class="p"><!----></div>
(Trying to recompute the character table with <font face="helvetica">GAP</font>'s default algorithm
from a permutation representation on 2<sup>11</sup> points failed
on my small notebook, due to space limitations.)

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;The power maps of J<sub>4</sub></h3><a name="sectpowermapsJ4">
</a>

<div class="p"><!----></div>
Before we can compute the irreducible characters of J<sub>4</sub> by inducing
characters from U and from cyclic subgroups of J<sub>4</sub>,
we determine the power maps of J<sub>4</sub>.

<div class="p"><!----></div>
In addition to the conditions that are imposed by the representative orders
and centralizer orders,
we use the following information from&nbsp;[<a href="#Jan76" name="CITEJan76">Jan76</a>,Table&nbsp;I];
each entry <tt>[ c, p, i ]</tt> means that the <tt>p</tt>-th power of the <tt>c</tt>-th class
is the <tt>i</tt>-th class.
(Note that the classes 14 and 21 must be swapped with 15 and 22,
respectively, in our character table,
compared with the classes description from&nbsp;[<a href="#Jan76" name="CITEJan76">Jan76</a>,Table&nbsp;I].)

<div class="p"><!----></div>

<pre>
    gap&#62; powinfo:= [
    &#62;     [  5,  2,  2 ],
    &#62;     [  6,  2,  2 ],
    &#62;     [  7,  2,  3 ],
    &#62;     [ 10,  3,  2 ],
    &#62;     [ 11,  3,  3 ],
    &#62;     [ 15,  2,  6 ],
    &#62;     [ 16,  2,  6 ],
    &#62;     [ 17,  5,  2 ],
    &#62;     [ 18,  5,  3 ],
    &#62;     [ 21,  3,  5 ],
    &#62;     [ 22,  3,  6 ],
    &#62;     [ 23,  3,  7 ],
    &#62;     [ 24,  7,  2 ],
    &#62;     [ 25,  7,  2 ],
    &#62;     [ 26,  7,  3 ],
    &#62;     [ 27,  7,  3 ],
    &#62;     [ 29,  2, 16 ],
    &#62;     [ 34, 11,  2 ],
    &#62;     [ 35, 11,  3 ],
    &#62;     ];;

</pre>

<div class="p"><!----></div>
Next we enter information about Galois conjugation;
we will need p-th power maps for primes p up to the largest
element order in J<sub>4</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; maxorder:= Maximum( OrdersClassRepresentatives( j4 ) );
    66
    gap&#62; primes:= Filtered( [ 1 .. maxorder ], IsPrimeInt );;

</pre>

<div class="p"><!----></div>
The three classes of element order 6 are rational;
note that the classes of x<sub>10</sub> and x<sub>11</sub> have the same size,
but their third powers are different.
Analogously, the three classes of element order 12 are rational,
because their third powers lie in the three different rational classes
of element order 4.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Union( Positions( orders, 6 ), Positions( orders, 12 ) );
    [ 9, 10, 11, 21, 22, 23 ]
    gap&#62; for p in primes do
    &#62;      if 6 mod p &lt;&#62; 0 then
    &#62;        for i in pos do
    &#62;          Add( powinfo, [ i, p, i ] );
    &#62;        od;
    &#62;      fi;
    &#62;    od;

</pre>

<div class="p"><!----></div>
Without loss of generality,
we may choose x<sub>24</sub><sup>2</sup> &#160;&#8764;&#160;x<sub>12</sub>, x<sub>25</sub><sup>2</sup> &#160;&#8764;&#160;x<sub>13</sub>,
x<sub>26</sub><sup>2</sup> &#160;&#8764;&#160;x<sub>12</sub>, and x<sub>27</sub><sup>2</sup> &#160;&#8764;&#160;x<sub>13</sub>.
Analogously, we may choose
x<sub>55</sub><sup>2</sup> &#160;&#8764;&#160;x<sub>32</sub>, and x<sub>56</sub><sup>2</sup> &#160;&#8764;&#160;x<sub>33</sub>.

<div class="p"><!----></div>
The squares of x<sub>39</sub> and x<sub>40</sub> can be chosen as conjugates of
x<sub>26</sub> and x<sub>27</sub>, respectively,
since the 14-th powers of x<sub>39</sub> and x<sub>40</sub> are conjugate to x<sub>3</sub>.

<div class="p"><!----></div>
When we choose x<sub>55</sub><sup>3</sup> &#160;&#8764;&#160;x<sub>25</sub> and x<sub>56</sub><sup>3</sup> &#160;&#8764;&#160;x<sub>24</sub>,
we have to choose x<sub>32</sub><sup>3</sup> &#160;&#8764;&#160;x<sub>13</sub> and x<sub>33</sub><sup>3</sup> &#160;&#8764;&#160;x<sub>12</sub>,
in order to get compatible 6-th powers.
(We choose these powers in order to get the same third power map
as in the <font face="helvetica">GAP</font> table.)

<div class="p"><!----></div>

<pre>
    gap&#62; Add( powinfo, [ 24, 2, 12 ] );
    gap&#62; Add( powinfo, [ 25, 2, 13 ] );
    gap&#62; Add( powinfo, [ 26, 2, 12 ] );
    gap&#62; Add( powinfo, [ 27, 2, 13 ] );
    gap&#62; Add( powinfo, [ 39, 2, 26 ] );
    gap&#62; Add( powinfo, [ 40, 2, 27 ] );
    gap&#62; Add( powinfo, [ 55, 2, 32 ] );
    gap&#62; Add( powinfo, [ 56, 2, 33 ] );
    gap&#62; Add( powinfo, [ 55, 3, 25 ] );
    gap&#62; Add( powinfo, [ 56, 3, 24 ] );
    gap&#62; Add( powinfo, [ 32, 3, 13 ] );
    gap&#62; Add( powinfo, [ 33, 3, 12 ] );

</pre>

<div class="p"><!----></div>
For the non-rational classes, it is more suitable to set the power map entries
directly, instead of using the list <tt>powinfo</tt>.
Thus we first initialize the power maps and then evaluate this list.

<div class="p"><!----></div>

<pre>
    gap&#62; powermaps:= [];;
    gap&#62; for p in primes do
    &#62;      powermaps[p]:= InitPowerMap( j4, p );
    &#62;    od;
    gap&#62; for entry in powinfo do
    &#62;      p:= entry[2];
    &#62;      pow:= powermaps[p];
    &#62;      src:= entry[1];
    &#62;      trg:= entry[3];
    &#62;      if IsInt( pow[ src ] ) then
    &#62;        if pow[ src ] &lt;&#62; trg then
    &#62;          Error( "contradiction!" );
    &#62;        fi;
    &#62;      elif not trg in pow[ src ] then
    &#62;        Error( "contradiction!" );
    &#62;      else
    &#62;        pow[ src ]:= trg;
    &#62;      fi;
    &#62;    od;
    gap&#62; SetComputedPowerMaps( j4, powermaps );

</pre>

<div class="p"><!----></div>
There are two Galois conjugate conjugacy classes of elements of order 7
in J<sub>4</sub>,
that is, the character values attained on these classes lie in the unique
quadratic extension field F, say, of the rationals.
The field F is generated by &#8730;{&#8722;7}.
If p is a prime different from 7
then the p-th power map swaps the two classes
if and only if &#8730;{&#8722;7} differs from the Galois image &#8730;{&#8722;7}<sup>&#8727;p</sup>,
otherwise the p-th power map fixes the two classes.
The same holds for the p-th powers of the elements of order
n  &#8712; { 14, 21, 28, 35, 42 } in J<sub>4</sub> if p does not divide n.
The function <tt>setGaloisInfo</tt> that has been introduced in
Section&nbsp;<a href="#sectpowermapsTh">2.3</a> will be used for setting the power map info
in these cases.

<div class="p"><!----></div>
(As we have used already above,
the distribution of the four classes of element order 14 into two pairs
is determined by the known seventh powers.)

<div class="p"><!----></div>

<pre>
    gap&#62; x:= Sqrt( -7 );;
    gap&#62; pos:= Positions( orders, 7 );
    [ 12, 13 ]
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, x );
    gap&#62; setGaloisInfo( powermaps, [ 24, 25 ], orders, primes, x );
    gap&#62; setGaloisInfo( powermaps, [ 26, 27 ], orders, primes, x );
    gap&#62; pos:= Positions( orders, 21 );
    [ 32, 33 ]
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, x );
    gap&#62; pos:= Positions( orders, 28 );
    [ 39, 40 ]
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, x );
    gap&#62; pos:= Positions( orders, 35 );
    [ 48, 49 ]
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, x );
    gap&#62; pos:= Positions( orders, 42 );
    [ 55, 56 ]
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, x );

</pre>

<div class="p"><!----></div>
Without loss of generality,
we choose the representatives x<sub>48</sub>, x<sub>49</sub> in such a way that
their 5-th powers are x<sub>13</sub> and x<sub>12</sub>, respectively.

<div class="p"><!----></div>

<pre>
    gap&#62; powermaps[5]{ [ 48, 49 ] }:= [ 13, 12 ];;

</pre>

<div class="p"><!----></div>
There are four possibilities for the two classes of element order 33.
Either they are rational, or the character values lie in the quadratic
number field generated by &#8730;{&#8722;3}, &#8730;{&#8722;11}, or &#8730;{33}.
We check for which of them the induction of characters from the cyclic
subgroup can yield characters of J<sub>4</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Positions( orders, 33 );
    [ 46, 47 ]
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, 1 );
    gap&#62; ind:= InducedCyclic( j4, [ 46 ], "all" );;
    gap&#62; ForAll( ind, x -&#62; IsInt( ScalarProduct( j4, x, x ) ) );
    false
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, Sqrt( -3 ) );
    gap&#62; ind:= InducedCyclic( j4, [ 46 ], "all" );;
    gap&#62; ForAll( ind, x -&#62; IsInt( ScalarProduct( j4, x, x ) ) );
    false
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, Sqrt( -11 ) );
    gap&#62; ind:= InducedCyclic( j4, [ 46 ], "all" );;
    gap&#62; ForAll( ind, x -&#62; IsInt( ScalarProduct( j4, x, x ) ) );
    false
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, Sqrt( 33 ) );
    gap&#62; ind:= InducedCyclic( j4, [ 46 ], "all" );;
    gap&#62; ForAll( ind, x -&#62; IsInt( ScalarProduct( j4, x, x ) ) );
    true

</pre>

<div class="p"><!----></div>
We see that the character values must lie in the field generated by
&#8730;{33}.
This implies that also the two classes of element order 66 are
Galois conjugate, and the character values lie in the same field.
Moreover, we may choose x<sub>46</sub> and x<sub>47</sub> as the squares of x<sub>61</sub>
and x<sub>62</sub>, respectively.

<div class="p"><!----></div>

<pre>
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, Sqrt( 33 ) );
    gap&#62; pos:= Positions( orders, 66 );
    [ 61, 62 ]
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, Sqrt( 33 ) );
    gap&#62; powermaps[2]{ pos }:= [ 46, 47 ];;

</pre>

<div class="p"><!----></div>
We show that the two classes of element order 20 cannot be real,
in the same way as we did for the elements of order 33.
Since the subgroup U of J<sub>4</sub> contains two Galois conjugate classes
of element order 20, with character values in the quadratic number field
generated by &#8730;5,
the two classes of element order 20 in J<sub>4</sub> have the same property.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Positions( orders, 20 );
    [ 30, 31 ]
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, 1 );
    gap&#62; ind:= InducedCyclic( j4, [ 30 ], "all" );;
    gap&#62; ForAll( ind, x -&#62; IsInt( ScalarProduct( j4, x, x ) ) );
    false
    gap&#62; u:= CharacterTable( "J4M1" );
    CharacterTable( "mx1j4" )
    gap&#62; pos:= Positions( OrdersClassRepresentatives( u ), 20 );
    [ 60, 61 ]
    gap&#62; flds:= List( pos, i -&#62; Field( List( Irr( u ), x -&#62; x[i] ) ) );
    [ NF(5,[ 1, 4 ]), NF(5,[ 1, 4 ]) ]
    gap&#62; x:= Sqrt(5);;
    gap&#62; ForAll( flds, f -&#62; x in f );
    true
    gap&#62; setGaloisInfo( powermaps, Positions( orders, 20 ), orders, primes, x );

</pre>

<div class="p"><!----></div>
As a consequence, also the two classes of element order 40 must be
Galois conjugate,
the character values on these classes must lie in the same quadratic field,
and we may choose x<sub>31</sub>, x<sub>30</sub> as the squares of x<sub>53</sub>, x<sub>54</sub>,
respectively.
(Again, we choose these images in order to get the same power maps as in
the <font face="helvetica">GAP</font> table.)

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Positions( orders, 40 );
    [ 53, 54 ]
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, Sqrt( 5 ) );
    gap&#62; powermaps[2]{ pos }:= [ 31, 30 ];;

</pre>

<div class="p"><!----></div>
For each element order p  &#8712; { 31, 37, 43 },
there are three Galois conjugate conjugacy classes in J<sub>4</sub>.
Thus the character values lie in the unique cubic subfield of the
field of p-th roots of unity in each of these cases.
Without loss of generality,
we choose the representatives in such a way that

<div class="p"><!----></div>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 </td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
x<sub>43</sub><sup>&#8727;5</sup> &#160;&#8764;&#160;x<sub>44</sub>, </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
x<sub>44</sub><sup>&#8727;5</sup> &#160;&#8764;&#160;x<sub>45</sub>, </td></tr></table></td></tr>
<tr><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
x<sub>50</sub><sup>&#8727;2</sup> &#160;&#8764;&#160;x<sub>51</sub>, </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
x<sub>51</sub><sup>&#8727;2</sup> &#160;&#8764;&#160;x<sub>52</sub>, </td></tr></table></td></tr>
<tr><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
x<sub>57</sub><sup>&#8727;6</sup> &#160;&#8764;&#160;x<sub>58</sub>, </td></tr></table></td><td align="center"><table border="0" cellspacing="0" cellpadding="0"><tr><td nowrap="nowrap" align="center">
x<sub>58</sub><sup>&#8727;6</sup> &#160;&#8764;&#160;x<sub>59</sub> </td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
hold.
Note that the three cubic field extensions are generated by the
algebraic integer c<sub>p</sub> (see&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,p.&nbsp;xxvii]),
which can be created with the function <tt>EC</tt> in <font face="helvetica">GAP</font>.

<div class="p"><!----></div>

<pre>
    gap&#62; x:= EC( 31 );;
    gap&#62; classes:= [ 43 .. 45 ];;
    gap&#62; vals:= List( [ 1, 5, 25 ], k -&#62; GaloisCyc( x, k ) );;
    gap&#62; for p in primes do
    &#62;   if p mod 31 &lt;&#62; 0 then
    &#62;     for i in [ 1 .. 3 ] do
    &#62;       powermaps[p][ classes[i] ]:=
    &#62;         classes[ Position( vals, GaloisCyc( vals[i], p ) ) ];
    &#62;     od;
    &#62;   fi;
    &#62; od;
    gap&#62; x:= EC( 37 );;
    gap&#62; classes:= [ 50 .. 52 ];;
    gap&#62; vals:= List( [ 1, 2, 4 ], k -&#62; GaloisCyc( x, k ) );;
    gap&#62; for p in primes do
    &#62;   if p mod 37 &lt;&#62; 0 then
    &#62;     for i in [ 1 .. 3 ] do
    &#62;       powermaps[p][ classes[i] ]:=
    &#62;         classes[ Position( vals, GaloisCyc( vals[i], p ) ) ];
    &#62;     od;
    &#62;   fi;
    &#62; od;
    gap&#62; x:= EC( 43 );;
    gap&#62; classes:= [ 57 .. 59 ];;
    gap&#62; vals:= List( [ 1, 6, 36 ], k -&#62; GaloisCyc( x, k ) );;
    gap&#62; for p in primes do
    &#62;   if p mod 43 &lt;&#62; 0 then
    &#62;     for i in [ 1 .. 3 ] do
    &#62;       powermaps[p][ classes[i] ]:=
    &#62;         classes[ Position( vals, GaloisCyc( vals[i], p ) ) ];
    &#62;     od;
    &#62;   fi;
    &#62; od;

</pre>

<div class="p"><!----></div>
What information is missing now?

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= PositionsProperty( powermaps[2], IsList );
    [ 21, 22, 23, 35, 37, 38 ]
    gap&#62; orders{ pos };
    [ 12, 12, 12, 22, 24, 24 ]

</pre>

<div class="p"><!----></div>
The square of x<sub>35</sub> is not yet determined.
Since the centralizer order of each of the two classes of element order 11
is even, both x<sub>19</sub> and x<sub>20</sub> must have square roots of order 22,
and since x<sub>34</sub><sup>2</sup> is conjugate to x<sub>19</sub>,
we know that x<sub>35</sub><sup>2</sup> is conjugate to x<sub>20</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; powermaps[2]{ [ 34, 35 ] };
    [ 19, [ 19, 20 ] ]
    gap&#62; powermaps[2][35]:= 20;;

</pre>

<div class="p"><!----></div>
Since x<sub>23</sub> is the only representative of order 12
whose 6-th power is conjugate to x<sub>3</sub>,
and since x<sub>11</sub> is the only representative of order 6
whose cube is conjugate to x<sub>3</sub>,
we know that the square of x<sub>23</sub> is conjugate to x<sub>11</sub>.
Conversely, x<sub>11</sub> cannot be conjugate to the squares of x<sub>21</sub>
or x<sub>22</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; powermaps[2]{ [ 21, 22, 23 ] }:= [ [ 9, 10 ], [ 9, 10 ], 11 ];;

</pre>

<div class="p"><!----></div>
Because of x<sub>37</sub><sup>3</sup> &#160;&#8764;&#160;x<sub>38</sub><sup>3</sup> &#160;&#8764;&#160;x<sub>14</sub> and x<sub>14</sub><sup>2</sup> &#160;&#8764;&#160;x<sub>6</sub>,
and because the only representative of order 12 whose third power is
conjugate to x<sub>6</sub> is x<sub>21</sub>, we conclude that the squares of
x<sub>37</sub> and x<sub>38</sub> are conjugate to x<sub>21</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; powermaps[2]{ [ 37, 38 ] }:= [ 22, 22 ];;

</pre>

<div class="p"><!----></div>
Now the three open questions are
whether the classes of element order 24 are rational or not,
and whether the squares of x<sub>21</sub> and x<sub>22</sub> are conjugate to
x<sub>9</sub> or x<sub>10</sub>.

<div class="p"><!----></div>
First we show that the squares of both x<sub>21</sub> and x<sub>22</sub> are conjugate
to x<sub>10</sub>,
since the other three possibilities do not admit a class fusion from U.

<div class="p"><!----></div>

<pre>
    gap&#62; poss:= [];;
    gap&#62; for cand in [ [ 9, 9 ], [ 9, 10 ], [ 10, 9 ] ] do
    &#62;   powermaps[2]{ [ 21, 22 ] }:= cand;
    &#62;   fus:= InitFusion( u, j4 );
    &#62;   TestConsistencyMaps( ComputedPowerMaps( u ), fus, powermaps );
    &#62;   indcyc:= InducedCyclic( j4, [ 21, 22 ], "all" );
    &#62;   possfus:= FusionsAllowedByRestrictions( u, j4, Irr( u ), indcyc, fus,
    &#62;        rec( maxlen:= 10, minamb:= 1, maxamb:= 10^6, quick:= false,
    &#62;             contained:= ContainedPossibleCharacters ) );
    &#62;   Add( poss, Length( possfus ) );
    &#62; od;
    gap&#62; poss;
    [ 0, 0, 0 ]
    gap&#62; powermaps[2]{ [ 21, 22 ] }:= [ 10, 10 ];;

</pre>

<div class="p"><!----></div>
Next we show that the classes of x<sub>37</sub>, x<sub>38</sub> cannot be rational.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Positions( orders, 24 );
    [ 37, 38 ]
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, 1 );
    gap&#62; indcyc:= InducedCyclic( j4, pos, "all" );;
    gap&#62; ForAll( indcyc, x -&#62; IsInt( ScalarProduct( j4, x, x ) ) );
    false

</pre>

<div class="p"><!----></div>
Note that U contains two Galois conjugate classes of element order 24,
with character values in the field generated by &#8730;3.
Thus also the character values in the classes of x<sub>37</sub>, x<sub>38</sub> of J<sub>4</sub>
lie in this field.

<div class="p"><!----></div>

<pre>
    gap&#62; setGaloisInfo( powermaps, pos, orders, primes, Sqrt( 3 ) );

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc3.4">
3.4</a>&nbsp;&nbsp;The irreducible characters of J<sub>4</sub></h3><a name="sectirreduciblesJ4">
</a>

<div class="p"><!----></div>
We start with creating some characters of J<sub>4</sub> by inducing all linear
characters of cyclic subgroups.

<div class="p"><!----></div>

<pre>
    gap&#62; indcyc:= InducedCyclic( j4, [ 2 .. NrConjugacyClasses( j4 ) ], "all" );;

</pre>

<div class="p"><!----></div>
In order to induce characters from the subgroup U,
we have to determine the class fusion of U in J<sub>4</sub>.
For that, we use element orders, centralizer orders, power maps,
and the fact that the restrictions of the known characters of J<sub>4</sub>
are characters of U.

<div class="p"><!----></div>
Note that we may use also the character table automorphisms of U
in those cases where a pair of Galois conjugate classes of U is mapped to
a pair of Galois conjugate classes of J<sub>4</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; u:= CharacterTable( "J4M1" );
    CharacterTable( "mx1j4" )
    gap&#62; fus:= InitFusion( u, j4 );
    [ 1, [ 2, 3 ], 2, [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], [ 2, 3 ], 4, 4, 5, [ 5, 6 ], 
      [ 5, 6 ], 7, [ 5, 6 ], [ 5, 6, 7 ], [ 5, 6, 7 ], [ 5, 6, 7 ], [ 5, 6, 7 ], 
      [ 5, 6, 7 ], [ 5, 6, 7 ], [ 5, 6, 7 ], [ 5, 6, 7 ], 8, 9, [ 9, 10, 11 ], 
      [ 9, 10, 11 ], [ 9, 10, 11 ], [ 9, 10, 11 ], [ 9, 10, 11 ], [ 9, 10, 11 ], 
      [ 9, 10, 11 ], [ 12, 13 ], [ 12, 13 ], 15, 16, [ 14, 15, 16 ], 
      [ 14, 15, 16 ], [ 14, 15, 16 ], [ 14, 15, 16 ], 17, [ 17, 18 ], [ 17, 18 ], 
      [ 17, 18 ], [ 19, 20 ], [ 21, 22 ], [ 21, 22 ], [ 21, 22, 23 ], 
      [ 21, 22, 23 ], [ 21, 22, 23 ], [ 21, 22, 23 ], [ 21, 22, 23 ], 
      [ 21, 22, 23 ], [ 26, 27 ], [ 26, 27 ], [ 24, 25, 26, 27 ], 
      [ 24, 25, 26, 27 ], 28, 28, 29, [ 30, 31 ], [ 30, 31 ], [ 32, 33 ], 
      [ 32, 33 ], [ 34, 35 ], 36, 36, [ 37, 38 ], [ 37, 38 ], [ 39, 40 ], 
      [ 39, 40 ], 42, 42 ]
    gap&#62; Print( AutomorphismsOfTable( u ), "\n" );
    Group( [ (67,68), (65,66), (60,61), (57,58)(71,72), (57,58)(67,68)(71,72), 
      (57,58)(60,61)(71,72), (32,33)(53,54)(55,56)(62,63)(69,70), 
      ( 5, 6)(15,16)(21,22)(30,31)(42,43)(49,50)(51,52) ] )
    gap&#62; fus{ [ 60, 61, 67, 68, 69, 70 ] };
    [ [ 30, 31 ], [ 30, 31 ], [ 37, 38 ], [ 37, 38 ], [ 39, 40 ], [ 39, 40 ] ]
    gap&#62; fus[60]:= 30;;
    gap&#62; fus[67]:= 37;;
    gap&#62; fus[69]:= 40;;
    gap&#62; TestConsistencyMaps( ComputedPowerMaps( u ), fus,
    &#62;        ComputedPowerMaps( j4 ) );
    true

</pre>

<div class="p"><!----></div>
We get 1440 possible class fusions with the property that
all those characters of J<sub>4</sub> that are induced from cyclic subgroups
restrict to characters of U,
in 720 orbits under table automorphisms of U.

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; irr:= [ TrivialCharacter( j4 ) ];;
    gap&#62; indcyc:= ReducedOrdinary( j4, irr, indcyc );;
    gap&#62; possfus:= FusionsAllowedByRestrictions( u, j4, Irr( u ),
    &#62;      indcyc.remainders, fus,
    &#62;      rec( maxlen:= 10, minamb:= 1, maxamb:= 10^3, quick:= false,
    &#62;           contained:= ContainedPossibleCharacters ) );;
    gap&#62; Length( possfus );
    1440
    gap&#62; reps:= RepresentativesFusions( u, possfus, Group(()) );;
    gap&#62; Length( reps );
    720

</pre>

<div class="p"><!----></div>
Only two of these fusion candidates have the property that all characters
induced from U to J<sub>4</sub> have integral norms.
All scalar products between these induced characters are integral for
exactly one candidate.
Thus we have determined the class fusion up to table automorphisms of U.

<div class="p"><!----></div>

<pre>
    gap&#62; reps:= Filtered( reps,
    &#62;      map -&#62; ForAll( InducedClassFunctionsByFusionMap( u, j4, Irr(u), map ),
    &#62;                     x -&#62; IsPosInt( ScalarProduct( j4, x, x ) ) ) );;
    gap&#62; Length( reps );
    2
    gap&#62; inds:= List( reps,
    &#62;      map -&#62; InducedClassFunctionsByFusionMap( u, j4, Irr( u ), map ) );;
    gap&#62; ForAll( Flat( MatScalarProducts( j4, inds[1], inds[1] ) ), IsInt );
    false
    gap&#62; ForAll( Flat( MatScalarProducts( j4, inds[2], inds[2] ) ), IsInt );
    true

</pre>

<div class="p"><!----></div>
We reduce the induced characters with the trivial character.
Applying the LLL algorithm to the reduced characters yields 29 new
irreducibles.

<div class="p"><!----></div>

<pre>
    gap&#62; ind:= ReducedOrdinary( j4, irr, inds[2] );;
    gap&#62; Length( ind.irreducibles );
    0
    gap&#62; lll:= LLL( j4, Concatenation( indcyc.remainders, ind.remainders ) );;
    gap&#62; Length( lll.irreducibles );
    29
    gap&#62; Append( irr, lll.irreducibles );

</pre>

<div class="p"><!----></div>
The remaining LLL-reduced lattice is spanned by vectors of norm 2.
We compute irreducible characters from sublattices of the types D<sub>4</sub>
and D<sub>5</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; lll.norms;
    [ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
      2, 2, 2, 2, 2, 2, 2 ]
    gap&#62; dn:= DnLatticeIterative( j4, lll.remainders );;
    gap&#62; Length( dn.irreducibles );
    28
    gap&#62; Append( irr, dn.irreducibles );

</pre>

<div class="p"><!----></div>
Now just four irreducibles are missing.
We compute the possible orthogonal embeddings of the LLL-reduced
lattice of virtual characters into the 4-dimensional standard lattice.

<div class="p"><!----></div>

<pre>
    gap&#62; gram:= MatScalarProducts( j4, dn.remainders, dn.remainders );;
    gap&#62; emb:= OrthogonalEmbeddings( gram, 4 );;
    gap&#62; Length( emb.solutions );
    3

</pre>

<div class="p"><!----></div>
One of the three solutions does not satisfy the condition that the standard
basis vectors are irreducible characters.

<div class="p"><!----></div>

<pre>
    gap&#62; dec:= List( emb.solutions,
    &#62;                x -&#62; Decreased( j4, dn.remainders, emb.vectors{ x } ) );;
    gap&#62; dec:= Filtered( dec, x -&#62; x &lt;&#62; fail );;
    gap&#62; Length( dec );
    2

</pre>

<div class="p"><!----></div>
The first solution is not compatible with the 2-nd power map.

<div class="p"><!----></div>

<pre>
    gap&#62; possirr:= List( dec, x -&#62; x.irreducibles );;
    gap&#62; chi:= possirr[1][1];;
    gap&#62; sym:= Symmetrizations( j4, [ chi ], 2 );;
    gap&#62; ForAll( sym, x -&#62; IsInt( ScalarProduct( j4, x, chi ) ) );
    false

</pre>

<div class="p"><!----></div>
Thus we are left with one solution.
We check whether it yields a character table for J<sub>4</sub>
that is permutation equivalent to the character table in
<font face="helvetica">GAP</font>'s library of character tables,
which is equal to the table that is shown in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,pp.&nbsp;188-189].

<div class="p"><!----></div>

<pre>
    gap&#62; SetIrr( j4, List( Concatenation( irr, possirr[2] ),
    &#62;                      x -&#62; Character( j4, x ) ) );
    gap&#62; IsRecord( TransformingPermutationsCharacterTables( lib, j4 ) );
    true

</pre>

<div class="p"><!----></div>
We see that the table which we have computed is permutation equivalent
to the  A<font size="-2">TLAS</font> table of J<sub>4</sub>.

<div class="p"><!----></div>

 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;The character table of 2.<sup>2</sup>E<sub>6</sub>(2) (February 29th, 2016)</h2><a name="sect22e62">
</a>

<div class="p"><!----></div>
In the following, we compute the character table of the double cover 2.G
of the group G = <sup>2</sup>E<sub>6</sub>(2) with character theoretic methods.

<div class="p"><!----></div>
For that, we assume the character table of G,
the existence of several subgroups of 2.G,
and the knowledge of their character tables, see Section&nbsp;<a href="#assumptions2G">4.1</a>.
The first step is to determine an approximation of the conjugacy classes
of 2.G (see Section&nbsp;<a href="#theclasses">4.3</a>).
Next we determine the class fusions of the subgroups in question
(see Sections&nbsp;<a href="#f42subs">4.4</a> to&nbsp;<a href="#2o10m2subs">4.14</a>),
and finally we use standard techniques
to compute the faithful irreducible characters of 2.G
from induced characters (see Section&nbsp;<a href="#thecharacters">4.17</a>).

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Assumptions</h3><a name="assumptions2G">
</a>

<div class="p"><!----></div>
We assume that the outer automorphism group of G = <sup>2</sup>E<sub>6</sub>(2)
is isomorphic to the symmetric group of order six.
Let &#945; be an outer automorphism of order three
and &#946; be an outer automorphism of order two.

<div class="p"><!----></div>
We assume that a perfect central extension H of the structure 2<sup>2</sup>.G
exists,
and that the action of &#9001;&#945;, &#946;&#9002;
lifts to an action on H, which permutes the three central involutions
transitively.
Thus the lift of &#946; fixes a unique central subgroup of order two,
and we choose the factor group of H by this subgroup
as the double cover 2.G whose character table we are going to construct.
We denote the natural epimorphism from 2.G to G by &#960;.

<div class="p"><!----></div>
(The split extension of the chosen double cover 2.G by &#946; will be
the group 2.G.2 whose character table will be considered in
Section&nbsp;<a href="#section22e622">5</a>.)

<div class="p"><!----></div>
We assume that G contains subgroups of the following structures.

<div class="p"><!----></div>

<ul>
<li>    F<sub>4</sub>(2),
<div class="p"><!----></div>
</li>

<li>
    Fi<sub>22</sub>,
<div class="p"><!----></div>
</li>

<li>
    3 &times;U<sub>6</sub>(2) (the centralizer of an element of order three
    in G, see&nbsp;[<a href="#LSS92" name="CITELSS92">LSS92</a>,Table&nbsp;5.1]),
<div class="p"><!----></div>
</li>

<li>
    O<sup>&#8722;</sup><sub>10</sub>(2) (the centralizer in G of an element of order three
    in G.3 \G, see&nbsp;[<a href="#LSS92" name="CITELSS92">LSS92</a>,Table&nbsp;5.1]).
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Furthermore,
we assume that 2.G contains subgroups of the structure 2.F<sub>4</sub>(2),
the double cover of F<sub>4</sub>(2).
This fact is stated for example in&nbsp;[<a href="#SW99" name="CITESW99">SW99</a>,Section&nbsp;6];
I would be happy to add a reference to a proof of the statement.

<div class="p"><!----></div>
By&nbsp;[<a href="#BMO17" name="CITEBMO17">BMO17</a>],
we can assume the correctness of the character tables of
G, 2.F<sub>4</sub>(2), Fi<sub>22</sub>, U<sub>6</sub>(2), and O<sup>&#8722;</sup><sub>10</sub>(2)
that are available in the <font face="helvetica">GAP</font> Character Table Library.
(In particular, the character table of G has been computed
with MAGMA&nbsp;[<a href="#Magma" name="CITEMagma">BCP97</a>] from the smallest faithful permutation representation
of G.)

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Outer automorphisms of G</h3>

<div class="p"><!----></div>
The orbits of &#945; on the conjugacy classes of G are determined
by the character table of G,
since the group of character table automorphisms of G contains a unique
subgroup of order three.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "2E6(2)" );;
    gap&#62; t2:= CharacterTable( "2E6(2).2" );;
    gap&#62; aut:= AutomorphismsOfTable( t );;
    gap&#62; Factors( Size( aut ) );
    [ 2, 2, 2, 2, 2, 2, 2, 2, 3 ]
    gap&#62; syl:= SylowSubgroup( aut, 3 );;
    gap&#62; IsNormal( aut, syl );
    true
    gap&#62; orbs:= Orbits( syl, [ 1 .. NrConjugacyClasses( t ) ] );;
    gap&#62; orbsalpha:= List( Filtered( orbs, l -&#62; Length( l ) &lt;&#62; 1 ), Set );
    [ [ 11, 12, 13 ], [ 16, 17, 18 ], [ 39, 40, 41 ], [ 43, 44, 45 ], 
      [ 46, 47, 48 ], [ 64, 65, 66 ], [ 67, 68, 69 ], [ 75, 76, 77 ], 
      [ 78, 79, 80 ], [ 88, 89, 90 ], [ 91, 92, 93 ], [ 94, 95, 96 ], 
      [ 114, 115, 116 ], [ 117, 118, 119 ] ]

</pre>

<div class="p"><!----></div>
The orbits of &#946; on the conjugacy classes of G are determined
by the class fusion of G in G.2,
except that we have to choose one of the three possible sets of orbits,
which correspond to the three subgroups of index three in the
automorphism group of G.
We choose the case where class number 11 is fixed and
the classes 12 and 13 are swapped.

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; tfust2:= PossibleClassFusions( t, t2 );;
    gap&#62; poss:= Set( List( tfust2, l -&#62; Filtered( InverseMap( l ), IsList ) ) );
    [ [ [ 11, 12 ], [ 16, 17 ], [ 39, 40 ], [ 43, 44 ], [ 46, 47 ], [ 55, 56 ], 
          [ 61, 62 ], [ 64, 65 ], [ 67, 68 ], [ 75, 76 ], [ 78, 79 ], [ 88, 89 ], 
          [ 91, 92 ], [ 94, 95 ], [ 99, 100 ], [ 103, 104 ], [ 109, 110 ], 
          [ 114, 115 ], [ 117, 118 ], [ 123, 124 ], [ 125, 126 ] ], 
      [ [ 11, 13 ], [ 16, 18 ], [ 39, 41 ], [ 43, 45 ], [ 46, 48 ], [ 55, 56 ], 
          [ 61, 62 ], [ 64, 66 ], [ 67, 69 ], [ 75, 77 ], [ 78, 80 ], [ 88, 90 ], 
          [ 91, 93 ], [ 94, 96 ], [ 99, 100 ], [ 103, 104 ], [ 109, 110 ], 
          [ 114, 116 ], [ 117, 119 ], [ 123, 124 ], [ 125, 126 ] ], 
      [ [ 12, 13 ], [ 17, 18 ], [ 40, 41 ], [ 44, 45 ], [ 47, 48 ], [ 55, 56 ], 
          [ 61, 62 ], [ 65, 66 ], [ 68, 69 ], [ 76, 77 ], [ 79, 80 ], [ 89, 90 ], 
          [ 92, 93 ], [ 95, 96 ], [ 99, 100 ], [ 103, 104 ], [ 109, 110 ], 
          [ 115, 116 ], [ 118, 119 ], [ 123, 124 ], [ 125, 126 ] ] ]
    gap&#62; orbsbeta:= poss[3];;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;Tools for determining the conjugacy classes of 2.G</h3><a name="theclasses">
</a>

<div class="p"><!----></div>
The aim of this section is to provide <font face="helvetica">GAP</font> functions for determining
the class fusion from 2.G to G,
that is, determining for which conjugacy classes g<sup>G</sup> of G
the two elements in &#960;<sup>&#8722;1</sup>( g ) are conjugate in 2.G or not.
In the former case, &#960;<sup>&#8722;1</sup>( g<sup>G</sup> ) forms a single conjugacy class of 2.G;
we say that g<sup>G</sup> does not split.
In the latter case, &#960;<sup>&#8722;1</sup>( g<sup>G</sup> ) consists of two conjugacy classes
of 2.G; we say that g<sup>G</sup> splits.

<div class="p"><!----></div>
Let z denote the central involution in 2.G.

<div class="p"><!----></div>

      <h4><a name="tth_sEc4.3.1">
1</a>&nbsp;&nbsp;Elementary criteria</h4><a name="elementarysplitting">
</a>

<div class="p"><!----></div>
If g  &#8712; G has odd order n, say, then the two preimages of g
under &#960; have the orders n and 2 n;
hence they cannot be conjugate.

<div class="p"><!----></div>

<pre>
    gap&#62; orders:= OrdersClassRepresentatives( t );;
    gap&#62; mustsplit:= PositionsProperty( orders, IsOddInt );
    [ 1, 5, 6, 7, 23, 33, 34, 51, 52, 55, 56, 83, 86, 87, 97, 98, 103, 104, 107, 
      108, 123, 124, 125, 126 ]

</pre>

<div class="p"><!----></div>
If g  &#8712; G is self-centralizing then
the elements in &#960;<sup>&#8722;1</sup>( g ) are not conjugate in &#960;<sup>&#8722;1</sup>( G ).

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; selfCentralizingClassesSplit:= function( t, mustsplit )
    &#62;      local centralizers, orders, i;
    &#62; 
    &#62;      centralizers:= SizesCentralizers( t );
    &#62;      orders:= OrdersClassRepresentatives( t );
    &#62;      for i in [ 1 .. Length( centralizers ) ] do
    &#62;        if centralizers[i] = orders[i] and not i in mustsplit then
    &#62;          Print( "#I  class ", i, " splits (self-centralizing)\n" );
    &#62;          AddSet( mustsplit, i );
    &#62;        fi;
    &#62;      od;
    &#62;    end;;
    gap&#62; selfCentralizingClassesSplit( t, mustsplit );
    #I  class 109 splits (self-centralizing)
    #I  class 110 splits (self-centralizing)
    #I  class 120 splits (self-centralizing)
    #I  class 122 splits (self-centralizing)

</pre>

<div class="p"><!----></div>
Let g, h be elements of G, and n be an odd integer
such that h<sup>n</sup> = g holds.
If the elements in &#960;<sup>&#8722;1</sup>( g ) are not conjugate in 2.G
then also the elements in &#960;<sup>&#8722;1</sup>( h ) are not conjugate in 2.G.

<div class="p"><!----></div>
(This is in fact a generalization of the first criterion if one assumes
that the elements in  &#960;<sup>&#8722;1</sup>( 1 ) are not conjugate.)

<div class="p"><!----></div>

<pre>
    gap&#62; oddRootsOfSplittingClassesSplit:= function( t, mustsplit )
    &#62;      local powmaps, found, p, map, i;
    &#62; 
    &#62;      powmaps:= ComputedPowerMaps( t );
    &#62;      repeat
    &#62;        found:= false;
    &#62;        for p in [ 1 .. Length( powmaps ) ] do
    &#62;          if p mod 2 = 1 and IsBound( powmaps[p] ) then
    &#62;            map:= powmaps[p];
    &#62;            for i in [ 1 .. Length( map ) ] do
    &#62;              if map[i] in mustsplit and not i in mustsplit then
    &#62;                Print( "#I  class ", i, " splits (",
    &#62;                       Ordinal( p ), " root of ", map[i], ")\n" );
    &#62;                found:= true;
    &#62;                AddSet( mustsplit, i );
    &#62;              fi;
    &#62;            od;
    &#62;          fi;
    &#62;        od;
    &#62;      until found = false;
    &#62;    end;;

</pre>

<div class="p"><!----></div>
Let U be a subgroup of G, and g  &#8712; U.

<div class="p"><!----></div>
If the elements of &#960;<sup>&#8722;1</sup>( g ) are conjugate in &#960;<sup>&#8722;1</sup>( U )
then they are conjugate in &#960;<sup>&#8722;1</sup>( G ).

<div class="p"><!----></div>

<pre>
    gap&#62; notSplittingClassesOfSubgroupDoNotSplit:= function( 2sfuss, sfust,
    &#62;                                                  mustnotsplit )
    &#62;      local new, i;
    &#62; 
    &#62;      new:= sfust{ PositionsProperty( InverseMap( 2sfuss ), IsInt ) };
    &#62;      for i in Set( new ) do
    &#62;        if not i in mustnotsplit then
    &#62;          Print( "#I  class ", i, " does not split (as in subgroup)\n" );
    &#62;        fi;
    &#62;      od;
    &#62;      UniteSet( mustnotsplit, new );
    &#62;    end;;

</pre>

<div class="p"><!----></div>
If &#124;C<sub>G</sub>(g)&#124; / &#124;C<sub>U</sub>(g)&#124; is odd
and if the elements of &#960;<sup>&#8722;1</sup>( g ) are not conjugate in &#960;<sup>&#8722;1</sup>( U )
then they are not conjugate in &#960;<sup>&#8722;1</sup>( G ).

<div class="p"><!----></div>

<pre>
    gap&#62; splittingClassesWithOddCentralizerIndexSplit:= function( s, t,
    &#62;        sfust, 2sfuss, mustsplit )
    &#62;      local inv, scents, tcents, i;
    &#62; 
    &#62;      inv:= InverseMap( 2sfuss );
    &#62;      scents:= SizesCentralizers( s );
    &#62;      tcents:= SizesCentralizers( t );
    &#62;      for i in [ 1 .. Length( sfust ) ] do
    &#62;        if IsList( inv[i] ) and
    &#62;           IsOddInt( tcents[ sfust[i] ] / scents[i] ) then
    &#62;          if not sfust[i] in mustsplit then
    &#62;            Print( "#I  class ", sfust[i],
    &#62;                   " splits (odd centralizer index)\n" );
    &#62;            AddSet( mustsplit, sfust[i] );
    &#62;          fi;
    &#62;        fi;
    &#62;      od;
    &#62;      oddRootsOfSplittingClassesSplit( t, mustsplit );
    &#62;    end;;

</pre>

<div class="p"><!----></div>

      <h4><a name="tth_sEc4.3.2">
2</a>&nbsp;&nbsp;Norms of induced characters</h4><a name="normsinduced">
</a>

<div class="p"><!----></div>
The next criterion tries to exploit the fact that for a given character
of a subgroup, the norm of the induced character is an integer,
and that there are only few possibilities for the contribution of each
conjugacy class of G to this norm.

<div class="p"><!----></div>
Let U be a subgroup of G
and &#967; be a character of &#960;<sup>&#8722;1</sup>( U )
with the property &#967;( z ) = &#8722; &#967;( 1 );
then &#967;( gz ) = &#8722; &#967;( g ) holds for any g  &#8712; &#960;<sup>&#8722;1</sup>( U ).

<div class="p"><!----></div>
Fix representatives u<sub>1</sub>, u<sub>2</sub>, &#8230;, u<sub>n</sub> of the conjugacy classes of U,
choose g<sub>i</sub>  &#8712; &#960;<sup>&#8722;1</sup>( u<sub>i</sub> ),
and define the class function &#967;&#8242; of U by &#967;&#8242;( u<sub>i</sub> ) = &#967;( g<sub>i</sub> ).
Consider the induced character &#968; =  &#967;<sup>&#960;<sup>&#8722;1</sup>(G)</sup>.

<div class="p"><!----></div>
If g and gz are conjugate in &#960;<sup>&#8722;1</sup>(G) then &#968;(g) = 0 holds.
If g and gz are not conjugate in &#960;<sup>&#8722;1</sup>(G)
then set

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 R( &#960;(g) ) = { i; 1  &#8804; i  &#8804; n, g<sub>i</sub> &#160;&#8764;&#160;g &nbsp;<span class="roman">or</span>&nbsp; g<sub>i</sub> z &#160;&#8764;&#160;g },</td></tr></table>
</td></tr></table>


where &#160;&#8764;&#160; denotes conjugacy in &#960;<sup>&#8722;1</sup>(G).
Note that at most one of g<sub>i</sub>, g<sub>i</sub> z can be conjugate to g.

<div class="p"><!----></div>
Then we have

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 &#968;(g) = &#124;C<sub>&#960;<sup>&#8722;1</sup>(G)</sub>(g)&#124; &#183;</td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i  &#8712; R( &#960;(g) )</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&#177;&#967;(g<sub>i</sub>)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#124;C<sub>&#960;<sup>&#8722;1</sup>(U)</sub>(g<sub>i</sub>)&#124;<br /></td><td nowrap="nowrap" align="center">
,</td></tr></table>
</td></tr></table>


where &#177; means that there is an appropriate choice of signs
for the summands such that the equation holds.

<div class="p"><!----></div>
Since &#124;C<sub>&#960;<sup>&#8722;1</sup>(G)</sub>(g)&#124; = 2 &#183;&#124;C<sub>G</sub>( &#960;(g) )&#124;
if g and gz are not conjugate in &#960;<sup>&#8722;1</sup>(G)
and hence
&#124;C<sub>&#960;<sup>&#8722;1</sup>(U)</sub>(g<sub>i</sub>)&#124; = 2 &#183;&#124;C<sub>U</sub>(&#960;(g<sub>i</sub>))&#124;, this can be written as

<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
 &#968;(g) = &#124;C<sub>G</sub>( &#960;(g) )&#124; &#183;</td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i  &#8712; R( &#960;(g) )</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&#177;&#967;&#8242;(u<sub>i</sub>)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#124;C<sub>U</sub>(u<sub>i</sub>)&#124;<br /></td><td nowrap="nowrap" align="center">
.</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
Now we set R( &#960;(g) ) = &#8709; if g and gz are conjugate,
and get

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 [ &#968;, &#968;] </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 = </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#124;&#960;<sup>&#8722;1</sup>(G)&#124;<br /></td><td nowrap="nowrap" align="center">
&#183;</td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>g  &#8712; &#960;<sup>&#8722;1</sup>(G)</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&#124;&#968;(g)&#124;<sup>2</sup> </td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 = </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>g  &#8712; &#960;<sup>&#8722;1</sup>(G)/&#160;&#8764;&#160;</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&#124;&#968;(g)&#124;<sup>2</sup>
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2 &#183;&#124;C<sub>G</sub>( &#960;(g) )&#124;<br /></td><td nowrap="nowrap" align="center">
</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 = </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
</td><td nowrap="nowrap" align="center">
1
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>2<br /></td><td nowrap="nowrap" align="center">
&#183;</td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>g  &#8712; &#960;<sup>&#8722;1</sup>(G)/&#160;&#8764;&#160;</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&#124;C<sub>G</sub>( &#960;(g) )&#124; &#183;</td><td align="left" class="cl">&#63727;<br />&#63727;
 </td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i  &#8712; R( &#960;(g) )</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&#177;&#967;&#8242;(u<sub>i</sub>)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#124;C<sub>U</sub>(u<sub>i</sub>)&#124;<br /></td><td align="left" class="cl">&#63727;<br />&#63727;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td></tr></table></td><td width="50%"></td></tr>
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 = </td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1"></td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>g  &#8712; G/&#160;&#8764;&#160;<sub>G</sub></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
&#124;C<sub>G</sub>(g)&#124; &#183;</td><td align="left" class="cl">&#63727;<br />&#63727;
 </td><td nowrap="nowrap" align="center">
<small></small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>i  &#8712; R(g)</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
&#177;&#967;&#8242;(u<sub>i</sub>)
<div class="hrcomp"><hr noshade="noshade" size="1"/></div>&#124;C<sub>U</sub>(u<sub>i</sub>)&#124;<br /></td><td align="left" class="cl">&#63727;<br />&#63727;
</td><td nowrap="nowrap" align="center">
<small>2</small><!--sup
--><br /><br />
<small></small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
.</td></tr></table></td><td width="50%"></td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
Note that last expression on the right hand side is expressed
in terms of G.
The fact that [ &#968;, &#968;] is an integer can be turned into
a splitting criterion, as follows.

<div class="p"><!----></div>

<ul>
<li>    Classes of G that are known not to split can be ignored
    in the summation, since they contribute zero.
<div class="p"><!----></div>
</li>

<li>
    For a class g<sup>G</sup> that is known to split,
    the possible choices of signs yield at most 2<sup>&#124;R(g)&#124; &#8722; 1</sup>
    different contributions
    | &#8721;<sub>i  &#8712; R(g)</sub> [(&#177;&#967;&#8242;(u<sub>i</sub>))/(&#124;C<sub>U</sub>(u<sub>i</sub>)&#124;)] |<sup>2</sup>
    to the norm.
    The number can be much smaller, for example if some &#967;&#8242;(u<sub>i</sub>) are zero.
<div class="p"><!----></div>
</li>

<li>
    For those classes g<sup>G</sup> where we do not know whether they split,
    we get the analogous sets of possible contributions from hypothetical
    sets R(g) (if the class splits)
    plus the value zero (if the class does not split).
<div class="p"><!----></div>
</li>

<li>
    For given &#967;, we compute all those combinations of possible
    contributions for which the summation yields an integer.
    If the contribution of a given class g<sup>G</sup> to the norm of &#968;
    is nonzero in all these cases,
    we conclude that this class must split.
    If the contribution is zero in all these cases and if zero cannot be
    obtained as some
    &#8721;<sub>i  &#8712; R(g)</sub> [(&#177;&#967;&#8242;(u<sub>i</sub>))/(&#124;C<sub>U</sub>(u<sub>i</sub>)&#124;)],
    we conclude that this class must not split.
<div class="p"><!----></div>
</li>

<li>
    Our strategy is to check all irreducible characters &#967;
    of &#960;<sup>&#8722;1</sup>(U) with the property &#967;(z) = &#8722; &#967;(1),
    ordered by increasing number of combinations to be checked.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
This leads to the following <font face="helvetica">GAP</font> functions.

<div class="p"><!----></div>
The function <tt>contributionData</tt> takes
the character tables of U and G,
a list <tt>inv</tt> that describes the class fusion,
a class function (projective character) &#967;&#8242; of U,
and the list <tt>mustsplit</tt>.
The entry at position i of <tt>inv</tt> is bound if and only if
some class of U maps to class i of G;
in this cases the entry is an integer if the the class of U
at this position is the unique class of U that fuses into class i of G,
and otherwise the entry is the list of class positions in U that fuse into
this class; this data format is returned by the <font face="helvetica">GAP</font> function
<tt>InverseMap</tt>.
Positions of not splitting classes of G should be unbound in <tt>inv</tt>,
since these classes are known not to contribute to the norm of the
induced character.

<div class="p"><!----></div>
The function returns a record with the components
<tt>size</tt> (the number of combinations to be checked),
<tt>safepart</tt> (the sum of the known contributions to the norm of the induced
character),
<tt>bound</tt> (the list of positions of those classes for which only a list of
possible contributions is known),
<tt>contrib</tt> (the list of value lists for the classes in <tt>bound</tt>), and
<tt>zeroonlyifnonsplit</tt> (if the i-th entry is <tt>true</tt> then contribution 0
at i for all solutions means that the i-th class does not split).

<div class="p"><!----></div>

<pre>
    gap&#62; contributionData:= function( s, t, inv, chiprime, mustsplit )
    &#62;      local contrib, zeroonlyifnonsplit, safepart, n, tcents,
    &#62;            sclasses, i, j, val, choices, signs, cand;
    &#62; 
    &#62;      contrib:= [];
    &#62;      zeroonlyifnonsplit:= [];
    &#62;      safepart:= 0;
    &#62;      n:= 1;
    &#62;      tcents:= SizesCentralizers( t );
    &#62;      sclasses:= SizesConjugacyClasses( s );
    &#62;      for i in [ 1 .. Length( inv ) ] do
    &#62;        if IsBound( inv[i] ) then
    &#62;          # The subgroup contains elements in the 'i'-th class.
    &#62;          if IsInt( inv[i] ) then
    &#62;            # Only one class of the subgroup fuses into the 'i'-th class.
    &#62;            j:= inv[i];
    &#62;            val:= sclasses[j] * chiprime[j];
    &#62;            val:= tcents[i] / Size(s)^2 * val * GaloisCyc( val, -1 );
    &#62;            if not IsInt( val ) then
    &#62;              if i in mustsplit then
    &#62;                # The summand is known, add it to 'safepart'.
    &#62;                safepart:= safepart + val;
    &#62;              else
    &#62;                # The class may or may not split.
    &#62;                # If it splits then 'val' is the contribution to the norm.
    &#62;                contrib[i]:= [ 0, val ];
    &#62;                zeroonlyifnonsplit[i]:= true;
    &#62;                n:= n * 2;
    &#62;              fi;
    &#62;            fi;
    &#62;          else
    &#62;            # Several classes of the subgroup fuse into the 'i'-th class.
    &#62;            choices:= List( inv[i], j -&#62; sclasses[j] * chiprime[j] );
    &#62;            signs:= Tuples( [ 1, -1 ], Length( choices ) );
    &#62;            cand:= signs * choices;
    &#62;            cand:= tcents[i] / Size(s)^2 *
    &#62;                     Set( List( cand, x -&#62; x * GaloisCyc( x, -1 ) ) );
    &#62;            if not ForAll( cand, IsInt ) then
    &#62;              if Length( cand ) = 1 then
    &#62;                if i in mustsplit then
    &#62;                  # We get a contribution to 'safepart'.
    &#62;                  safepart:= safepart + cand[1];
    &#62;                else
    &#62;                  UniteSet( cand, [ 0 ] );
    &#62;                  contrib[i]:= cand;
    &#62;                  zeroonlyifnonsplit[i]:= true;
    &#62;                  n:= n * Length( cand );
    &#62;                fi;
    &#62;              else
    &#62;                if not i in mustsplit then
    &#62;                  if not 0 in cand then
    &#62;                    UniteSet( cand, [ 0 ] );
    &#62;                    zeroonlyifnonsplit[i]:= true;
    &#62;                  fi;
    &#62;                fi;
    &#62;                contrib[i]:= cand;
    &#62;                n:= n * Length( cand );
    &#62;              fi;
    &#62;            fi;
    &#62;          fi;
    &#62;        fi;
    &#62;      od;
    &#62; 
    &#62;      return rec( safepart:= safepart,
    &#62;                  contrib:= contrib,
    &#62;                  size:= n,
    &#62;                  bound:= Filtered( [ 1 .. Length( contrib ) ],
    &#62;                                    x -&#62; IsBound( contrib[x] ) ),
    &#62;                  zeroonlyifnonsplit:= zeroonlyifnonsplit,
    &#62;                );
    &#62;    end;;

</pre>

<div class="p"><!----></div>
The function <tt>integralContributions</tt> runs over all combinations
given by <tt>r.contrib</tt>,
and returns the list of those vectors whose sum plus <tt>r.safepart</tt>
is an integer.

<div class="p"><!----></div>

<pre>
    gap&#62; integralContributions:= function( r )
    &#62;      local positions, len, images, number, index, direction, initial,
    &#62;            norm, solutions, i;
    &#62; 
    &#62;      # Initialize the counter and the list of solutions.
    &#62;      positions:= r.bound;
    &#62;      len:= Length( positions );
    &#62;      images:= r.contrib{ positions };
    &#62;      number:= List( images, Length );
    &#62;      index:= ListWithIdenticalEntries( len, 1 );
    &#62;      direction:= ShallowCopy( index );  # 1 means up, -1 means down
    &#62;      initial:= List( images, l -&#62; l[1] );
    &#62;      norm:= r.safepart + Sum( initial );
    &#62;      solutions:= [];
    &#62;      if IsInt( norm ) then
    &#62;        solutions[1]:= initial;
    &#62;      fi;
    &#62; 
    &#62;      while true do
    &#62;        # Increase the counter. (Change only one position in each step.)
    &#62;        i:= 1;
    &#62;        while i &lt;= len and
    &#62;              ( ( index[i] = number[i] and direction[i] = 1 ) or
    &#62;                ( index[i] = 1 and direction[i] = -1 ) ) do
    &#62;          direction[i]:= - direction[i];
    &#62;          i:= i+1;
    &#62;        od;
    &#62; 
    &#62;        if len &lt; i then
    &#62;          # We are done.
    &#62;          return solutions;
    &#62;        fi;
    &#62; 
    &#62;        # Update at position 'i'.
    &#62;        norm:= norm - images[i][ index[i] ];
    &#62;        index[i]:= index[i] + direction[i];
    &#62;        norm:= norm + images[i][ index[i] ];
    &#62; 
    &#62;        if IsInt( norm ) then
    &#62;          # We have found a solution.
    &#62;          Add( solutions,
    &#62;               List( [ 1 .. len ], i -&#62; images[i][ index[i] ] ) );
    &#62;        fi;
    &#62;      od;
    &#62;    end;;

</pre>

<div class="p"><!----></div>
The function <tt>evaluateContributions</tt> takes
the record computed by the function <tt>contributions</tt>
and the list of vectors which yield induced class functions
with integral norms, as computed by the function <tt>integralContributions</tt>,
and extends the lists <tt>mustsplit</tt>, <tt>mustnotsplit</tt> whenever possible.

<div class="p"><!----></div>

<pre>
    gap&#62; evaluateContributions:= function( r, res, sfust,
    &#62;                                      mustsplit, mustnotsplit )
    &#62;      local param, i, c;
    &#62; 
    &#62;      param:= Parametrized( res );
    &#62;      for i in [ 1 .. Length( r.bound ) ] do
    &#62;        c:= r.bound[i];
    &#62;        if param[i] = 0 then
    &#62;          # If contribution zero cannot arise as a sum of values
    &#62;          # then the class cannot split.
    &#62;          if IsBound( r.zeroonlyifnonsplit[c] ) and
    &#62;             r.zeroonlyifnonsplit[c] = true and
    &#62;             not c in mustnotsplit then
    &#62;            Print( "#I  class ", c,
    &#62;                   " does not split (contribution criterion)\n" );
    &#62;            if c in mustsplit then
    &#62;              Error( "contradiction for class ", c );
    &#62;            fi;
    &#62;            AddSet( mustnotsplit, c );
    &#62;          fi;
    &#62;        elif IsRat( param[i] ) then
    &#62;          if not c in mustsplit then
    &#62;            Print( "#I  class ", c, " splits (contribution criterion)\n" );
    &#62;            if c in mustnotsplit then
    &#62;              Error( "contradiction for class ", c );
    &#62;            fi;
    &#62;            AddSet( mustsplit, c );
    &#62;          fi;
    &#62;        elif IsList( param[i] ) and not 0 in param[i] then
    &#62;          # If no zero occurs then the class must split.
    &#62;          if not c in mustsplit then
    &#62;            Print( "#I  class ", c, " splits (contribution criterion)\n" );
    &#62;            if c in mustnotsplit then
    &#62;              Error( "contradiction for class ", c );
    &#62;            fi;
    &#62;            AddSet( mustsplit, c );
    &#62;          fi;
    &#62;        fi;
    &#62;      od;
    &#62;    end;;

</pre>

<div class="p"><!----></div>
The strategy is implemented as follows.

<div class="p"><!----></div>

<pre>
    gap&#62; computeContributions:= function( s, t, sfust, classfuns, bound,
    &#62;                                     mustsplit, mustnotsplit )
    &#62;      local inv, i, known, candidates, r, res;
    &#62; 
    &#62;      inv:= InverseMap( sfust );
    &#62; 
    &#62;      repeat
    &#62;        for i in mustnotsplit do
    &#62;          # The induced character is zero at the preimage of 'i',
    &#62;          # there is no contribution to the norm.
    &#62;          Unbind( inv[i] );
    &#62;        od;
    &#62;        known:= [ ShallowCopy( mustsplit ), ShallowCopy( mustnotsplit ) ];
    &#62;        candidates:= List( classfuns,
    &#62;            chi -&#62; contributionData( s, t, inv, chi, mustsplit ) );
    &#62;        candidates:= Filtered( candidates, r -&#62; r.size &lt; bound );
    &#62;        SortParallel( List( candidates, r -&#62; r.size ), candidates );
    &#62;        for r in candidates do
    &#62;          res:= integralContributions( r );
    &#62;          if Length( res ) = 0 then
    &#62;            Error( "no solution" );
    &#62;          fi;
    &#62;          evaluateContributions( r, res, sfust, mustsplit, mustnotsplit );
    &#62;          oddRootsOfSplittingClassesSplit( t, mustsplit );
    &#62;        od;
    &#62;      until known = [ mustsplit, mustnotsplit ];
    &#62;    end;;

</pre>

<div class="p"><!----></div>
Note that the function <tt>computeContributions</tt> does not stop when it has
determined for all classes in question whether they split or not,
but processes all given characters.
The idea is that contradictions because of wrong assumptions should
get chances to be noticed.

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.4">
4.4</a>&nbsp;&nbsp;Subgroups of the type F<sub>4</sub>(2) in G</h3><a name="f42subs">
</a>

<div class="p"><!----></div>
There are three possible class fusion of F<sub>4</sub>(2) in G,
up to symmetries of the character table of F<sub>4</sub>(2),
and these fusions form one orbit under the action of &#945;.

<div class="p"><!----></div>

<pre>
    gap&#62; s:= CharacterTable( "F4(2)" );;
    gap&#62; fus:= PossibleClassFusions( s, t );;
    gap&#62; rep:= RepresentativesFusions( s, fus, Group( () ) );;
    gap&#62; Length( rep );
    3
    gap&#62; oneorbit:= orbsalpha[1];
    [ 11, 12, 13 ]
    gap&#62; List( rep, map -&#62; Intersection( map, oneorbit ) );
    [ [ 11 ], [ 12 ], [ 13 ] ]

</pre>

<div class="p"><!----></div>
By our assumption that G contains F<sub>4</sub>(2) type subgroups,
this means that all three possibilities are really class fusions
of F<sub>4</sub>(2) type subgroups in G.
We fix three such subgroups with these fusions,
in one orbit under the action of &#945;,
and call the subgroups M<sub>3</sub>, M<sub>4</sub>, and M<sub>5</sub>.
(Note that the three classes of maximal subgroups of the type F<sub>4</sub>(2)
in G claimed in the list in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,pp.&nbsp;191]
appear in the positions 3 to 5.)

<div class="p"><!----></div>

<pre>
    gap&#62; m3:= s;;  m3fust:= rep[1];;
    gap&#62; m4:= s;;  m4fust:= rep[2];;
    gap&#62; m5:= s;;  m5fust:= rep[3];;

</pre>

<div class="p"><!----></div>
Concerning the structures of the preimages &#960;<sup>&#8722;1</sup>( M<sub>i</sub> ),
for 3  &#8804; i  &#8804; 5,
we first note that the preimages of the three subgroups in H
are conjugate under the lift of &#945; to H.
Since the Schur multiplier of F<sub>4</sub>(2) is cyclic of order two,
the structure must be either 2 &times;2.F<sub>4</sub>(2) or 2<sup>2</sup> &times;F<sub>4</sub>(2),
and since we have assumed the existence of subgroups of the type
2.F<sub>4</sub>(2) in 2.G,
we may choose the subgroups in such a way that the former case applies.
This implies that one of the preimages in question is a direct product
2 &times;F<sub>4</sub>(2),
and the other two have the structure 2.F<sub>4</sub>(2).
Without loss of generality, we may choose the subgroups such that
&#960;<sup>&#8722;1</sup>( M<sub>3</sub> )  &#8773; 2 &times;F<sub>4</sub>(2) holds.

<div class="p"><!----></div>

<pre>
    gap&#62; 2m3:= CharacterTable( "Cyclic", 2 ) * m3;;
    gap&#62; 2m4:= CharacterTable( "2.F4(2)" );;
    gap&#62; 2m5:= 2m4;;

</pre>

<div class="p"><!----></div>
Let us apply the criteria from Section&nbsp;<a href="#theclasses">4.3</a>
to the subgroups M<sub>3</sub>, M<sub>4</sub>, M<sub>5</sub> of G.

<div class="p"><!----></div>

<pre>
    gap&#62; splittingClassesWithOddCentralizerIndexSplit( m3, t, m3fust,
    &#62;        GetFusionMap( 2m3, m3 ), mustsplit );
    #I  class 73 splits (odd centralizer index)
    #I  class 85 splits (odd centralizer index)
    #I  class 101 splits (odd centralizer index)
    #I  class 106 splits (odd centralizer index)
    gap&#62; splittingClassesWithOddCentralizerIndexSplit( m4, t, m4fust,
    &#62;        GetFusionMap( 2m4, m4 ), mustsplit );
    gap&#62; splittingClassesWithOddCentralizerIndexSplit( m5, t, m5fust,
    &#62;        GetFusionMap( 2m5, m5 ), mustsplit );
    gap&#62; mustnotsplit:= [];;
    gap&#62; notSplittingClassesOfSubgroupDoNotSplit( GetFusionMap( 2m4, m4 ),
    &#62;        m4fust, mustnotsplit );
    #I  class 9 does not split (as in subgroup)
    #I  class 12 does not split (as in subgroup)
    #I  class 14 does not split (as in subgroup)
    #I  class 17 does not split (as in subgroup)
    #I  class 20 does not split (as in subgroup)
    #I  class 21 does not split (as in subgroup)
    #I  class 22 does not split (as in subgroup)
    #I  class 44 does not split (as in subgroup)
    #I  class 47 does not split (as in subgroup)
    #I  class 49 does not split (as in subgroup)
    #I  class 58 does not split (as in subgroup)
    #I  class 68 does not split (as in subgroup)
    #I  class 72 does not split (as in subgroup)
    #I  class 79 does not split (as in subgroup)
    #I  class 81 does not split (as in subgroup)
    #I  class 82 does not split (as in subgroup)
    #I  class 92 does not split (as in subgroup)
    gap&#62; notSplittingClassesOfSubgroupDoNotSplit( GetFusionMap( 2m5, m5 ),
    &#62;        m5fust, mustnotsplit );
    #I  class 13 does not split (as in subgroup)
    #I  class 18 does not split (as in subgroup)
    #I  class 45 does not split (as in subgroup)
    #I  class 48 does not split (as in subgroup)
    #I  class 69 does not split (as in subgroup)
    #I  class 80 does not split (as in subgroup)
    #I  class 93 does not split (as in subgroup)

</pre>

<div class="p"><!----></div>
Since &#960;<sup>&#8722;1</sup>( M<sub>3</sub> ) is a direct product &#9001;z &#9002;&times;M<sub>3</sub>,
the irreducible characters of M<sub>3</sub> can be taken as the characters &#967;&#8242;
corresponding to the characters &#967;
with the property &#967;(z) = &#8722; &#967;(1).
For M<sub>4</sub> and M<sub>5</sub>, we extract the relevant projective characters
from the character table of 2.F<sub>4</sub>(2).

<div class="p"><!----></div>

<pre>
    gap&#62; computeContributions( m3, t, m3fust, Irr( m3 ), 10^7,
    &#62;        mustsplit, mustnotsplit );
    #I  class 2 splits (contribution criterion)
    #I  class 24 splits (3rd root of 2)
    #I  class 25 splits (3rd root of 2)
    #I  class 27 splits (3rd root of 2)
    #I  class 99 splits (3rd root of 27)
    #I  class 100 splits (3rd root of 27)
    #I  class 53 splits (5th root of 2)
    #I  class 8 splits (contribution criterion)
    #I  class 63 splits (3rd root of 8)
    #I  class 105 splits (5th root of 8)
    #I  class 15 splits (contribution criterion)
    #I  class 70 splits (3rd root of 15)
    #I  class 4 does not split (contribution criterion)
    #I  class 16 splits (contribution criterion)
    #I  class 78 splits (3rd root of 16)
    #I  class 59 splits (contribution criterion)
    #I  class 30 splits (contribution criterion)
    #I  class 102 splits (3rd root of 30)
    #I  class 3 splits (contribution criterion)
    #I  class 84 splits (contribution criterion)
    #I  class 26 splits (3rd root of 3)
    #I  class 28 splits (3rd root of 3)
    #I  class 54 splits (5th root of 3)
    #I  class 121 splits (5th root of 28)
    #I  class 32 splits (contribution criterion)
    #I  class 11 splits (contribution criterion)
    #I  class 67 splits (contribution criterion)
    #I  class 75 splits (contribution criterion)
    #I  class 117 splits (contribution criterion)
    #I  class 64 splits (3rd root of 11)
    #I  class 71 does not split (contribution criterion)
    gap&#62; proj:= Filtered( Irr( 2m4 ), x -&#62; x[1] &lt;&#62; x[2] );;
    gap&#62; projmap:= ProjectionMap( GetFusionMap( 2m4, m4 ) );;
    gap&#62; proj:= List( proj, x -&#62; x{ projmap } );;
    gap&#62; computeContributions( m4, t, m4fust, proj, 10^7,
    &#62;        mustsplit, mustnotsplit );
    #I  class 118 does not split (contribution criterion)
    #I  class 31 splits (contribution criterion)
    #I  class 29 does not split (contribution criterion)
    gap&#62; computeContributions( m5, t, m5fust, proj, 10^7,
    &#62;        mustsplit, mustnotsplit );
    #I  class 119 does not split (contribution criterion)
    gap&#62; mustsplit;
    [ 1, 2, 3, 5, 6, 7, 8, 11, 15, 16, 23, 24, 25, 26, 27, 28, 30, 31, 32, 33, 
      34, 51, 52, 53, 54, 55, 56, 59, 63, 64, 67, 70, 73, 75, 78, 83, 84, 85, 86, 
      87, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 117, 
      120, 121, 122, 123, 124, 125, 126 ]
    gap&#62; mustnotsplit;
    [ 4, 9, 12, 13, 14, 17, 18, 20, 21, 22, 29, 44, 45, 47, 48, 49, 58, 68, 69, 
      71, 72, 79, 80, 81, 82, 92, 93, 118, 119 ]

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.5">
4.5</a>&nbsp;&nbsp;Element orders in 2.G</h3><a name="elementorders">
</a>

<div class="p"><!----></div>
We claim that for g  &#8712; G,
the orders of the elements in &#960;<sup>&#8722;1</sup>( g ) are equal to the order of g
if this order is even.
(It is obvious that for g of odd order, one element in &#960;<sup>&#8722;1</sup>( g )
has order &#124;g&#124; and the other has order 2 &#124;g&#124;.)

<div class="p"><!----></div>
For that,
it is enough to show that the preimages of involutions in G under &#960;
are again involutions,
and this follows from the fact that M<sub>3</sub> contains elements from all
involution classes in G,
since &#960;<sup>&#8722;1</sup>( M<sub>3</sub> ) is a direct product and hence involutions in M<sub>3</sub>
lift to involutions in the preimage.

<div class="p"><!----></div>

<pre>
    gap&#62; invol:= Positions( orders, 2 );
    [ 2, 3, 4 ]
    gap&#62; Difference( invol, m3fust );
    [  ]

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.6">
4.6</a>&nbsp;&nbsp;The class fusion from &#960;<sup>&#8722;1</sup>( M<sub>3</sub> )</h3><a name="sectinitialfusion">
</a>

<div class="p"><!----></div>
In order to get more information about the classes of 2.G,
we apply a different strategy.
Currently 12 classes of G are left which contain elements of M<sub>3</sub>
and for which we do not know whether they split.

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; open:= Difference( m3fust, Union( mustsplit, mustnotsplit ) );
    [ 19, 35, 36, 39, 43, 46, 50, 91, 94, 111, 112, 114 ]

</pre>

<div class="p"><!----></div>
In fact, we need not consider all 2<sup>12</sup> combinations from this set,
because the third power map connects some of the classes.

<div class="p"><!----></div>

<pre>
    gap&#62; orders{ open };
    [ 4, 8, 8, 8, 8, 8, 8, 16, 16, 24, 24, 24 ]
    gap&#62; PowerMap( t, 3 ){ [ 111, 112, 114 ] };
    [ 35, 36, 39 ]
    gap&#62; poss:= Filtered( Combinations( open ),
    &#62;               x -&#62; ( not 35 in x or 111 in x ) and
    &#62;                    ( not 36 in x or 112 in x ) and
    &#62;                    ( not 39 in x or 114 in x ) );;
    gap&#62; Length( poss );
    1728

</pre>

<div class="p"><!----></div>
For the 1728 cases, we create a preliminary character table head
of 2.G, and compute possible class fusions from &#960;<sup>&#8722;1</sup>( M<sub>3</sub> )
into this table.
Again, the idea is to look at the norms of induced characters,
but now we will use several induced characters simultaneously.

<div class="p"><!----></div>
We need a few more <font face="helvetica">GAP</font> functions for this step.
The first one creates the character table head object that corresponds
to the proposed set of splitting classes.
We will use the information about element orders
from Section&nbsp;<a href="#elementorders">4.5</a> by setting the arguments <tt>invmustlift</tt>
and <tt>invmaylift</tt> to empty lists.

<div class="p"><!----></div>

<pre>
    gap&#62; tableHead:= function( t, tosplit, invmustlift, invmaylift )
    &#62;      local tcents, orders, splcentralizers, spl, splorders, mustlift,
    &#62;            maylift, i, pow, ord;
    &#62; 
    &#62;      tcents:= SizesCentralizers( t );
    &#62;      orders:= OrdersClassRepresentatives( t );
    &#62;      splcentralizers:= [];
    &#62;      spl:= [];
    &#62;      splorders:= [];
    &#62;      mustlift:= ShallowCopy( invmustlift );
    &#62;      maylift:= ShallowCopy( invmaylift );
    &#62; 
    &#62;      if invmaylift &lt;&#62; [] or invmustlift &lt;&#62; [] then
    &#62;        for i in [ 2 .. NrConjugacyClasses( t ) ] do
    &#62;          if orders[i] mod 2 = 0 then
    &#62;            pow:= PowerMap( t, orders[i] / 2 )[i];
    &#62;            if pow in invmustlift then
    &#62;              Add( mustlift, i );
    &#62;            elif pow in invmaylift then
    &#62;              Add( maylift, i );
    &#62;            fi;
    &#62;          fi;
    &#62;        od;
    &#62;      fi;
    &#62; 
    &#62;      for i in [ 1 .. NrConjugacyClasses( t ) ] do
    &#62;        ord:= orders[i];
    &#62;        if i in tosplit then
    &#62;          Append( spl, [ i, i ] );
    &#62;          Append( splcentralizers, tcents[i] * [ 2, 2 ] );
    &#62;          if orders[i] mod 2 = 1 then
    &#62;            Append( splorders, [ ord, 2 * ord ] );
    &#62;          elif i in mustlift then
    &#62;            Append( splorders, [ 2 * ord, 2 * ord ] );
    &#62;          elif i in maylift then
    &#62;            Append( splorders, [ [ ord, 2 * ord ], [ ord, 2 * ord ] ] );
    &#62;          else
    &#62;            Append( splorders, [ ord, ord ] );
    &#62;          fi;
    &#62;        else
    &#62;          Add( spl, i );
    &#62;          Add( splcentralizers, tcents[i] );
    &#62;          if i in mustlift then
    &#62;            Add( splorders, 2 * ord );
    &#62;          elif i in maylift then
    &#62;            Add( splorders, [ ord, 2 * ord ] );
    &#62;          else
    &#62;            Add( splorders, ord );
    &#62;          fi;
    &#62;        fi;
    &#62;      od;
    &#62; 
    &#62;      return ConvertToCharacterTableNC( rec(
    &#62;                 UnderlyingCharacteristic:= 0,
    &#62;                 OrdersClassRepresentatives:= splorders,
    &#62;                 SizesCentralizers:= splcentralizers,
    &#62;                 Size:= splcentralizers[1],
    &#62;                 ComputedClassFusions:= [ rec( name:= Identifier( t ),
    &#62;                     map:= spl ) ],
    &#62;               ) );
    &#62;  end;;

</pre>

<div class="p"><!----></div>
The next function creates an approximation of the class fusion from
the character table <tt>2s</tt> of a subgroup &#960;<sup>&#8722;1</sup>(U)
into the character table <tt>2t</tt> of &#960;<sup>&#8722;1</sup>(G),
using that the composition of the class fusions <tt>sfust</tt> from U to G
and <tt>2sfuss</tt> from &#960;<sup>&#8722;1</sup>(U) to U must be equal to the composition
of the class fusion <tt>2tfust</tt> from &#960;<sup>&#8722;1</sup>(G) to G and the desired
class fusion from &#960;<sup>&#8722;1</sup>(U) to &#960;<sup>&#8722;1</sup>(G).

<div class="p"><!----></div>
Moreover, the function takes a list <tt>defined</tt> of class positions in G
such that the preimages in 2.G have already been defined;
the fusion from one pair of classes in <tt>2s</tt> to a given pair of classes
in <tt>2t</tt> may be chosen if the numbers in the latter pair map to a class
position in <tt>t</tt> that does not occur in <tt>defined</tt>.

<div class="p"><!----></div>

<div class="p"><!----></div>
It may happen that the function returns <tt>fail</tt>,
because the splitting of classes prescribed by <tt>2tfust</tt>
is not compatible with the embedding of <tt>2s</tt> in <tt>2t</tt>.
In all other cases, the result is an approximation of the class fusion
from <tt>2s</tt> to <tt>2t</tt> in the sense that the entry at position i is either
a class position in <tt>2t</tt> (the position of the unique possible image class
of the i-th class of <tt>2s</tt>) or a list of such class positions.

<div class="p"><!----></div>

<pre>
    gap&#62; initialFusion:= function( 2s, 2t, 2sfuss, 2tfust, sfust, defined )
    &#62;      local fus, comp, pre, imgs;
    &#62; 
    &#62;      # Use element orders and centralizer orders.
    &#62;      fus:= InitFusion( 2s, 2t );
    &#62; 
    &#62;      # Use the commutative diagram.
    &#62;      comp:= CompositionMaps( InverseMap( 2tfust ),
    &#62;                              CompositionMaps( sfust, 2sfuss ) );
    &#62;      if MeetMaps( fus, comp ) &lt;&#62; true then
    &#62;        return fail;
    &#62;      fi;
    &#62; 
    &#62;      # Define classes that are not yet defined.
    &#62;      defined:= ShallowCopy( defined );
    &#62;      for pre in InverseMap( 2sfuss ) do
    &#62;        if IsList( pre ) then
    &#62;          imgs:= fus{ pre };
    &#62;          if imgs[1] = imgs[2] and IsList( imgs[1] ) then
    &#62;            if Intersection( defined, 2tfust{ imgs[1] } ) = [] then
    &#62;              # The classes in preimage and image split, and we may choose.
    &#62;              fus[ pre[1] ]:= imgs[1][1];
    &#62;              fus[ pre[2] ]:= imgs[1][2];
    &#62;              UniteSet( defined, 2tfust{ imgs[1] } );
    &#62;            fi;
    &#62;          fi;
    &#62;        elif IsList( fus[ pre ] ) then
    &#62;          # The class splits in the image but not in the preimage,
    &#62;          # we should have noticed this earlier.
    &#62;          return fail;
    &#62;        fi;
    &#62;      od;
    &#62; 
    &#62;      return fus;
    &#62;    end;;

</pre>

<div class="p"><!----></div>
The next function tries to improve an approximation of a class fusion
<tt>2sfus2t</tt> between the character tables <tt>2s</tt> and <tt>2t</tt>
by computing the class functions of <tt>2t</tt> that can be induced from a
character <tt>chi</tt> of <tt>2s</tt> via some choice of images compatible with <tt>2sfus2t</tt>,
and then computing the subset of class functions which have integral norms.
Whenever this subset allows us to deduce that some possible images
in <tt>2sfus2t</tt> cannot occur then <tt>2sfus2t</tt> gets improved in place.

<div class="p"><!----></div>
If no induced class function can have integral norm, the function returns
<tt>false</tt>, otherwise <tt>true</tt> is returned.

<div class="p"><!----></div>

<pre>
    gap&#62; useInducedClassFunction:= function( 2s, 2t, chi, 2sfuss, 2sfus2t )
    &#62;      local localfus, unknown, i, swaps, inv, pair, poss, choices, choice,
    &#62;            map, ind, para, new;
    &#62; 
    &#62;      # Remove indet. in places where the character is zero.
    &#62;      localfus:= ShallowCopy( 2sfus2t );
    &#62;      unknown:= [];
    &#62;      for i in [ 1 .. Length( 2sfus2t ) ] do
    &#62;        if IsList( 2sfus2t[i] ) then
    &#62;          if chi[i] = 0 then
    &#62;            localfus[i]:= localfus[i][1];
    &#62;          else
    &#62;            Add( unknown, i );
    &#62;          fi;
    &#62;        fi;
    &#62;      od;
    &#62; 
    &#62;      # Collect the possible swaps.
    &#62;      swaps:= [];
    &#62;      inv:= InverseMap( 2sfuss );
    &#62;      for i in [ 1 .. Length( localfus ) ] do
    &#62;        if IsList( localfus[i] ) then
    &#62;          pair:= inv[ 2sfuss[i] ];
    &#62;          Add( swaps, ( pair[1], pair[2] ) );
    &#62;          localfus{ pair }:= localfus[i];
    &#62;        fi;
    &#62;      od;
    &#62; 
    &#62;      # Try all possibilities (hopefully not too many).
    &#62;      poss:= [];
    &#62;      if IsEmpty( swaps ) then
    &#62;        choices:= [ [] ];
    &#62;      else
    &#62;        choices:= IteratorOfCombinations( swaps );
    &#62;      fi;
    &#62;      for choice in choices do
    &#62;        map:= Permuted( localfus, Product( choice, () ) );
    &#62;        ind:= InducedClassFunctionsByFusionMap( 2s, 2t, [ chi ], map )[1];
    &#62;        if IsInt( ScalarProduct( 2t, ind, ind ) ) then
    &#62;          Add( poss, map );
    &#62;        fi;
    &#62;      od;
    &#62; 
    &#62;      if poss = [] then
    &#62;        return false;
    &#62;      fi;
    &#62; 
    &#62;      para:= Parametrized( poss );
    &#62;      new:= Filtered( unknown, i -&#62; IsInt( para[i] ) );
    &#62;      if new &lt;&#62; [] then
    &#62;        2sfus2t{ new }:= para{ new };
    &#62;      fi;
    &#62; 
    &#62;      return true;
    &#62;    end;;

</pre>

<div class="p"><!----></div>
Now we check the possible splittings that can be distinguished
by characters of &#960;<sup>&#8722;1</sup>( M<sub>3</sub> ).

<div class="p"><!----></div>

<pre>
    gap&#62; good:= [];;
    gap&#62; ker:= ClassPositionsOfKernel( GetFusionMap( 2m3, m3 ) );;
    gap&#62; testcharsm3:= Filtered( Irr( 2m3 ),
    &#62;        chi -&#62; not IsSubset( ClassPositionsOfKernel( chi ), ker ) );;
    gap&#62; runOneTest:= function( s, 2s, t, 2t, sfust, testchars, defined )
    &#62;      local fus, pos, l, chi;
    &#62;      fus:= initialFusion( 2s, 2t, GetFusionMap( 2s, s ),
    &#62;                           GetFusionMap( 2t, t ), sfust, defined );
    &#62;      # Process the irreducible characters,
    &#62;      # ordered by increasing indeterminateness.
    &#62;      pos:= PositionsProperty( fus, IsList );
    &#62;      testchars:= ShallowCopy( testchars );
    &#62;      l:= - List( testchars, x -&#62; Number( pos, i -&#62; x[i] = 0 ) );
    &#62;      SortParallel( l, testchars );
    &#62;      for chi in testchars do
    &#62;        if useInducedClassFunction( 2s, 2t, chi, GetFusionMap( 2s, s ),
    &#62;                                    fus ) = false then
    &#62;          # This splitting is not possible.
    &#62;          return fail;
    &#62;        fi;
    &#62;      od;
    &#62;      return fus;
    &#62;    end;;
    gap&#62; defined:= [];;
    gap&#62; for choice in poss do
    &#62;      2t:= tableHead( t, Union( mustsplit, choice ), [], [] );
    &#62;      fus:= runOneTest( m3, 2m3, t, 2t, m3fust, testcharsm3, defined );
    &#62;      if fus &lt;&#62; fail then
    &#62;        Add( good, choice );
    &#62;      fi;
    &#62;    od;
    gap&#62; Length( good );
    1

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
We get a unique solution for the splitting.
Thus we update our lists,
create the table head corresponding to the currently known splitting,
and recompute the class fusion from &#960;<sup>&#8722;1</sup>( M<sub>3</sub> ) to 2.G,
which is also uniquely determined.

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; choice:= good[1];
    [ 19, 36, 39, 43, 46, 50, 91, 94, 111, 112, 114 ]
    gap&#62; UniteSet( mustsplit, choice );
    gap&#62; oddRootsOfSplittingClassesSplit( t, mustsplit );
    #I  class 74 splits (3rd root of 19)
    #I  class 76 splits (3rd root of 19)
    #I  class 77 splits (3rd root of 19)
    gap&#62; UniteSet( mustnotsplit, Difference( open, choice ) );
    gap&#62; Difference( [ 1 .. Length( orders ) ],
    &#62;                Union( mustsplit, mustnotsplit ) );
    [ 10, 37, 38, 40, 41, 42, 57, 60, 61, 62, 65, 66, 88, 89, 90, 95, 96, 113, 
      115, 116 ]
    gap&#62; 2t:= tableHead( t, mustsplit, [], [] );;
    gap&#62; NrConjugacyClasses( 2t );
    202
    gap&#62; 2m3fus2t:= runOneTest( m3, 2m3, t, 2t, m3fust, testcharsm3, defined );
    [ 1, 3, 5, 5, 7, 8, 10, 12, 16, 18, 14, 18, 23, 23, 22, 25, 26, 31, 23, 29, 
      31, 32, 33, 34, 36, 44, 40, 38, 42, 47, 40, 44, 46, 49, 51, 55, 53, 71, 71, 
      57, 62, 58, 63, 67, 71, 68, 75, 76, 80, 78, 82, 84, 84, 99, 92, 91, 103, 
      107, 111, 107, 111, 99, 97, 109, 111, 110, 121, 115, 125, 126, 127, 131, 
      129, 135, 133, 144, 145, 140, 140, 148, 150, 156, 158, 166, 166, 170, 168, 
      181, 176, 182, 178, 189, 185, 193, 191, 2, 4, 6, 6, 7, 9, 11, 13, 16, 19, 
      15, 19, 24, 24, 22, 26, 25, 31, 24, 30, 31, 32, 33, 35, 37, 45, 41, 39, 43, 
      48, 41, 45, 46, 50, 52, 56, 54, 72, 72, 57, 63, 59, 62, 68, 72, 67, 75, 77, 
      81, 79, 83, 85, 85, 100, 93, 91, 104, 108, 112, 108, 112, 100, 98, 109, 
      112, 110, 122, 116, 125, 126, 128, 132, 130, 136, 134, 145, 144, 141, 141, 
      149, 151, 157, 159, 167, 167, 171, 169, 182, 177, 181, 179, 190, 186, 194, 
      192 ]
    gap&#62; defined:= Set( m3fust );;

</pre>

<div class="p"><!----></div>
For later use, we compute the characters of 2.G that arise by
induction from &#960;<sup>&#8722;1</sup>( M<sub>3</sub> ).

<div class="p"><!----></div>

<pre>
    gap&#62; ind2m3:= InducedClassFunctionsByFusionMap( 2m3, 2t, testcharsm3,
    &#62;                 2m3fus2t );;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.7">
4.7</a>&nbsp;&nbsp;Subgroups of the type Fi<sub>22</sub> in G</h3><a name="fi22subs">
</a>

<div class="p"><!----></div>

<div class="p"><!----></div>
There are three possible class fusion of Fi<sub>22</sub> in G,
up to symmetries of the character table of Fi<sub>22</sub>,
and these fusions form one orbit under the action of &#945;.

<div class="p"><!----></div>

<pre>
    gap&#62; s:= CharacterTable( "Fi22" );;
    gap&#62; fus:= PossibleClassFusions( s, t );;
    gap&#62; rep:= RepresentativesFusions( s, fus, Group( () ) );;
    gap&#62; Length( rep );
    3
    gap&#62; List( rep, map -&#62; Intersection( map, oneorbit ) );
    [ [ 11 ], [ 12 ], [ 13 ] ]

</pre>

<div class="p"><!----></div>
By our assumption that G contains Fi<sub>22</sub> type subgroups,
this means that all three possibilities are really class fusions
of Fi<sub>22</sub> type subgroups in G.
We fix three such subgroups with these fusions,
in one orbit under the action of &#945;,
and call the subgroups M<sub>7</sub>, M<sub>8</sub>, and M<sub>9</sub>.
(Note that the three classes of maximal subgroups of the type Fi<sub>22</sub>
in G claimed in the list in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,pp.&nbsp;191]
appear in the positions 7 to 9.)

<div class="p"><!----></div>

<pre>
    gap&#62; m7:= s;;  m7fust:= rep[1];;
    gap&#62; m8:= s;;  m8fust:= rep[2];;
    gap&#62; m9:= s;;  m9fust:= rep[3];;

</pre>

<div class="p"><!----></div>
Concerning the structures of the preimages &#960;<sup>&#8722;1</sup>( M<sub>i</sub> ),
for 7  &#8804; i  &#8804; 9,
the same arguments as for F<sub>4</sub>(2) yield that at least one of them
is a direct product 2 &times;Fi<sub>22</sub>,
and that the other two have the same structure
-either also 2 &times;Fi<sub>22</sub> or double covers 2.Fi<sub>22</sub>.

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.8">
4.8</a>&nbsp;&nbsp;The class fusion from &#960;<sup>&#8722;1</sup>( M<sub>7</sub> )</h3>

<div class="p"><!----></div>
The first question about M<sub>7</sub> is whether &#960;<sup>&#8722;1</sup>( M<sub>7</sub> ) has the type
2.Fi<sub>22</sub> or 2 &times;Fi<sub>22</sub>.
The former case is ruled out by the fact that no fusion exists,
according to the current knowledge about 2.G.
(The reason is that class 11 of G,
which splits as a consequence of the embedding of M<sub>3</sub>,
contains elements in a class of M<sub>7</sub> that does not split.)

<div class="p"><!----></div>

<pre>
    gap&#62; open:= Difference( m7fust, Union( mustsplit, mustnotsplit ) );
    [  ]
    gap&#62; 2s:= CharacterTable( "2.Fi22" );;
    gap&#62; initialFusion( 2s, 2t, GetFusionMap( 2s, m7 ),
    &#62;        GetFusionMap( 2t, t ), m7fust, defined );
    fail

</pre>

<div class="p"><!----></div>
Thus &#960;<sup>&#8722;1</sup>( M<sub>7</sub> ) has the type 2 &times;Fi<sub>22</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; 2m7:= CharacterTable( "Cyclic", 2 ) * m7;;

</pre>

<div class="p"><!----></div>
We are now in a better situation than in the case of the subgroup M<sub>3</sub>,
since we can use that the induced characters computed above
must restrict to characters of &#960;<sup>&#8722;1</sup>( M<sub>7</sub> ).
This criterion is implemented by the <font face="helvetica">GAP</font> function
<tt>FusionsAllowedByRestrictions</tt>, which requires some parameters as its
last argument; we use the following settings.

<div class="p"><!----></div>

<pre>
    gap&#62; parametersFABR:= rec( maxlen:= 10, minamb:= 1, maxamb:= 10^6,
    &#62;        quick:= false, contained:= ContainedPossibleCharacters );;

</pre>

<div class="p"><!----></div>
The class fusion in 2.G is not uniquely determined,
we get two possibilities and also two possible lists of
characters induced from &#960;<sup>&#8722;1</sup>( M<sub>7</sub> ).

<div class="p"><!----></div>

<pre>
    gap&#62; ker:= ClassPositionsOfKernel( GetFusionMap( 2m7, m7 ) );;
    gap&#62; testcharsm7:= Filtered( Irr( 2m7 ),
    &#62;        chi -&#62; not IsSubset( ClassPositionsOfKernel( chi ), ker ) );;
    gap&#62; fus:= initialFusion( 2m7, 2t, GetFusionMap( 2m7, m7 ),
    &#62;              GetFusionMap( 2t, t ), m7fust, defined );;
    gap&#62; possfus:= FusionsAllowedByRestrictions( 2m7, 2t, testcharsm7,
    &#62;                  ind2m3, fus, parametersFABR );
    [ [ 1, 4, 5, 7, 8, 12, 10, 12, 18, 24, 26, 29, 31, 34, 37, 43, 47, 40, 39, 
          46, 52, 49, 44, 50, 51, 55, 63, 62, 68, 75, 78, 80, 80, 83, 84, 86, 88, 
          103, 99, 99, 108, 117, 119, 113, 122, 109, 112, 115, 127, 127, 132, 
          135, 140, 140, 152, 154, 157, 158, 167, 170, 172, 174, 181, 182, 194, 
          2, 3, 6, 7, 9, 13, 11, 13, 19, 23, 25, 30, 31, 35, 36, 42, 48, 41, 38, 
          46, 51, 50, 45, 49, 52, 56, 62, 63, 67, 75, 79, 81, 81, 82, 85, 87, 89, 
          104, 100, 100, 107, 118, 120, 114, 121, 109, 111, 116, 128, 128, 131, 
          136, 141, 141, 153, 155, 156, 159, 166, 171, 173, 175, 182, 181, 193 ], 
      [ 1, 4, 5, 7, 8, 12, 10, 12, 18, 24, 26, 29, 31, 34, 37, 43, 47, 40, 39, 
          46, 52, 49, 44, 50, 51, 55, 62, 63, 68, 75, 78, 80, 80, 83, 84, 86, 88, 
          103, 99, 99, 108, 117, 119, 113, 122, 109, 112, 115, 127, 127, 132, 
          135, 140, 140, 152, 154, 157, 158, 167, 170, 172, 174, 182, 181, 194, 
          2, 3, 6, 7, 9, 13, 11, 13, 19, 23, 25, 30, 31, 35, 36, 42, 48, 41, 38, 
          46, 51, 50, 45, 49, 52, 56, 63, 62, 67, 75, 79, 81, 81, 82, 85, 87, 89, 
          104, 100, 100, 107, 118, 120, 114, 121, 109, 111, 116, 128, 128, 131, 
          136, 141, 141, 153, 155, 156, 159, 166, 171, 173, 175, 181, 182, 193 ] ]
    gap&#62; poss2m7fus2t:= possfus;;
    gap&#62; UniteSet( defined, Set( m7fust ) );
    gap&#62; possind2m7:= List( poss2m7fus2t,
    &#62;        map -&#62; Set( InducedClassFunctionsByFusionMap( 2m7, 2t,
    &#62;                        testcharsm7, map ) ) );;
    gap&#62; List( possind2m7, Length );
    [ 63, 63 ]
    gap&#62; Length( Intersection( possind2m7 ) );
    39

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.9">
4.9</a>&nbsp;&nbsp;The class fusion from &#960;<sup>&#8722;1</sup>( M<sub>8</sub> )</h3>

<div class="p"><!----></div>
Now we turn to the subgroup M<sub>8</sub>.
Again, we have to decide whether its type is
2.Fi<sub>22</sub> or 2 &times;Fi<sub>22</sub>.

<div class="p"><!----></div>
This time, the latter case is ruled out by the fact that no fusion exists,
according to the current knowledge about 2.G.
For that, we first observe that the splitting of three classes
in the image of the class fusion from M<sub>8</sub> to G is not yet
decided.
We check in each of the eight possible situations that no class fusion
of 2 &times;Fi<sub>22</sub> in 2.G exists that is compatible with both the
class fusion of M<sub>8</sub> in G
and the characters of 2.G that are induced from &#960;<sup>&#8722;1</sup>( M<sub>3</sub> ).

<div class="p"><!----></div>

<pre>
    gap&#62; 2s:= 2m7;
    CharacterTable( "C2xFi22" )
    gap&#62; open:= Difference( m8fust, Union( mustsplit, mustnotsplit ) );
    [ 40, 65, 115 ]
    gap&#62; good:= [];;
    gap&#62; for choice in Combinations( open ) do
    &#62;      2t:= tableHead( t, Union( mustsplit, choice ), [], [] );
    &#62;      fus:= initialFusion( 2s, 2t, GetFusionMap( 2s, m8 ),
    &#62;                GetFusionMap( 2t, t ), m8fust, defined );;
    &#62;      if FusionsAllowedByRestrictions( 2s, 2t, testcharsm7, ind2m3, fus,
    &#62;             parametersFABR ) &lt;&#62; [] then
    &#62;        Add( good, choice );
    &#62;      fi;
    &#62;    od;
    gap&#62; good;
    [  ]

</pre>

<div class="p"><!----></div>
Thus &#960;<sup>&#8722;1</sup>( M<sub>8</sub> ) has the type 2.Fi<sub>22</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; 2m8:= CharacterTable( "2.Fi22" );;

</pre>

<div class="p"><!----></div>
This yields information about the splitting of the three classes.

<div class="p"><!----></div>

<pre>
    gap&#62; notSplittingClassesOfSubgroupDoNotSplit( GetFusionMap( 2m8, m8 ),
    &#62; m8fust, mustnotsplit );
    #I  class 40 does not split (as in subgroup)
    #I  class 65 does not split (as in subgroup)
    #I  class 115 does not split (as in subgroup)
    gap&#62; 2t:= tableHead( t, mustsplit, [], [] );;

</pre>

<div class="p"><!----></div>
The class fusion in 2.G is uniquely determined.

<div class="p"><!----></div>

<pre>
    gap&#62; ker:= ClassPositionsOfKernel( GetFusionMap( 2m8, m8 ) );;
    gap&#62; testcharsm8:= Filtered( Irr( 2m8 ),
    &#62;        chi -&#62; not IsSubset( ClassPositionsOfKernel( chi ), ker ) );;
    gap&#62; fus:= initialFusion( 2m8, 2t, GetFusionMap( 2m8, m8 ),
    &#62;        GetFusionMap( 2t, t ), m8fust, defined );;
    gap&#62; ind:= Concatenation( ind2m3, Intersection( possind2m7 ) );;
    gap&#62; possfus:= FusionsAllowedByRestrictions( 2m8, 2t, testcharsm8, ind,
    &#62;        fus, parametersFABR );
    [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 10, 11, 12, 13, 20, 23, 24, 27, 29, 
          30, 31, 34, 35, 36, 37, 42, 43, 47, 48, 40, 41, 38, 39, 46, 51, 52, 49, 
          50, 44, 45, 49, 50, 51, 52, 55, 56, 64, 64, 69, 75, 75, 78, 79, 80, 81, 
          80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 105, 101, 101, 101, 107, 108, 
          116, 115, 120, 119, 113, 114, 123, 109, 111, 112, 117, 118, 127, 128, 
          127, 128, 131, 132, 135, 136, 142, 142, 153, 152, 155, 154, 156, 157, 
          158, 159, 166, 167, 170, 171, 173, 172, 175, 174, 183, 183, 193, 194 ] ]
    gap&#62; 2m8fus2t:= possfus[1];;
    gap&#62; UniteSet( defined, m8fust );
    gap&#62; ind2m8:= InducedClassFunctionsByFusionMap( 2m8, 2t, testcharsm8,
    &#62;                 2m8fus2t );;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.10">
4.10</a>&nbsp;&nbsp;The class fusion from &#960;<sup>&#8722;1</sup>( M<sub>9</sub> )</h3>

<div class="p"><!----></div>
By the action of the outer automorphism &#946;,
we know that &#960;<sup>&#8722;1</sup>( M<sub>9</sub> ) has the type 2.Fi<sub>22</sub>.
The images under &#946; of the not splitting classes found above
do not split,
and the class fusion from &#960;<sup>&#8722;1</sup>( M<sub>9</sub> ) is determined analogously
to that from &#960;<sup>&#8722;1</sup>( M<sub>8</sub> ).

<div class="p"><!----></div>

<pre>
    gap&#62; Filtered( orbsbeta, l -&#62; Intersection( l, [ 40, 65, 115 ] ) &lt;&#62; [] );
    [ [ 40, 41 ], [ 65, 66 ], [ 115, 116 ] ]
    gap&#62; UniteSet( mustnotsplit, [ 41, 66, 116 ] );
    gap&#62; open:= Difference( m9fust, Union( mustsplit, mustnotsplit ) );
    [  ]
    gap&#62; 2m9:= 2m8;;
    gap&#62; testcharsm9:= testcharsm8;;
    gap&#62; fus:= initialFusion( 2m9, 2t, GetFusionMap( 2m9, m9 ),
    &#62;        GetFusionMap( 2t, t ), m9fust, defined );;
    gap&#62; ind:= Concatenation( ind2m3, Intersection( possind2m7 ), ind2m8 );;
    gap&#62; possfus:= FusionsAllowedByRestrictions( 2m9, 2t, testcharsm9, ind,
    &#62;        fus, parametersFABR );
    [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 10, 11, 12, 13, 21, 23, 24, 28, 29, 
          30, 31, 34, 35, 36, 37, 42, 43, 47, 48, 40, 41, 38, 39, 46, 51, 52, 49, 
          50, 44, 45, 49, 50, 51, 52, 55, 56, 65, 65, 70, 75, 75, 78, 79, 80, 81, 
          80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 106, 102, 102, 102, 107, 108, 
          116, 115, 118, 117, 113, 114, 124, 109, 111, 112, 119, 120, 127, 128, 
          127, 128, 131, 132, 135, 136, 143, 143, 153, 152, 155, 154, 156, 157, 
          158, 159, 166, 167, 170, 171, 173, 172, 175, 174, 184, 184, 193, 194 ] ]
    gap&#62; 2m9fus2t:= possfus[1];;
    gap&#62; UniteSet( defined, m9fust );
    gap&#62; ind2m9:= InducedClassFunctionsByFusionMap( 2m9, 2t, testcharsm9,
    &#62;                 2m9fus2t );;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.11">
4.11</a>&nbsp;&nbsp;The class fusion from &#960;<sup>&#8722;1</sup>( M<sub>4</sub> )</h3>

<div class="p"><!----></div>
The subgroup M<sub>4</sub> of G contains elements in one class for which
we do not know yet whether it splits.
As above, we use norms of induced characters in order to determine
the splitting.
In order to speed up <tt>runOneTest</tt>, we do <b>not</b> enter the
information about the classes of G whose preimages are already defined.
Thus we cannot use the class fusion that is returned by <tt>runOneTest</tt>,
it may be not compatible with the information which we have already
collected.

<div class="p"><!----></div>

<pre>
    gap&#62; open:= Difference( m4fust, Union( mustsplit, mustnotsplit ) );
    [ 95 ]
    gap&#62; ker:= ClassPositionsOfKernel( GetFusionMap( 2m4, m4 ) );;
    gap&#62; testcharsm4:= Filtered( Irr( 2m4 ),
    &#62;        chi -&#62; not IsSubset( ClassPositionsOfKernel( chi ), ker ) );;
    gap&#62; good:= [];;
    gap&#62; for choice in Combinations( open ) do
    &#62;      2t:= tableHead( t, Union( mustsplit, choice ), [], [] );
    &#62;      fus:= runOneTest( m4, 2m4, t, 2t, m4fust, testcharsm4, [] );
    &#62;      if fus &lt;&#62; fail then
    &#62;        Add( good, [ choice, 2t ] );
    &#62;      fi;
    &#62;    od;
    gap&#62; List( good, l -&#62; l[1] );
    [ [  ] ]
    gap&#62; UniteSet( mustnotsplit, open );
    gap&#62; 2t:= good[1][2];;
    gap&#62; 2tfust:= GetFusionMap( 2t, t );;
    gap&#62; fus:= initialFusion( 2m4, 2t, GetFusionMap( 2m4, m4 ),
    &#62;                         2tfust, m4fust, defined );;
    gap&#62; ind:= Concatenation( ind2m3, Intersection( possind2m7 ), ind2m8,
    &#62;                         ind2m9 );;
    gap&#62; possfus:= FusionsAllowedByRestrictions( 2m4, 2t, testcharsm4, ind,
    &#62;        fus, parametersFABR );
    [ [ 1, 2, 3, 4, 6, 5, 5, 6, 7, 7, 8, 9, 10, 11, 12, 13, 16, 20, 14, 15, 20, 
          20, 24, 23, 24, 23, 22, 27, 27, 27, 31, 31, 23, 24, 29, 30, 31, 32, 33, 
          34, 35, 36, 37, 45, 44, 41, 40, 38, 39, 42, 43, 48, 47, 40, 41, 44, 45, 
          46, 46, 50, 49, 52, 51, 55, 56, 53, 54, 73, 73, 73, 57, 57, 64, 64, 58, 
          59, 64, 64, 69, 73, 69, 75, 76, 77, 80, 81, 78, 79, 82, 83, 85, 84, 84, 
          85, 101, 101, 92, 93, 91, 105, 108, 107, 112, 111, 108, 107, 112, 111, 
          101, 101, 97, 98, 109, 109, 111, 112, 110, 123, 117, 118, 125, 126, 
          127, 128, 131, 132, 130, 129, 135, 136, 133, 134, 146, 146, 146, 146, 
          142, 142, 148, 149, 150, 151, 156, 157, 159, 158, 167, 166, 167, 166, 
          170, 171, 168, 169, 183, 183, 177, 176, 183, 183, 178, 179, 189, 190, 
          187, 187, 194, 193, 192, 191 ] ]
    gap&#62; 2m4fus2t:= possfus[1];;
    gap&#62; UniteSet( defined, Set( m4fust ) );
    gap&#62; ind2m4:= InducedClassFunctionsByFusionMap( 2m4, 2t, testcharsm4,
    &#62;                 2m4fus2t );;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.12">
4.12</a>&nbsp;&nbsp;The class fusion from &#960;<sup>&#8722;1</sup>( M<sub>5</sub> )</h3>

<div class="p"><!----></div>
The case &#960;<sup>&#8722;1</sup>( M<sub>5</sub> ) is analogous.
The classes in the image of the class fusion from M<sub>5</sub> to G
that are not known to split are the images under the outer automorphisms
&#946; of the classes that were considered for M<sub>4</sub>.
Thus we know that also these classes do not split.

<div class="p"><!----></div>

<pre>
    gap&#62; open:= Difference( m5fust, Union( mustsplit, mustnotsplit ) );
    [ 96 ]
    gap&#62; UniteSet( mustnotsplit, open );

</pre>

<div class="p"><!----></div>
The class fusion is determined in the same way as for M<sub>4</sub>.

<div class="p"><!----></div>

<pre>
    gap&#62; ker:= ClassPositionsOfKernel( GetFusionMap( 2m5, m5 ) );;
    gap&#62; testcharsm5:= Filtered( Irr( 2m5 ),
    &#62;        chi -&#62; not IsSubset( ClassPositionsOfKernel( chi ), ker ) );;
    gap&#62; fus:= initialFusion( 2m5, 2t, GetFusionMap( 2m5, m5 ),
    &#62;              GetFusionMap( 2t, t ), m5fust, defined );;
    gap&#62; ind:= Concatenation( ind2m3, Intersection( possind2m7 ), ind2m8,
    &#62;              ind2m9, ind2m4 );;
    gap&#62; possfus:= FusionsAllowedByRestrictions( 2m5, 2t, testcharsm5,
    &#62;                  ind, fus, parametersFABR );
    [ [ 1, 2, 3, 4, 6, 5, 5, 6, 7, 7, 8, 9, 10, 11, 12, 13, 16, 21, 14, 15, 21, 
          21, 24, 23, 24, 23, 22, 28, 28, 28, 31, 31, 23, 24, 29, 30, 31, 32, 33, 
          34, 35, 36, 37, 45, 44, 41, 40, 38, 39, 42, 43, 48, 47, 40, 41, 44, 45, 
          46, 46, 50, 49, 52, 51, 55, 56, 53, 54, 74, 74, 74, 57, 57, 65, 65, 58, 
          59, 65, 65, 70, 74, 70, 75, 76, 77, 80, 81, 78, 79, 82, 83, 85, 84, 84, 
          85, 102, 102, 92, 93, 91, 106, 108, 107, 112, 111, 108, 107, 112, 111, 
          102, 102, 97, 98, 109, 109, 111, 112, 110, 124, 119, 120, 125, 126, 
          127, 128, 131, 132, 130, 129, 135, 136, 133, 134, 147, 147, 147, 147, 
          143, 143, 148, 149, 150, 151, 156, 157, 159, 158, 167, 166, 167, 166, 
          170, 171, 168, 169, 184, 184, 177, 176, 184, 184, 178, 179, 189, 190, 
          188, 188, 194, 193, 192, 191 ] ]
    gap&#62; 2m5fus2t:= possfus[1];;
    gap&#62; UniteSet( defined, Set( m5fust ) );
    gap&#62; ind2m5:= InducedClassFunctionsByFusionMap( 2m5, 2t, testcharsm5,
    &#62;                 2m5fus2t );;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.13">
4.13</a>&nbsp;&nbsp;Subgroups of the type 3 &times;U<sub>6</sub>(2) in G</h3><a name="3u62subs">
</a>

<div class="p"><!----></div>
Let U<sub>12</sub> be a subgroup of the type 3 &times;U<sub>6</sub>(2) in G.
The preimage under &#960; may have the structure 6 &times;U<sub>6</sub>(2)
or 3 &times;2.U<sub>6</sub>(2),
where 2.U<sub>6</sub>(2) denotes the double cover of U<sub>6</sub>(2).
The latter possibility must occur, since the former does not admit
a class fusion into 2.G.

<div class="p"><!----></div>

<pre>
    gap&#62; s:= CharacterTable( "U6(2)" );;
    gap&#62; InitFusion( CharacterTable( "C6" ) * s, 2t );
    fail

</pre>

<div class="p"><!----></div>
(We construct first the character table of &#960;<sup>&#8722;1</sup>( U<sub>12</sub> )
and then that of U<sub>12</sub> as the table of the factor group by the central
subgroup of order two;
this guarantees that the factor fusion between the two tables
is automatically available.)

<div class="p"><!----></div>

<pre>
    gap&#62; 2s:= CharacterTable( "2.U6(2)" );;
    gap&#62; 2u12:= CharacterTable( "C3" ) * 2s;;
    gap&#62; orders2u12:= OrdersClassRepresentatives( 2u12 );;
    gap&#62; inv:= First( ClassPositionsOfCentre( 2u12 ), 
    &#62;                 i -&#62; orders2u12[i] = 2 );;
    gap&#62; ker:= [ 1, inv ];;
    gap&#62; u12:= 2u12 / ker;;
    gap&#62; testcharsu12:= Filtered( Irr( 2u12 ),
    &#62;        chi -&#62; not IsSubset( ClassPositionsOfKernel( chi ), ker ) );;

</pre>

<div class="p"><!----></div>
The class fusion of U<sub>12</sub> in G is not uniquely
determined up to symmetries of U<sub>12</sub>;
we get two candidates for the fusion.
(The fusion <b>is</b> unique up to symmetries of U<sub>12</sub> and G,
but our choices of the fusions for the other subgroups may have broken
some symmetries of G.)

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; fus:= PossibleClassFusions( u12, t );;
    gap&#62; rep:= RepresentativesFusions( u12, fus, Group( () ) );;
    gap&#62; Length( rep );
    2
    gap&#62; possu12fust:= rep;;

</pre>

<div class="p"><!----></div>
This subgroup yields new information about the classes of 2.G:
Seven out of the 12 classes of G for which we do not yet know
whether they split can now be shown not to split.

<div class="p"><!----></div>

<pre>
    gap&#62; List( possu12fust, map -&#62; Difference( map,
    &#62;                         Union( mustsplit, mustnotsplit ) ) );
    [ [ 10, 37, 57, 60, 61, 62, 113 ], [ 10, 37, 57, 60, 61, 62, 113 ] ]
    gap&#62; possnotsplit:= List( [ 1, 2 ], i -&#62; ShallowCopy( mustnotsplit ) );;
    gap&#62; for i in [ 1, 2 ] do
    &#62;      notSplittingClassesOfSubgroupDoNotSplit(
    &#62;          GetFusionMap( 2u12, u12 ), rep[i], possnotsplit[i] );
    &#62;    od;
    #I  class 10 does not split (as in subgroup)
    #I  class 37 does not split (as in subgroup)
    #I  class 57 does not split (as in subgroup)
    #I  class 60 does not split (as in subgroup)
    #I  class 61 does not split (as in subgroup)
    #I  class 62 does not split (as in subgroup)
    #I  class 113 does not split (as in subgroup)
    #I  class 10 does not split (as in subgroup)
    #I  class 37 does not split (as in subgroup)
    #I  class 57 does not split (as in subgroup)
    #I  class 60 does not split (as in subgroup)
    #I  class 61 does not split (as in subgroup)
    #I  class 62 does not split (as in subgroup)
    #I  class 113 does not split (as in subgroup)
    gap&#62; Set( possnotsplit );
    [ [ 4, 9, 10, 12, 13, 14, 17, 18, 20, 21, 22, 29, 35, 37, 40, 41, 44, 45, 47, 
          48, 49, 57, 58, 60, 61, 62, 65, 66, 68, 69, 71, 72, 79, 80, 81, 82, 92, 
          93, 95, 96, 113, 115, 116, 118, 119 ] ]
    gap&#62; mustnotsplit:= possnotsplit[1];;

</pre>

<div class="p"><!----></div>
We defer the computation of the possible class fusions
of &#960;<sup>&#8722;1</sup>( U<sub>12</sub> ) in 2.G
until we know characters induced from another subgroup,
in Section&nbsp;<a href="#2o10m2subs">4.14</a>.

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.14">
4.14</a>&nbsp;&nbsp;Subgroups of the type O<sup>&#8722;</sup><sub>10</sub>(2) in G</h3><a name="2o10m2subs">
</a>

<div class="p"><!----></div>
Let M<sub>10</sub> be a subgroup of type O<sup>&#8722;</sup><sub>10</sub>(2) in G.
The class fusion of M<sub>10</sub> in G is not uniquely
determined up to symmetries of M<sub>10</sub>;
we get two candidates for the fusion.
(The fusion <b>is</b> unique up to symmetries of M<sub>10</sub> and G,
but our choices of the fusions for the other subgroups may have broken
some symmetries of G.)

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; s:= CharacterTable( "O10-(2)" );;
    gap&#62; fus:= PossibleClassFusions( s, t );;
    gap&#62; rep:= RepresentativesFusions( s, fus, Group( () ) );;
    gap&#62; Length( rep );
    2
    gap&#62; m10:= s;;  possm10fust:= rep;;

</pre>

<div class="p"><!----></div>
The Schur multiplier of O<sup>&#8722;</sup><sub>10</sub>(2) is trivial,
thus &#960;<sup>&#8722;1</sup>( M<sub>10</sub> ) is a direct product 2 &times;O<sup>&#8722;</sup><sub>10</sub>(2).

<div class="p"><!----></div>

<pre>
    gap&#62; 2m10:= CharacterTable( "Cyclic", 2 ) * m10;;

</pre>

<div class="p"><!----></div>
The subgroup M<sub>10</sub> contains elements from one class of G
for which we do not know yet whether it splits.
This class turns out not to split.

<div class="p"><!----></div>

<pre>
    gap&#62; List( possm10fust, map -&#62; Difference( map,
    &#62;                         Union( mustsplit, mustnotsplit ) ) );
    [ [ 42 ], [ 42 ] ]
    gap&#62; possnotsplit:= List( [ 1, 2 ], i -&#62; ShallowCopy( mustnotsplit ) );;
    gap&#62; for i in [ 1, 2 ] do
    &#62;      computeContributions( m10, t, possm10fust[i], Irr( m10 ), 10^7,
    &#62;          ShallowCopy( mustsplit ), possnotsplit[i] );
    &#62;    od;
    #I  class 42 does not split (contribution criterion)
    #I  class 42 does not split (contribution criterion)
    gap&#62; Set( possnotsplit );
    [ [ 4, 9, 10, 12, 13, 14, 17, 18, 20, 21, 22, 29, 35, 37, 40, 41, 42, 44, 45, 
          47, 48, 49, 57, 58, 60, 61, 62, 65, 66, 68, 69, 71, 72, 79, 80, 81, 82, 
          92, 93, 95, 96, 113, 115, 116, 118, 119 ] ]
    gap&#62; mustnotsplit:= possnotsplit[1];;

</pre>

<div class="p"><!----></div>
For each of the two possible class fusions of M<sub>10</sub> in G,
we get a unique possible class fusion of &#960;<sup>&#8722;1</sup>( M<sub>10</sub> ) in 2.G.

<div class="p"><!----></div>

<pre>
    gap&#62; fus:= List( rep, map -&#62; initialFusion( 2m10, 2t,
    &#62;                 GetFusionMap( 2m10, m10 ), GetFusionMap( 2t, t ),
    &#62;                 map, defined ) );;
    gap&#62; ker:= ClassPositionsOfKernel( GetFusionMap( 2m10, m10 ) );;
    gap&#62; testcharsm10:= Filtered( Irr( 2m10 ),
    &#62;        chi -&#62; not IsSubset( ClassPositionsOfKernel( chi ), ker ) );;
    gap&#62; ind:= Concatenation( ind2m3, ind2m4, ind2m5,
    &#62;              Intersection( possind2m7 ), ind2m8, ind2m9 );;
    gap&#62; possfus:= List( fus, map -&#62; FusionsAllowedByRestrictions( 2m10, 2t,
    &#62;                  testcharsm10, ind, map, parametersFABR ) );
    [ [ [ 1, 3, 5, 5, 7, 10, 8, 8, 8, 10, 12, 16, 14, 17, 23, 22, 23, 31, 29, 33, 
              34, 34, 38, 36, 36, 36, 44, 44, 44, 40, 40, 36, 49, 42, 42, 38, 40, 
              42, 47, 40, 44, 47, 47, 46, 51, 53, 58, 57, 60, 66, 75, 76, 78, 78, 
              78, 78, 82, 84, 84, 86, 88, 92, 90, 90, 97, 94, 94, 90, 111, 111, 
              111, 92, 91, 94, 107, 107, 113, 107, 95, 96, 111, 110, 109, 129, 
              133, 133, 133, 135, 133, 135, 135, 148, 150, 153, 155, 153, 155, 
              158, 164, 166, 168, 178, 176, 180, 180, 191, 191, 191, 193, 195, 
              197, 197, 195, 199, 201, 2, 4, 6, 6, 7, 11, 9, 9, 9, 11, 13, 16, 
              15, 17, 24, 22, 24, 31, 30, 33, 35, 35, 39, 37, 37, 37, 45, 45, 45, 
              41, 41, 37, 50, 43, 43, 39, 41, 43, 48, 41, 45, 48, 48, 46, 52, 54, 
              59, 57, 60, 66, 75, 77, 79, 79, 79, 79, 83, 85, 85, 87, 89, 93, 90, 
              90, 98, 94, 94, 90, 112, 112, 112, 93, 91, 94, 108, 108, 114, 108, 
              95, 96, 112, 110, 109, 130, 134, 134, 134, 136, 134, 136, 136, 149, 
              151, 152, 154, 152, 154, 159, 165, 167, 169, 179, 177, 180, 180, 
              192, 192, 192, 194, 196, 198, 198, 196, 200, 202 ] ], 
      [ [ 1, 3, 5, 5, 7, 10, 8, 8, 8, 10, 12, 16, 14, 17, 23, 22, 23, 31, 29, 33, 
              34, 34, 38, 36, 36, 36, 44, 44, 44, 40, 40, 36, 49, 42, 42, 38, 40, 
              42, 47, 40, 44, 47, 47, 46, 51, 53, 58, 57, 60, 66, 75, 76, 78, 78, 
              78, 78, 82, 84, 84, 86, 88, 92, 90, 90, 97, 94, 94, 90, 111, 111, 
              111, 92, 91, 94, 107, 107, 113, 107, 95, 96, 111, 110, 109, 129, 
              133, 133, 133, 135, 133, 135, 135, 148, 150, 155, 153, 155, 153, 
              158, 164, 166, 168, 178, 176, 180, 180, 191, 191, 191, 193, 195, 
              197, 197, 195, 199, 201, 2, 4, 6, 6, 7, 11, 9, 9, 9, 11, 13, 16, 
              15, 17, 24, 22, 24, 31, 30, 33, 35, 35, 39, 37, 37, 37, 45, 45, 45, 
              41, 41, 37, 50, 43, 43, 39, 41, 43, 48, 41, 45, 48, 48, 46, 52, 54, 
              59, 57, 60, 66, 75, 77, 79, 79, 79, 79, 83, 85, 85, 87, 89, 93, 90, 
              90, 98, 94, 94, 90, 112, 112, 112, 93, 91, 94, 108, 108, 114, 108, 
              95, 96, 112, 110, 109, 130, 134, 134, 134, 136, 134, 136, 136, 149, 
              151, 154, 152, 154, 152, 159, 165, 167, 169, 179, 177, 180, 180, 
              192, 192, 192, 194, 196, 198, 198, 196, 200, 202 ] ] ]
    gap&#62; List( possfus, Length );
    [ 1, 1 ]
    gap&#62; poss2m10fus2t:= Concatenation( possfus );;
    gap&#62; Set( possm10fust[1] ) = Set( possm10fust[2] );
    true
    gap&#62; UniteSet( defined, possm10fust[1] );

</pre>

<div class="p"><!----></div>
The set of induced characters is the same
for each of the two fusion candidates.

<div class="p"><!----></div>

<pre>
    gap&#62; possind2m10:= List( poss2m10fus2t,
    &#62;        map -&#62; Set( InducedClassFunctionsByFusionMap( 2m10, 2t,
    &#62;                        testcharsm10, map ) ) );;
    gap&#62; possind2m10[1] = possind2m10[2];
    true
    gap&#62; ind2m10:= possind2m10[1];;

</pre>

<div class="p"><!----></div>
With the help of these characters, we can show that
for each of the two possible class fusions of U<sub>12</sub> in G,
we get a unique possible class fusion of &#960;<sup>&#8722;1</sup>( U<sub>12</sub> ) in 2.G.

<div class="p"><!----></div>

<pre>
    gap&#62; fus:= List( possu12fust, map -&#62; initialFusion( 2u12, 2t,
    &#62;                 GetFusionMap( 2u12, u12 ), GetFusionMap( 2t, t ),
    &#62;                 map, defined ) );;
    gap&#62; ind:= Concatenation( ind2m3, ind2m4, ind2m5,
    &#62;              Intersection( possind2m7 ), ind2m8, ind2m9, ind2m10 );;
    gap&#62; possfus:= List( fus, map -&#62; FusionsAllowedByRestrictions( 2u12, 2t,
    &#62;                  testcharsu12, ind, map, parametersFABR ) );
    [ [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 10, 11, 16, 17, 18, 19, 20, 21, 23, 
              24, 31, 34, 35, 42, 43, 42, 43, 36, 37, 47, 48, 40, 41, 38, 39, 44, 
              45, 49, 50, 55, 56, 60, 62, 63, 64, 65, 78, 79, 78, 79, 80, 81, 82, 
              83, 86, 87, 88, 89, 91, 91, 90, 90, 95, 96, 103, 104, 105, 106, 
              107, 108, 135, 136, 153, 152, 155, 154, 8, 9, 36, 37, 40, 41, 46, 
              10, 11, 8, 9, 12, 13, 90, 94, 99, 100, 101, 102, 107, 108, 109, 
              135, 136, 36, 37, 36, 37, 38, 39, 40, 41, 44, 45, 42, 43, 47, 48, 
              51, 52, 170, 171, 180, 181, 182, 183, 184, 78, 79, 78, 79, 80, 81, 
              193, 194, 195, 196, 197, 198, 90, 90, 92, 93, 94, 94, 99, 100, 101, 
              102, 111, 112, 133, 134, 153, 152, 155, 154, 8, 9, 36, 37, 40, 41, 
              46, 10, 11, 8, 9, 12, 13, 90, 94, 99, 100, 101, 102, 107, 108, 109, 
              135, 136, 36, 37, 36, 37, 38, 39, 40, 41, 44, 45, 42, 43, 47, 48, 
              51, 52, 170, 171, 180, 181, 182, 183, 184, 78, 79, 78, 79, 80, 81, 
              193, 194, 195, 196, 197, 198, 90, 90, 92, 93, 94, 94, 99, 100, 101, 
              102, 111, 112, 133, 134, 153, 152, 155, 154 ] ], 
      [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 10, 11, 16, 17, 18, 19, 20, 21, 23, 
              24, 31, 34, 35, 42, 43, 42, 43, 36, 37, 47, 48, 40, 41, 38, 39, 44, 
              45, 49, 50, 55, 56, 60, 62, 63, 64, 65, 78, 79, 78, 79, 80, 81, 82, 
              83, 86, 87, 88, 89, 91, 91, 90, 90, 95, 96, 103, 104, 105, 106, 
              107, 108, 135, 136, 155, 154, 153, 152, 8, 9, 36, 37, 40, 41, 46, 
              10, 11, 8, 9, 12, 13, 90, 94, 99, 100, 101, 102, 107, 108, 109, 
              135, 136, 36, 37, 36, 37, 38, 39, 40, 41, 44, 45, 42, 43, 47, 48, 
              51, 52, 170, 171, 180, 181, 182, 183, 184, 78, 79, 78, 79, 80, 81, 
              193, 194, 195, 196, 197, 198, 90, 90, 92, 93, 94, 94, 99, 100, 101, 
              102, 111, 112, 133, 134, 155, 154, 153, 152, 8, 9, 36, 37, 40, 41, 
              46, 10, 11, 8, 9, 12, 13, 90, 94, 99, 100, 101, 102, 107, 108, 109, 
              135, 136, 36, 37, 36, 37, 38, 39, 40, 41, 44, 45, 42, 43, 47, 48, 
              51, 52, 170, 171, 180, 181, 182, 183, 184, 78, 79, 78, 79, 80, 81, 
              193, 194, 195, 196, 197, 198, 90, 90, 92, 93, 94, 94, 99, 100, 101, 
              102, 111, 112, 133, 134, 155, 154, 153, 152 ] ] ]
    gap&#62; List( possfus, Length );
    [ 1, 1 ]
    gap&#62; poss2u12fus2t:= Concatenation( possfus );;
    gap&#62; Set( possu12fust[1] ) = Set( possu12fust[2] );
    true
    gap&#62; UniteSet( defined, possu12fust[1] );

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
The set of induced characters is the same
for each of the two fusion candidates.

<div class="p"><!----></div>

<pre>
    gap&#62; possind2u12:= List( poss2u12fus2t,
    &#62;        map -&#62; Set( InducedClassFunctionsByFusionMap( 2u12, 2t,
    &#62;                        testcharsu12, map ) ) );;
    gap&#62; possind2u12[1] = possind2u12[2];
    true
    gap&#62; ind2u12:= possind2u12[1];;

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.15">
4.15</a>&nbsp;&nbsp;What do we know up to now about the table of 2.G?</h3>

<div class="p"><!----></div>
We have determined for all except four classes of G whether they split
or not.

<div class="p"><!----></div>

<pre>
    gap&#62; posssplit:= Difference( [ 1 .. Length( orders ) ],
    &#62;                            Union( mustsplit, mustnotsplit ) );
    [ 38, 88, 89, 90 ]
    gap&#62; NrConjugacyClasses( t );
    126
    gap&#62; NrConjugacyClasses( 2t );
    202

</pre>

<div class="p"><!----></div>
Thus 2.G has at least 202 and at most 206 classes,
and we have to compute at least 76 and at most 80 faithful
irreducible characters.
If some of the above four classes split then the class fusions of the
subgroups have to be adjusted by shifting the image classes
appropriately.

<div class="p"><!----></div>
For the subgroups
U  &#8712; { M<sub>3</sub>, M<sub>4</sub>, M<sub>5</sub>, M<sub>7</sub>, M<sub>8</sub>, M<sub>9</sub>, M<sub>10</sub>, U<sub>12</sub> } of G,
we have computed characters of 2.G by induction from &#960;<sup>&#8722;1</sup>( U ).
For the subgroup &#960;<sup>&#8722;1</sup>( M<sub>7</sub> ) of 2.G,
we know only two possible sets of induced characters.
Now we are able to eliminate one of these cases.

<div class="p"><!----></div>

<pre>
    gap&#62; ForAll( ind2u12,
    &#62;        chi -&#62; ForAll( possind2m7[1],
    &#62;                   psi -&#62; IsInt( ScalarProduct( 2t, chi, psi ) ) ) );
    false

</pre>

<div class="p"><!----></div>
This means that we know the class fusion from &#960;<sup>&#8722;1</sup>( M<sub>7</sub> ) to 2.G,
and the corresponding induced characters.

<div class="p"><!----></div>

<pre>
    gap&#62; 2m7fus2t:= poss2m7fus2t[2];;
    gap&#62; ind2m7:= possind2m7[2];;

</pre>

<div class="p"><!----></div>
The known induced characters do not span the subspace of all "faithful
class functions of 2.G", that is, those class functions &#968; with
the property &#968;( g ) = &#8722; &#968;( g z ),
since all known induced characters are zero on the preimages in 2.G
of elements of order 19 in G.

<div class="p"><!----></div>

<pre>
    gap&#62; nothit:= Difference( [ 1 .. Length( orders ) ],
    &#62;                 Flat( [ m3fust, m4fust, m5fust, m7fust, m8fust, m9fust,
    &#62;                         possm10fust, possu12fust ] ) );
    [ 38, 88, 89, 90, 103, 104 ]
    gap&#62; orders{ nothit };
    [ 8, 16, 16, 16, 19, 19 ]

</pre>

<div class="p"><!----></div>
Thus we need some more characters of 2.G.

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.16">
4.16</a>&nbsp;&nbsp;Additional characters of 2.G</h3><a name="minuscharacters">
</a>

<div class="p"><!----></div>
First we compute characters with nonzero values on the classes of element
order 38,
by inducing from the cyclic subgroups of order 38 in 2.G.
For that, we need some power maps of 2.G on the classes that contain
elements in these subgroups;
this information is determined by the corresponding power maps of G.

<div class="p"><!----></div>

<pre>
    gap&#62; for p in [ 2 .. Maximum( OrdersClassRepresentatives( 2t ) ) ] do
    &#62;      if IsPrimeInt( p ) then
    &#62;        PowerMap( t, p );
    &#62;        pow:= InitPowerMap( 2t, p );
    &#62;        comp:= CompositionMaps( InverseMap( GetFusionMap( 2t, t ) ),
    &#62;                   CompositionMaps( PowerMap( t, p ),
    &#62;                      GetFusionMap( 2t, t ) ) );
    &#62;        MeetMaps( pow, comp );
    &#62;        ComputedPowerMaps( 2t )[p]:= pow;
    &#62;      fi;
    &#62;    od;

</pre>

<div class="p"><!----></div>
Note that we need only the faithful induced characters.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Positions( OrdersClassRepresentatives( 2t ), 38 );
    [ 161, 163 ]
    gap&#62; indcyc:= Filtered( InducedCyclic( 2t, pos, "all" ),
    &#62;                       chi -&#62; chi[1] = - chi[2] );;

</pre>

<div class="p"><!----></div>
Additionally, we compute also some 5-th symmetrizations
of induced characters.
For a given character &#967;, the symmetrization in question
is &#967;<sup>5&#8722;</sup>, given by &#967;<sup>5&#8722;</sup>(g) = (&#967;(g)<sup>5</sup> &#8722; &#967;(g)) / 5.

<div class="p"><!----></div>
For that, we need the 5-th power map on all classes of 2.G.
The compatibility with the 5-th power maps of &#960;<sup>&#8722;1</sup>( U ),
for U  &#8712; { M<sub>3</sub>, M<sub>7</sub>, M<sub>10</sub> },
determines the map uniquely,
and we can compute the symmetrizations.

<div class="p"><!----></div>
Note that the four classes of G which might split consist of elements
of 2-power order; each of these classes maps to itself under the
5-th power map, and there are no other 5-th roots than itself.
Thus the symmetrizations are independent of their potential splitting.

<div class="p"><!----></div>

<pre>
    gap&#62; pow:= ComputedPowerMaps( 2t )[5];;
    gap&#62; comp:= CompositionMaps( CompositionMaps( 2m3fus2t, PowerMap( 2m3, 5 ) ),
    &#62;                            InverseMap( 2m3fus2t ) );;
    gap&#62; MeetMaps( pow, comp );
    true
    gap&#62; comp:= CompositionMaps( CompositionMaps( 2m7fus2t, PowerMap( 2m7, 5 ) ),
    &#62;                            InverseMap( 2m7fus2t ) );;
    gap&#62; MeetMaps( pow, comp );
    true
    gap&#62; fus:= Parametrized( poss2m10fus2t );;
    gap&#62; comp:= CompositionMaps( CompositionMaps( fus, PowerMap( 2m10, 5 ) ),
    &#62;                            InverseMap( fus ) );;
    gap&#62; MeetMaps( pow, comp );
    true
    gap&#62; ForAll( pow, IsInt );
    true
    gap&#62; Intersection( PowerMap( t, 5 ), posssplit ) = posssplit;
    true
    gap&#62; ForAll( posssplit, i -&#62; Positions( PowerMap( t, 5 ), i ) = [ i ] );
    true
    gap&#62; ind:= Concatenation(
    &#62;              [ ind2m3, ind2m4, ind2m5, ind2m7, ind2m8, ind2m9 ] );;
    gap&#62; minus:= List( ind, chi -&#62; MinusCharacter( chi, pow, 5 ) );;
    gap&#62; ind:= Concatenation(
    &#62;              [ ind2m3, ind2m4, ind2m5, minus, ind2m7, ind2m8, ind2m9,
    &#62;                ind2u12, ind2m10, indcyc ] );;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc4.17">
4.17</a>&nbsp;&nbsp;The faithful irreducible characters of 2.G</h3><a name="thecharacters">
</a>

<div class="p"><!----></div>
First we apply the LLL algorithm to our characters of 2.G.
This yields two irreducible characters.
We project the lattice basis to the orthogonal space of the found
irreducibles, apply LLL again, and find two more irreducible characters.

<div class="p"><!----></div>

<pre>
    gap&#62; lll:= LLL( 2t, ind );;
    gap&#62; Length( lll.irreducibles );
    2
    gap&#62; irr:= Set( lll.irreducibles );;
    gap&#62; red:= Reduced( 2t, irr, lll.remainders );;
    gap&#62; lll:= LLL( 2t, red.remainders );;
    gap&#62; Length( lll.irreducibles );
    2
    gap&#62; UniteSet( irr, lll.irreducibles );
    gap&#62; red:= Reduced( 2t, irr, lll.remainders );;
    gap&#62; lll:= LLL( 2t, red.remainders );;
    gap&#62; Sum( lll.norms );
    772
    gap&#62; lll:= LLL( 2t, lll.remainders, "sort" );;
    gap&#62; Sum( lll.norms );
    729
    gap&#62; Length( lll.irreducibles );
    0
    gap&#62; red:= Reduced( 2t, irr, lll.remainders );;
    gap&#62; lll:= LLL( 2t, red.remainders );;
    gap&#62; Sum( lll.norms );
    710

</pre>

<div class="p"><!----></div>
Now we have a basis for a 72-dimensional lattice,
and compute all possible orthogonal embeddings of this lattice
into a 76-dimensional lattice.
(Note that four more classes of G may split.)

<div class="p"><!----></div>

<pre>
    gap&#62; Length( lll.norms );
    72
    gap&#62; gram:= MatScalarProducts( 2t, lll.remainders, lll.remainders );;
    gap&#62; emb:= OrthogonalEmbeddings( gram, 72 + 4 );;
    gap&#62; Length( emb.solutions );
    1
    gap&#62; Length( emb.solutions[1] );
    72

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
There is a unique solution, and we get 72 new irreducibles.
Together with the 126 irreducibles of the factor group G
and the known four faithful irreducibles,
this yields a square matrix of dimension 202.

<div class="p"><!----></div>

<pre>
    gap&#62; dec:= Decreased( 2t, lll.remainders,
    &#62;                     emb.vectors{ emb.solutions[1] } );;
    gap&#62; Length( dec.irreducibles );
    72
    gap&#62; UniteSet( irr, dec.irreducibles );
    gap&#62; factchars:= RestrictedClassFunctions( Irr( t ), 2t );;
    gap&#62; irr:= Concatenation( factchars, irr );;
    gap&#62; DimensionsMat( irr );
    [ 202, 202 ]

</pre>

<div class="p"><!----></div>
Since the squares of the degrees add up to the group order,
we are done.

<div class="p"><!----></div>

<pre>
    gap&#62; Size( 2t ) = Sum( List( irr, chi -&#62; chi[1]^2 ) );
    true
    gap&#62; SetIrr( 2t, List( irr, x -&#62; Character( 2t, x ) ) );

</pre>

<div class="p"><!----></div>
Finally, we check whether the character table for 2.G
is permutation equivalent to the character table in
<font face="helvetica">GAP</font>'s library of character tables,
which is equal to the table that is shown in&nbsp;[<a href="#CCN85" name="CITECCN85">CCN<sup>+</sup>85</a>,pp.&nbsp;192-199].

<div class="p"><!----></div>
For that, we compute the power maps of 2.G,
using the known power maps of G, the element orders of 2.G,
and the irreducible characters of 2.G;
it turns out that the power maps are uniquely determined by
this information.

<div class="p"><!----></div>

<pre>
    gap&#62; for p in [ 2 .. Maximum( OrdersClassRepresentatives( 2t ) ) ] do
    &#62;      if IsPrimeInt( p ) then
    &#62;        poss:= PossiblePowerMaps( 2t, p,
    &#62;                   rec( powermap:= ComputedPowerMaps( 2t )[p] ) );
    &#62;        if Length( poss ) &lt;&#62; 1 then
    &#62;          Error( "problem with ", Ordinal( p ), " power map" );
    &#62;        fi;
    &#62;        ComputedPowerMaps( 2t )[p]:= poss[1];
    &#62;      fi;
    &#62;    od;
    gap&#62; lib:= CharacterTable( "2.2E6(2)" );;
    gap&#62; tr:= TransformingPermutationsCharacterTables( lib, 2t );;
    gap&#62; IsRecord( tr );
    true

</pre>

<div class="p"><!----></div>
The two tables are equivalent only up to a permutation of the classes.

<div class="p"><!----></div>

<pre>
    gap&#62; tr.columns;
    (25,26)(62,63)(67,68)(121,122)(144,145)(152,153)(154,155)(172,173)(174,
    175)(181,182)

</pre>

<div class="p"><!----></div>
This is due to the choices in the function <tt>initialFusion</tt>,
see Section&nbsp;<a href="#sectinitialfusion">4.6</a>.

<div class="p"><!----></div>

<div class="p"><!----></div>

 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;The character table of 2.<sup>2</sup>E<sub>6</sub>(2).2 (March 28th, 2016)</h2><a name="section22e622">
</a>

<div class="p"><!----></div>
In the following, we compute the character table of a bicyclic extension
2.G.2 of the simple group G = <sup>2</sup>E<sub>6</sub>(2)
with character theoretic methods.

<div class="p"><!----></div>
For that, we assume the character tables of G, G.2,
and 2.G (see Section&nbsp;<a href="#sect22e62">4</a>),
the existence of subgroups of the structures 2 &times;F<sub>4</sub>(2) &times;2
and 3 &times;2.U<sub>6</sub>(2).2 in 2.G.2,
and the knowledge of their character tables,
see Sections&nbsp;<a href="#2s2">5.2</a> and&nbsp;<a href="#2u2">5.3</a>.

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;Class numbers of 2.G.2</h3><a name="classnumbers2G2">
</a>

<div class="p"><!----></div>
The action of the field automorphism &#946; of G on the
conjugacy classes of G is determined by the class fusion of G in G.2.
The action of the lift of &#946; to 2.G is uniquely determined by this
permutation, the table of 2.G, and the factor fusion from 2.G to G.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "2E6(2)" );;
    gap&#62; t2:= CharacterTable( "2E6(2).2" );;
    gap&#62; 2t:= CharacterTable( "2.2E6(2)" );;
    gap&#62; tfust2:= GetFusionMap( t, t2 );;
    gap&#62; 2tfust:= GetFusionMap( 2t, t );;
    gap&#62; orbsbeta:= Filtered( InverseMap( tfust2 ), IsList );
    [ [ 12, 13 ], [ 17, 18 ], [ 40, 41 ], [ 44, 45 ], [ 47, 48 ], [ 55, 56 ], 
      [ 61, 62 ], [ 65, 66 ], [ 68, 69 ], [ 76, 77 ], [ 79, 80 ], [ 89, 90 ], 
      [ 92, 93 ], [ 95, 96 ], [ 99, 100 ], [ 103, 104 ], [ 109, 110 ], 
      [ 115, 116 ], [ 118, 119 ], [ 123, 124 ], [ 125, 126 ] ]
    gap&#62; beta:= Product( List( orbsbeta, x -&#62; ( x[1], x[2] ) ) );
    (12,13)(17,18)(40,41)(44,45)(47,48)(55,56)(61,62)(65,66)(68,69)(76,77)(79,
    80)(89,90)(92,93)(95,96)(99,100)(103,104)(109,110)(115,116)(118,119)(123,
    124)(125,126)
    gap&#62; aut:= AutomorphismsOfTable( 2t );;
    gap&#62; Size( aut );
    256
    gap&#62; filt:= Filtered( Elements( aut ),
    &#62;               x -&#62; OnTuples( 2tfust, beta ) = Permuted( 2tfust, x ) );;
    gap&#62; Length( filt );
    1
    gap&#62; betalift:= filt[1];;

</pre>

<div class="p"><!----></div>
This determines the classes of 2.G in 2.G.2.
We fix the corresponding class fusion.

<div class="p"><!----></div>

<pre>
    gap&#62; 2tfus2t2:= [];;
    gap&#62; max:= 0;;
    gap&#62; for i in [ 1 .. NrConjugacyClasses( 2t ) ] do
    &#62;      img:= i^betalift;
    &#62;      if img = i then
    &#62;        # no fusion
    &#62;        max:= max + 1;
    &#62;        2tfus2t2[i]:= max;
    &#62;      elif i &lt; img then
    &#62;        # fusion of two classes
    &#62;        max:= max + 1;
    &#62;        2tfus2t2[i]:= max;
    &#62;        2tfus2t2[ img ]:= max;
    &#62;      fi;
    &#62;    od;
    gap&#62; max;
    174

</pre>

<div class="p"><!----></div>
Now we can compute the number of classes of 2.G.2.
If 2.G has n classes and the lift of &#946; has f nontrivial orbits
then 2.G.2 has f + 2 (n &#8722; 2f) = 2n &#8722; 3f classes,
of which n &#8722; f classes contain the elements of 2.G,
and n &#8722; 2f classes contain the elements outside 2.G.

<div class="p"><!----></div>
In our case, we have n = 202 and f = 28,
thus 2.G.2 has 320 classes, of which 174 are inner and 146 are outer.

<div class="p"><!----></div>

<pre>
    gap&#62; n:= NrConjugacyClasses( 2t );
    202
    gap&#62; f:= NrMovedPoints( betalift ) / 2;
    28
    gap&#62; 2 * n - 3 * f;  n - f;  n - 2 * f;
    320
    174
    146

</pre>

<div class="p"><!----></div>
Since G.2 has 84 outer classes,
we know that the preimages of exactly 146 &#8722; 84 = 62 of these classes
consist of two classes of 2.G.2 ("the class splits"),
and the preimages of exactly 84 &#8722; 62 = 22 classes
form one class of 2.G.2 ("the class does not split").

<div class="p"><!----></div>
The number of faithful irreducible characters of 2.G.2 is 131.

<div class="p"><!----></div>

<pre>
    gap&#62; NrConjugacyClasses( t2 ) - Maximum( tfust2 );
    84
    gap&#62; 320 - NrConjugacyClasses( t2 );
    131

</pre>

<div class="p"><!----></div>
Concerning the splitting of classes,
we start with applying the elementary criteria from
Section&nbsp;<a href="#elementarysplitting">4.3.1</a>.
The splitting of classes inside 2.G is of course given by the
factor fusion from 2.G to G and the class fusion of G to G.2.

<div class="p"><!----></div>

<pre>
    gap&#62; inv:= InverseMap( 2tfust );;
    gap&#62; nonsplit:= PositionsProperty( inv, IsInt);;
    gap&#62; mustnotsplit:= Set( tfust2{ nonsplit } );
    [ 4, 9, 10, 12, 13, 16, 18, 19, 20, 27, 33, 35, 36, 38, 39, 41, 43, 44, 51, 
      52, 54, 55, 58, 60, 62, 63, 69, 70, 71, 77, 78, 80, 82, 96, 98, 100 ]
    gap&#62; split:= PositionsProperty( inv, IsList );;
    gap&#62; mustsplit:= Set( tfust2{ split } );
    [ 1, 2, 3, 5, 6, 7, 8, 11, 14, 15, 17, 21, 22, 23, 24, 25, 26, 28, 29, 30, 
      31, 32, 34, 37, 40, 42, 45, 46, 47, 48, 49, 50, 53, 56, 57, 59, 61, 64, 65, 
      66, 67, 68, 72, 73, 74, 75, 76, 79, 81, 83, 84, 85, 86, 87, 88, 89, 90, 91, 
      92, 93, 94, 95, 97, 99, 101, 102, 103, 104, 105 ]
    gap&#62; selfCentralizingClassesSplit( t2, mustsplit );
    #I  class 172 splits (self-centralizing)
    #I  class 180 splits (self-centralizing)
    #I  class 181 splits (self-centralizing)
    #I  class 182 splits (self-centralizing)
    #I  class 183 splits (self-centralizing)
    #I  class 184 splits (self-centralizing)
    #I  class 185 splits (self-centralizing)
    #I  class 188 splits (self-centralizing)
    #I  class 189 splits (self-centralizing)

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;Subgroups of the type 2 &times;F<sub>4</sub>(2) &times;2 in 2.G.2</h3><a name="2s2">
</a>

<div class="p"><!----></div>
By&nbsp;[<a href="#Str76b" name="CITEStr76b">Str76</a>,Lemma&nbsp;(3.1)],
we can assume that 2.G.2 contains subgroups 2.S.2
of the structure 2 &times;F<sub>4</sub>(2) &times;2.
More precisely, we choose the isoclinism type of 2.G.2 in such a way that
subgroups of this structure exist.

<div class="p"><!----></div>
In order to use as much known information as possible about 2.S.2,
we assume a subgroup S of type F<sub>4</sub>(2) in G that extends to
a subgroup S.2 of type F<sub>4</sub>(2) &times;2 in G.2
and that is an epimorphic image of a subgroup 2.S of type 2 &times;F<sub>4</sub>(2)
in 2.G under the natural epimorphism &#960; from 2.G.2 to 2.G.

<div class="p"><!----></div>
Technically, we assume that all quadrangles in the following cube
describe commutative diagrams.

<div class="p"><!----></div>

<div class="p"><!----></div>

<center> <a href="ctblatlas01.png">Figure</a>

</center>

<div class="p"><!----></div>
First we construct the character tables of S, 2.S, S.2, and 2.S.2.

<div class="p"><!----></div>

<pre>
    gap&#62; c2:= CharacterTable( "C2" );;
    gap&#62; s:= CharacterTable( "F4(2)" );;
    gap&#62; s2:= c2 * s;;
    gap&#62; 2s:= s * c2;;
    gap&#62; 2s2:= s2 * c2;;
    gap&#62; sfuss2:= GetFusionMap( s, s2 );;
    gap&#62; 2sfuss:= GetFusionMap( 2s, s );;
    gap&#62; 2s2fuss2:= GetFusionMap( 2s2, s2 );;

</pre>

<div class="p"><!----></div>
The natural class fusion of 2.S in 2.S.2 is not stored on the tables
if they are constructed this way.
We compute an equivalent table that stores the fusion in question.

<div class="p"><!----></div>

<pre>
    gap&#62; 2s2alt:= c2 * 2s;;
    gap&#62; Irr( 2s2alt ) = Irr( 2s2 );
    true
    gap&#62; ComputedPowerMaps( 2s2alt ) = ComputedPowerMaps( 2s2 );
    true
    gap&#62; 2sfus2s2:= GetFusionMap( 2s, 2s2alt );;

</pre>

<div class="p"><!----></div>
The diagram on the front side of the cube commutes.

<div class="p"><!----></div>

<pre>
    gap&#62; CompositionMaps( sfuss2, 2sfuss )
    &#62;        = CompositionMaps( 2s2fuss2, 2sfus2s2 );
    true

</pre>

<div class="p"><!----></div>
Concerning the left side of the cube,
we have to fix suitable class fusions from S to G
and from 2.S to 2.G.

<div class="p"><!----></div>

<pre>
    gap&#62; sfust:= PossibleClassFusions( s, t );;
    gap&#62; rep:= RepresentativesFusions( AutomorphismsOfTable( s ),
    &#62;              sfust, Group( () ) );;
    gap&#62; Length( rep );
    3
    gap&#62; comp:= List( rep, map -&#62; CompositionMaps( InverseMap( 2tfust ),
    &#62;                                 CompositionMaps( map, 2sfuss ) ) );;
    gap&#62; poss:= List( comp, map -&#62; PossibleClassFusions( 2s, 2t,
    &#62;                                  rec( fusionmap:= map ) ) );;
    gap&#62; List( poss, Length );
    [ 1, 0, 0 ]
    gap&#62; sfust:= rep[1];;
    gap&#62; 2sfus2t:= poss[1][1];;
    gap&#62; CompositionMaps( sfust, 2sfuss )
    &#62;        = CompositionMaps( 2tfust, 2sfus2t );
    true

</pre>

<div class="p"><!----></div>
Concerning the top side of the cube,
we have to choose a fusion from S.2 into G.2.

<div class="p"><!----></div>

<pre>
    gap&#62; comp:= CompositionMaps( CompositionMaps( tfust2, sfust ),
    &#62;                            InverseMap( sfuss2 ) );;
    gap&#62; poss:= PossibleClassFusions( s2, t2, rec( fusionmap:= comp ) );;
    gap&#62; Length(  poss );
    1
    gap&#62; s2fust2:= poss[1];;
    gap&#62; CompositionMaps( tfust2, sfust )
    &#62;        = CompositionMaps( s2fust2, sfuss2 );
    true

</pre>

<div class="p"><!----></div>
The diagrams on the bottom, right, and back sides of the cube involve the
character table of 2.G.2, for which we have not yet created an
approximation.

<div class="p"><!----></div>
We will use the known diagrams to derive information about the missing ones.

<div class="p"><!----></div>

<pre>
    gap&#62; splittingClassesWithOddCentralizerIndexSplit( s2, t2, s2fust2,
    &#62;        2s2fuss2, mustsplit );
    #I  class 106 splits (odd centralizer index)
    #I  class 107 splits (odd centralizer index)
    #I  class 114 splits (odd centralizer index)
    #I  class 115 splits (odd centralizer index)
    #I  class 117 splits (odd centralizer index)
    #I  class 133 splits (odd centralizer index)
    #I  class 116 splits (odd centralizer index)
    #I  class 118 splits (odd centralizer index)
    #I  class 119 splits (odd centralizer index)
    #I  class 148 splits (odd centralizer index)
    #I  class 147 splits (odd centralizer index)
    #I  class 156 splits (odd centralizer index)
    #I  class 155 splits (odd centralizer index)
    #I  class 134 splits (odd centralizer index)
    #I  class 140 splits (odd centralizer index)
    #I  class 143 splits (odd centralizer index)
    #I  class 149 splits (odd centralizer index)
    #I  class 176 splits (odd centralizer index)
    #I  class 175 splits (odd centralizer index)
    #I  class 157 splits (odd centralizer index)
    #I  class 174 splits (odd centralizer index)
    #I  class 177 splits (odd centralizer index)

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.3">
5.3</a>&nbsp;&nbsp;Subgroups of the type 3 &times;2.U<sub>6</sub>(2).2 in 2.G.2</h3><a name="2u2">
</a>

<div class="p"><!----></div>
We have used in Section&nbsp;<a href="#3u62subs">4.13</a> that G contains subgroups of the
structure 3 &times;U<sub>6</sub>(2).
In fact, these groups are the full centralizers of certain elements of order
3 in G.

<div class="p"><!----></div>

<pre>
    gap&#62; c3:= CharacterTable( "Cyclic", 3 );;
    gap&#62; h:= c3 * CharacterTable( "U6(2)" );;
    gap&#62; poss:= PossibleClassFusions( h, t );;
    gap&#62; cen:= ClassPositionsOfCentre( h );
    [ 1, 47, 93 ]
    gap&#62; Set( List( poss, x -&#62; x{ cen } ) );
    [ [ 1, 5, 5 ] ]
    gap&#62; SizesCentralizers( t )[5] = Size( h );
    true

</pre>

<div class="p"><!----></div>
Let x be such an element of order 3 in G.
Since the G-class of x cannot fuse with another class under the
action of G.2,
we know that the centralizer of x in G.2 is larger by a factor of two.

<div class="p"><!----></div>
We have also used that the preimage in 2.G of the centralizer of x in G
has the structure 3 &times;2.U<sub>6</sub>(2).
Again, this subgroup is the full centralizer of an element of order 3
in 2.G,
and the centralizer of this element in 2.G.2 is larger by a factor of two.

<div class="p"><!----></div>
In order to determine the structures of these centralizers,
we notice that no U<sub>6</sub>(2) type subgroup of G can extend to a
subgroup of the structure U<sub>6</sub>(2) &times;2 in G.2, because no element in
G.2 \G has centralizer order divisible by the order of U<sub>6</sub>(2).

<div class="p"><!----></div>

<pre>
    gap&#62; h:= CharacterTable( "U6(2)" );;
    gap&#62; pos:= PositionsProperty( SizesCentralizers( t2 ),
    &#62;                             x -&#62; x mod Size( h ) = 0 );
    [ 1, 2, 5 ]
    gap&#62; Difference( pos, tfust2 );
    [  ]

</pre>

<div class="p"><!----></div>
Hence U<sub>6</sub>(2) extends to U<sub>6</sub>(2).2,
and since this U<sub>6</sub>(2).2 type subgroup centralizes x and intersects
trivially with &#9001;x &#9002;, the centralizer of x in G.2
has the structure 3 &times;U<sub>6</sub>(2).2.

<div class="p"><!----></div>
Analogously, the preimage of this centralizer in 2.G.2 has the structure
3 &times;2.U<sub>6</sub>(2).2.
There are two isomorphism classes of 2.U<sub>6</sub>(2).2 type groups,
we have to decide which one occurs.
The group U<sub>6</sub>(2).2 contains exactly two classes of involutions that
do not lie in the derived subgroup U<sub>6</sub>(2).
The images of these classes in G.2 contain elements of subgroups
of the type F<sub>4</sub>(2) &times;2 which are known to lift to involutions
in 2.G.2.
This implies that the outer involutions of U<sub>6</sub>(2).2 lift to involutions
in 2.U<sub>6</sub>(2).2,
and this information determines the isomorphism type of the 2.U<sub>6</sub>(2).2
type subgroup in question.

<div class="p"><!----></div>

<pre>
    gap&#62; h:= c3 * CharacterTable( "U6(2).2" );;
    gap&#62; possfus:= PossibleClassFusions( h, t2 );;
    gap&#62; inv:= Positions( OrdersClassRepresentatives( h ), 2 );
    [ 2, 3, 4, 38, 39 ]
    gap&#62; outerinv:= Difference( inv, ClassPositionsOfDerivedSubgroup( h ) );
    [ 38, 39 ]
    gap&#62; imgs:= Set( List( possfus, x -&#62; x{ outerinv } ) );
    [ [ 106, 107 ] ]
    gap&#62; List( imgs[1], x -&#62; Positions( s2fust2, x ) );
    [ [ 96, 98 ], [ 97, 99, 100 ] ]
    gap&#62; h:= CharacterTable( "2.U6(2).2" );
    CharacterTable( "2.U6(2).2" )
    gap&#62; Positions( OrdersClassRepresentatives( h ), 2 );
    [ 2, 3, 4, 5, 6, 7, 65, 66, 67, 68 ]

</pre>

<div class="p"><!----></div>
Now we proceed with the subgroups U = 3 &times;U<sub>6</sub>(2) of G,
U.2 = 3 &times;U<sub>6</sub>(2).2 of G.2,
2.U = 3 &times;2.U<sub>6</sub>(2) of 2.G,
and 2.U.2 = 3 &times;2.U<sub>6</sub>(2).2 of 2.G.2
in the same way as with S and its decorations.

<div class="p"><!----></div>

<pre>
    gap&#62; c3:= CharacterTable( "Cyclic", 3 );;
    gap&#62; 2u:= c3 * CharacterTable( "2.U6(2)" );;
    gap&#62; 2uorders:= OrdersClassRepresentatives( 2u );;
    gap&#62; ker:= First( ClassPositionsOfCentre( 2u ), i -&#62; 2uorders[i] = 2 );
    2
    gap&#62; u:= 2u / [ 1, ker ];;
    gap&#62; 2u2:= c3 * CharacterTable( "2.U6(2).2" );;
    gap&#62; 2u2orders:= OrdersClassRepresentatives( 2u2 );;
    gap&#62; ker:= First( ClassPositionsOfCentre( 2u2 ), i -&#62; 2u2orders[i] = 2 );
    2
    gap&#62; u2:= 2u2 / [ 1, ker ];;
    gap&#62; 2ufusu:= GetFusionMap( 2u, u );;
    gap&#62; 2u2fusu2:= GetFusionMap( 2u2, u2 );;
    gap&#62; poss:= PossibleClassFusions( 2u, 2u2 );;
    gap&#62; rep:= RepresentativesFusions( 2u, poss, Group( () ) );;
    gap&#62; Length( rep );
    1
    gap&#62; 2ufus2u2:= rep[1];;
    gap&#62; ufusu2:= CompositionMaps( 2u2fusu2,
    &#62;              CompositionMaps( 2ufus2u2, InverseMap( 2ufusu ) ) );;

</pre>

<div class="p"><!----></div>
By construction, the diagram on the front side of the cube commutes.

<div class="p"><!----></div>

<pre>
    gap&#62; CompositionMaps( ufusu2, 2ufusu )
    &#62;        = CompositionMaps( 2u2fusu2, 2ufus2u2 );
    true

</pre>

<div class="p"><!----></div>
Concerning the left side of the cube,
we get two possible class fusions from 2.U to 2.G
and also two possible class fusions from U to G.
Again, the diagram on this side commutes by construction.

<div class="p"><!----></div>

<pre>
    gap&#62; poss:= PossibleClassFusions( 2u, 2t );;
    gap&#62; rep:= RepresentativesFusions( 2u, poss, Group( () ) );;
    gap&#62; Length( rep );
    2
    gap&#62; poss2ufus2t:= rep;;
    gap&#62; possufust:= List( rep, map -&#62; CompositionMaps( 2tfust,
    &#62;        CompositionMaps( map, InverseMap( 2ufusu ) ) ) );;
    gap&#62; Length( Set( possufust ) );
    2

</pre>

<div class="p"><!----></div>
Concerning the top side of the cube,
we have to compute the fusions from U.2 to G.2 compatibly
with the possible fusions from U to G.
Fortunately, we get the same result in both cases.

<div class="p"><!----></div>

<pre>
    gap&#62; comp1:= CompositionMaps(
    &#62;                CompositionMaps( tfust2, possufust[1] ),
    &#62;                    InverseMap( ufusu2 ) );;
    gap&#62; poss1:= PossibleClassFusions( u2, t2, rec( fusionmap:= comp1 ) );;
    gap&#62; Length( poss1 );
    2
    gap&#62; comp2:= CompositionMaps(
    &#62;                CompositionMaps( tfust2, possufust[2] ),
    &#62;                    InverseMap( ufusu2 ) );;
    gap&#62; poss2:= PossibleClassFusions( u2, t2, rec( fusionmap:= comp2 ) );;
    gap&#62; Length(  poss2 );
    2
    gap&#62; poss1 = poss2;
    true
    gap&#62; rep:= RepresentativesFusions( u2, poss1, Group( () ) );;
    gap&#62; Length( rep );
    1
    gap&#62; u2fust2:= rep[1];;

</pre>

<div class="p"><!----></div>
We use the fusions to derive new information about the class splitting.

<div class="p"><!----></div>

<pre>
    gap&#62; splittingClassesWithOddCentralizerIndexSplit( u2, t2, u2fust2,
    &#62;        2u2fusu2, mustsplit );
    #I  class 135 splits (odd centralizer index)
    #I  class 139 splits (odd centralizer index)
    #I  class 141 splits (odd centralizer index)
    #I  class 161 splits (odd centralizer index)
    gap&#62; notSplittingClassesOfSubgroupDoNotSplit( 2u2fusu2, u2fust2,
    &#62;        mustnotsplit );
    #I  class 120 does not split (as in subgroup)
    #I  class 126 does not split (as in subgroup)
    #I  class 127 does not split (as in subgroup)
    #I  class 150 does not split (as in subgroup)
    #I  class 151 does not split (as in subgroup)
    #I  class 163 does not split (as in subgroup)
    #I  class 164 does not split (as in subgroup)
    #I  class 165 does not split (as in subgroup)
    #I  class 186 does not split (as in subgroup)
    #I  class 187 does not split (as in subgroup)

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.4">
5.4</a>&nbsp;&nbsp;Norms of induced characters - a refinement</h3>

<div class="p"><!----></div>
The next step is to use the idea developed in Section&nbsp;<a href="#normsinduced">4.3.2</a>.
However, we are in a better situation now, in the following sense.

<div class="p"><!----></div>
Let 2.H.2 be a subgroup of 2.G.2,
and let &#967; be a character of 2.H.2 that is faithful on the central
subgroup of order two.
As before, we can compute a set of all possible values for the contribution
of each class of G.2 to the norm of the induced character
&#968; =  &#967;<sup>2.G.2</sup>, and considering all combinations of these values
may yield new information on the class splitting.
The number of possible values for a class C of G.2 depends on the number
of classes of H.2 that fuse into C.

<div class="p"><!----></div>
Here we can do better,
because we can compute &#968;<sub>2.G</sub> = (&#967;<sub>2.H</sub>)<sup>2.G</sup> and its norm,
hence we have to deal with the combinatorial effort only for the classes
outside 2.G.
For that, we have to refine the <font face="helvetica">GAP</font> functions from
Section&nbsp;<a href="#normsinduced">4.3.2</a>.

<div class="p"><!----></div>

<div class="p"><!----></div>
The functions <tt>contributionData</tt>, <tt>integralContributions</tt>,
and <tt>evaluateContributions</tt> can remain unchanged.
Just <tt>computeContributions</tt> must be changed, in order to deal with the
different situation.

<div class="p"><!----></div>

<pre>
    gap&#62; computeContributions2:= function( s2, 2s, t2, 2t, s2fust2, 2sfus2s2,
    &#62;                                2sfus2t, tfust2,
    &#62;                                characters, bound,
    &#62;                                mustsplit, mustnotsplit, proj )
    &#62;      local inv, i, known, candidates, r, psi, res;
    &#62; 
    &#62;      inv:= InverseMap( s2fust2 );
    &#62; 
    &#62;      repeat
    &#62;        for i in Union( mustnotsplit, tfust2 ) do
    &#62;          # The induced character is either zero at the preimage of 'i',
    &#62;          # and there is no contribution to the norm,
    &#62;          # or the preimage of 'i' lies inside the subgroup of index 2.
    &#62;          Unbind( inv[i] );
    &#62;        od;
    &#62;        known:= [ ShallowCopy( mustsplit ), ShallowCopy( mustnotsplit ) ];
    &#62;        candidates:= [];
    &#62;        for i in [ 1 .. Length( characters ) ] do
    &#62;          r:= contributionData( s2, t2, inv, characters[i]{ proj },
    &#62;                                mustsplit );
    &#62;          if r.size &lt; bound then
    &#62;            # Restrict the character to 2.U, and induce it to 2.G.
    &#62;            psi:= InducedClassFunctionsByFusionMap( 2s, 2t,
    &#62;                      [ characters[i]{ 2sfus2s2 } ], 2sfus2t )[1];
    &#62;            r.safepart:= r.safepart + ScalarProduct( 2t, psi, psi ) / 2;
    &#62;            Add( candidates, r );
    &#62;          fi;
    &#62;        od;
    &#62;        SortParallel( List( candidates, r -&#62; r.size ), candidates );
    &#62;        for r in candidates do
    &#62;          res:= integralContributions( r );
    &#62;          if Length( res ) = 0 then
    &#62;            Error( "no solution" );
    &#62;          fi;
    &#62;          evaluateContributions( r, res, s2fust2, mustsplit, mustnotsplit );
    &#62;          oddRootsOfSplittingClassesSplit( t2, mustsplit );
    &#62;        od;
    &#62;      until known = [ mustsplit, mustnotsplit ];
    &#62;    end;;

</pre>

<div class="p"><!----></div>
Let us apply this criterion to the subgroup 2.S.2 of type
2 &times;F<sub>4</sub>(2) &times;2 of 2.G.2.

<div class="p"><!----></div>

<pre>
    gap&#62; ker:= ClassPositionsOfKernel( 2s2fuss2 );;
    gap&#62; testchars:= Filtered( Irr( 2s2 ), x -&#62; x[ ker[1] ] &lt;&#62; x[ ker[2] ]  );;
    gap&#62; computeContributions2( s2, 2s, t2, 2t, s2fust2, 2sfus2s2, 2sfus2t,
    &#62;        tfust2, testchars, 10^7, mustsplit, mustnotsplit,
    &#62;        ProjectionMap( 2s2fuss2 ) );
    #I  class 109 splits (contribution criterion)
    #I  class 136 splits (contribution criterion)
    #I  class 158 splits (5th root of 109)
    #I  class 173 splits (7th root of 109)
    #I  class 110 splits (contribution criterion)
    #I  class 108 splits (contribution criterion)
    #I  class 137 splits (contribution criterion)
    #I  class 159 splits (contribution criterion)
    #I  class 138 splits (3rd root of 108)
    #I  class 111 splits (contribution criterion)
    #I  class 112 splits (contribution criterion)
    #I  class 142 splits (3rd root of 111)
    #I  class 144 splits (3rd root of 111)
    #I  class 145 splits (3rd root of 112)

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.5">
5.5</a>&nbsp;&nbsp;Element orders in 2.G.2</h3><a name="elementorders2G2">
</a>

<div class="p"><!----></div>
Before we compute the class fusions from the subgroups 2.S.2 and
2.U.2 to 2.G.2,
we determine the element orders of 2.G.2.
As in Section&nbsp;<a href="#elementorders">4.5</a>, we have to consider only the classes
of involutions in G.2,
and we get that all of them lift to involutions in 2.G.2
because the same holds for the involutions in S.2.

<div class="p"><!----></div>

<pre>
    gap&#62; orders:= OrdersClassRepresentatives( t2 );;
    gap&#62; invol:= Positions( orders, 2 );;
    gap&#62; Difference( invol, s2fust2 );
    [  ]

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.6">
5.6</a>&nbsp;&nbsp;The class fusion from 2 &times;F<sub>4</sub>(2) &times;2</h3>

<div class="p"><!----></div>
Currently 14 classes of G.2 are left which contain elements of S.2
and for which we do not know whether they split.

<div class="p"><!----></div>

<pre>
    gap&#62; open:= Difference( s2fust2, Union( mustsplit, mustnotsplit ) );
    [ 113, 121, 122, 123, 125, 128, 129, 131, 132, 146, 153, 154, 162, 166 ]

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
We are going to use norms of induced characters for determining the splitting.
In fact, we need not consider all 2<sup>14</sup> combinations from the above set,
because the third power map connects some of the classes.

<div class="p"><!----></div>

<pre>
    gap&#62; PowerMap( t2, 3 ){ [ 146, 162, 166 ] };
    [ 113, 123, 121 ]
    gap&#62; poss:= Filtered( Combinations( open ),
    &#62;               x -&#62; ( not 113 in x or 146 in x ) and
    &#62;                    ( not 123 in x or 162 in x ) and
    &#62;                    ( not 121 in x or 166 in x ) );;
    gap&#62; Length( poss );
    6912

</pre>

<div class="p"><!----></div>
For the 6912 cases, we create a preliminary character table head
of 2.G.2, and compute possible class fusions from 2.S.2
into this table by checking norms of induced characters.

<div class="p"><!----></div>
The functions <tt>tableHead</tt> and <tt>useInducedClassFunction</tt>
from Section&nbsp;<a href="#sectinitialfusion">4.6</a> can be used also here,
but we want to use two commutative diagrams and not just one
when we initialize the class fusion.
Therefore, we provide a refined version <tt>initialFusion2</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; initialFusion2:= function( 2s2, 2t2,
    &#62;                               2s2fuss2, 2t2fust2, s2fust2,
    &#62;                               2sfus2s2, 2tfus2t2, 2sfus2t,
    &#62;                               defined )
    &#62;      local fus, comp, pre, imgs;
    &#62; 
    &#62;      # Use element orders and centralizer orders.
    &#62;      fus:= InitFusion( 2s2, 2t2 );
    &#62; 
    &#62;      # Use the commutative diagram on the right of the cube.
    &#62;      comp:= CompositionMaps( InverseMap( 2t2fust2 ),
    &#62;                 CompositionMaps( s2fust2, 2s2fuss2 ) );
    &#62;      if not MeetMaps( fus, comp ) then
    &#62;        return fail;
    &#62;      fi;
    &#62; 
    &#62;      # Use the commutative diagram on the bottom of the cube.
    &#62;      comp:= CompositionMaps( 2tfus2t2,
    &#62;                 CompositionMaps( 2sfus2t, InverseMap( 2sfus2s2 ) ) );
    &#62; 
    &#62;      if not MeetMaps( fus, comp ) then
    &#62;        return fail;
    &#62;      fi;
    &#62; 
    &#62;      # Define classes that are not yet defined.
    &#62;      defined:= ShallowCopy( defined );
    &#62;      for pre in InverseMap( 2s2fuss2 ) do
    &#62;        if IsList( pre ) then
    &#62;          imgs:= fus{ pre };
    &#62;          if imgs[1] = imgs[2] and IsList( imgs[1] )
    &#62;             and Intersection( defined, imgs[1] ) = [] then
    &#62;            # The classes in preimage and image split, and we may choose.
    &#62;            fus[ pre[1] ]:= imgs[1][1];
    &#62;            fus[ pre[2] ]:= imgs[1][2];
    &#62;            UniteSet( defined, imgs[1] );
    &#62;          fi;
    &#62;        elif IsList( fus[ pre ] ) then
    &#62;          # The class splits in the image but not in the preimage,
    &#62;          # something must be wrong.
    &#62;          return fail;
    &#62;        fi;
    &#62;      od;
    &#62; 
    &#62;      return fus;
    &#62;    end;;

</pre>

<div class="p"><!----></div>
Now we check the possible splittings that can be distinguished
by characters of 2.S.2.

<div class="p"><!----></div>

<pre>
    gap&#62; good:= [];;
    gap&#62; ker:= ClassPositionsOfKernel( GetFusionMap( 2s2, s2 ) );;
    gap&#62; testcharss:= Filtered( Irr( 2s2 ),
    &#62;        chi -&#62; not IsSubset( ClassPositionsOfKernel( chi ), ker ) );;
    gap&#62; runOneTest2:= function( s2, 2s2, t2, 2t2, s2fust2,
    &#62;                            2sfus2s2, 2tfus2t2, 2sfus2t,
    &#62;                            testchars, defined )
    &#62;      local fus, pos, l, chi;
    &#62; 
    &#62;      fus:= initialFusion2( 2s2, 2t2,
    &#62;                            GetFusionMap( 2s2, s2 ),
    &#62;                            GetFusionMap( 2t2, t2 ),
    &#62;                            s2fust2,
    &#62;                            2sfus2s2, 2tfus2t2, 2sfus2t,
    &#62;                            defined );
    &#62; 
    &#62;      # Process the irreducible characters,
    &#62;      # ordered by increasing indeterminateness.
    &#62;      pos:= PositionsProperty( fus, IsList );
    &#62;      testchars:= ShallowCopy( testchars );
    &#62;      l:= - List( testchars, x -&#62; Number( pos, i -&#62; x[i] = 0 ) );
    &#62;      SortParallel( l, testchars );
    &#62;      for chi in testchars do
    &#62;        if useInducedClassFunction( 2s2, 2t2, chi,
    &#62;               GetFusionMap( 2s2, s2 ), fus ) = false then
    &#62;          # This splitting is not possible.
    &#62;          return fail;
    &#62;        fi;
    &#62;      od;
    &#62;      return fus;
    &#62;    end;;
    gap&#62; defined:= [];;
    gap&#62; for choice in poss do
    &#62;      2t2:= tableHead( t2, Union( mustsplit, choice ), [], [] );
    &#62;      fus:= runOneTest2( s2, 2s2, t2, 2t2, s2fust2,
    &#62;                   2sfus2s2, 2tfus2t2, 2sfus2t,
    &#62;                testcharss, defined );
    &#62;      if fus &lt;&#62; fail then
    &#62;        Add( good, choice );
    &#62;      fi;
    &#62;    od;
    gap&#62; Length( good );
    1

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
We get a unique solution for the splitting.
Thus we update our lists.

<div class="p"><!----></div>

<pre>
    gap&#62; choice:= good[1];
    [ 113, 121, 122, 123, 125, 131, 146, 153, 154, 162, 166 ]
    gap&#62; UniteSet( mustsplit, choice );
    gap&#62; UniteSet( mustnotsplit, Difference( open, choice ) );
    gap&#62; oddRootsOfSplittingClassesSplit( t2, mustsplit );
    #I  class 168 splits (3rd root of 122)
    #I  class 171 splits (3rd root of 131)

</pre>

<div class="p"><!----></div>
Because of the two splitting classes which were found in the end,
we have to create a new character table object,
and the fusion from 2.S.2 must be adjusted.

<div class="p"><!----></div>

<pre>
    gap&#62; 2t2:= tableHead( t2, mustsplit, [], [] );;
    gap&#62; 2s2fus2t2:= runOneTest2( s2, 2s2, t2, 2t2, s2fust2,
    &#62;                       2sfus2s2, 2tfus2t2, 2sfus2t,
    &#62;                       testcharss, defined );;
    gap&#62; NrConjugacyClasses( 2t2 );
    320
    gap&#62; defined:= Set( 2s2fus2t2 );;
    gap&#62; inds:= Set( InducedClassFunctionsByFusionMap( 2s2, 2t2, testcharss,
    &#62;                                                  2s2fus2t2 ) );;

</pre>

<div class="p"><!----></div>
Now we have found all class splittings, according to the considerations
in Section&nbsp;<a href="#classnumbers2G2">5.1</a>.

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.7">
5.7</a>&nbsp;&nbsp;The class fusion from 3 &times;2.U<sub>6</sub>(2).2</h3>

<div class="p"><!----></div>
Since no further class splittings can occur,
we compute the possible class fusions from 2.U.2 to 2.G.2 that are
compatible with the restrictions of the characters induced from 2.S.2.
The first approximation given by the commutative diagrams is the same for
both possible fusions from 2.U to 2.G,
and altogether 32 possible fusions are compatible with the restrictions.

<div class="p"><!----></div>

<pre>
    gap&#62; poss2u2fus2t2:= List( poss2ufus2t, map -&#62;
    &#62;                              initialFusion2( 2u2, 2t2,
    &#62;                                  GetFusionMap( 2u2, u2 ),
    &#62;                                  GetFusionMap( 2t2, t2 ),
    &#62;                                  u2fust2,
    &#62;                                  2ufus2u2, 2tfus2t2, map,
    &#62;                                  defined ) );;
    gap&#62; Length( Set( poss2u2fus2t2 ) );
    1
    gap&#62; fus:= poss2u2fus2t2[1];;
    gap&#62; ker:= ClassPositionsOfKernel( GetFusionMap( 2u2, u2 ) );;
    gap&#62; testcharsu:= Filtered( Irr( 2u2 ),
    &#62;        chi -&#62; not IsSubset( ClassPositionsOfKernel( chi ), ker ) );;
    gap&#62; possfus:= FusionsAllowedByRestrictions( 2u2, 2t2, testcharsu,
    &#62;                  inds, fus, parametersFABR );;
    gap&#62; List( possfus, Indeterminateness );
    [ 16, 16 ]

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Exactly two of these maps yield integral norms of characters induced from
2.U.2.
We compute the two possible lists of induced characters.

<div class="p"><!----></div>

<pre>
    gap&#62; good:= [];;
    gap&#62; for map in Set( Concatenation( List( possfus, ContainedMaps ) ) ) do
    &#62;      indu:= Set( InducedClassFunctionsByFusionMap( 2u2, 2t2,
    &#62;                      testcharsu, map ) );
    &#62;      if ForAll( indu, x -&#62; IsInt( ScalarProduct( 2t2, x, x ) ) ) then
    &#62;        Add( good, map );
    &#62;      fi;
    &#62;    od;
    gap&#62; Length( good );
    2
    gap&#62; poss2u2fus2t2:= good;;
    gap&#62; indu:= List( good,
    &#62;                 map -&#62; Set( InducedClassFunctionsByFusionMap( 2u2, 2t2,
    &#62;                                 testcharsu, map ) ) );;
    gap&#62; List( indu, Length );
    [ 98, 98 ]
    gap&#62; Length( Intersection( indu ) );
    34
    gap&#62; Set( poss2u2fus2t2[1] ) = Set( poss2u2fus2t2[2] );
    true
    gap&#62; UniteSet( defined, Set( poss2u2fus2t2[1] ) );

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.8">
5.8</a>&nbsp;&nbsp;Approximations for some power maps of 2.G.2</h3>

<div class="p"><!----></div>
In order to compute characters of 2.G.2 which distinguish the preimages
of splitting classes that contain no elements of S.2 or U.2,
we will compute some symmetrizations of the known characters
(cf. Section&nbsp;<a href="#minuscharacters">4.16</a>).
For that, we need approximations of the 3-rd and the 5-th power map
of 2.G.2.

<div class="p"><!----></div>
We start with the 5-th power map.

<div class="p"><!----></div>

<pre>
    gap&#62; 2t2fust2:= GetFusionMap( 2t2, t2 );;
    gap&#62; p:= 5;;
    gap&#62; pow5:= InitPowerMap( 2t2, p );;
    gap&#62; comp:= CompositionMaps( InverseMap( 2t2fust2 ),
    &#62;            CompositionMaps( PowerMap( t2, p ), 2t2fust2 ) );;
    gap&#62; MeetMaps( pow5, comp );
    true
    gap&#62; comp:= CompositionMaps( 2tfus2t2,
    &#62;            CompositionMaps( PowerMap( 2t, p ),
    &#62;                InverseMap( 2tfus2t2 ) ) );;
    gap&#62; MeetMaps( pow5, comp );
    true
    gap&#62; comp:= CompositionMaps( 2s2fus2t2,
    &#62;            CompositionMaps( PowerMap( 2s2, p ),
    &#62;                InverseMap( 2s2fus2t2 ) ) );;
    gap&#62; MeetMaps( pow5, comp );
    true
    gap&#62; para:= Parametrized( poss2u2fus2t2 );;
    gap&#62; comp:= CompositionMaps( para,
    &#62;            CompositionMaps( PowerMap( 2u2, p ),
    &#62;                InverseMap( para ) ) );;
    gap&#62; MeetMaps( pow5, comp );
    true
    gap&#62; Indeterminateness( pow5 );
    4096

</pre>

<div class="p"><!----></div>
We may <b>choose</b> the images under the 5-th power map of those classes
whose images in G.2 have not been defined yet and which have element order
divisible by 5.

<div class="p"><!----></div>

<pre>
    gap&#62; ambig:= PositionsProperty( pow5, IsList );
    [ 283, 284, 287, 288, 307, 308, 309, 310, 317, 318, 319, 320 ]
    gap&#62; ambig:= Filtered( ambig,
    &#62;                i -&#62; OrdersClassRepresentatives( 2t2 )[i] mod 5 = 0 );
    [ 309, 310, 319, 320 ]
    gap&#62; Intersection( ambig, defined );
    [  ]
    gap&#62; pow5{ ambig };
    [ [ 204, 205 ], [ 204, 205 ], [ 227, 228 ], [ 227, 228 ] ]
    gap&#62; pow5{ ambig }:= [ 204, 205, 227, 228 ];;
    gap&#62; UniteSet( defined, ambig );

</pre>

<div class="p"><!----></div>
We cannot improve the 5-th power map with the currently known induced
characters.
This means that we can compute the symmetrizations &#967;<sup>5&#8722;</sup> for all
these characters &#967; with the known approximation of the 5-th power map.

<div class="p"><!----></div>
The 3-rd power map is initialized analogously.
Additionally we use the fact that the 3-rd and the 5-th power maps
commute.

<div class="p"><!----></div>

<pre>
    gap&#62; p:= 3;;
    gap&#62; pow3:= InitPowerMap( 2t2, p );;
    gap&#62; comp:= CompositionMaps( InverseMap( 2t2fust2 ),
    &#62;            CompositionMaps( PowerMap( t2, p ), 2t2fust2 ) );;
    gap&#62; MeetMaps( pow3, comp );
    true
    gap&#62; comp:= CompositionMaps( 2tfus2t2,
    &#62;            CompositionMaps( PowerMap( 2t, p ),
    &#62;                InverseMap( 2tfus2t2 ) ) );;
    gap&#62; MeetMaps( pow3, comp );
    true
    gap&#62; comp:= CompositionMaps( 2s2fus2t2,
    &#62;            CompositionMaps( PowerMap( 2s2, p ),
    &#62;                InverseMap( 2s2fus2t2 ) ) );;
    gap&#62; MeetMaps( pow3, comp );
    true
    gap&#62; para:= Parametrized( poss2u2fus2t2 );;
    gap&#62; comp:= CompositionMaps( para,
    &#62;            CompositionMaps( PowerMap( 2u2, p ),
    &#62;                InverseMap( para ) ) );;
    gap&#62; MeetMaps( pow3, comp );
    true
    gap&#62; Indeterminateness( pow3 );
    65536
    gap&#62; CommutativeDiagram( pow3, pow5, pow5, pow3 );
    rec( imp1 := [ 309, 310, 319, 320 ], imp2 := [  ], imp3 := [  ], imp4 := [  ] 
     )
    gap&#62; Indeterminateness( pow3 );
    4096
    gap&#62; ambig:= PositionsProperty( pow3, IsList );
    [ 239, 240, 273, 274, 283, 284, 287, 288, 307, 308, 317, 318 ]
    gap&#62; ambig:=  Difference( ambig, defined );
    [ 283, 284, 287, 288, 307, 308, 317, 318 ]
    gap&#62; pow3{ ambig };
    [ [ 206, 207 ], [ 206, 207 ], [ 218, 219 ], [ 218, 219 ], [ 231, 232 ], 
      [ 231, 232 ], [ 317, 318 ], [ 317, 318 ] ]
    gap&#62; pow3{ [ 283, 284, 287, 288, 307, 308 ] }:=
    &#62;              [ 206, 207, 218, 219, 231, 232 ];;
    gap&#62; CommutativeDiagram( pow3, pow5, pow5, pow3 );
    rec( imp1 := [  ], imp2 := [  ], imp3 := [ 283, 284, 287, 288, 307, 308 ], 
      imp4 := [  ] )

</pre>

<div class="p"><!----></div>
We will need more information about the 3-rd power map,
at the cost of case distinctions.
For each set of candidates of characters induced from 2.U.2,
we get an approximation of the 3-rd power map.

<div class="p"><!----></div>

<pre>
    gap&#62; poss3:= [];;
    gap&#62; for possindu in indu do
    &#62;      testchars:= Concatenation( inds, possindu );
    &#62;      Add( poss3, PowerMapsAllowedBySymmetrizations( 2t2, testchars,
    &#62;                      testchars, StructuralCopy( pow3 ), p,
    &#62;                      parametersFABR ) );
    &#62;    od;
    gap&#62; List( poss3, Length );
    [ 1, 1 ]
    gap&#62; poss3:= List( poss3, l -&#62; l[1] );;
    gap&#62; List( poss3, Indeterminateness );
    [ 4, 4 ]

</pre>

<div class="p"><!----></div>
For other purposes,
we will also need an approximation of the 2-nd power map
of 2.G.2.

<div class="p"><!----></div>

<pre>
    gap&#62; p:= 2;;
    gap&#62; pow2:= InitPowerMap( 2t2, p );;
    gap&#62; comp:= CompositionMaps( InverseMap( 2t2fust2 ),
    &#62;               CompositionMaps( PowerMap( t2, p ), 2t2fust2 ) );;
    gap&#62; MeetMaps( pow2, comp );
    true
    gap&#62; comp:= CompositionMaps( 2tfus2t2,
    &#62;               CompositionMaps( PowerMap( 2t, p ),
    &#62;                   InverseMap( 2tfus2t2 ) ) );;
    gap&#62; MeetMaps( pow2, comp );
    true
    gap&#62; comp:= CompositionMaps( 2s2fus2t2,
    &#62;               CompositionMaps( PowerMap( 2s2, p ),
    &#62;                   InverseMap( 2s2fus2t2 ) ) );;
    gap&#62; MeetMaps( pow2, comp );
    true
    gap&#62; para:= Parametrized( poss2u2fus2t2 );;
    gap&#62; comp:= CompositionMaps( para,
    &#62;               CompositionMaps( PowerMap( 2u2, p ),
    &#62;                   InverseMap( para ) ) );;
    gap&#62; MeetMaps( pow2, comp );
    true
    gap&#62; Indeterminateness( pow2 );
    131072
    gap&#62; CommutativeDiagram( pow3, pow2, pow2, pow3 );
    rec( imp1 := [  ], imp2 := [  ], 
      imp3 := [ 283, 284, 287, 288, 307, 308, 319, 320 ], imp4 := [  ] )
    gap&#62; Indeterminateness( pow2 );
    512
    gap&#62; CommutativeDiagram( pow5, pow2, pow2, pow5 );
    rec( imp1 := [  ], imp2 := [  ], imp3 := [ 309, 310 ], imp4 := [  ] )
    gap&#62; Indeterminateness( pow2 );
    128

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc5.9">
5.9</a>&nbsp;&nbsp;The faithful irreducible characters of 2.G.2</h3>

<div class="p"><!----></div>
A few faithful irreducible characters of 2.G.2 are obtained by
induction from 2.G.

<div class="p"><!----></div>

<pre>
    gap&#62; indt:= Set( InducedClassFunctionsByFusionMap( 2t, 2t2,
    &#62;               Filtered( Irr( 2t ), x -&#62; x[1] &lt;&#62; x[2] ), 2tfus2t2 ) );;
    gap&#62; irr:= Filtered( indt, x -&#62; ScalarProduct( 2t2, x, x ) = 1 );;
    gap&#62; Length( irr ); 
    7

</pre>

<div class="p"><!----></div>
A few more characters are obtained by the LLL algorithm.

<div class="p"><!----></div>

<pre>
    gap&#62; red:= Reduced( 2t2, irr, Concatenation( indt, inds ) );;
    gap&#62; Length( red.irreducibles );
    0
    gap&#62; lll:= LLL( 2t2, red.remainders, 99/100 );;
    gap&#62; Length( lll.irreducibles );
    4
    gap&#62; UniteSet( irr, lll.irreducibles );
    gap&#62; Length( irr ); 
    11
    gap&#62; missing:= NrConjugacyClasses( 2t2 ) - NrConjugacyClasses( t2 )
    &#62;                  - Length( irr );
    120
    gap&#62; redindu:= List( indu, l -&#62; ReducedCharacters( 2t2, irr, l ) );;
    gap&#62; List( redindu, r -&#62; r.irreducibles );
    [ [  ], [  ] ]
    gap&#62; redindu:= List( redindu, r -&#62; r.remainders );;

</pre>

<div class="p"><!----></div>
We have two cases to consider,
one for each of the two sets of characters induced from 2.U.2;
note that we have to prescribe the 3-rd power map that fits to the
chosen list of induced characters.

<div class="p"><!----></div>
First we try the first set of induced characters and the first power map
candidate.

<div class="p"><!----></div>

<pre>
    gap&#62; inducand:= redindu[1];;
    gap&#62; testchars:= Concatenation( irr, red.remainders, inducand );;
    gap&#62; minus5:= List( testchars, x -&#62; MinusCharacter( x, pow5, 5 ) );;
    gap&#62; minus3:= List( testchars, x -&#62; MinusCharacter( x, poss3[1], 3 ) );;
    gap&#62; minus:= Reduced( 2t2, irr, Concatenation( minus5, minus3 ) );;
    gap&#62; Length( minus.irreducibles );
    0
    gap&#62; lll2:= LLL( 2t2, Concatenation( lll.remainders, inducand,
    &#62;                         minus.remainders ), 99/100 );;
    gap&#62; Length( lll2.irreducibles );
    0
    gap&#62; Length( lll2.norms );
    119
    gap&#62; gram:= MatScalarProducts( 2t2, lll2.remainders, lll2.remainders );;
    gap&#62; emb:= OrthogonalEmbeddings( gram, missing );;
    gap&#62; Length( emb.solutions );
    1
    gap&#62; dec:= Decreased( 2t2, lll2.remainders, emb.vectors{ emb.solutions[1] } );;
    gap&#62; Length( dec.irreducibles );
    118
    gap&#62; Length( dec.remainders );
    1

</pre>

<div class="p"><!----></div>
We have found all except two irreducibles.
What are the two missing characters?
Of course they are the two extensions of one irreducible character of 2.G.

<div class="p"><!----></div>

<pre>
    gap&#62; redt:= Reduced( 2t2, Concatenation( irr, dec.irreducibles ), indt );;
    gap&#62; Length( redt.remainders );
    1
    gap&#62; redt.remainders[1] in indt;
    true

</pre>

<div class="p"><!----></div>
The two missing irreducibles are the only ones that distinguish the two
classes of element order 56.

<div class="p"><!----></div>

<pre>
    gap&#62; split:= Union( Filtered( InverseMap( 2t2fust2 ), IsList ) );;
    gap&#62; Filtered( split, i -&#62; ForAll( Concatenation( irr, dec.irreducibles ),
    &#62;                                  x -&#62; x[i] = 0 ) );
    [ 317, 318 ]
    gap&#62; Positions( OrdersClassRepresentatives( 2t2 ), 56 );
    [ 317, 318 ]
    gap&#62; SizesCentralizers( 2t2 )[317];
    112

</pre>

<div class="p"><!----></div>
This means that the values of the two missing irreducibles on these classes
are &#177;x such that 2 &#124;x&#124;<sup>2</sup> = &#124;C<sub>2.G.2</sub>(g)&#124;/2 = 56 holds,
where g is an element of order 56 in 2.G.2.
As a consequence, we know that either x = &#177;2 &#8730;7 or
x = &#177;2 &#8730;{&#8722;7}.
Moreover, the orthogonality relations imply that the classes of element
order 56 are the only classes outside 2.G where two missing irreducible
characters do not vanish.

<div class="p"><!----></div>
We have to decide which of the two cases occurs,
that is, whether the classes of element order 56 are real or not.
For that, we use symmetrizations &#967;<sup>2&#8722;</sup>, so we need the approximation
of the 2-nd power map of 2.G.2 computed above.

<div class="p"><!----></div>

<pre>
    gap&#62; factirr:= List( Irr( t2 ), x -&#62; x{ 2t2fust2 } );;
    gap&#62; poss2:= PowerMapsAllowedBySymmetrizations( 2t2, factirr,
    &#62;                dec.irreducibles, StructuralCopy( pow2 ), 2,
    &#62;                parametersFABR );;
    gap&#62; Length( poss2 );
    1
    gap&#62; Indeterminateness( poss2[1] );
    1
    gap&#62; cand:= ShallowCopy( redt.remainders[1] / 2 );;
    gap&#62; cand{ [ 317, 318 ] }:= [ 1, -1 ] * ( 2 * Sqrt(-7) );;
    gap&#62; minus2:= MinusCharacter( cand, poss2[1], 2 );;
    gap&#62; ForAll( Flat( MatScalarProducts( 2t2, factirr, [ minus2 ] ) ), IsInt );
    false
    gap&#62; cand{ [ 317, 318 ] }:= [ 1, -1 ] * ( 2 * Sqrt(7) );;
    gap&#62; minus2:= MinusCharacter( cand, poss2[1], 2 );;
    gap&#62; ForAll( Flat( MatScalarProducts( 2t2, factirr, [ minus2 ] ) ), IsInt );
    true

</pre>

<div class="p"><!----></div>
This proves that the classes of element order 56 are real.
We set the list of irreducibles in the character table of 2.G.2,
compute the power maps, and compare the table with the  A<font size="-2">TLAS</font> table
from <font face="helvetica">GAP</font>'s library.
It turns out that this first solution is equivalent to the library table.

<div class="p"><!----></div>

<pre>
    gap&#62; cand2:= ShallowCopy( cand );;
    gap&#62; cand2{ [ 317, 318 ] }:= [ -1, 1 ] * ( 2 * Sqrt(7) );;
    gap&#62; SetIrr( 2t2, Concatenation( factirr, irr, dec.irreducibles,
    &#62;                     [ cand, cand2 ] ) );
    gap&#62; for p in [ 2 .. Maximum( OrdersClassRepresentatives( 2t2 ) ) ] do
    &#62;      if IsPrimeInt( p ) then
    &#62;        if p = 2 then
    &#62;          poss:= PossiblePowerMaps( 2t2, p,
    &#62;                     rec( powermap:= poss2[1] ) );
    &#62;        elif p = 3 then
    &#62;          poss:= PossiblePowerMaps( 2t2, p,
    &#62;                     rec( powermap:= StructuralCopy( pow3 ) ) );
    &#62;        elif p = 5 then
    &#62;          poss:= PossiblePowerMaps( 2t2, p,
    &#62;                     rec( powermap:= StructuralCopy( pow5 ) ) );
    &#62;        else
    &#62;          poss:= PossiblePowerMaps( 2t2, p );
    &#62;        fi;
    &#62;        if Length( poss ) &lt;&#62; 1 then
    &#62;          Error( "not expected" );
    &#62;        fi;
    &#62;        ComputedPowerMaps( 2t2 )[p]:= poss[1];
    &#62;      fi;
    &#62;    od;
    gap&#62; lib:= CharacterTable( "2.2E6(2).2" );;
    gap&#62; tr:= TransformingPermutationsCharacterTables( lib, 2t2 );;
    gap&#62; tr.columns;
    (177,178)(179,180)(183,184)(185,186)(189,190)(195,196)(199,200)(201,202)(204,
    205)(206,207)(208,209)(218,219)(223,224)(225,226)(227,228)(231,232)(233,
    234)(235,236)(241,242)(243,244)(245,246)(247,248)(253,254)(258,259)(260,
    261)(266,267)(268,269)(273,274)(275,276)(280,281)(283,284)(287,288)(293,
    294)(299,300)(307,308)(309,310)

</pre>

<div class="p"><!----></div>
Now we repeat the above arguments to the second set of induced characters.
Again, we get one complete character table which is equivalent to the
library table.
This proves the correctness of the  A<font size="-2">TLAS</font> table.

<div class="p"><!----></div>

<pre>
    gap&#62; 2t2:= tableHead( t2, mustsplit, [], [] );;
    gap&#62; inducand:= redindu[2];;
    gap&#62; testchars:= Concatenation( irr, red.remainders, inducand );;
    gap&#62; minus5:= List( testchars, x -&#62; MinusCharacter( x, pow5, 5 ) );;
    gap&#62; minus3:= List( testchars, x -&#62; MinusCharacter( x, poss3[2], 3 ) );;
    gap&#62; minus:= Reduced( 2t2, irr, Concatenation( minus5, minus3 ) );;
    gap&#62; Length( minus.irreducibles );
    0
    gap&#62; lll2:= LLL( 2t2, Concatenation( lll.remainders, inducand,
    &#62;                         minus.remainders ), 99/100 );;
    gap&#62; Length( lll2.irreducibles );
    0
    gap&#62; Length( lll2.norms );
    119
    gap&#62; gram:= MatScalarProducts( 2t2, lll2.remainders, lll2.remainders );;
    gap&#62; emb:= OrthogonalEmbeddings( gram, missing );;
    gap&#62; Length( emb.solutions );
    1
    gap&#62; dec:= Decreased( 2t2, lll2.remainders, emb.vectors{ emb.solutions[1] } );;
    gap&#62; Length( dec.irreducibles );
    118
    gap&#62; Length( dec.remainders );
    1
    gap&#62; redt:= Reduced( 2t2, Concatenation( irr, dec.irreducibles ), indt );;
    gap&#62; Length( redt.remainders );
    1
    gap&#62; redt.remainders[1] in indt;
    true
    gap&#62; poss2:= PowerMapsAllowedBySymmetrizations( 2t2, factirr,
    &#62;                dec.irreducibles, StructuralCopy( pow2 ), 2,
    &#62;                parametersFABR );;
    gap&#62; Length( poss2 );
    1
    gap&#62; Indeterminateness( poss2[1] );
    1
    gap&#62; cand:= ShallowCopy( redt.remainders[1] / 2 );;
    gap&#62; cand{ [ 317, 318 ] }:= [ 1, -1 ] * ( 2 * Sqrt(-7) );;
    gap&#62; minus2:= MinusCharacter( cand, poss2[1], 2 );;
    gap&#62; ForAll( Flat( MatScalarProducts( 2t2, factirr, [ minus2 ] ) ), IsInt );
    false
    gap&#62; cand{ [ 317, 318 ] }:= [ 1, -1 ] * ( 2 * Sqrt(7) );;
    gap&#62; minus2:= MinusCharacter( cand, poss2[1], 2 );;
    gap&#62; ForAll( Flat( MatScalarProducts( 2t2, factirr, [ minus2 ] ) ), IsInt );
    true
    gap&#62; cand2:= ShallowCopy( cand );;
    gap&#62; cand2{ [ 317, 318 ] }:= [ -1, 1 ] * ( 2 * Sqrt(7) );;
    gap&#62; SetIrr( 2t2, Concatenation( factirr, irr, dec.irreducibles,
    &#62;                     [ cand, cand2 ] ) );
    gap&#62; for p in [ 2 .. Maximum( OrdersClassRepresentatives( 2t2 ) ) ] do
    &#62;      if IsPrimeInt( p ) then
    &#62;        if p = 2 then
    &#62;          poss:= PossiblePowerMaps( 2t2, p,
    &#62;                     rec( powermap:= poss2 ) );
    &#62;        elif p = 3 then
    &#62;          poss:= PossiblePowerMaps( 2t2, p,
    &#62;                     rec( powermap:= StructuralCopy( pow3 ) ) );
    &#62;        elif p = 5 then
    &#62;          poss:= PossiblePowerMaps( 2t2, p,
    &#62;                     rec( powermap:= StructuralCopy( pow5 ) ) );
    &#62;        else
    &#62;          poss:= PossiblePowerMaps( 2t2, p );
    &#62;        fi;
    &#62;        if Length( poss ) &lt;&#62; 1 then
    &#62;          Error( "not expected" );
    &#62;        fi;
    &#62;        ComputedPowerMaps( 2t2 )[p]:= poss[1];
    &#62;      fi;
    &#62;    od;
    gap&#62; tr:= TransformingPermutationsCharacterTables( lib, 2t2 );;
    gap&#62; tr.columns;
    (177,178)(179,180)(183,184)(185,186)(189,190)(195,196)(199,200)(201,202)(204,
    205)(206,207)(208,209)(218,219)(223,224)(225,226)(227,228)(231,232)(233,
    234)(235,236)(239,240)(241,242)(243,244)(245,246)(247,248)(253,254)(258,
    259)(260,261)(266,267)(268,269)(275,276)(280,281)(283,284)(287,288)(293,
    294)(299,300)(307,308)(309,310)

</pre>

<div class="p"><!----></div>

 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;The character table of 2.B (May 8th, 2016)</h2><a name="section2B">
</a>

<div class="p"><!----></div>
In the following, we compute the character table of the double cover
2.B of the sporadic simple Baby Monster group B,
with character theoretic methods.

<div class="p"><!----></div>
For that, we assume the character table of B,
the existence of subgroups of the structures 2<sup>2</sup>.<sup>2</sup>E<sub>6</sub>(2).2
and 2 &times;Th in 2.B,
and the knowledge of their character tables;
see Sections&nbsp;<a href="#V42E622in2B">6.2</a> and&nbsp;<a href="#2xThin2B">6.5</a>.

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Assumptions</h3><a name="assumptions2B">
</a>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;Subgroups of the type 2<sup>2</sup>.<sup>2</sup>E<sub>6</sub>(2).2 in 2.B</h3><a name="V42E622in2B">
</a>

<div class="p"><!----></div>
We assume that the sporadic simple Monster group M contains an involution
z whose centralizer in M has the structure 2.B,
and that M contains an elementary abelian subgroup E of order four
that contains z and whose normalizer in M has the structure
2<sup>2</sup>.<sup>2</sup>E<sub>6</sub>(2).S<sub>3</sub>.
The three involutions in E are conjugate in N<sub>M</sub>(E),
thus N<sub>2.B</sub>(E) = 2.B &#8745;N has the structure 2<sup>2</sup>.<sup>2</sup>E<sub>6</sub>(2).2.
The factor group N<sub>2.B</sub>(E) / &#9001;z &#9002; is an
involution centralizer in the Baby Monster group B,
thus it is isomorphic with the group of the structure
2.<sup>2</sup>E<sub>6</sub>(2).2 whose character table is constructed in
Section&nbsp;<a href="#section22e622">5</a>.

<div class="p"><!----></div>
We denote N<sub>2.B</sub>(E) by 2.S
and N<sub>2.B</sub>(E) / &#9001;z &#9002; by S.

<div class="p"><!----></div>
We will need the character table of 2.S.
It can be constructed with character theoretic methods, as follows.

<div class="p"><!----></div>

<ul>
<li>    The character table of the index two subgroup 2.S&#8242; of 2.S
    can be constructed from the character table of 2.<sup>2</sup>E<sub>6</sub>(2)
    and the action of the outer automorphism of order three on the
    classes of <sup>2</sup>E<sub>6</sub>(2),
    using that this automorphism lifts to an automorphism of 2.S&#8242;
    that permutes the three central involutions transitively;
    the general method for this kind of character table construction
    is described in the section
    "Character Tables of Groups of the Structure 2<sup>2</sup>.G" of&nbsp;[<a href="#Auto" name="CITEAuto">Bre</a>],
    and the case of 2.S&#8242; is treated in the section
    "Examples for the Type 2<sup>2</sup>.G".
<div class="p"><!----></div>
</li>

<li>
    Now the character table of 2.S can be constructed
    from the character tables of its subgroup 2.S&#8242; and its factor group
    of the structure 2.<sup>2</sup>E<sub>6</sub>(2).2,
    using the general method described in [<a href="#Bre11" name="CITEBre11">Bre11</a>].
    The case of 2.S is treated in the section
    "Examples for the Type M.G.A" of [<a href="#Auto" name="CITEAuto">Bre</a>].
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
The character tables of S and 2.S is available in
<font face="helvetica">GAP</font>'s character table library,
via the names <tt>"2.2E6(2).2"</tt> and <tt>"2^2.2E6(2).2"</tt>.

<div class="p"><!----></div>

<pre>
    gap&#62; t:= CharacterTable( "B" );;
    gap&#62; s:= CharacterTable( "2.2E6(2).2" );;
    gap&#62; 2s:= CharacterTable( "2^2.2E6(2).2" );;
    gap&#62; 2sfuss:= GetFusionMap( 2s, s );;

</pre>

<div class="p"><!----></div>
First we determine the class fusion from S to B.
Up to the action of those table automorphisms of the character table of S
that lift to the character table of 2.S,
we get two candidates.

<div class="p"><!----></div>

<pre>
    gap&#62; fus:= PossibleClassFusions( s, t );;
    gap&#62; Length( fus );
    16
    gap&#62; n:= NrConjugacyClasses( 2s );;
    gap&#62; indperm:= pi -&#62; PermList( CompositionMaps( 2sfuss,
    &#62;        CompositionMaps( ListPerm( pi, n ), InverseMap( 2sfuss ) ) ) );;
    gap&#62; ind:= Group( List( GeneratorsOfGroup( AutomorphismsOfTable( 2s ) ),
    &#62;                       indperm ) );;
    gap&#62; Size( ind );
    16
    gap&#62; rep:= RepresentativesFusions( ind, fus, Group( () ) );;
    gap&#62; Length( rep );
    2

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Let &#960; denote the epimorphism from 2.B to B.
We know that the preimage of the centre of S under &#960;
is elementary abelian.
Since the central involution of S lies in the class <tt>2A</tt> of B,
this means that the preimages of this class in 2.B are involutions.
Only the first fusion candidate is compatible with this condition.

<div class="p"><!----></div>

<pre>
    gap&#62; List( rep, map -&#62; map{ ClassPositionsOfCentre( s ) } );
    [ [ 1, 2 ], [ 1, 2 ] ]
    gap&#62; List( rep, map -&#62; Positions( map, 2 ) );
    [ [ 2, 4, 175 ], [ 2, 4, 176 ] ]
    gap&#62; pos:= List( [ 175, 176 ], i -&#62; Positions( 2sfuss, i ) );
    [ [ 251 ], [ 252 ] ]
    gap&#62; OrdersClassRepresentatives( 2s ){ [ 251, 252 ] };
    [ 2, 4 ]
    gap&#62; sfust:= rep[1];;

</pre>

<div class="p"><!----></div>
Next we use the subgroups S and 2.S to determine the class fusion
from 2.B to B, that is, to decide for which classes of B the
preimage under &#960; forms one class of 2.B or splits into two
classes of 2.B.
The tools for that are introduced in Section&nbsp;<a href="#theclasses">4.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; orders:= OrdersClassRepresentatives( t );;
    gap&#62; mustsplit:= PositionsProperty( orders, IsOddInt );
    [ 1, 6, 7, 18, 19, 31, 46, 47, 54, 75, 81, 82, 91, 98, 109, 112, 113, 128, 
      131, 145, 146, 151, 155, 160, 172, 173, 177 ]
    gap&#62; selfCentralizingClassesSplit( t, mustsplit );
    #I  class 158 splits (self-centralizing)
    #I  class 159 splits (self-centralizing)
    #I  class 165 splits (self-centralizing)
    #I  class 169 splits (self-centralizing)
    #I  class 170 splits (self-centralizing)
    #I  class 171 splits (self-centralizing)
    #I  class 176 splits (self-centralizing)
    #I  class 182 splits (self-centralizing)
    #I  class 183 splits (self-centralizing)
    #I  class 184 splits (self-centralizing)
    gap&#62; splittingClassesWithOddCentralizerIndexSplit( s, t, sfust,
    &#62;        2sfuss, mustsplit );
    #I  class 110 splits (odd centralizer index)
    #I  class 68 splits (odd centralizer index)
    #I  class 73 splits (odd centralizer index)
    #I  class 79 splits (odd centralizer index)
    #I  class 94 splits (odd centralizer index)
    #I  class 136 splits (odd centralizer index)
    #I  class 140 splits (odd centralizer index)
    gap&#62; mustnotsplit:= [];;
    gap&#62; notSplittingClassesOfSubgroupDoNotSplit( 2sfuss, sfust, mustnotsplit );
    #I  class 2 does not split (as in subgroup)
    #I  class 4 does not split (as in subgroup)
    #I  class 5 does not split (as in subgroup)
    #I  class 8 does not split (as in subgroup)
    #I  class 9 does not split (as in subgroup)
    #I  class 10 does not split (as in subgroup)
    #I  class 11 does not split (as in subgroup)
    #I  class 13 does not split (as in subgroup)
    #I  class 14 does not split (as in subgroup)
    #I  class 15 does not split (as in subgroup)
    #I  class 17 does not split (as in subgroup)
    #I  class 20 does not split (as in subgroup)
    #I  class 21 does not split (as in subgroup)
    #I  class 23 does not split (as in subgroup)
    #I  class 24 does not split (as in subgroup)
    #I  class 25 does not split (as in subgroup)
    #I  class 27 does not split (as in subgroup)
    #I  class 29 does not split (as in subgroup)
    #I  class 30 does not split (as in subgroup)
    #I  class 32 does not split (as in subgroup)
    #I  class 33 does not split (as in subgroup)
    #I  class 34 does not split (as in subgroup)
    #I  class 35 does not split (as in subgroup)
    #I  class 36 does not split (as in subgroup)
    #I  class 37 does not split (as in subgroup)
    #I  class 38 does not split (as in subgroup)
    #I  class 39 does not split (as in subgroup)
    #I  class 40 does not split (as in subgroup)
    #I  class 41 does not split (as in subgroup)
    #I  class 44 does not split (as in subgroup)
    #I  class 48 does not split (as in subgroup)
    #I  class 50 does not split (as in subgroup)
    #I  class 52 does not split (as in subgroup)
    #I  class 55 does not split (as in subgroup)
    #I  class 56 does not split (as in subgroup)
    #I  class 57 does not split (as in subgroup)
    #I  class 58 does not split (as in subgroup)
    #I  class 59 does not split (as in subgroup)
    #I  class 61 does not split (as in subgroup)
    #I  class 62 does not split (as in subgroup)
    #I  class 63 does not split (as in subgroup)
    #I  class 65 does not split (as in subgroup)
    #I  class 66 does not split (as in subgroup)
    #I  class 67 does not split (as in subgroup)
    #I  class 69 does not split (as in subgroup)
    #I  class 70 does not split (as in subgroup)
    #I  class 71 does not split (as in subgroup)
    #I  class 72 does not split (as in subgroup)
    #I  class 76 does not split (as in subgroup)
    #I  class 77 does not split (as in subgroup)
    #I  class 78 does not split (as in subgroup)
    #I  class 80 does not split (as in subgroup)
    #I  class 83 does not split (as in subgroup)
    #I  class 84 does not split (as in subgroup)
    #I  class 85 does not split (as in subgroup)
    #I  class 86 does not split (as in subgroup)
    #I  class 87 does not split (as in subgroup)
    #I  class 88 does not split (as in subgroup)
    #I  class 92 does not split (as in subgroup)
    #I  class 93 does not split (as in subgroup)
    #I  class 95 does not split (as in subgroup)
    #I  class 97 does not split (as in subgroup)
    #I  class 99 does not split (as in subgroup)
    #I  class 101 does not split (as in subgroup)
    #I  class 102 does not split (as in subgroup)
    #I  class 103 does not split (as in subgroup)
    #I  class 114 does not split (as in subgroup)
    #I  class 115 does not split (as in subgroup)
    #I  class 116 does not split (as in subgroup)
    #I  class 117 does not split (as in subgroup)
    #I  class 118 does not split (as in subgroup)
    #I  class 119 does not split (as in subgroup)
    #I  class 120 does not split (as in subgroup)
    #I  class 122 does not split (as in subgroup)
    #I  class 123 does not split (as in subgroup)
    #I  class 124 does not split (as in subgroup)
    #I  class 126 does not split (as in subgroup)
    #I  class 129 does not split (as in subgroup)
    #I  class 130 does not split (as in subgroup)
    #I  class 132 does not split (as in subgroup)
    #I  class 133 does not split (as in subgroup)
    #I  class 134 does not split (as in subgroup)
    #I  class 135 does not split (as in subgroup)
    #I  class 137 does not split (as in subgroup)
    #I  class 138 does not split (as in subgroup)
    #I  class 139 does not split (as in subgroup)
    #I  class 141 does not split (as in subgroup)
    #I  class 149 does not split (as in subgroup)
    #I  class 150 does not split (as in subgroup)
    #I  class 152 does not split (as in subgroup)
    #I  class 153 does not split (as in subgroup)
    #I  class 154 does not split (as in subgroup)
    #I  class 156 does not split (as in subgroup)
    #I  class 157 does not split (as in subgroup)
    #I  class 161 does not split (as in subgroup)
    #I  class 163 does not split (as in subgroup)
    #I  class 166 does not split (as in subgroup)
    #I  class 167 does not split (as in subgroup)
    #I  class 168 does not split (as in subgroup)
    #I  class 175 does not split (as in subgroup)
    #I  class 178 does not split (as in subgroup)
    #I  class 179 does not split (as in subgroup)
    #I  class 180 does not split (as in subgroup)
    #I  class 181 does not split (as in subgroup)
    gap&#62; proj:= Filtered( Irr( 2s ), x -&#62; x[1] &lt;&#62; x[2] );;
    gap&#62; projmap:= ProjectionMap( 2sfuss );;
    gap&#62; proj:= List( proj, x -&#62; x{ projmap } );;
    gap&#62; computeContributions( s, t, sfust, proj, 10^6,
    &#62;        mustsplit, mustnotsplit );
    #I  class 3 splits (contribution criterion)
    #I  class 12 splits (contribution criterion)
    #I  class 42 splits (contribution criterion)
    #I  class 22 splits (3rd root of 3)
    #I  class 26 splits (3rd root of 3)
    #I  class 60 splits (3rd root of 12)
    #I  class 64 splits (3rd root of 12)
    #I  class 125 splits (3rd root of 42)
    #I  class 49 splits (5th root of 3)
    #I  class 51 splits (5th root of 3)
    #I  class 105 splits (5th root of 12)
    #I  class 143 splits (5th root of 26)
    #I  class 144 splits (5th root of 26)
    #I  class 111 splits (11th root of 3)
    #I  class 104 does not split (contribution criterion)
    #I  class 28 splits (contribution criterion)
    #I  class 142 splits (5th root of 28)

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;Element orders in 2.B</h3><a name="elementorders2B">
</a>

<div class="p"><!----></div>
All classes of involutions in B contain elements of S.
We see that exactly the preimages under &#960; of the elements
in the third involution class <tt>2C</tt> have order four,
the other involutions of B lift to involutions in 2.B.

<div class="p"><!----></div>

<pre>
    gap&#62; invol:= Positions( OrdersClassRepresentatives( t ), 2 );
    [ 2, 3, 4, 5 ]
    gap&#62; IsSubset( sfust, invol );
    true
    gap&#62; invols:= List( invol, i -&#62; Positions( sfust, i ) );
    [ [ 2, 4, 175 ], [ 3, 5 ], [ 176, 177 ], [ 6, 7, 178 ] ]
    gap&#62; preim2s:= List( invols,
    &#62;        l -&#62; PositionsProperty( 2sfuss, x -&#62; x in l ) );
    [ [ 3, 6, 251 ], [ 4, 5, 7, 8 ], [ 252, 253 ], [ 9, 10, 254 ] ]
    gap&#62; List( preim2s, l -&#62; OrdersClassRepresentatives( 2s ){ l } );
    [ [ 2, 2, 2 ], [ 2, 2, 2, 2 ], [ 4, 4 ], [ 2, 2, 2 ] ]
    gap&#62; invmustlift:= [ 4 ];;
    gap&#62; invmaylift:= [];;

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.4">
6.4</a>&nbsp;&nbsp;The class fusion from 2<sup>2</sup>.<sup>2</sup>E<sub>6</sub>(2).2</h3>

<div class="p"><!----></div>
For two classes of B that contain elements of S,
we have not yet decided whether the preimages under &#960; consist
of one or two classes of 2.B.
We try to use norms of induced characters for a decision.

<div class="p"><!----></div>

<pre>
    gap&#62; open:= Difference( sfust, Union( mustsplit, mustnotsplit ) );
    [ 89, 90 ]
    gap&#62; defined:= [];;
    gap&#62; ker:= ClassPositionsOfKernel( GetFusionMap( 2s, s ) );
    [ 1, 2 ]
    gap&#62; testcharss:= Filtered( Irr( 2s ),
    &#62;        chi -&#62; not IsSubset( ClassPositionsOfKernel( chi ), ker ) );;
    gap&#62; good:= [];;
    gap&#62; for choice in Combinations( open ) do
    &#62;      2t:= tableHead( t, Union( mustsplit, choice ),
    &#62;                      invmustlift, invmaylift ); 
    &#62;      fus:= runOneTest( s, 2s, t, 2t, sfust, testcharss, defined );
    &#62;      if fus &lt;&#62; fail then
    &#62;        Add( good, rec( choice:= choice, table:= 2t, map:= fus ) );
    &#62;      fi;
    &#62;    od;
    gap&#62; List( good, x -&#62; x.choice );
    [ [ 89 ], [ 90 ] ]

</pre>

<div class="p"><!----></div>
We see that exactly one of the two classes must split.
The first possibility can be excluded using other scalar products
between induced characters;
for that, we check all four possible fusions for this case.

<div class="p"><!----></div>

<pre>
    gap&#62; List( good, x -&#62; Indeterminateness( x.map ) );
    [ 4, 4 ]
    gap&#62; goodfus:= [];;
    gap&#62; for map in ContainedMaps( good[1].map ) do
    &#62;      2t:= good[1].table;
    &#62;      ind:= InducedClassFunctionsByFusionMap( 2s, 2t, testcharss, map );
    &#62;      if ForAll( Flat( MatScalarProducts( 2t, ind, ind ) ), IsInt ) then
    &#62;        Add( goodfus, map );
    &#62;      fi;
    &#62;    od;
    gap&#62; Length( goodfus );
    0
    gap&#62; 2t:= good[2].table;;
    gap&#62; 2tfust:= GetFusionMap( 2t, t );;
    gap&#62; AddSet( mustnotsplit, 89 );
    gap&#62; AddSet( mustsplit, 90 );

</pre>

<div class="p"><!----></div>
Two of the remaining four fusion candidates get excluded
by the same criterion.

<div class="p"><!----></div>

<pre>
    gap&#62; inds:= [];;
    gap&#62; for map in ContainedMaps( good[2].map ) do
    &#62;      ind:= InducedClassFunctionsByFusionMap( 2s, 2t, testcharss, map );
    &#62;      if ForAll( Flat( MatScalarProducts( 2t, ind, ind ) ), IsInt ) then
    &#62;        Add( inds, rec( 2tfust:= 2tfust, characters:= ind, map:= map ) );
    &#62;      fi;
    &#62;    od;
    gap&#62; Length( inds );
    2

</pre>

<div class="p"><!----></div>
The second candidate turns out to admit no 2-nd power map.
This determines the class fusion from 2.S and the characters induced
from irreducible characters of 2.S.

<div class="p"><!----></div>

<pre>
    gap&#62; p:= 2;;
    gap&#62; 2tfust:= GetFusionMap( 2t, t );;
    gap&#62; for testinds in inds do
    &#62;      pow:= InitPowerMap( 2t, p );
    &#62;      Congruences( 2t, testinds.characters, pow, p, false );
    &#62;      TransferDiagram( pow, 2tfust, PowerMap( t, p ) );
    &#62;      TransferDiagram( PowerMap( 2s, p ), testinds.map, pow );
    &#62;      factirr:= List( Irr( t ), x -&#62; x{ 2tfust } );
    &#62;      testinds.pow2:= PowerMapsAllowedBySymmetrizations( 2t, factirr,
    &#62;                          testinds.characters, pow, p, parametersFABR );
    &#62;    od;
    gap&#62; List( inds, x -&#62; Length( x.pow2 ) );
    [ 1, 0 ]
    gap&#62; inds:= inds[1];;

</pre>

<div class="p"><!----></div>
Currently 17 classes of B are left for which we do not know yet
whether they split under &#960;<sup>&#8722;1</sup> or not.

<div class="p"><!----></div>

<pre>
    gap&#62; Length( Difference( [ 1 .. NrConjugacyClasses( t ) ],
    &#62;            Union( mustsplit, mustnotsplit ) ) );
    17

</pre>

<div class="p"><!----></div>
We consider another subgroup of B for getting more information
about these classes.

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.5">
6.5</a>&nbsp;&nbsp;Subgroups of the type 2 &times;Th in 2.B</h3><a name="2xThin2B">
</a>

<div class="p"><!----></div>
The sporadic simple Monster group contains a subgroup of the structure
S<sub>3</sub> &times;Th, where the involutions in the direct factor S<sub>3</sub>
are conjugate to z, see [<a href="#Wilson87" name="CITEWilson87">Wil87</a>,p.&nbsp;207].
Thus 2.B contains a subgroup of the structure 2 &times;Th.

<div class="p"><!----></div>

<div class="p"><!----></div>
We apply our criteria to this subgroup.

<div class="p"><!----></div>

<pre>
    gap&#62; th:= CharacterTable( "Th" );;
    gap&#62; poss:= PossibleClassFusions( th, t );;
    gap&#62; Length( poss );
    2
    gap&#62; rep:= RepresentativesFusions( th, poss, Group( () ) );;
    gap&#62; Length( rep );
    1
    gap&#62; thfust:= rep[1];;
    gap&#62; 2th:= CharacterTable( "Cyclic", 2 ) * th;;
    gap&#62; 2thfusth:= GetFusionMap( 2th, th );;
    gap&#62; splittingClassesWithOddCentralizerIndexSplit( th, t, thfust,
    &#62;        2thfusth, mustsplit );
    #I  class 96 splits (odd centralizer index)

</pre>

<div class="p"><!----></div>
We have to adjust the class fusion and the induced characters from 2.S
to the splitting of class 96.
Since such cases will occur several times,
we write a small auxiliary function.

<div class="p"><!----></div>

<pre>
    gap&#62; splitFusionAndCharacters:= function( r, t, tosplit_in_t )
    &#62;      local 2tfust, inv, tosplit_in_2t, result, shift, j, i, spl;
    &#62; 
    &#62;      2tfust:= r.2tfust;
    &#62;      inv:= InverseMap( 2tfust );
    &#62;      tosplit_in_2t:= inv{ tosplit_in_t };
    &#62;      if ForAny( inv{ tosplit_in_t }, IsList ) then
    &#62;        Error( "the classes in ",
    &#62;               Filtered( tosplit_in_t, i -&#62; IsList( inv[i] ) ),
    &#62;               " were already split" );
    &#62;      elif ForAny( r.characters,
    &#62;                   x -&#62; not IsZero( x{ tosplit_in_2t } ) ) then
    &#62;        Error( "all characters must vanish on the classes to be split" );
    &#62;      fi;
    &#62; 
    &#62;      # Adjust the characters of '2t'.
    &#62;      spl:= Concatenation( [ 1 .. Length( r.characters[1] ) ],
    &#62;                           tosplit_in_2t );
    &#62;      Sort( spl );
    &#62;      result:= rec( characters:= List( r.characters, chi -&#62; chi{ spl } ),
    &#62;                    2tfust:= 2tfust{ spl } );
    &#62; 
    &#62;      if IsBound( r.map ) then
    &#62;        if Intersection( tosplit_in_2t, r.map ) &lt;&#62; [] then
    &#62;          Error( "the classes to be split must not occur in the subgroup" );
    &#62;        fi;
    &#62; 
    &#62;        # Adjust the fusion from a subgroup to '2t'.
    &#62;        Add( tosplit_in_2t, Length( 2tfust ) + 1 );
    &#62;        shift:= [];
    &#62;        for j in [ 1 .. tosplit_in_2t[1] - 1 ] do
    &#62;          shift[j]:= 0;
    &#62;        od;
    &#62;        for i in [ 1 .. Length( tosplit_in_2t ) - 1 ] do
    &#62;          for j in [ tosplit_in_2t[i] .. tosplit_in_2t[ i+1 ] - 1 ] do
    &#62;            shift[j]:= i;
    &#62;          od;
    &#62;        od;
    &#62;        result.map:= r.map + shift{ r.map };
    &#62;      fi;
    &#62; 
    &#62;      return result;
    &#62; end;;
    gap&#62; inds:= splitFusionAndCharacters( inds, t, [ 96 ] );;

</pre>

<div class="p"><!----></div>
Four classes of B for which we do not yet know whether they split
contain elements of Th.

<div class="p"><!----></div>

<pre>
    gap&#62; open:= Difference( thfust, Union( mustsplit, mustnotsplit ) );
    [ 45, 53, 108, 127 ]
    gap&#62; defined:= Set( sfust );;
    gap&#62; ker:= ClassPositionsOfKernel( GetFusionMap( 2th, th ) );
    [ 1, 49 ]
    gap&#62; testcharsth:= Filtered( Irr( 2th ),
    &#62;               x -&#62; not IsSubset( ClassPositionsOfKernel( x ), ker ) );;
    gap&#62; good:= [];;
    gap&#62; for choice in Combinations( open ) do
    &#62;      2t:= tableHead( t, Union( mustsplit, choice ),
    &#62;                      invmustlift, invmaylift );
    &#62;      fus:= runOneTest( th, 2th, t, 2t, thfust, testcharsth, defined );
    &#62;      if fus &lt;&#62; fail then
    &#62;        Add( good, rec( choice:= choice, map:= fus, table:= 2t ) );
    &#62;      fi;
    &#62;    od;
    gap&#62; List( good, x -&#62; x.choice );
    [ [ 45, 53, 127 ], [ 53 ], [ 53, 127 ] ]

</pre>

<div class="p"><!----></div>
We see that the class 53 splits, and the class 108 does not split,
but the current information does not allow us to decide which of the
three possible solutions is the right one.

<div class="p"><!----></div>

<pre>
    gap&#62; UniteSet( mustsplit, [ 53 ] );
    gap&#62; UniteSet( mustnotsplit, [ 108 ] );

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Thus we consider all three cases,
adjust the list of characters induced from 2.S accordingly,
and use them to determine the class fusion from 2 &times;Th.
Using also the compatibility with the 2-nd power map,
each possible splitting of classes yields a unique class fusion
from 2 &times;Th and thus a unique list of induced characters
from 2.S and from 2 &times;Th.

<div class="p"><!----></div>

<pre>
    gap&#62; good2:= [];;
    gap&#62; for r in good do
    &#62;      splitinds:= splitFusionAndCharacters( inds, t, r.choice );
    &#62;      2t:= r.table;;
    &#62;      fus:= StructuralCopy( r.map );;
    &#62;      2tfust:= GetFusionMap( 2t, t );;
    &#62;      factirr:= List( Irr( t ), x -&#62; x{ 2tfust } );;
    &#62;      possfus:= FusionsAllowedByRestrictions( 2th, 2t, testcharsth,
    &#62;                   splitinds.characters, fus, parametersFABR );;
    &#62;      for paramap in possfus do
    &#62;        for map in ContainedMaps( paramap ) do
    &#62;          indth:= Set( InducedClassFunctionsByFusionMap( 2th, 2t,
    &#62;                           testcharsth, map ) );
    &#62;          if ForAll( Flat( MatScalarProducts( 2t, indth, indth ) ),
    &#62;                     IsInt ) and
    &#62;             ForAll( Flat( MatScalarProducts( 2t, indth,
    &#62;                               splitinds.characters ) ), IsInt ) then
    &#62;            # Use the 2-nd power map.
    &#62;            ind:= Concatenation( splitinds.characters, indth );
    &#62;            pow:= InitPowerMap( 2t, p );
    &#62;            if Congruences( 2t, ind, pow, p, false ) = true and
    &#62;               TransferDiagram( pow, 2tfust, PowerMap( t, p ) ) &lt;&#62; fail and
    &#62;               TransferDiagram( PowerMap( 2th, p ), map, pow ) &lt;&#62; fail and
    &#62;               TransferDiagram( PowerMap( 2s, p ), splitinds.map,
    &#62;                                pow ) &lt;&#62; fail then
    &#62;              poss:= PowerMapsAllowedBySymmetrizations( 2t, factirr, ind,
    &#62;                         pow, p, parametersFABR );
    &#62;              if Length( poss ) &lt;&#62; 0 then
    &#62;                r.pow2:= poss;
    &#62;                Add( good2, rec( table:= 2t,
    &#62;                                 choice:= r.choice,
    &#62;                                 2thfus2t:= map,
    &#62;                                 ind:= ind,
    &#62;                                 2sfus2t:= splitinds.map ) );
    &#62;              fi;
    &#62;            fi;
    &#62;          fi;
    &#62;        od;
    &#62;      od;
    &#62;    od;
    gap&#62; List( good2, x -&#62; x.choice );
    [ [ 45, 53, 127 ], [ 53 ], [ 53, 127 ] ]

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.6">
6.6</a>&nbsp;&nbsp;Additional characters of 2.B</h3>

<div class="p"><!----></div>
First we consider the case where only class 53 splits.
The cases where also the classes 45 or 127 split
will be dealt with later.

<div class="p"><!----></div>

<pre>
    gap&#62; 2t:= good2[2].table;;
    gap&#62; 2tfust:= GetFusionMap( 2t, t );;
    gap&#62; 2thfus2t:= good2[2].2thfus2t;;
    gap&#62; 2sfus2t:= good2[2].2sfus2t;;
    gap&#62; ind:= good2[2].ind;;
    gap&#62; factirr:= List( Irr( t ), x -&#62; x{ 2tfust } );;

</pre>

<div class="p"><!----></div>
Several classes of B that are known to split into two classes of 2.B
are not contained in the conjugates of the subgroups 2.S and 2 &times;Th.

<div class="p"><!----></div>

<pre>
    gap&#62; nothit_in_t:= Difference( mustsplit, Union( thfust, sfust ) );;
    gap&#62; nothit_in_2t:= PositionsProperty( 2tfust, i -&#62; i in nothit_in_t );
    [ 66, 67, 136, 137, 147, 148, 149, 150, 162, 163, 166, 167, 186, 187, 188, 
      189, 217, 218, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 234, 235, 
      236, 237, 242, 243 ]
    gap&#62; orders_2t:= OrdersClassRepresentatives( 2t );;
    gap&#62; orders_2t{ nothit_in_2t };
    [ 10, 10, 20, 20, 23, 46, 23, 46, 24, 24, 25, 50, 30, 30, 30, 30, 40, 40, 44, 
      44, 46, 46, 46, 46, 47, 94, 47, 94, 104, 104, 55, 110, 60, 60 ]

</pre>

<div class="p"><!----></div>
In order to get characters of 2.B which distinguish the preimages of these
classes, we want to induce from the cyclic subgroups.
For that, we need the values of the power maps on these classes.

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; powermaps:= ComputedPowerMaps( 2t );;
    gap&#62; primes:= Filtered( [ 1 .. Maximum( orders_2t ) ], IsPrimeInt );;
    gap&#62; for p in primes do
    &#62;      pow:= InitPowerMap( 2t, p );
    &#62;      if TransferDiagram( pow, 2tfust, PowerMap( t, p ) ) = fail or
    &#62;         TransferDiagram( PowerMap( 2th, p ), 2thfus2t, pow ) = fail or
    &#62;         TransferDiagram( PowerMap( 2s, p ), 2sfus2t, pow ) = fail or
    &#62;         ConsiderSmallerPowerMaps( 2t, pow, p, false ) &lt;&#62; true or
    &#62;         Congruences( 2t, ind, pow, p, false ) &lt;&#62; true then
    &#62;        Error( "contradiction" );
    &#62;      fi;
    &#62;      poss:= PowerMapsAllowedBySymmetrizations( 2t, ind, ind,
    &#62;                 pow, p, parametersFABR );
    &#62;      if Length( poss ) = 1 then
    &#62;        powermaps[p]:= poss[1];
    &#62;      else
    &#62;        powermaps[p]:= pow;
    &#62;      fi;
    &#62;    od;

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
Now the power maps for several of the interesting classes are known.

<div class="p"><!----></div>

<pre>
    gap&#62; known:= Filtered( nothit_in_2t,
    &#62;                i -&#62; ForAll( powermaps, map -&#62; IsInt( map[i] ) ) );
    [ 147, 148, 149, 150, 166, 167, 228, 229, 230, 231, 236, 237 ]

</pre>

<div class="p"><!----></div>
Note that the ambiguities in the current power map information
concern the question whether the p-th power of an element is conjugate
to some element g or to g z,
since the power maps of the factor group B must be respected.
In several cases, we can improve the power map information using the
following criterion.

<div class="p"><!----></div>
Suppose that g and g z are not conjugate
and that p is an odd prime such that g<sup>p</sup> is conjugate
to either g or g z.
Suppose that k is an odd number (dividing the order of g)
such that g<sup>k</sup> and g<sup>k</sup> z are not conjugate.
Then g<sup>p</sup> is conjugate to g if and only if (g<sup>k</sup>)<sup>p</sup> is conjugate to g<sup>k</sup>.

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; List( Difference( nothit_in_2t, known ),
    &#62;          i -&#62; Number( powermaps, map -&#62; IsList( map[i] ) ) );
    [ 22, 22, 25, 25, 26, 26, 26, 26, 26, 26, 27, 27, 26, 26, 27, 27, 27, 27, 27, 
      27, 27, 27 ]
    gap&#62; oddprimes:= Difference( primes, [ 2 ] );;
    gap&#62; inv:= InverseMap( 2tfust );;
    gap&#62; for i in [ 1 .. Length( inv ) ] do
    &#62;      if IsList( inv[i] ) then
    &#62;        # the classes of g and g*z
    &#62;        pair:= inv[i];
    &#62;        for p in oddprimes do
    &#62;          if powermaps[p]{ pair } = [ pair, pair ] then
    &#62;            # the p-th powers of g and g*z are conj. to g or g*z
    &#62;            for k in Filtered( oddprimes,
    &#62;                               x -&#62; orders_2t[ pair[1] ] mod x = 0 ) do
    &#62;              img:= powermaps[k][ pair[1] ];
    &#62;              if IsList( img ) then
    &#62;                if powermaps[p]{ img } = img then
    &#62;                  # the p-th power of g^k is conj. to g^k 
    &#62;                  powermaps[p]{ pair }:= pair;
    &#62;                elif powermaps[p]{ img } = Reversed( img ) then
    &#62;                  # the p-th power of g^k is conj. to g^k*z
    &#62;                  powermaps[p]{ pair }:= pair{ [ 2, 1 ] };
    &#62;                fi;
    &#62;              fi;
    &#62;            od;
    &#62;          fi;
    &#62;        od;
    &#62;      fi;
    &#62;    od;
    gap&#62; List( Difference( nothit_in_2t, known ),
    &#62;          i -&#62; Number( powermaps, map -&#62; IsList( map[i] ) ) );
    [ 1, 1, 1, 1, 1, 1, 17, 17, 17, 17, 27, 27, 26, 26, 18, 18, 18, 18, 27, 27, 
      2, 2 ]

</pre>

<div class="p"><!----></div>
We may choose the 5-th powers of the classes 66, 67, 136, 137,
and the 3-rd powers of the classes 162, 163.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= [ 66, 67, 136, 137 ];;
    gap&#62; powermaps[5]{ pos };
    [ [ 4, 5 ], [ 4, 5 ], [ 16, 17 ], [ 16, 17 ] ]
    gap&#62; powermaps[5]{ pos }:= [ 4, 5, 16, 17 ];;
    gap&#62; pos:= [ 162, 163 ];;
    gap&#62; powermaps[3]{ pos };
    [ [ 53, 54 ], [ 53, 54 ] ]
    gap&#62; powermaps[3]{ pos }:= [ 53, 54 ];;

</pre>

<div class="p"><!----></div>
Concerning the classes 242 and 243 (of element order 60),
the 3-rd and 5-th powers are not yet determined.
We may choose the 3-rd powers, this determines the 5-th powers.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= [ 242, 243 ];;
    gap&#62; powermaps[3]{ pos };
    [ [ 136, 137 ], [ 136, 137 ] ]
    gap&#62; powermaps[5]{ pos };
    [ [ 78, 79 ], [ 78, 79 ] ]
    gap&#62; powermaps[3]{ [ 78, 79 ] };
    [ 16, 17 ]
    gap&#62; powermaps[3]{ pos }:= [ 136, 137 ];;
    gap&#62; powermaps[5]{ pos }:= [ 78, 79 ];;

</pre>

<div class="p"><!----></div>
Let us look at the four relevant classes of element order 46.
They are the preimages of two Galois conjugate classes of B.
The current power maps would admit the possibilities that all four classes
are Galois conjugate or that they are two pairs of generators of
nonconjugate cyclic subgroups.
The former possibility is excluded by the fact that
the number field generated by 46-th roots of unity does not
contain a field of degree four.
Thus the character values on the four classes lie in the unique quadratic
subfield, which is the field generated by &#8730;{&#8722;23}.
We can set the correct power map values with the function
<tt>setGaloisInfo</tt> that has been introduced in Section&nbsp;<a href="#sectpowermapsTh">2.3</a>.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Intersection( Difference( nothit_in_2t, known ),
    &#62;                        Positions( orders_2t, 46 ) );
    [ 224, 225, 226, 227 ]
    gap&#62; powermaps[5]{ pos };
    [ [ 226, 227 ], [ 226, 227 ], [ 224, 225 ], [ 224, 225 ] ]
    gap&#62; setGaloisInfo( powermaps, [ 224, 226 ], orders_2t, primes, Sqrt(-23) );
    gap&#62; setGaloisInfo( powermaps, [ 225, 227 ], orders_2t, primes, Sqrt(-23) );

</pre>

<div class="p"><!----></div>
Now only the 23-rd power map is not uniquely determined on the classes
in question.
Since we have not yet distinguished the two preimages of the corresponding
classes of the factor group B (all induced characters computed up to now
are zero on these classes), we may choose them.

<div class="p"><!----></div>

<pre>
    gap&#62; powermaps[23]{ pos };                                            
    [ [ 4, 5 ], [ 4, 5 ], [ 4, 5 ], [ 4, 5 ] ]
    gap&#62; powermaps[23]{ pos }:= [ 4, 5, 4, 5 ];;
    gap&#62; ForAll( List( powermaps, x -&#62; x{ pos } ), IsPositionsList );
    true

</pre>

<div class="p"><!----></div>
Let us look at the four relevant classes of element order 30.
They are the preimages of two Galois conjugate classes of B,
with character values in the field generated by &#8730;{&#8722;15}.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Intersection( nothit_in_2t, Positions( orders_2t, 30 ) );
    [ 186, 187, 188, 189 ]
    gap&#62; Field( Flat( List( factirr, x -&#62; x{ pos } ) ) )
    &#62;    = Field( Rationals, [ Sqrt( -15 ) ] );
    true

</pre>

<div class="p"><!----></div>
The 3-rd powers of the classes 186, 187 are the classes 66 and 67,
which are known to be rational from the above computations.
This means that the classes 186 and 187 are not Galois conjugate.
Thus there are two pairs of Galois conjugate classes,
and we may choose that the class 186 is Galois conjugate to 188.
Furthermore, we may choose that the 3-rd powers of the class 186 lie
in the class 66.
This determines the 5-th powers.

<div class="p"><!----></div>

<pre>
    gap&#62; List( powermaps, x -&#62; x[66] );
    [ , 25, 66,, 4,, 66,,,, 66,, 66,,,, 66,, 66,,,, 66,,,,,, 66,, 66,,,,,, 66,,,, 
      66,, 66,,,, 66,,,,,, 66,,,,,, 66,, 66,,,,,, 66,,,, 66,, 66,,,,,, 66,,,, 66,,
      ,,,, 66,,,,,,,, 66,,,, 66,, 66,,,, 66,, 66 ]
    gap&#62; setGaloisInfo( powermaps, [ 186, 188 ], orders_2t, primes, Sqrt(-15) );
    gap&#62; setGaloisInfo( powermaps, [ 187, 189 ], orders_2t, primes, Sqrt(-15) );
    gap&#62; powermaps[3]{ pos };
    [ [ 66, 67 ], [ 66, 67 ], [ 66, 67 ], [ 66, 67 ] ]
    gap&#62; powermaps[3]{ pos }:= [ 66, 67, 66, 67 ];;
    gap&#62; powermaps[5]{ pos };
    [ [ 34, 35 ], [ 34, 35 ], [ 34, 35 ], [ 34, 35 ] ]
    gap&#62; powermaps[3]{ [ 34, 35 ] };
    [ 4, 5 ]
    gap&#62; powermaps[5]{ [ 66, 67 ] };
    [ 4, 5 ]
    gap&#62; powermaps[5]{ pos }:= [ 34, 35, 34, 35 ];;
    gap&#62; ForAll( List( powermaps, x -&#62; x{ pos } ), IsPositionsList ); #  true
    true

</pre>

<div class="p"><!----></div>
Let us look at the two classes of element order 44.
They are the preimages of a unique (and hence rational) class of B.
Thus the character values on the classes of element order 44 lie in
a quadratic subfield of the field of 44-th roots of unity;
so the possible fields are the rational number field and the fields
generated by &#8730;{&#8722;1}, &#8730;{11}, &#8730;{&#8722;11}.
For all four cases, we compute the candidates of characters induced from
the cyclic subgroup of order 44,
and check their norms and scalar products of 2-nd symmetrizations
with the irreducible characters of B.
It turns out that the field of character values on the classes in question
is generated by &#8730;{&#8722;11}.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Intersection( nothit_in_2t, Positions( orders_2t, 44 ) );
    [ 222, 223 ]
    gap&#62; vals:= List( [ 1, -1, 11, -11 ], Sqrt );;
    gap&#62; good:= [];;
    gap&#62; for val in vals do
    &#62;      setGaloisInfo( powermaps, pos, orders_2t, primes, val );
    &#62;      indcyc:= InducedCyclic( 2t, pos, "all" );
    &#62;      if ForAll( indcyc, x -&#62; IsInt( ScalarProduct( 2t, x, x ) ) ) then
    &#62;        minus:= MinusCharacter( indcyc[1], powermaps[2], 2 );
    &#62;        if ForAll( List( factirr, x -&#62; ScalarProduct( 2t, x, minus ) ), 
    &#62;                   IsInt ) then
    &#62;          Add( good, val );
    &#62;        fi;
    &#62;      fi;
    &#62;    od;
    gap&#62; good = [ Sqrt( -11 ) ];
    true
    gap&#62; setGaloisInfo( powermaps, pos, orders_2t, primes, good[1] );

</pre>

<div class="p"><!----></div>
Let us look at the two classes of element order 104.
As in the previous case,
they are the preimages of a unique (and hence rational) class of B.
Here the candidates for the fields of character values are generated by
&#8730;n, for n  &#8712; { &#177;1, &#177;2, &#177;13, &#177;26 }.
We proceed as above, and get the unique solution &#8730;{&#8722;26}.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Intersection( nothit_in_2t, Positions( orders_2t, 104 ) );
    [ 234, 235 ]
    gap&#62; vals:= List( [ 1, -1, 2, -2, 13, -13, 26, -26 ], Sqrt );;
    gap&#62; good:= [];;
    gap&#62; for val in vals do
    &#62;      setGaloisInfo( powermaps, pos, orders_2t, primes, val );
    &#62;      indcyc:= InducedCyclic( 2t, pos, "all" );
    &#62;      if ForAll( indcyc, x -&#62; IsInt( ScalarProduct( 2t, x, x ) ) ) then
    &#62;        minus:= MinusCharacter( indcyc[1], powermaps[2], 2 );
    &#62;        if ForAll( List( factirr, x -&#62; ScalarProduct( 2t, x, minus ) ), 
    &#62;                   IsInt ) then
    &#62;          Add( good, val );
    &#62;        fi;
    &#62;      fi;
    &#62;    od;
    gap&#62; good = [ Sqrt( -26 ) ];
    true
    gap&#62; setGaloisInfo( powermaps, pos, orders_2t, primes, good[1] );

</pre>

<div class="p"><!----></div>
Now exactly two classes are left for which we want to determine the
power map values; these classes have element order 40.

<div class="p"><!----></div>

<pre>
    gap&#62; pos:= Intersection( nothit_in_2t, Positions( orders_2t, 40 ) );
    [ 217, 218 ]

</pre>

<div class="p"><!----></div>
First we observe that the 2-nd power map for these classes is determined
by the fact that the 2-nd power map commutes with the 5-th power map.

<div class="p"><!----></div>

<pre>
    gap&#62; powermaps[2]{ pos };
    [ [ 136, 137 ], [ 136, 137 ] ]
    gap&#62; TransferDiagram( powermaps[5], powermaps[2], powermaps[5] );
    rec( impbetween := [ 131, 139, 217, 218 ], impinside1 := [  ], 
      impinside2 := [  ] )
    gap&#62; IsPositionsList( powermaps[2] );
    true

</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
As in the above cases, we have to determine the field of character values
on these classes, in order to write down the power maps.
Here the candidates for the fields of character values are generated by
&#8730;n, for n  &#8712; { &#177;1, &#177;2, &#177;5, &#177;10 }.
We proceed as above, but unfortunately we get two solutions.

<div class="p"><!----></div>

<pre>
    gap&#62; vals:= List( [ 1, -1, 2, -2, 5, -5, 10, -10 ], Sqrt );;
    gap&#62; good:= [];;
    gap&#62; for val in vals do
    &#62;      setGaloisInfo( powermaps, pos, orders_2t, primes, val );
    &#62;      indcyc:= InducedCyclic( 2t, pos, "all" );
    &#62;      if ForAll( indcyc, x -&#62; IsInt( ScalarProduct( 2t, x, x ) ) ) then
    &#62;        minus:= MinusCharacter( indcyc[1], powermaps[2], 2 );
    &#62;        if ForAll( List( factirr, x -&#62; ScalarProduct( 2t, x, minus ) ),
    &#62;                   IsInt ) then
    &#62;          Add( good, val );
    &#62;        fi;
    &#62;      fi;
    &#62;    od;
    gap&#62; good = [ Sqrt( 5 ), Sqrt( -5 ) ];
    true

</pre>

<div class="p"><!----></div>

     <h3><a name="tth_sEc6.7">
6.7</a>&nbsp;&nbsp;The irreducible characters of 2.B</h3>

<div class="p"><!----></div>
Now we can induce characters from the interesting cyclic subgroups,
except that we get two sets of candidates induced from the subgroups
of order 40, depending on the power maps.

<div class="p"><!----></div>
We try the first case, where the field of character values on class 217
is generated by &#8730;5.
As in the preceding sections, we apply the LLL algorithm to the set
of induced characters, and compute the possible orthogonal embeddings.
Note that the maximal possible dimension is 63 + 14 = 77.

<div class="p"><!----></div>

<pre>
    gap&#62; indcyc:= InducedCyclic( 2t, Difference( nothit_in_2t, pos ), "all" );;
    gap&#62; indcyc:= Reduced( 2t, factirr, indcyc ).remainders;;
    gap&#62; setGaloisInfo( powermaps, pos, orders_2t, primes, Sqrt( 5 ) );
    gap&#62; indcyc40r5:= InducedCyclic( 2t, pos, "all" );;
    gap&#62; indcyc40r5:= Reduced( 2t, factirr, indcyc40r5 ).remainders;;
    gap&#62; testind:= Concatenation( ind, indcyc, indcyc40r5 );;
    gap&#62; lll:= LLL( 2t, testind, 99/100 );;
    gap&#62; Length( lll.norms );
    63
    gap&#62; Length( mustsplit );
    63
    gap&#62; Length( Difference( [ 1 .. NrConjugacyClasses( t ) ],
    &#62;            Union( mustsplit, mustnotsplit ) ) );
    14
    gap&#62; gram:= MatScalarProducts( 2t, lll.remainders, lll.remainders );;
    gap&#62; emb:= OrthogonalEmbeddings( gram, 63 + 14 );;
    gap&#62; List( emb.solutions, Length );
    [ 63, 63, 63, 65, 65, 65 ]
    gap&#62; dec:= List( emb.solutions,
    &#62;              x -&#62; Decreased( 2t, lll.remainders, emb.vectors{ x } ) );;
    gap&#62; Positions( dec, fail );
    [ 1, 2, 3, 6 ]

</pre>

<div class="p"><!----></div>
We got six possible embeddings,
of which two are compatible with the situation that the vectors
are virtual characters;
these two solutions would require (at least) 65
faithful irreducible characters.

<div class="p"><!----></div>

<pre>
    gap&#62; dec:= Filtered( dec, x -&#62; x &lt;&#62; fail );;
    gap&#62; List( dec, r -&#62; Length( r.irreducibles ) );
    [ 61, 61 ]

</pre>

<div class="p"><!----></div>
We claim that these solutions cannot lead to the character table of 2.B.
Suppose that the 61 vectors are irreducible characters of 2.B.
Then there are four more irreducible characters &#967;<sub>i</sub>,
i  &#8712; { 1, 2, 3, 4 }, such that n = &#8721;<sub>i=1</sub><sup>4</sup> &#967;<sub>i</sub>(1)<sup>2</sup>
is the difference of &#124;B&#124; and the sum of the squares of the degrees
of the 61 irreducible characters.

<div class="p"><!----></div>

<pre>
    gap&#62; degreesum:= List( dec,
    &#62;        r -&#62; Sum( List( r.irreducibles, x -&#62; x[1]^2 ) ) );;
    gap&#62; Set( degreesum );
    [ 4154780380522839827726467072000000 ]
    gap&#62; n:= Size( t ) - degreesum[1];
    1100703586363451113472000000

</pre>

<div class="p"><!----></div>
Reducing the input characters with the 61 irreducible characters
yields a character &#968; of norm 2 and degree &#8730;{2n}.

<div class="p"><!----></div>

<pre>
    gap&#62; red:= List( dec, r -&#62; Reduced( 2t, r.irreducibles, testind ) );;
    gap&#62; norm2:= List( red, r -&#62; First( r.remainders,
    &#62;                              x -&#62; ScalarProduct( 2t, x, x ) = 2 ) );;
    gap&#62; norm2[1] = norm2[2];
    true
    gap&#62; norm2[1][1] = Sqrt( 2 * n );
    true

</pre>

<div class="p"><!----></div>
Without loss of generality, let &#968; =  &#967;<sub>1</sub> + &#967;<sub>2</sub>.
Then the general inequality 2 (a<sup>2</sup> + b<sup>2</sup>)  &#8805; (a+b)<sup>2</sup>
yields &#967;<sub>1</sub>(1)<sup>2</sup> + &#967;<sub>2</sub>(1)<sup>2</sup>  &#8805; &#968;(1)<sup>2</sup> / 2 = n.
This contradicts the conditions &#967;<sub>3</sub>(1)  &#8805; 0 and &#967;<sub>4</sub>(1)  &#8805; 0.

<div class="p"><!----></div>
Let us try the other possibility for the power maps.

<div class="p"><!----></div>

<pre>
    gap&#62; setGaloisInfo( powermaps, pos, orders_2t, primes, Sqrt( -5 ) );
    gap&#62; indcyc40i5:= InducedCyclic( 2t, pos, "all" );;
    gap&#62; indcyc40i5:= Reduced( 2t, factirr, indcyc40i5 ).remainders;;
    gap&#62; testind:= Concatenation( ind, indcyc, indcyc40i5 );;
    gap&#62; lll:= LLL( 2t, testind, 99/100 );;
    gap&#62; gram:= MatScalarProducts( 2t, lll.remainders, lll.remainders );;
    gap&#62; emb:= OrthogonalEmbeddings( gram, 63 + 14 );;
    gap&#62; List( emb.solutions, Length );
    [ 63, 63, 63, 65, 65, 65 ]
    gap&#62; dec:= List( emb.solutions,
    &#62;              x -&#62; Decreased( 2t, lll.remainders, emb.vectors{ x } ) );;
    gap&#62; Positions( dec, fail );
    [ 3, 6 ]
    gap&#62; dec:= Filtered( dec, x -&#62; x &lt;&#62; fail );;
    gap&#62; List( dec, r -&#62; Length( r.irreducibles ) );
    [ 63, 63, 61, 61 ]

</pre>

<div class="p"><!----></div>
Here we get four solutions, two in dimension 63 and two in dimension 65.
The latter two solutions are excluded with the same argument as above.

<div class="p"><!----></div>

<pre>
    gap&#62; dec1:= dec{ [ 1, 2 ] };;
    gap&#62; dec2:= dec{ [ 3, 4 ] };;
    gap&#62; degreesum:= List( dec2,
    &#62;        r -&#62; Sum( List( r.irreducibles, x -&#62; x[1]^2 ) ) );;
    gap&#62; Set( degreesum );
    [ 4154780380522839827726467072000000 ]
    gap&#62; n:= Size( t ) - degreesum[1];
    1100703586363451113472000000
    gap&#62; red:= List( dec2, r -&#62; Reduced( 2t, r.irreducibles, testind ) );;
    gap&#62; norm2:= List( red, r -&#62; First( r.remainders,
    &#62;                              x -&#62; ScalarProduct( 2t, x, x ) = 2 ) );;
    gap&#62; Length( Set( norm2 ) );
    1
    gap&#62; norm2[1][1] = Sqrt( 2 * n );
    true

</pre>

<div class="p"><!----></div>
Thus we are left with the two solutions in dimension 63,
for which all irreducibles are known.
Each of them leads to a character table that is equivalent to the
character table that is stored for 2.B in <font face="helvetica">GAP</font>'s character table library.

<div class="p"><!----></div>

<pre>
    gap&#62; HasIrr( 2t );
    false
    gap&#62; SetIrr( 2t, Concatenation( factirr, dec1[1].irreducibles ) );
    gap&#62; lib:= CharacterTable( "2.B" );;
    gap&#62; TransformingPermutationsCharacterTables( 2t, lib );
    rec( columns := (4,5)(29,30)(34,35)(63,64)(66,67)(122,123)(125,126)(145,
        146)(186,187)(188,189)(224,225)(226,227), 
      group := &lt;permutation group with 17 generators&#62;, 
      rows := (185,213,243,236,191,205,225,229,247,200,232,222,207,216,187,206,
        212,234,194,244,217,202,245,199,238,235,221,192,214,230,201,186,211,227,
        226,208,198,242,218,193,209,220,196,210,241,203,189,224,219,197,204,223,
        240,190,215,195,233)(188,239)(231,246,237) )
    gap&#62; ResetFilterObj( 2t, HasIrr );
    gap&#62; SetIrr( 2t, Concatenation( factirr, dec1[2].irreducibles ) );
    gap&#62; TransformingPermutationsCharacterTables( 2t, lib );
    rec( columns := (4,5)(29,30)(34,35)(63,64)(66,67)(122,123)(125,126)(143,
        144)(145,146)(186,187)(188,189)(224,225)(226,227)(244,245), 
      group := &lt;permutation group with 17 generators&#62;, 
      rows := (185,212,234,194,244,217,202,245,199,238,190,215,195,233)(186,211,
        227,226,208,198,242,218,193,209,220,196,210,241,203,189,224,219,197,204,
        223,240,235,221,192,214,230,201)(187,206,213,243,191,205,225,229,247,200,
        232,222,207,216)(188,239)(231,246,237) )

</pre>

<div class="p"><!----></div>
It remains to show that the two possible class splittings cannot occur
where the classes 127 or 45 of B split in 2.B.

<div class="p"><!----></div>
For that, it suffices to split the relevant classes
in the characters that are induced from cyclic subgroups.
First we deal with the case where additionally exactly class 127 splits.
As above, we have to consider two possible sets of induced characters.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; good2[3].choice;
    [ 53, 127 ]
    gap&#62; pos:= Positions( 2tfust, 127 );
    [ 165 ]
    gap&#62; 2t:= good2[3].table;;
    gap&#62; 2tfust:= GetFusionMap( 2t, t );;
    gap&#62; 2thfus2t:= good2[3].2thfus2t;;
    gap&#62; 2sfus2t:= good2[3].2sfus2t;;
    gap&#62; ind:= good2[3].ind;;
    gap&#62; factirr:= List( Irr( t ), x -&#62; x{ 2tfust } );;
    gap&#62; UniteSet( mustsplit, good2[3].choice );
    gap&#62; spl:= SortedList( Concatenation( [ 1 .. 247 ], pos ) );;
    gap&#62; testind:= Concatenation( good2[3].ind,
    &#62;        List( Concatenation( indcyc, indcyc40r5 ), x -&#62; x{ spl } ) );;
    gap&#62; lll:= LLL( 2t, testind, 99/100 );;
    gap&#62; Length( lll.norms );
    64
    gap&#62; Length( mustsplit );
    64
    gap&#62; Length( Difference( [ 1 .. NrConjugacyClasses( t ) ],
    &#62;            Union( mustsplit, mustnotsplit ) ) );
    13
    gap&#62; gram:= MatScalarProducts( 2t, lll.remainders, lll.remainders );;
    gap&#62; emb:= OrthogonalEmbeddings( gram, 64+13 );;
    gap&#62; List( emb.solutions, Length );
    [ 64, 64, 64, 65, 65, 65, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 
      69, 69 ]
    gap&#62; dec:= List( emb.solutions,
    &#62;            x -&#62; Decreased( 2t, lll.remainders, emb.vectors{ x } ) );;
    gap&#62; Positions( dec, fail );
    [ 1, 2, 3, 6, 7, 8, 9, 16, 17, 18, 21 ]
    gap&#62; dec:= Filtered( dec, x -&#62; x &lt;&#62; fail );;
    gap&#62; List( dec, r -&#62; Length( r.irreducibles ) );
    [ 61, 61, 63, 61, 61, 63, 61, 61, 61, 61 ]
    gap&#62; degreesum:= List( dec,
    &#62;        r -&#62; Sum( List( r.irreducibles, x -&#62; x[1]^2 ) ) );;
    gap&#62; degreesumset:= Set( degreesum );
    [ 4154780380522839827726467072000000, 4154781481226426191177580544000000 ]
    gap&#62; n:= Size( t ) - degreesumset;
    [ 1100703586363451113472000000, 0 ]
    gap&#62; List( degreesumset, x -&#62; Positions( degreesum, x ) );
    [ [ 1, 2, 4, 5, 7, 8, 9, 10 ], [ 3, 6 ] ]
    gap&#62; dec:= dec{ Positions( degreesum, degreesumset[1] ) };;
    gap&#62; red:= List( dec, r -&#62; Reduced( 2t, r.irreducibles, testind ) );;
    gap&#62; norm2:= List( red, r -&#62; First( r.remainders,
    &#62;                              x -&#62; ScalarProduct( 2t, x, x ) = 2 ) );;
    gap&#62; Length( Set( norm2 ) );
    1
    gap&#62; norm2[1][1] = Sqrt( 2 * n[1] );
    true

</pre>

<div class="p"><!----></div>
We see that all possible embeddings would require dimension
at least 65.
In those cases where 63 irreducible characters are known,
the sum of squares of their degrees is already too large.
And in those cases where 61 irreducible characters are known,
there is a character of norm two (as above)
such that no space is left for the remaining irreducibles.

<div class="p"><!----></div>
Next we consider the second set of induced characters.

<div class="p"><!----></div>

<pre>
    gap&#62; testind:= Concatenation( good2[3].ind,
    &#62;        List( Concatenation( indcyc, indcyc40i5 ), x -&#62; x{ spl } ) );;
    gap&#62; lll:= LLL( 2t, testind, 99/100 );;
    gap&#62; gram:= MatScalarProducts( 2t, lll.remainders, lll.remainders );;
    gap&#62; emb:= OrthogonalEmbeddings( gram, 64+13 );;
    gap&#62; List( emb.solutions, Length );
    [ 64, 64, 64, 65, 65, 65, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 69, 
      69, 69 ]
    gap&#62; dec:= List( emb.solutions,
    &#62;            x -&#62; Decreased( 2t, lll.remainders, emb.vectors{ x } ) );;
    gap&#62; Positions( dec, fail );
    [ 1, 2, 3, 6, 7, 8, 9, 16, 17, 18, 21 ]
    gap&#62; dec:= Filtered( dec, x -&#62; x &lt;&#62; fail );;
    gap&#62; List( dec, r -&#62; Length( r.irreducibles ) );
    [ 61, 61, 63, 61, 61, 63, 61, 61, 61, 61 ]
    gap&#62; degreesum:= List( dec,
    &#62;        r -&#62; Sum( List( r.irreducibles, x -&#62; x[1]^2 ) ) );;
    gap&#62; degreesumset:= Set( degreesum );
    [ 4154780380522839827726467072000000, 4154781481226426191177580544000000 ]
    gap&#62; n:= Size( t ) - degreesumset;
    [ 1100703586363451113472000000, 0 ]
    gap&#62; List( degreesumset, x -&#62; Positions( degreesum, x ) );
    [ [ 1, 2, 4, 5, 7, 8, 9, 10 ], [ 3, 6 ] ]
    gap&#62; dec:= dec{ Positions( degreesum, degreesumset[1] ) };;
    gap&#62; red:= List( dec, r -&#62; Reduced( 2t, r.irreducibles, testind ) );;
    gap&#62; norm2:= List( red, r -&#62; First( r.remainders,
    &#62;                              x -&#62; ScalarProduct( 2t, x, x ) = 2 ) );;
    gap&#62; Length( Set( norm2 ) );
    1
    gap&#62; norm2[1][1] = Sqrt( 2 * n[1] );
    true

</pre>

<div class="p"><!----></div>
All solutions for this case can be excluded by the same arguments.
Thus <tt>good2[3]</tt> does not lead to a character table.

<div class="p"><!----></div>
Finally, we consider the two sets of induced characters in the case
that the two classes 45 and 127 of B split in 2.B.

<div class="p"><!----></div>

<div class="p"><!----></div>

<pre>
    gap&#62; good2[1].choice;
    [ 45, 53, 127 ]
    gap&#62; 2tfust:= GetFusionMap( good2[2].table, t );;
    gap&#62; pos:= Union( Positions( 2tfust, 45 ), Positions( 2tfust, 127 ) );
    [ 57, 165 ]
    gap&#62; 2t:= good2[1].table;;
    gap&#62; 2tfust:= GetFusionMap( 2t, t );;
    gap&#62; 2thfus2t:= good2[1].2thfus2t;;
    gap&#62; 2sfus2t:= good2[1].2sfus2t;;
    gap&#62; ind:= good2[1].ind;;
    gap&#62; factirr:= List( Irr( t ), x -&#62; x{ 2tfust } );;
    gap&#62; UniteSet( mustsplit, good2[1].choice );
    gap&#62; spl:= SortedList( Concatenation( [ 1 .. 247 ], pos ) );;
    gap&#62; testind:= Concatenation( good2[1].ind,
    &#62;        List( Concatenation( indcyc, indcyc40r5 ), x -&#62; x{ spl } ) );;
    gap&#62; lll:= LLL( 2t, testind, 99/100 );;
    gap&#62; Length( lll.norms );
    65
    gap&#62; Length( mustsplit );
    65
    gap&#62; Length( Difference( [ 1 .. NrConjugacyClasses( t ) ],
    &#62;            Union( mustsplit, mustnotsplit ) ) );
    12
    gap&#62; gram:= MatScalarProducts( 2t, lll.remainders, lll.remainders );;
    gap&#62; emb:= OrthogonalEmbeddings( gram, 65+12 );;
    gap&#62; List( emb.solutions, Length );
    [ 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 
      67, 67, 67, 67, 67, 67, 67, 67, 68, 68, 68, 69, 69, 69, 69, 69, 69, 69, 69, 
      69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 71, 71, 71 ]
    gap&#62; dec:= List( emb.solutions,
    &#62;            x -&#62; Decreased( 2t, lll.remainders, emb.vectors{ x } ) );;
    gap&#62; Positions( dec, fail );
    [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 14, 15, 24, 25, 26, 27, 28, 29, 30, 33, 
      34, 35, 36, 45, 46, 47, 48, 51 ]
    gap&#62; dec:= Filtered( dec, x -&#62; x &lt;&#62; fail );;
    gap&#62; List( dec, r -&#62; Length( r.irreducibles ) );
    [ 63, 63, 63, 61, 61, 61, 63, 61, 61, 61, 63, 63, 63, 61, 61, 61, 63, 61, 61, 
      61, 61, 61 ]
    gap&#62; degreesum:= List( dec,
    &#62;        r -&#62; Sum( List( r.irreducibles, x -&#62; x[1]^2 ) ) );;
    gap&#62; degreesumset:= Set( degreesum );
    [ 4154780380522839827726467072000000, 4154781481226426191177580544000000 ]
    gap&#62; Size( t ) - degreesumset;
    [ 1100703586363451113472000000, 0 ]
    gap&#62; Positions( degreesum, degreesumset[2] );
    [ 1, 2, 3, 7, 11, 12, 13, 17 ]
    gap&#62; dec:= dec{ Positions( degreesum, degreesumset[1] ) };;
    gap&#62; red:= List( dec, r -&#62; Reduced( 2t, r.irreducibles, testind ) );;
    gap&#62; norm2:= List( red, r -&#62; First( r.remainders,
    &#62;                              x -&#62; ScalarProduct( 2t, x, x ) = 2 ) );;
    gap&#62; Length( Set( norm2 ) );
    1
    gap&#62; norm2[1][1];
    0

</pre>

<div class="p"><!----></div>
In the situation of the first set of induced characters,
we get no character table.
The only difference in the arguments is that some solutions
are excluded by the existence of a "character" of norm two
and degree zero.

<div class="p"><!----></div>
As a last step, we consider the second set of induced characters.
The arguments are exactly the same as above.

<div class="p"><!----></div>

<pre>
    gap&#62; testind:= Concatenation( good2[1].ind,
    &#62;        List( Concatenation( indcyc, indcyc40i5 ), x -&#62; x{ spl } ) );;
    gap&#62; lll:= LLL( 2t, testind, 99/100 );;
    gap&#62; gram:= MatScalarProducts( 2t, lll.remainders, lll.remainders );;
    gap&#62; emb:= OrthogonalEmbeddings( gram, 65+12 );;
    gap&#62; List( emb.solutions, Length );
    [ 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 
      67, 67, 67, 67, 67, 67, 67, 67, 68, 68, 68, 69, 69, 69, 69, 69, 69, 69, 69, 
      69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 71, 71, 71 ]
    gap&#62; dec:= List( emb.solutions,
    &#62;            x -&#62; Decreased( 2t, lll.remainders, emb.vectors{ x } ) );;
    gap&#62; Positions( dec, fail );
    [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 14, 15, 24, 25, 26, 27, 28, 29, 30, 33, 
      34, 35, 36, 45, 46, 47, 48, 51 ]
    gap&#62; dec:= Filtered( dec, x -&#62; x &lt;&#62; fail );;
    gap&#62; List( dec, r -&#62; Length( r.irreducibles ) );
    [ 63, 63, 63, 61, 61, 61, 63, 61, 61, 61, 63, 63, 63, 61, 61, 61, 63, 61, 61, 
      61, 61, 61 ]
    gap&#62; degreesum:= List( dec,
    &#62;        r -&#62; Sum( List( r.irreducibles, x -&#62; x[1]^2 ) ) );;
    gap&#62; degreesumset:= Set( degreesum );
    [ 4154780380522839827726467072000000, 4154781481226426191177580544000000 ]
    gap&#62; Size( t ) - degreesumset;
    [ 1100703586363451113472000000, 0 ]
    gap&#62; Positions( degreesum, degreesumset[2] );
    [ 1, 2, 3, 7, 11, 12, 13, 17 ]
    gap&#62; dec:= dec{ Positions( degreesum, degreesumset[1] ) };;
    gap&#62; red:= List( dec, r -&#62; Reduced( 2t, r.irreducibles, testind ) );;
    gap&#62; norm2:= List( red, r -&#62; First( r.remainders,
    &#62;                              x -&#62; ScalarProduct( 2t, x, x ) = 2 ) );;
    gap&#62; Length( Set( norm2 ) );
    1
    gap&#62; norm2[1][1];
    0

</pre>

<div class="p"><!----></div>
Thus also <tt>good2[1]</tt> does not lead to a character table.

<div class="p"><!----></div>


<h2>References</h2>

<dl compact="compact">
 <dt><a href="#CITEMagma" name="Magma">[BCP97]</a></dt><dd>
W.&nbsp;Bosma, J.&nbsp;Cannon, and C.&nbsp;Playoust, <em>The Magma algebra system. I.
  The user language</em>, J. Symbolic Comput. <b>24</b> (1997),
  no.&nbsp;3-4, 235-265. MR 1484478

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEAtlas2017" name="Atlas2017">[BGH<sup>+</sup>17]</a></dt><dd>
M.&nbsp;Bhargava, R.&nbsp;Guralnick, G.&nbsp;Hiss, K.&nbsp;Lux, and P.&nbsp;H. Tiep (eds.), <em>Finite
  simple groups: thirty years of the Atlas and beyond</em>, Contemporary
  Mathematics, vol. 694, Providence, RI, American Mathematical Society, 2017.
  MR 3682583

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEBMO17" name="BMO17">[BMO17]</a></dt><dd>
T.&nbsp;Breuer, G.&nbsp;Malle, and E.&nbsp;A. O'Brien, <em>Reliability and reproducibility
  of Atlas information</em>, in Bhargava et&nbsp;al. [<a href="#Atlas2017" name="CITEAtlas2017">BGH<sup>+</sup>17</a>],
  p.&nbsp;21-31. MR 3682588

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEAuto" name="Auto">[Bre]</a></dt><dd>
T.&nbsp;Breuer, <em>Using table automorphisms for constructing character tables in
  <font face="helvetica">GAP</font></em>, <a href="https://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib/doc2/manual.pdf"><tt>https://www.math.rwth-aachen.de/</tt>
<tt><tt>~</tt>Thomas.Breuer/</tt>
<tt>ctbllib/</tt><tt>doc2/</tt>
<tt>manual.pdf</tt></a>.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEBre11" name="Bre11">[Bre11]</a></dt><dd>
<br /><table align="left" border="0"><tr><td width="50">
<hr />
</td></tr></table><!--hbox-->
 , <em>Computing character tables of groups of type M.G.A</em>, LMS J.
  Comput. Math. <b>14</b> (2011), 173-178. MR 2831228

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITECTblLib" name="CTblLib">[Bre21]</a></dt><dd>
<br /><table align="left" border="0"><tr><td width="50">
<hr />
</td></tr></table><!--hbox-->
 , <em>The <font face="helvetica">GAP</font> Character Table Library, Version
  1.3.2</em>, <a href="https://www.math.rwth-aachen.de/~Thomas.Breuer/ctbllib"><tt>https://www.math.rwth-aachen.de/</tt>
<tt><tt>~</tt>Thomas.Breuer/</tt>
<tt>ctbllib</tt></a>, Mar 2021, <font face="helvetica">GAP</font> package.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITECCN85" name="CCN85">[CCN<sup>+</sup>85]</a></dt><dd>
J.&nbsp;H. Conway, R.&nbsp;T. Curtis, S.&nbsp;P. Norton, R.&nbsp;A. Parker, and R.&nbsp;A. Wilson,
  <em>Atlas of finite groups</em>, Oxford University Press, Eynsham, 1985,
  Maximal subgroups and ordinary characters for simple groups, With
  computational assistance from J. G. Thackray. MR 827219 (88g:20025)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEDem72" name="Dem72">[Dem72]</a></dt><dd>
U.&nbsp;Dempwolff, <em>On extensions of an elementary abelian group of order
  2<sup>5</sup> by <span class="roman">GL</span>(5,&nbsp;2)</em>, Rend. Sem. Mat. Univ. Padova <b>48</b>
  (1972), 359-364 (1973). MR 0393276 (52
  <tt>\</tt>#14086)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEGAP483" name="GAP483">[GAP16]</a></dt><dd>
<em><font face="helvetica">GAP</font> - Groups, Algorithms, and Programming,
  Version 4.8.3</em>, <a href="https://www.gap-system.org"><tt>https://www.gap-system.org</tt></a>, 2016.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEJan76" name="Jan76">[Jan76]</a></dt><dd>
Z.&nbsp;Janko, <em>A new finite simple group of order
  86,775,571,046,077,562,880 which possesses M<sub>24</sub> and the full
  covering group of M<sub>22</sub> as subgroups</em>, J. Algebra <b>42</b> (1976),
  no.&nbsp;2, 564-596. MR 0432751 (55 #5734)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITELLL82" name="LLL82">[LLJL82]</a></dt><dd>
A.&nbsp;K. Lenstra, H.&nbsp;W. Lenstra&nbsp;Jr., and L.&nbsp;Lov'asz, <em>Factoring
  polynomials with rational coefficients</em>, Math. Ann. <b>261</b> (1982),
  no.&nbsp;4, 515-534. MR 682664 (84a:12002)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITELSS92" name="LSS92">[LSS92]</a></dt><dd>
M.&nbsp;W. Liebeck, J.&nbsp;Saxl, and G.&nbsp;M. Seitz, <em>Subgroups of maximal rank in
  finite exceptional groups of Lie type</em>, Proc. London Math. Soc. (3)
  <b>65</b> (1992), no.&nbsp;2, 297-325. MR 1168190

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEPar77" name="Par77">[Par77]</a></dt><dd>
D.&nbsp;Parrott, <em>On Thompson's simple group</em>, J. Algebra <b>46</b> (1977),
  no.&nbsp;2, 389-404. MR 0447396 (56 #5708)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEPle90" name="Ple90">[Ple95]</a></dt><dd>
W.&nbsp;Plesken, <em>Solving XX<sup><span class="roman">tr</span></sup> = A over the integers</em>, Linear
  Algebra Appl. <b>226/228</b> (1995), 331-344. MR 1344572 (96h:15016)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITESmi76c" name="Smi76c">[Smi76]</a></dt><dd>
P.&nbsp;E. Smith, <em>A simple subgroup of M? and E<sub>8</sub>(3)</em>, Bull. London
  Math. Soc. <b>8</b> (1976), no.&nbsp;2, 161-165. MR 0409630 (53
  #13382)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEStr76b" name="Str76b">[Str76]</a></dt><dd>
G.&nbsp;Stroth, <em>A characterization of Fischer's sporadic simple group of the
  order 2<sup>41</sup> &#183;3<sup>13</sup> &#183;5<sup>6</sup> &#183;7<sup>2</sup> &#183;11 &#183;13 &#183;17 &#183;19 &#183;23 &#183;31 &#183;47</em>, J. Algebra <b>40</b> (1976), no.&nbsp;2,
  499-531. MR 0417277 (54 #5334)

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITESW99" name="SW99">[SW99]</a></dt><dd>
I.&nbsp;A.&nbsp;I. Suleiman and R.&nbsp;A. Wilson, <em>Construction of exceptional covers of
  generic groups</em>, Math. Proc. Cambridge Philos. Soc. <b>125</b> (1999),
  no.&nbsp;1, 31-38. MR 1645505

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEWilson87" name="Wilson87">[Wil87]</a></dt><dd>
R.&nbsp;A. Wilson, <em>Some subgroups of the Baby Monster</em>, Invent. Math.
  <b>89</b> (1987), no.&nbsp;1, 197-218. MR 892191 (88d:20030)</dd>
</dl>


<div class="p"><!----></div>

<div class="p"><!----></div>

<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.59.<br />On 30 Dec 2021, 22:24.</small>
</html>
