<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Examples_and_Tests">
<Heading>Examples and Tests</Heading>

<Section Label="Chapter_Examples_and_Tests_Section_Dummy_category">
<Heading>Dummy category</Heading>

<Example><![CDATA[
gap> LoadPackage( "CAP", false );
true
gap> list_of_operations_to_install := [
>     "ObjectConstructor",
>     "MorphismConstructor",
>     "ObjectDatum",
>     "MorphismDatum",
>     "PreCompose",
>     "IdentityMorphism",
>     "DirectSum",
> ];;
gap> dummy := DummyCategory( rec(
>     list_of_operations_to_install := list_of_operations_to_install,
>     properties := [ "IsAdditiveCategory" ],
> ) );;
gap> ForAll( list_of_operations_to_install, o -> CanCompute( dummy, o ) );
true
gap> IsAdditiveCategory( dummy );
true
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Functors">
<Heading>Functors</Heading>

 We create a binary functor <Math>F</Math> with one covariant and one contravariant component in two ways.
 Here is the first way to model a binary functor:
<Example><![CDATA[
gap> field := HomalgFieldOfRationals( );;
gap> vec := LeftPresentations( field );;
gap> F := CapFunctor( "CohomForVec", [ vec, [ vec, true ] ], vec );;
gap> obj_func := function( A, B ) return TensorProductOnObjects( A, DualOnObjects( B ) ); end;;
gap> mor_func := function( source, alpha, beta, range ) return TensorProductOnMorphismsWithGivenTensorProducts( source, alpha, DualOnMorphisms( beta ), range ); end;;
gap> AddObjectFunction( F, obj_func );;
gap> AddMorphismFunction( F, mor_func );;
]]></Example>


 CAP regards <Math>F</Math> as a binary functor on a technical level,
 as we can see by looking at its input signature:
<Example><![CDATA[
gap> InputSignature( F );
[ [ Category of left presentations of Q, false ], [ Category of left presentations of Q, true ] ]
]]></Example>


 We can see that <C>ApplyFunctor</C> works both on two arguments and on one argument (in the product category).
<Example><![CDATA[
gap> V1 := TensorUnit( vec );;
gap> V3 := DirectSum( V1, V1, V1 );;
gap> pi1 := ProjectionInFactorOfDirectSum( [ V1, V1 ], 1 );;
gap> pi2 := ProjectionInFactorOfDirectSum( [ V3, V1 ], 1 );;
gap> value1 := ApplyFunctor( F, pi1, pi2 );;
gap> input := Product( pi1, Opposite( pi2 ) );;
gap> value2 := ApplyFunctor( F, input );;
gap> IsCongruentForMorphisms( value1, value2 );
true
]]></Example>


 Here is the second way to model a binary functor:
<Example><![CDATA[
gap> F2 := CapFunctor( "CohomForVec2", Product( vec, Opposite( vec ) ), vec );;
gap> AddObjectFunction( F2, a -> obj_func( a[1], Opposite( a[2] ) ) );;
gap> AddMorphismFunction( F2, function( source, datum, range ) return mor_func( source, datum[1], Opposite( datum[2] ), range ); end );;
gap> value3 := ApplyFunctor( F2,input );;
gap> IsCongruentForMorphisms( value1, value3 );
true
]]></Example>


 CAP regards <Math>F2</Math> as a unary functor on a technical level,
 as we can see by looking at its input signature:
<Example><![CDATA[
gap> InputSignature( F2 );
[ [ Product of: Category of left presentations of Q, Opposite( Category of left presentations of Q ), false ] ]
]]></Example>


 Installation of the first functor as a GAP-operation.
 It will be installed both as a unary and binary version.
<Example><![CDATA[
gap> InstallFunctor( F, "F_installation" );;
gap> F_installation( pi1, pi2 );;
gap> F_installation( input );;
gap> F_installationOnObjects( V1, V1 );;
gap> F_installationOnObjects( Product( V1, Opposite( V1 ) ) );;
gap> F_installationOnMorphisms( pi1, pi2 );;
gap> F_installationOnMorphisms( input );;
]]></Example>


 Installation of the second functor as a GAP-operation.
 It will be installed only as a unary version.
<Example><![CDATA[
gap> InstallFunctor( F2, "F_installation2" );;
gap> F_installation2( input );;
gap> F_installation2OnObjects( Product( V1, Opposite( V1 ) ) );;
gap> F_installation2OnMorphisms( input );;
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_HandlePrecompiledTowers">
<Heading>HandlePrecompiledTowers</Heading>

<Example><![CDATA[
gap> LoadPackage( "CAP", false );
true
gap> dummy1 := CreateCapCategory( );;
gap> dummy2 := CreateCapCategory( );;
gap> dummy3 := CreateCapCategory( );;
gap> DisplayAndReturn := function ( string )
>     Display( string ); return string; end;;
gap> dummy1!.compiler_hints := rec( );;
gap> dummy1!.compiler_hints.precompiled_towers := [
>   rec(
>     remaining_constructors_in_tower := [ "Constructor1" ],
>     precompiled_functions_adder := cat ->
>       DisplayAndReturn( "Adding precompiled operations for Constructor1" ),
>   ),
>   rec(
>     remaining_constructors_in_tower := [ "Constructor1", "Constructor2" ],
>     precompiled_functions_adder := cat ->
>       DisplayAndReturn( "Adding precompiled operations for Constructor2" ),
>   ),
> ];;
gap> HandlePrecompiledTowers( dummy2, dummy1, "Constructor1" );
Adding precompiled operations for Constructor1
gap> HandlePrecompiledTowers( dummy3, dummy2, "Constructor2" );
Adding precompiled operations for Constructor2
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Homomorphism_structure">
<Heading>Homomorphism structure</Heading>

<Example><![CDATA[
gap> ReadPackage( "CAP", "examples/FieldAsCategory.g" );;
gap> Q := HomalgFieldOfRationals();;
gap> Qoid := FieldAsCategory( Q );;
gap> a := FieldAsCategoryMorphism( 1/2, Qoid );;
gap> b := FieldAsCategoryMorphism( -2/3, Qoid );;
gap> u := FieldAsCategoryUniqueObject( Qoid );;
gap> IsCongruentForMorphisms( a,
>     InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism(
>         u,u,
>         InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure(
>             a
>         )
>     )
> );
true
gap> a = HomStructure( u, u, HomStructure( a ) );
true
gap> IsEqualForObjects( HomStructure( Qoid ), DistinguishedObjectOfHomomorphismStructure( Qoid ) );
true
gap> c := FieldAsCategoryMorphism( 3, Qoid );;
gap> d := FieldAsCategoryMorphism( 0, Qoid );;
gap> left_coeffs := [ [ a, b ], [ c, d ] ];;
gap> right_coeffs := [ [ PreCompose( a, b ), PreCompose( b, c ) ], [ c, PreCompose( a, a ) ] ];;
gap> right_side := [ a, b ];;
gap> MereExistenceOfSolutionOfLinearSystemInAbCategory( left_coeffs, right_coeffs, right_side );
true
gap> solution := 
>     SolveLinearSystemInAbCategory(
>     left_coeffs,
>     right_coeffs,
>     right_side
> );;
gap> ForAll( [ 1, 2 ], i ->
>     IsCongruentForMorphisms(
>         Sum( List( [ 1, 2 ], j -> PreCompose( [ left_coeffs[i][j], solution[j], right_coeffs[i][j] ] ) ) ),
>         right_side[i]
>     )
> );
true
gap> IsLiftable( c, d );
false
gap> LiftOrFail( c, d );
fail
gap> IsLiftable( d, c );
true
gap> LiftOrFail( d, c );
0
gap> Lift( d, c );
0
gap> IsColiftable( c, d );
true
gap> ColiftOrFail( c, d );
0
gap> Colift( c, d );
0
gap> IsColiftable( d, c );
false
gap> ColiftOrFail( d, c );
fail
]]></Example>


<Example><![CDATA[
gap> ReadPackage( "CAP", "examples/StringsAsCategory.g" );;
gap> C := StringsAsCategory();;
gap> obj1 := StringsAsCategoryObject( "qaeiou", C );;
gap> obj2 := StringsAsCategoryObject( "qxayeziouT", C );;
gap> mor := StringsAsCategoryMorphism( obj1, "xyzaTe", obj2 );;
gap> IsWellDefined( mor );
true
gap> ## Test SimplifyObject
> IsEqualForObjects( SimplifyObject( obj1, 0 ), obj1 );
true
gap> IsEqualForObjects( SimplifyObject( obj1, 1 ), obj1 );
false
gap> ForAny( [0,1,2,3,4], i -> IsEqualForObjects( SimplifyObject( obj1, i ), SimplifyObject( obj1, i + 1 ) ) );
false
gap> ForAll( [5,6,7,8], i -> IsEqualForObjects( SimplifyObject( obj1, i ), SimplifyObject( obj1, i + 1 ) ) );
true
gap> ## Test SimplifyMorphism
> IsEqualForMorphisms( SimplifyMorphism( mor, 0 ), mor );
true
gap> IsEqualForMorphisms( SimplifyMorphism( mor, 1 ), mor );
false
gap> ForAny( [0,1], i -> IsEqualForMorphisms( SimplifyMorphism( mor, i ), SimplifyMorphism( mor, i + 1 ) ) );
false
gap> ForAll( [2,3,4,5], i -> IsEqualForMorphisms( SimplifyMorphism( mor, i ), SimplifyMorphism( mor, i + 1 ) ) );
true
gap> ## Test SimplifySource
> IsEqualForMorphismsOnMor( SimplifySource( mor, 0 ), mor );
true
gap> IsEqualForMorphismsOnMor( SimplifySource( mor, 1 ), mor );
false
gap> ForAny( [0,1,2,3,4], i -> IsEqualForMorphismsOnMor( SimplifySource( mor, i ), SimplifySource( mor, i + 1 ) ) );
false
gap> ForAll( [5,6,7,8,9], i -> IsEqualForMorphismsOnMor( SimplifySource( mor, i ), SimplifySource( mor, i + 1 ) ) );
true
gap> IsCongruentForMorphisms(
>     PreCompose( SimplifySource_IsoFromInputObject( mor, infinity ), SimplifySource( mor, infinity ) ), mor
> );
true
gap> IsCongruentForMorphisms(
>     PreCompose( SimplifySource_IsoToInputObject( mor, infinity ), mor ) , SimplifySource( mor, infinity )
> );
true
gap> ## Test SimplifyRange
> IsEqualForMorphismsOnMor( SimplifyRange( mor, 0 ), mor );
true
gap> IsEqualForMorphismsOnMor( SimplifyRange( mor, 1 ), mor );
false
gap> ForAny( [0,1,2,3,4], i -> IsEqualForMorphismsOnMor( SimplifyRange( mor, i ), SimplifyRange( mor, i + 1 ) ) );
false
gap> ForAll( [5,6,7,8,9], i -> IsEqualForMorphismsOnMor( SimplifyRange( mor, i ), SimplifyRange( mor, i + 1 ) ) );
true
gap> IsCongruentForMorphisms(
>     PreCompose( SimplifyRange( mor, infinity ), SimplifyRange_IsoToInputObject( mor, infinity ) ), mor
> );
true
gap> IsCongruentForMorphisms(
>     PreCompose( mor, SimplifyRange_IsoFromInputObject( mor, infinity ) ), SimplifyRange( mor, infinity )
> );
true
gap> ## Test SimplifySourceAndRange
> IsEqualForMorphismsOnMor( SimplifySourceAndRange( mor, 0 ), mor );
true
gap> IsEqualForMorphismsOnMor( SimplifySourceAndRange( mor, 1 ), mor );
false
gap> ForAny( [0,1,2,3,4], i -> IsEqualForMorphismsOnMor( SimplifySourceAndRange( mor, i ), SimplifySourceAndRange( mor, i + 1 ) ) );
false
gap> ForAll( [5,6,7,8,9], i -> IsEqualForMorphismsOnMor( SimplifySourceAndRange( mor, i ), SimplifySourceAndRange( mor, i + 1 ) ) );
true
gap> IsCongruentForMorphisms(
>     mor,
>     PreCompose( [ SimplifySourceAndRange_IsoFromInputSource( mor, infinity ),
>                   SimplifySourceAndRange( mor, infinity ),
>                   SimplifySourceAndRange_IsoToInputRange( mor, infinity ) ] )
> );
true
gap> IsCongruentForMorphisms(
>     SimplifySourceAndRange( mor, infinity ),
>     PreCompose( [ SimplifySourceAndRange_IsoToInputSource( mor, infinity ),
>                   mor,
>                   SimplifySourceAndRange_IsoFromInputRange( mor, infinity ) ] )
> );
true
gap> ## Test SimplifyEndo
> endo := StringsAsCategoryMorphism( obj1, "uoiea", obj1 );;
gap> IsWellDefined( endo );
true
gap> IsEqualForMorphismsOnMor( SimplifyEndo( endo, 0 ), endo );
true
gap> IsEqualForMorphismsOnMor( SimplifyEndo( endo, 1 ), endo );
false
gap> ForAny( [0,1,2,3,4], i -> IsEqualForMorphismsOnMor( SimplifySourceAndRange( endo, i ), SimplifySourceAndRange( endo, i + 1 ) ) );
false
gap> ForAll( [5,6,7,8,9], i -> IsEqualForMorphismsOnMor( SimplifySourceAndRange( endo, i ), SimplifySourceAndRange( endo, i + 1 ) ) );
true
gap> iota := SimplifyEndo_IsoToInputObject( endo, infinity );;
gap> iota_inv := SimplifyEndo_IsoFromInputObject( endo, infinity );;
gap> IsCongruentForMorphisms( PreCompose( [ iota_inv, SimplifyEndo( endo, infinity ), iota ] ), endo );
true
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Homology_object">
<Heading>Homology object</Heading>

<Example><![CDATA[
gap> field := HomalgFieldOfRationals( );;
gap> A := VectorSpaceObject( 1, field );;
gap> B := VectorSpaceObject( 2, field );;
gap> C := VectorSpaceObject( 3, field );;
gap> alpha := VectorSpaceMorphism( A, HomalgMatrix( [ [ 1, 0, 0 ] ], 1, 3, field ), C );;
gap> beta := VectorSpaceMorphism( C, HomalgMatrix( [ [ 1, 0 ], [ 1, 1 ], [ 1, 2 ] ], 3, 2, field ), B );;
gap> IsZero( PreCompose( alpha, beta ) );
false
gap> IsCongruentForMorphisms(
>     IdentityMorphism( HomologyObject( alpha, beta ) ),
>     HomologyObjectFunctorial( alpha, beta, IdentityMorphism( C ), alpha, beta )
> );
true
gap> kernel_beta := KernelEmbedding( beta );;
gap> K := Source( kernel_beta );;
gap> IsIsomorphism(
>     HomologyObjectFunctorial( 
>         MorphismFromZeroObject( K ), 
>         MorphismIntoZeroObject( K ),
>         kernel_beta,
>         MorphismFromZeroObject( Source( beta ) ),
>         beta
>     )
> );
true
gap> cokernel_alpha := CokernelProjection( alpha );;
gap> Co := Range( cokernel_alpha );;
gap> IsIsomorphism(
>     HomologyObjectFunctorial( 
>         alpha,
>         MorphismIntoZeroObject( Range( alpha ) ),
>         cokernel_alpha,
>         MorphismFromZeroObject( Co ),
>         MorphismIntoZeroObject( Co )
>     )
> );
true
gap> alpha_op := Opposite( alpha );;
gap> beta_op := Opposite( beta );;
gap> IsCongruentForMorphisms(
>     IdentityMorphism( HomologyObject( beta_op, alpha_op ) ),
>     HomologyObjectFunctorial( beta_op, alpha_op, IdentityMorphism( Opposite( C ) ), beta_op, alpha_op )
> );
true
gap> kernel_beta := KernelEmbedding( beta_op );;
gap> K := Source( kernel_beta );;
gap> IsIsomorphism(
>     HomologyObjectFunctorial( 
>         MorphismFromZeroObject( K ), 
>         MorphismIntoZeroObject( K ),
>         kernel_beta,
>         MorphismFromZeroObject( Source( beta_op ) ),
>         beta_op
>     )
> );
true
gap> cokernel_alpha := CokernelProjection( alpha_op );;
gap> Co := Range( cokernel_alpha );;
gap> IsIsomorphism(
>     HomologyObjectFunctorial( 
>         alpha_op,
>         MorphismIntoZeroObject( Range( alpha_op ) ),
>         cokernel_alpha,
>         MorphismFromZeroObject( Co ),
>         MorphismIntoZeroObject( Co )
>     )
> );
true
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Liftable">
<Heading>Liftable</Heading>

<Example><![CDATA[
gap> field := HomalgFieldOfRationals( );;
gap> V := VectorSpaceObject( 1, field );;
gap> W := VectorSpaceObject( 2, field );;
gap> alpha := VectorSpaceMorphism( V, HomalgMatrix( [ [ 1, -1 ] ], 1, 2, field ), W );;
gap> beta := VectorSpaceMorphism( W, HomalgMatrix( [ [ 1, 2 ], [ 3, 4 ] ], 2, 2, field ), W );;
gap> IsLiftable( alpha, beta );
true
gap> IsLiftable( beta, alpha );
false
gap> IsLiftableAlongMonomorphism( beta, alpha );
true
gap> gamma := VectorSpaceMorphism( W, HomalgMatrix( [ [ 1 ], [ 1 ] ], 2, 1, field ), V );;
gap> IsColiftable( beta, gamma );
true
gap> IsColiftable( gamma, beta );
false
gap> IsColiftableAlongEpimorphism( beta, gamma );
true
gap> PreCompose( PreInverseForMorphisms( gamma ), gamma ) = IdentityMorphism( V );
true
gap> PreCompose( alpha, PostInverseForMorphisms( alpha ) ) = IdentityMorphism( V );
true
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_WrapperCategory">
<Heading>WrapperCategory</Heading>

<Example><![CDATA[
gap> LoadPackage( "LinearAlgebraForCAP", false );
true
gap> Q := HomalgFieldOfRationals( );
Q
gap> Qmat := MATRIX_CATEGORY( Q );
Category of matrices over Q
gap> Wrapper := WrapperCategory( Qmat, rec( ) );
WrapperCategory( Category of matrices over Q )
gap> mor := ZeroMorphism( ZeroObject( Wrapper ), ZeroObject( Wrapper ) );;
gap> 2 * mor;;
gap> BasisOfExternalHom( Source( mor ), Range( mor ) );;
gap> CoefficientsOfMorphism( mor );;
gap> distinguished_object := DistinguishedObjectOfHomomorphismStructure( Wrapper );;
gap> object := HomomorphismStructureOnObjects( Source( mor ), Source( mor ) );;
gap> HomomorphismStructureOnMorphisms( mor, mor );;
gap> HomomorphismStructureOnMorphismsWithGivenObjects( object, mor, mor, object );;
gap> iota := InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( mor );;
gap> InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( distinguished_object, mor, object );;
gap> beta := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( mor ), Range( mor ), iota );;
gap> IsCongruentForMorphisms( mor, beta );
true
gap> Qmat2 := MATRIX_CATEGORY( Q );
Category of matrices over Q
gap> Wrapper2 := WrapperCategory( Qmat2, rec( wrap_range_of_hom_structure := true ) );
WrapperCategory( Category of matrices over Q )
gap> mor := ZeroMorphism( ZeroObject( Wrapper2 ), ZeroObject( Wrapper2 ) );;
gap> distinguished_object := DistinguishedObjectOfHomomorphismStructure( Wrapper2 );;
gap> object := HomomorphismStructureOnObjects( Source( mor ), Source( mor ) );;
gap> HomomorphismStructureOnMorphisms( mor, mor );;
gap> HomomorphismStructureOnMorphismsWithGivenObjects( object, mor, mor, object );;
gap> iota := InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( mor );;
gap> InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( distinguished_object, mor, object );;
gap> beta := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( mor ), Range( mor ), iota );;
gap> IsCongruentForMorphisms( mor, beta );
true
]]></Example>


<Example><![CDATA[
gap> LoadPackage( "LinearAlgebraForCAP" );
true
gap> LoadPackage( "GeneralizedMorphismsForCAP", false );
true
gap> old_generalized_morphism_standard := CAP_INTERNAL!.generalized_morphism_standard;;
gap> SwitchGeneralizedMorphismStandard( "cospan" );
gap> Q := HomalgFieldOfRationals( );
Q
gap> id := HomalgIdentityMatrix( 8, Q );
<An unevaluated 8 x 8 identity matrix over an internal ring>
gap> a := CertainColumns( CertainRows( id, [ 1, 2, 3 ] ), [ 2, 3, 4, 5 ] );
<An unevaluated non-zero 3 x 4 matrix over an internal ring>
gap> b := CertainColumns( CertainRows( id, [ 1, 2, 3, 4 ] ), [ 2, 3, 4, 5, 6 ] );
<An unevaluated non-zero 4 x 5 matrix over an internal ring>
gap> c := CertainColumns( CertainRows( id, [ 1, 2, 3, 4, 5 ] ), [ 3, 4, 5, 6, 7, 8 ] );
<An unevaluated non-zero 5 x 6 matrix over an internal ring>
gap> IsZero( a * b );
false
gap> IsZero( b * c );
false
gap> IsZero( a * b * c );
true
gap> Qmat := MatrixCategory( Q );
Category of matrices over Q
gap> Wrapper := WrapperCategory( Qmat, rec( ) );
WrapperCategory( Category of matrices over Q )
gap> a := a / Wrapper;
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> b := b / Wrapper;
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> c := c / Wrapper;
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> d := CokernelProjection( a );
<An epimorphism in WrapperCategory( Category of matrices over Q )>
gap> e := CokernelColift( a, PreCompose( b, c ) );
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> f := KernelEmbedding( e );
<A monomorphism in WrapperCategory( Category of matrices over Q )>
gap> g := KernelEmbedding( c );
<A monomorphism in WrapperCategory( Category of matrices over Q )>
gap> h := KernelLift( c, PreCompose( a, b ) );
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> i := CokernelProjection( h );
<An epi morphism in WrapperCategory( Category of matrices over Q )>
gap> ff := AsGeneralizedMorphism( f );
<A morphism in Generalized morphism category of
 WrapperCategory( Category of matrices over Q ) by cospan>
gap> dd := AsGeneralizedMorphism( d );
<A morphism in Generalized morphism category of
 WrapperCategory( Category of matrices over Q ) by cospan>
gap> bb := AsGeneralizedMorphism( b );
<A morphism in Generalized morphism category of
 WrapperCategory( Category of matrices over Q ) by cospan>
gap> gg := AsGeneralizedMorphism( g );
<A morphism in Generalized morphism category of
 WrapperCategory( Category of matrices over Q ) by cospan>
gap> ii := AsGeneralizedMorphism( i );
<A morphism in Generalized morphism category of
 WrapperCategory( Category of matrices over Q ) by cospan>
gap> ss := PreCompose( [ ff, PseudoInverse( dd ), bb, PseudoInverse( gg ), ii ] );
<A morphism in Generalized morphism category of
 WrapperCategory( Category of matrices over Q ) by cospan>
gap> s := HonestRepresentative( ss );
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> j := KernelObjectFunctorial( b, d, e );
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> k := CokernelObjectFunctorial( h, g, b );
<A morphism in WrapperCategory( Category of matrices over Q )>
gap> HK := HomologyObject( j, s );
<An object in WrapperCategory( Category of matrices over Q )>
gap> HC := HomologyObject( s, k );
<An object in WrapperCategory( Category of matrices over Q )>
gap> SwitchGeneralizedMorphismStandard( old_generalized_morphism_standard );
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Monoidal_Categories">
<Heading>Monoidal Categories</Heading>

<Example><![CDATA[
gap> ZZ := HomalgRingOfIntegers();;
gap> Ml := AsLeftPresentation( HomalgMatrix( [ [ 2 ] ], 1, 1, ZZ ) );
<An object in Category of left presentations of Z>
gap> Nl := AsLeftPresentation( HomalgMatrix( [ [ 3 ] ], 1, 1, ZZ ) );
<An object in Category of left presentations of Z>
gap> Tl := TensorProductOnObjects( Ml, Nl );
<An object in Category of left presentations of Z>
gap> Display( UnderlyingMatrix( Tl ) );
[ [  3 ],
  [  2 ] ]
gap> IsZeroForObjects( Tl );
true
gap> Bl := Braiding( DirectSum( Ml, Nl ), DirectSum( Ml, Ml ) );
<A morphism in Category of left presentations of Z>
gap> Display( UnderlyingMatrix( Bl ) );
[ [  1,  0,  0,  0 ],
  [  0,  0,  1,  0 ],
  [  0,  1,  0,  0 ],
  [  0,  0,  0,  1 ] ]
gap> IsWellDefined( Bl );
true
gap> Ul := TensorUnit( CapCategory( Ml ) );
<An object in Category of left presentations of Z>
gap> IntHoml := InternalHomOnObjects( DirectSum( Ml, Ul ), Nl );
<An object in Category of left presentations of Z>
gap> Display( UnderlyingMatrix( IntHoml ) );
[ [  1,  2 ],
  [  0,  3 ] ]
gap> generator_l1 := StandardGeneratorMorphism( IntHoml, 1 );
<A morphism in Category of left presentations of Z>
gap> morphism_l1 := LambdaElimination( DirectSum( Ml, Ul ), Nl, generator_l1 );
<A morphism in Category of left presentations of Z>
gap> Display( UnderlyingMatrix( morphism_l1 ) );
[ [  -3 ],
  [   2 ] ]
gap> generator_l2 := StandardGeneratorMorphism( IntHoml, 2 );
<A morphism in Category of left presentations of Z>
gap> morphism_l2 := LambdaElimination( DirectSum( Ml, Ul ), Nl, generator_l2 );
<A morphism in Category of left presentations of Z>
gap> Display( UnderlyingMatrix( morphism_l2 ) );
[ [   0 ],
  [  -1 ] ]
gap> IsEqualForMorphisms( LambdaIntroduction( morphism_l1 ), generator_l1 );
false
gap> IsCongruentForMorphisms( LambdaIntroduction( morphism_l1 ), generator_l1 );
true
gap> IsEqualForMorphisms( LambdaIntroduction( morphism_l2 ), generator_l2 );
false
gap> IsCongruentForMorphisms( LambdaIntroduction( morphism_l2 ), generator_l2 );
true
gap> Mr := AsRightPresentation( HomalgMatrix( [ [ 2 ] ], 1, 1, ZZ ) );
<An object in Category of right presentations of Z>
gap> Nr := AsRightPresentation( HomalgMatrix( [ [ 3 ] ], 1, 1, ZZ ) );
<An object in Category of right presentations of Z>
gap> Tr := TensorProductOnObjects( Mr, Nr );
<An object in Category of right presentations of Z>
gap> Display( UnderlyingMatrix( Tr ) );
[ [  3,  2 ] ]
gap> IsZeroForObjects( Tr );
true
gap> Br := Braiding( DirectSum( Mr, Nr ), DirectSum( Mr, Mr ) );
<A morphism in Category of right presentations of Z>
gap> Display( UnderlyingMatrix( Br ) );
[ [  1,  0,  0,  0 ],
  [  0,  0,  1,  0 ],
  [  0,  1,  0,  0 ],
  [  0,  0,  0,  1 ] ]
gap> IsWellDefined( Br );
true
gap> Ur := TensorUnit( CapCategory( Mr ) );
<An object in Category of right presentations of Z>
gap> IntHomr := InternalHomOnObjects( DirectSum( Mr, Ur ), Nr );
<An object in Category of right presentations of Z>
gap> Display( UnderlyingMatrix( IntHomr ) );
[ [  1,  0 ],
  [  2,  3 ] ]
gap> generator_r1 := StandardGeneratorMorphism( IntHomr, 1 );
<A morphism in Category of right presentations of Z>
gap> morphism_r1 := LambdaElimination( DirectSum( Mr, Ur ), Nr, generator_r1 );
<A morphism in Category of right presentations of Z>
gap> Display( UnderlyingMatrix( morphism_r1 ) );
[ [  -3,   2 ] ]
gap> generator_r2 := StandardGeneratorMorphism( IntHoml, 2 );
<A morphism in Category of left presentations of Z>
gap> morphism_r2 := LambdaElimination( DirectSum( Ml, Ul ), Nl, generator_r2 );
<A morphism in Category of left presentations of Z>
gap> Display( UnderlyingMatrix( morphism_r2 ) );
[ [   0 ],
  [  -1 ] ]
gap> IsEqualForMorphisms( LambdaIntroduction( morphism_r1 ), generator_r1 );
false
gap> IsCongruentForMorphisms( LambdaIntroduction( morphism_r1 ), generator_r1 );
true
gap> IsEqualForMorphisms( LambdaIntroduction( morphism_r2 ), generator_r2 );
false
gap> IsCongruentForMorphisms( LambdaIntroduction( morphism_r2 ), generator_r2 );
true
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_MorphismFromSourceToPushout_and_MorphismFromFiberProductToSink">
<Heading>MorphismFromSourceToPushout and MorphismFromFiberProductToSink</Heading>

<Example><![CDATA[
gap> field := HomalgFieldOfRationals( );;
gap> A := VectorSpaceObject( 3, field );;
gap> B := VectorSpaceObject( 2, field );;
gap> alpha := VectorSpaceMorphism( B, HomalgMatrix( [ [ 1, -1, 1 ], [ 1, 1, 1 ] ], 2, 3, field ), A );;
gap> beta := VectorSpaceMorphism( B, HomalgMatrix( [ [ 1, 2, 1 ], [ 2, 1, 1 ] ], 2, 3, field ), A );;
gap> m := MorphismFromFiberProductToSink( [ alpha, beta ] );;
gap> IsCongruentForMorphisms(
>     m,
>     PreCompose( ProjectionInFactorOfFiberProduct( [ alpha, beta ], 1 ), alpha )
> );
true
gap> IsCongruentForMorphisms(
>     m,
>     PreCompose( ProjectionInFactorOfFiberProduct( [ alpha, beta ], 2 ), beta )
> );
true
gap> IsCongruentForMorphisms(
> MorphismFromKernelObjectToSink( alpha ),
>     PreCompose( KernelEmbedding( alpha ), alpha )
> );
true
gap> alpha_p := DualOnMorphisms( alpha );;
gap> beta_p := DualOnMorphisms( beta );;
gap> m_p := MorphismFromSourceToPushout( [ alpha_p, beta_p ] );;
gap> IsCongruentForMorphisms(
>     m_p,
>     PreCompose( alpha_p, InjectionOfCofactorOfPushout( [ alpha_p, beta_p ], 1 ) )
> );
true
gap> IsCongruentForMorphisms(
>     m_p,
>     PreCompose( beta_p, InjectionOfCofactorOfPushout( [ alpha_p, beta_p ], 2 ) )
> );
true
gap> IsCongruentForMorphisms(
>     MorphismFromSourceToCokernelObject( alpha_p ),
>     PreCompose( alpha_p, CokernelProjection( alpha_p ) )
> );
true
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Opposite_category">
<Heading>Opposite category</Heading>

<Example><![CDATA[
gap> QQ := HomalgFieldOfRationals();;
gap> vec := MatrixCategory( QQ );;
gap> op := Opposite( vec );;
gap> ListKnownCategoricalProperties( op );
[ "IsAbCategory", "IsAbelianCategory", "IsAbelianCategoryWithEnoughInjectives",
  "IsAbelianCategoryWithEnoughProjectives", "IsAdditiveCategory",
  "IsBraidedMonoidalCategory", "IsClosedMonoidalCategory",
  "IsCoclosedMonoidalCategory", "IsEnrichedOverCommutativeRegularSemigroup",
  "IsLinearCategoryOverCommutativeRing", "IsMonoidalCategory",
  "IsPreAbelianCategory", "IsRigidSymmetricClosedMonoidalCategory",
  "IsRigidSymmetricCoclosedMonoidalCategory", "IsSkeletalCategory",
  "IsStrictMonoidalCategory", "IsSymmetricClosedMonoidalCategory",
  "IsSymmetricCoclosedMonoidalCategory", "IsSymmetricMonoidalCategory" ]
gap> V1 := Opposite( TensorUnit( vec ) );;
gap> V2 := DirectSum( V1, V1 );;
gap> V3 := DirectSum( V1, V2 );;
gap> V4 := DirectSum( V1, V3 );;
gap> V5 := DirectSum( V1, V4 );;
gap> alpha13 := InjectionOfCofactorOfDirectSum( [ V1, V2 ], 1 );;
gap> alpha14 := InjectionOfCofactorOfDirectSum( [ V1, V2, V1 ], 3 );;
gap> alpha15 := InjectionOfCofactorOfDirectSum( [ V2, V1, V2 ], 2 );;
gap> alpha23 := InjectionOfCofactorOfDirectSum( [ V2, V1 ], 1 );;
gap> alpha24 := InjectionOfCofactorOfDirectSum( [ V1, V2, V1 ], 2 );;
gap> alpha25 := InjectionOfCofactorOfDirectSum( [ V2, V2, V1 ], 1 );;
gap> mat := [
>     [ alpha13, alpha14, alpha15 ],
>     [ alpha23, alpha24, alpha25 ]
> ];;
gap> mor := MorphismBetweenDirectSums( mat );;
gap> IsWellDefined( mor );
true
gap> IsWellDefined( Opposite( mor ) );
true
gap> IsOne( UniversalMorphismFromImage( mor, [ CoastrictionToImage( mor ), ImageEmbedding( mor ) ] ) );
true
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Terminal_category">
<Heading>Terminal category</Heading>

<Example><![CDATA[
gap> LoadPackage( "MonoidalCategories" );
true
gap> T := TerminalCategoryWithMultipleObjects( );
TerminalCategoryWithMultipleObjects( )
gap> Display( T );
A CAP category with name TerminalCategoryWithMultipleObjects( ):

63 primitive operations were used to derive 280 operations for this category
which algorithmically
* IsCategoryWithDecidableColifts
* IsCategoryWithDecidableLifts
* IsEquippedWithHomomorphismStructure
* IsLinearCategoryOverCommutativeRing
* IsAbelianCategoryWithEnoughInjectives
* IsAbelianCategoryWithEnoughProjectives
* IsRigidSymmetricClosedMonoidalCategory
* IsRigidSymmetricCoclosedMonoidalCategory
and furthermore mathematically
* IsLocallyOfFiniteInjectiveDimension
* IsLocallyOfFiniteProjectiveDimension
* IsTerminalCategory
gap> i := InitialObject( T );
<A zero object in TerminalCategoryWithMultipleObjects( )>
gap> t := TerminalObject( T );
<A zero object in TerminalCategoryWithMultipleObjects( )>
gap> z := ZeroObject( T );
<A zero object in TerminalCategoryWithMultipleObjects( )>
gap> Display( i );
ZeroObject
gap> Display( t );
ZeroObject
gap> Display( z );
ZeroObject
gap> IsIdenticalObj( i, z );
true
gap> IsIdenticalObj( t, z );
true
gap> id_z := IdentityMorphism( z );
<A zero, identity morphism in TerminalCategoryWithMultipleObjects( )>
gap> fn_z := ZeroObjectFunctorial( T );
<A zero, isomorphism in TerminalCategoryWithMultipleObjects( )>
gap> IsEqualForMorphisms( id_z, fn_z );
false
gap> IsCongruentForMorphisms( id_z, fn_z );
true
gap> a := "a" / T;
<A zero object in TerminalCategoryWithMultipleObjects( )>
gap> Display( a );
a
gap> IsWellDefined( a );
true
gap> aa := ObjectConstructor( T, "a" );
<A zero object in TerminalCategoryWithMultipleObjects( )>
gap> Display( aa );
a
gap> a = aa;
true
gap> b := "b" / T;
<A zero object in TerminalCategoryWithMultipleObjects( )>
gap> Display( b );
b
gap> a = b;
false
gap> t := TensorProduct( a, b );
<A zero object in TerminalCategoryWithMultipleObjects( )>
gap> Display( t );
TensorProductOnObjects
gap> a = t;
false
gap> TensorProduct( a, a ) = t;
true
gap> m := MorphismConstructor( a, "m", b );
<A zero, isomorphism in TerminalCategoryWithMultipleObjects( )>
gap> Display( m );
a
|
| m
v
b
gap> IsWellDefined( m );
true
gap> n := MorphismConstructor( a, "n", b );
<A zero, isomorphism in TerminalCategoryWithMultipleObjects( )>
gap> Display( n );
a
|
| n
v
b
gap> IsEqualForMorphisms( m, n );
false
gap> IsCongruentForMorphisms( m, n );
true
gap> m = n;
true
gap> id := IdentityMorphism( a );
<A zero, identity morphism in TerminalCategoryWithMultipleObjects( )>
gap> Display( id );
a
|
| IdentityMorphism
v
a
gap> m = id;
false
gap> id = MorphismConstructor( a, "xyz", a );
true
gap> z := ZeroMorphism( a, a );
<A zero, isomorphism in TerminalCategoryWithMultipleObjects( )>
gap> Display( z );
a
|
| ZeroMorphism
v
a
gap> id = z;
true
gap> IsLiftable( m, n );
true
gap> lift := Lift( m, n );
<A zero, isomorphism in TerminalCategoryWithMultipleObjects( )>
gap> Display( lift );
a
|
| Lift
v
a
gap> IsColiftable( m, n );
true
gap> colift := Colift( m, n );
<A zero, isomorphism in TerminalCategoryWithMultipleObjects( )>
gap> Display( colift );
b
|
| Colift
v
b
]]></Example>


<Example><![CDATA[
gap> LoadPackage( "MonoidalCategories" );
true
gap> T := TerminalCategoryWithSingleObject( );
TerminalCategoryWithSingleObject( )
gap> Display( T );
A CAP category with name TerminalCategoryWithSingleObject( ):

63 primitive operations were used to derive 280 operations for this category
which algorithmically
* IsCategoryWithDecidableColifts
* IsCategoryWithDecidableLifts
* IsEquippedWithHomomorphismStructure
* IsLinearCategoryOverCommutativeRing
* IsAbelianCategoryWithEnoughInjectives
* IsAbelianCategoryWithEnoughProjectives
* IsRigidSymmetricClosedMonoidalCategory
* IsRigidSymmetricCoclosedMonoidalCategory
and furthermore mathematically
* IsLocallyOfFiniteInjectiveDimension
* IsLocallyOfFiniteProjectiveDimension
* IsSkeletalCategory
* IsStrictMonoidalCategory
* IsTerminalCategory
gap> i := InitialObject( T );
<A zero object in TerminalCategoryWithSingleObject( )>
gap> t := TerminalObject( T );
<A zero object in TerminalCategoryWithSingleObject( )>
gap> z := ZeroObject( T );
<A zero object in TerminalCategoryWithSingleObject( )>
gap> Display( i );
A zero object in TerminalCategoryWithSingleObject( ).
gap> Display( t );
A zero object in TerminalCategoryWithSingleObject( ).
gap> Display( z );
A zero object in TerminalCategoryWithSingleObject( ).
gap> IsIdenticalObj( i, z );
true
gap> IsIdenticalObj( t, z );
true
gap> IsWellDefined( z );
true
gap> id_z := IdentityMorphism( z );
<A zero, identity morphism in TerminalCategoryWithSingleObject( )>
gap> fn_z := ZeroObjectFunctorial( T );
<A zero, identity morphism in TerminalCategoryWithSingleObject( )>
gap> IsWellDefined( fn_z );
true
gap> IsEqualForMorphisms( id_z, fn_z );
true
gap> IsCongruentForMorphisms( id_z, fn_z );
true
gap> IsLiftable( id_z, fn_z );
true
gap> Lift( id_z, fn_z );
<A zero, identity morphism in TerminalCategoryWithSingleObject( )>
gap> IsColiftable( id_z, fn_z );
true
gap> Colift( id_z, fn_z );
<A zero, identity morphism in TerminalCategoryWithSingleObject( )>
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Generalized_Morphisms_Category">
<Heading>Generalized Morphisms Category</Heading>

<Example><![CDATA[
gap> vecspaces := CreateCapCategory( "VectorSpacesForGeneralizedMorphismsTest" );
VectorSpacesForGeneralizedMorphismsTest
gap> ReadPackage( "CAP", "examples/VectorSpacesAllMethods.g" );
true
gap> LoadPackage( "GeneralizedMorphismsForCAP", false );
true
gap> B := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> C := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> B_1 := QVectorSpace( 1 );
<A rational vector space of dimension 1>
gap> C_1 := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> c1_source_aid := VectorSpaceMorphism( B_1, [ [ 1, 0 ] ], B );
A rational vector space homomorphism with matrix: 
[ [  1,  0 ] ]

gap> SetIsSubobject( c1_source_aid, true );
gap> c1_range_aid := VectorSpaceMorphism( C, [ [ 1, 0 ], [ 0, 1 ], [ 0, 0 ] ], C_1 );
A rational vector space homomorphism with matrix: 
[ [  1,  0 ],
  [  0,  1 ],
  [  0,  0 ] ]

gap> SetIsFactorobject( c1_range_aid, true );
gap> c1_associated := VectorSpaceMorphism( B_1, [ [ 1, 1 ] ], C_1 );
A rational vector space homomorphism with matrix: 
[ [  1,  1 ] ]

gap> c1 := GeneralizedMorphism( c1_source_aid, c1_associated, c1_range_aid );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> B_2 := QVectorSpace( 1 );
<A rational vector space of dimension 1>
gap> C_2 := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> c2_source_aid := VectorSpaceMorphism( B_2, [ [ 2, 0 ] ], B );
A rational vector space homomorphism with matrix: 
[ [  2,  0 ] ]

gap> SetIsSubobject( c2_source_aid, true );
gap> c2_range_aid := VectorSpaceMorphism( C, [ [ 3, 0 ], [ 0, 3 ], [ 0, 0 ] ], C_2 );
A rational vector space homomorphism with matrix: 
[ [  3,  0 ],
  [  0,  3 ],
  [  0,  0 ] ]

gap> SetIsFactorobject( c2_range_aid, true );
gap> c2_associated := VectorSpaceMorphism( B_2, [ [ 6, 6 ] ], C_2 );
A rational vector space homomorphism with matrix: 
[ [  6,  6 ] ]

gap> c2 := GeneralizedMorphism( c2_source_aid, c2_associated, c2_range_aid );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> IsCongruentForMorphisms( c1, c2 );
true
gap> IsCongruentForMorphisms( c1, c1 );
true
gap> c3_associated := VectorSpaceMorphism( B_1, [ [ 2, 2 ] ], C_1 );
A rational vector space homomorphism with matrix: 
[ [  2,  2 ] ]

gap> c3 := GeneralizedMorphism( c1_source_aid, c3_associated, c1_range_aid );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> IsCongruentForMorphisms( c1, c3 );
false
gap> IsCongruentForMorphisms( c2, c3 );
false
gap> c1 + c2;
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> Arrow( c1 + c2 );
A rational vector space homomorphism with matrix: 
[ [  12,  12 ] ]

]]></Example>


 First composition test:
<Example><![CDATA[
gap> vecspaces := CreateCapCategory( "VectorSpacesForGeneralizedMorphismsTest" );
VectorSpacesForGeneralizedMorphismsTest
gap> ReadPackage( "CAP", "examples/VectorSpacesAllMethods.g" );
true
gap> A := QVectorSpace( 1 );
<A rational vector space of dimension 1>
gap> B := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> C := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> phi_tilde_associated := VectorSpaceMorphism( A, [ [ 1, 2, 0 ] ], C );
A rational vector space homomorphism with matrix: 
[ [  1,  2,  0 ] ]

gap> phi_tilde_source_aid := VectorSpaceMorphism( A, [ [ 1, 2 ] ], B );
A rational vector space homomorphism with matrix: 
[ [  1,  2 ] ]

gap> phi_tilde := GeneralizedMorphismWithSourceAid( phi_tilde_source_aid, phi_tilde_associated );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> psi_tilde_associated := IdentityMorphism( B );
A rational vector space homomorphism with matrix: 
[ [  1,  0 ],
  [  0,  1 ] ]

gap> psi_tilde_source_aid := VectorSpaceMorphism( B, [ [ 1, 0, 0 ], [ 0, 1, 0 ] ], C );
A rational vector space homomorphism with matrix: 
[ [  1,  0,  0 ],
  [  0,  1,  0 ] ]

gap> psi_tilde := GeneralizedMorphismWithSourceAid( psi_tilde_source_aid, psi_tilde_associated );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> composition := PreCompose( phi_tilde, psi_tilde );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> Arrow( composition );
A rational vector space homomorphism with matrix: 
[ [  1/2,    1 ] ]

gap> SourceAid( composition );
A rational vector space homomorphism with matrix: 
[ [  1/2,    1 ] ]

gap> RangeAid( composition );
A rational vector space homomorphism with matrix: 
[ [  1,  0 ],
  [  0,  1 ] ]
]]></Example>


 Second composition test
<Example><![CDATA[
gap> vecspaces := CreateCapCategory( "VectorSpacesForGeneralizedMorphismsTest" );
VectorSpacesForGeneralizedMorphismsTest
gap> ReadPackage( "CAP", "examples/VectorSpacesAllMethods.g" );
true
gap> A := QVectorSpace( 1 );
<A rational vector space of dimension 1>
gap> B := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> C := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> phi2_tilde_associated := VectorSpaceMorphism( A, [ [ 1, 5 ] ], B );
A rational vector space homomorphism with matrix: 
[ [  1,  5 ] ]

gap> phi2_tilde_range_aid := VectorSpaceMorphism( C, [ [ 1, 0 ], [ 0, 1 ], [ 1, 1 ] ], B );
A rational vector space homomorphism with matrix: 
[ [  1,  0 ],
  [  0,  1 ],
  [  1,  1 ] ]

gap> phi2_tilde := GeneralizedMorphismWithRangeAid( phi2_tilde_associated, phi2_tilde_range_aid );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> psi2_tilde_associated := VectorSpaceMorphism( C, [ [ 1 ], [ 3 ], [ 4 ] ], A );
A rational vector space homomorphism with matrix: 
[ [  1 ],
  [  3 ],
  [  4 ] ]

gap> psi2_tilde_range_aid := VectorSpaceMorphism( B, [ [ 1 ], [ 1 ] ], A );
A rational vector space homomorphism with matrix: 
[ [  1 ],
  [  1 ] ]

gap> psi2_tilde := GeneralizedMorphismWithRangeAid( psi2_tilde_associated, psi2_tilde_range_aid );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> composition2 := PreCompose( phi2_tilde, psi2_tilde );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> Arrow( composition2 );
A rational vector space homomorphism with matrix: 
[ [  16 ] ]

gap> RangeAid( composition2 );
A rational vector space homomorphism with matrix: 
[ [  1 ],
  [  1 ] ]

gap> SourceAid( composition2 );
A rational vector space homomorphism with matrix: 
[ [  1 ] ]
]]></Example>


 Third composition test
<Example><![CDATA[
gap> vecspaces := CreateCapCategory( "VectorSpacesForGeneralizedMorphismsTest" );
VectorSpacesForGeneralizedMorphismsTest
gap> ReadPackage( "CAP", "examples/VectorSpacesAllMethods.g" );
true
gap> A := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> Asub := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> B := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> Bfac := QVectorSpace( 1 );
<A rational vector space of dimension 1>
gap> Bsub := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> C := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> Cfac := QVectorSpace( 1 );
<A rational vector space of dimension 1>
gap> Asub_into_A := VectorSpaceMorphism( Asub, [ [ 1, 0, 0 ], [ 0, 1, 0 ] ], A );
A rational vector space homomorphism with matrix: 
[ [  1,  0,  0 ],
  [  0,  1,  0 ] ]

gap> Asub_to_Bfac := VectorSpaceMorphism( Asub, [ [ 1 ], [ 1 ] ], Bfac );
A rational vector space homomorphism with matrix: 
[ [  1 ],
  [  1 ] ]

gap> B_onto_Bfac := VectorSpaceMorphism( B, [ [ 1 ], [ 1 ], [ 1 ] ], Bfac );
A rational vector space homomorphism with matrix: 
[ [  1 ],
  [  1 ],
  [  1 ] ]

gap> Bsub_into_B := VectorSpaceMorphism( Bsub, [ [ 2, 2, 0 ], [ 0, 2, 2 ] ], B );
A rational vector space homomorphism with matrix: 
[ [  2,  2,  0 ],
  [  0,  2,  2 ] ]

gap> Bsub_to_Cfac := VectorSpaceMorphism( Bsub, [ [ 3 ], [ 0 ] ], Cfac );
A rational vector space homomorphism with matrix: 
[ [  3 ],
  [  0 ] ]

gap> C_onto_Cfac := VectorSpaceMorphism( C, [ [ 1 ], [ 2 ], [ 3 ] ], Cfac );
A rational vector space homomorphism with matrix: 
[ [  1 ],
  [  2 ],
  [  3 ] ]

gap> generalized_morphism1 := GeneralizedMorphism( Asub_into_A, Asub_to_Bfac, B_onto_Bfac );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> generalized_morphism2 := GeneralizedMorphism( Bsub_into_B, Bsub_to_Cfac, C_onto_Cfac );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> IsWellDefined( generalized_morphism1 );
true
gap> IsWellDefined( generalized_morphism2 );
true
gap> p := PreCompose( generalized_morphism1, generalized_morphism2 );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> SourceAid( p );
A rational vector space homomorphism with matrix: 
[ [  -1,   1,   0 ],
  [   1,   0,   0 ] ]

gap> Arrow( p );
A rational vector space homomorphism with matrix: 
(an empty 2 x 0 matrix)

gap> RangeAid( p );
A rational vector space homomorphism with matrix: 
(an empty 3 x 0 matrix)
gap> A := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> Asub := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> B := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> Bfac := QVectorSpace( 1 );
<A rational vector space of dimension 1>
gap> Bsub := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> C := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> Cfac := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> Asub_into_A := VectorSpaceMorphism( Asub, [ [ 1, 0, 0 ], [ 0, 1, 0 ] ], A );
A rational vector space homomorphism with matrix: 
[ [  1,  0,  0 ],
  [  0,  1,  0 ] ]

gap> Asub_to_Bfac := VectorSpaceMorphism( Asub, [ [ 1 ], [ 1 ] ], Bfac );
A rational vector space homomorphism with matrix: 
[ [  1 ],
  [  1 ] ]

gap> B_onto_Bfac := VectorSpaceMorphism( B, [ [ 1 ], [ 1 ], [ 1 ] ], Bfac );
A rational vector space homomorphism with matrix: 
[ [  1 ],
  [  1 ],
  [  1 ] ]

gap> Bsub_into_B := VectorSpaceMorphism( Bsub, [ [ 2, 2, 0 ], [ 0, 2, 2 ] ], B );
A rational vector space homomorphism with matrix: 
[ [  2,  2,  0 ],
  [  0,  2,  2 ] ]

gap> Bsub_to_Cfac := VectorSpaceMorphism( Bsub, [ [ 3, 3 ], [ 0, 0 ] ], Cfac );
A rational vector space homomorphism with matrix: 
[ [  3,  3 ],
  [  0,  0 ] ]

gap> C_onto_Cfac := VectorSpaceMorphism( C, [ [ 1, 0 ], [ 0, 2 ], [ 3, 3 ] ], Cfac );
A rational vector space homomorphism with matrix: 
[ [  1,  0 ],
  [  0,  2 ],
  [  3,  3 ] ]

gap> generalized_morphism1 := GeneralizedMorphism( Asub_into_A, Asub_to_Bfac, B_onto_Bfac );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> generalized_morphism2 := GeneralizedMorphism( Bsub_into_B, Bsub_to_Cfac, C_onto_Cfac );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> IsWellDefined( generalized_morphism1 );
true
gap> IsWellDefined( generalized_morphism2 );
true
gap> p := PreCompose( generalized_morphism1, generalized_morphism2 );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> SourceAid( p );
A rational vector space homomorphism with matrix: 
[ [  -1,   1,   0 ],
  [   1,   0,   0 ] ]

gap> Arrow( p );
A rational vector space homomorphism with matrix: 
[ [  0 ],
  [  0 ] ]

gap> RangeAid( p );
A rational vector space homomorphism with matrix: 
[ [  -1 ],
  [   2 ],
  [   0 ] ]
]]></Example>


 Honest representative test
<Example><![CDATA[
gap> vecspaces := CreateCapCategory( "VectorSpacesForGeneralizedMorphismsTest" );
VectorSpacesForGeneralizedMorphismsTest
gap> ReadPackage( "CAP", "examples/VectorSpacesAllMethods.g" );
true
gap> A := QVectorSpace( 1 );
<A rational vector space of dimension 1>
gap> B := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> phi_tilde_source_aid := VectorSpaceMorphism( A, [ [ 2 ] ], A );
A rational vector space homomorphism with matrix: 
[ [  2 ] ]

gap> phi_tilde_associated := VectorSpaceMorphism( A, [ [ 1, 1 ] ], B );
A rational vector space homomorphism with matrix: 
[ [  1,  1 ] ]

gap> phi_tilde_range_aid := VectorSpaceMorphism( B, [ [ 1, 2 ], [ 3, 4 ] ], B );
A rational vector space homomorphism with matrix: 
[ [  1,  2 ],
  [  3,  4 ] ]

gap> phi_tilde := GeneralizedMorphism( phi_tilde_source_aid, phi_tilde_associated, phi_tilde_range_aid );
<A morphism in Generalized morphism category of VectorSpacesForGeneralizedMorphismsTest>
gap> HonestRepresentative( phi_tilde );
A rational vector space homomorphism with matrix: 
[ [  -1/4,   1/4 ] ]

gap> IsWellDefined( phi_tilde );
true
gap> IsWellDefined( psi_tilde );
true
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_IsWellDefined">
<Heading>IsWellDefined</Heading>

<Example><![CDATA[
gap> vecspaces := CreateCapCategory( "VectorSpacesForIsWellDefinedTest" );
VectorSpacesForIsWellDefinedTest 
gap> ReadPackage( "CAP", "examples/VectorSpacesAllMethods.g" );
true
gap> LoadPackage( "GeneralizedMorphismsForCAP", false );
true
gap> A := QVectorSpace( 1 );
<A rational vector space of dimension 1>
gap> B := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> alpha := VectorSpaceMorphism( A, [ [ 1, 2 ] ], B );
A rational vector space homomorphism with matrix: 
[ [  1,  2 ] ]

gap> g := GeneralizedMorphism( alpha, alpha, alpha );
<A morphism in Generalized morphism category of VectorSpacesForIsWellDefinedTest>
gap> IsWellDefined( alpha );
true
gap> IsWellDefined( g );
true
gap> IsEqualForObjects( A, B );
false
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_Kernel">
<Heading>Kernel</Heading>

<Example><![CDATA[
gap> vecspaces := CreateCapCategory( "VectorSpaces01" );
VectorSpaces01
gap> ReadPackage( "CAP", "examples/VectorSpacesAddKernel01.g" );
true
gap> V := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> W := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> alpha := VectorSpaceMorphism( V, [ [ 1, 1, 1 ], [ -1, -1, -1 ] ], W );
A rational vector space homomorphism with matrix: 
[ [   1,   1,   1 ],
  [  -1,  -1,  -1 ] ]

gap> k := KernelObject( alpha );
<A rational vector space of dimension 1>
gap> T := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> tau := VectorSpaceMorphism( T, [ [ 2, 2 ], [ 2, 2 ] ], V );
A rational vector space homomorphism with matrix: 
[ [  2,  2 ],
  [  2,  2 ] ]

gap> k_lift := KernelLift( alpha, tau );
A rational vector space homomorphism with matrix: 
[ [  2 ],
  [  2 ] ]

gap> HasKernelEmbedding( alpha );
false
gap> KernelEmbedding( alpha );
A rational vector space homomorphism with matrix: 
[ [  1,  1 ] ]

]]></Example>


<Example><![CDATA[
gap> vecspaces := CreateCapCategory( "VectorSpaces02" );
VectorSpaces02
gap> ReadPackage( "CAP", "examples/VectorSpacesAddKernel02.g" );
true
gap> V := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> W := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> alpha := VectorSpaceMorphism( V, [ [ 1, 1, 1 ], [ -1, -1, -1 ] ], W );
A rational vector space homomorphism with matrix: 
[ [   1,   1,   1 ],
  [  -1,  -1,  -1 ] ]

gap> k := KernelObject( alpha );
<A rational vector space of dimension 1>
gap> T := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> tau := VectorSpaceMorphism( T, [ [ 2, 2 ], [ 2, 2 ] ], V );
A rational vector space homomorphism with matrix: 
[ [  2,  2 ],
  [  2,  2 ] ]

gap> k_lift := KernelLift( alpha, tau );
A rational vector space homomorphism with matrix: 
[ [  2 ],
  [  2 ] ]

gap> HasKernelEmbedding( alpha );
false
]]></Example>


<Example><![CDATA[
gap> vecspaces := CreateCapCategory( "VectorSpaces03" );
VectorSpaces03
gap> ReadPackage( "CAP", "examples/VectorSpacesAddKernel03.g" );
true
gap> V := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> W := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> alpha := VectorSpaceMorphism( V, [ [ 1, 1, 1 ], [ -1, -1, -1 ] ], W );
A rational vector space homomorphism with matrix: 
[ [   1,   1,   1 ],
  [  -1,  -1,  -1 ] ]

gap> k := KernelObject( alpha );
<A rational vector space of dimension 1>
gap> k_emb := KernelEmbedding( alpha );
A rational vector space homomorphism with matrix: 
[ [  1,  1 ] ]

gap> IsIdenticalObj( Source( k_emb ), k );
true
gap> V := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> W := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> beta := VectorSpaceMorphism( V, [ [ 1, 1, 1 ], [ -1, -1, -1 ] ], W );
A rational vector space homomorphism with matrix: 
[ [   1,   1,   1 ],
  [  -1,  -1,  -1 ] ]

gap> k_emb := KernelEmbedding( beta );
A rational vector space homomorphism with matrix: 
[ [  1,  1 ] ]

gap> IsIdenticalObj( Source( k_emb ), KernelObject( beta ) );
true
]]></Example>


</Section>


<Section Label="Chapter_Examples_and_Tests_Section_FiberProduct">
<Heading>FiberProduct</Heading>

<Example><![CDATA[
gap> vecspaces := CreateCapCategory( "VectorSpacesForFiberProductTest" );
VectorSpacesForFiberProductTest
gap> ReadPackage( "CAP", "examples/VectorSpacesAllMethods.g" );
true
gap> A := QVectorSpace( 1 );
<A rational vector space of dimension 1>
gap> B := QVectorSpace( 2 );
<A rational vector space of dimension 2>
gap> C := QVectorSpace( 3 );
<A rational vector space of dimension 3>
gap> AtoC := VectorSpaceMorphism( A, [ [ 1, 2, 0 ] ], C );
A rational vector space homomorphism with matrix: 
[ [  1,  2,  0 ] ]

gap> BtoC := VectorSpaceMorphism( B, [ [ 1, 0, 0 ], [ 0, 1, 0 ] ], C );
A rational vector space homomorphism with matrix: 
[ [  1,  0,  0 ],
  [  0,  1,  0 ] ]

gap> P := FiberProduct( AtoC, BtoC );
<A rational vector space of dimension 1>
gap> p1 := ProjectionInFactorOfFiberProduct( [ AtoC, BtoC ], 1 );
A rational vector space homomorphism with matrix: 
[ [  1/2 ] ]

gap> p2 := ProjectionInFactorOfFiberProduct( [ AtoC, BtoC ], 2 );
A rational vector space homomorphism with matrix: 
[ [  1/2,    1 ] ]

]]></Example>


</Section>


</Chapter>

