<Chapter><Heading>Subgroups of L-presented groups</Heading><P/>

As shown in <Cite Key="MR2864562"/> it is possible to deal with finite index
subgroups of L-presented groups algorithmically. The &lpres;-package
provides straightforward methods to deal with these subgroups.<P/>

The Reidemeister-Schreier algorithm from <Cite Key="MR2876891"/> is
implemented, and computes presentations for such subgroups.

<Section><Heading>Creating a subgroup of an L-presented group</Heading>

There are two ways of defining subgroups of finite index of an <A>lpgroup</A>.
The first is to define the subgroup by its generators while the second
defines the subgroup by a coset-table. Generators of subgroup of the 
latter type can be computed with the usual Schreier-algorithm.

<ManSection><Func Name="Subgroup" Arg="G gens"/>
<Description>
creates the subgroup <A>U</A> of <A>G</A> generated by
<A>gens</A>. The Parent value of <A>U</A> will be <A>G</A>.<P/>

For example, the branching subgroup of the Grigorchuk group can be 
defined as follows, and a presentation can be computed using <Ref Oper="IsomorphismLpGroup"/>:
<Example><![CDATA[
gap> G := ExamplesOfLPresentations(1);;
gap> a := G.1;; b := G.2;; c := G.3;; d := G.4;;
gap> K := Subgroup( G, [ Comm( a, b ), Comm( b^a, d ), Comm( b, d^a ) ] );
Group([ a^-1*b^-1*a*b, b^-1*a^-1*d^-1*a*b*a^-1*d*a, a^-1*b^-1*a*d^-1*a^-1*b*a*d ])
gap> iso := IsomorphismLpGroup(K);
[ a^-1*b^-1*a*b, a^-1*b^-1*a*d^-1*a^-1*b*a*d, b^-1*a^-1*d^-1*a*b*a^-1*d*a ] ->
[ x1^-1*x13^-1*x12*x3, x1^-1*x13^-1*x12*x8^-1*x22^-1*x23*x24*x11, x3^-1*x12^-1*x18^-1*x29*x21*x1 ]
gap> Range(iso);
<LpGroup with 98 generators>
]]></Example>
</Description>
</ManSection>

<ManSection><Oper Name="SubgroupLpGroupByCosetTable" Arg="G Tab"/>
<Description>
creates the subgroup <A>U</A> of <A>G</A> which is represented by the
coset-table <A>Tab</A>.<P/>

For instance, the branching subgroup of the Grigorchuk group can be 
defined by the following coset-table:
<Example><![CDATA[
gap> Tab := [ [ 2, 1, 6, 9, 10, 3, 11, 12, 4, 5, 7, 8, 15, 16, 13, 14 ],
  [ 2, 1, 6, 9, 10, 3, 11, 12, 4, 5, 7, 8, 15, 16, 13, 14 ],
  [ 3, 6, 1, 5, 4, 2, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15 ],
  [ 3, 6, 1, 5, 4, 2, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15 ],
  [ 4, 7, 5, 1, 3, 8, 2, 6, 13, 14, 15, 16, 9, 10, 11, 12 ],
  [ 4, 7, 5, 1, 3, 8, 2, 6, 13, 14, 15, 16, 9, 10, 11, 12 ],
  [ 5, 8, 4, 3, 1, 7, 6, 2, 14, 13, 16, 15, 10, 9, 12, 11 ],
  [ 5, 8, 4, 3, 1, 7, 6, 2, 14, 13, 16, 15, 10, 9, 12, 11 ] ]
gap> U := SubgroupLpGroupByCosetTable( G, Tab );
Group(<A>subgroup of L-presented group, no generators known</A>)
gap> U = K;
true
]]></Example>
The generators of <A>U</A> can be computed with the Schreier-algorithm
which is implemented in the method <Ref BookName="ref" Attr="GeneratorsOfGroup"/>.
</Description>
</ManSection>

</Section>

<Section><Heading>Computing the index of finite-index subgroups</Heading><P/>

In principle, it is possible to compute the index of a finite index
subgroup of an <A>lpgroup</A> <Cite Key="MR2864562"/>. The method reduces
the case to certain finitely presented groups by applying only
finitely many endomorphisms to the iterated relations. It then uses
coset enumeration for finitely presented groups to compute an upper
bound on the index of the subgroup.  If the coset enumeration for
finitely presented groups terminated, the method attempts to prove
that the upper bound is sharp. For further details we refer to <Cite
Key="MR2864562"/>.

<ManSection><Meth Name="IndexInWholeGroup" Arg="H"/>
<Meth Name="FactorCosetAction" Arg="G H"/>
<Description>
The first command attempts to compute the index of <A>H</A> in its
parent group. The second one gives the permutation action of <A>G</A>
on the right cosets of <A>H</A>.

<Example><![CDATA[
gap> G := ExamplesOfLPresentations(1);;
gap> a := G.1;; b := G.2;; c := G.3;; d := G.4;;
gap> K := Subgroup( G, [ Comm(a,b), Comm( b, d^a ), Comm( b^a, d )] );;
gap> IndexInWholeGroup( K );
16
gap> FactorCosetAction( G, K );
[ a, b, c, d ] -> [ (1,2)(3,6)(4,9)(5,10)(7,11)(8,12)(13,15)(14,16),
  (1,3)(2,6)(4,5)(7,8)(9,10)(11,12)(13,14)(15,16), (1,4)(2,7)(3,5)(6,8)(9,13)(10,14)(11,15)(12,16),
  (1,5)(2,8)(3,4)(6,7)(9,14)(10,13)(11,16)(12,15) ]
]]></Example>
</Description>
</ManSection>

<ManSection><Meth Name="Index" Arg="H I"/>
<Description>
attempts to compute the index of <A>I</A> in the subgroup
<A>H</A>. The subgroup <A>I</A> must be contained in <A>H</A>.

<Example><![CDATA[
gap> G := ExamplesOfLPresentations(1);;
gap> a := G.1;; b := G.2;; c := G.3;; d := G.4;;
gap> K := Subgroup( G, [ Comm(a,b), Comm( b, d^a ), Comm( b^a, d )] );;
gap> KxK := Subgroup( G, [ Comm(b,d^a), Comm(b^a,d), Comm(d^a,c^(a*c)),                         
</A> Comm( d^(a*c), c^a), Comm( d, c^(a*c*a) ), Comm( d^(a*c*a), c) ] );;
gap> Index( K, KxK );
4
]]></Example>
</Description>
</ManSection>

<ManSection><Meth Name="CosetTableInWholeGroup" Arg="H"/>
<Description>
computes a coset-table for the subgroup <A>H</A> in its parent group.

<Example><![CDATA[
gap> CosetTableInWholeGroup( K );
[ [ 2, 1, 6, 9, 10, 3, 11, 12, 4, 5, 7, 8, 15, 16, 13, 14 ],
  [ 2, 1, 6, 9, 10, 3, 11, 12, 4, 5, 7, 8, 15, 16, 13, 14 ],
  [ 3, 6, 1, 5, 4, 2, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15 ],
  [ 3, 6, 1, 5, 4, 2, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15 ],
  [ 4, 7, 5, 1, 3, 8, 2, 6, 13, 14, 15, 16, 9, 10, 11, 12 ],
  [ 4, 7, 5, 1, 3, 8, 2, 6, 13, 14, 15, 16, 9, 10, 11, 12 ],
  [ 5, 8, 4, 3, 1, 7, 6, 2, 14, 13, 16, 15, 10, 9, 12, 11 ],
  [ 5, 8, 4, 3, 1, 7, 6, 2, 14, 13, 16, 15, 10, 9, 12, 11 ] ]
]]></Example>
</Description>
</ManSection>

</Section>

<Section><Heading>Technical details</Heading><P/>

For performance issues the following global variables can be used to modify
the behaviour of the coset enumeration:

<ManSection><Var Name="LPRES_TCSTART"/>
<Description>
defines the maximal word-length of endomorphisms in the free monoid
which are applied to the iterated relations.
</Description>
</ManSection>

<ManSection><Var Name="LPRES_CosetEnumerator"/>
<Description>
defines the coset enumeration process used for finitely presented groups.
It should be a function which take as input a subgroup <A>h</A> of a finitely
presented group and it computes a coset table in the whole group.
The default uses the following method of the <Package>ACE</Package>-package
<Example><![CDATA[
function ( h )
    local  f, rels, gens;
    f := FreeGeneratorsOfFpGroup( Parent( h ) );
    rels := RelatorsOfFpGroup( Parent( h ) );
    gens := List( GeneratorsOfGroup( h ), UnderlyingElement );
    return ACECosetTable( f, rels, gens : silent := true,
        hard := true,
        max := 10 ^ 8,
        Wo := 10 ^ 8 );
]]></Example>
If the <Package>ACE</Package>-package is not available, the library
coset enumeration process is used.
</Description>
</ManSection>

</Section>
</Chapter>
